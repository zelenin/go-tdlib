// AUTOGENERATED

package client

import (
	"encoding/json"
)

const (
	ClassAuthenticationCodeType                 = "AuthenticationCodeType"
	ClassEmailAddressAuthentication             = "EmailAddressAuthentication"
	ClassEmailAddressResetState                 = "EmailAddressResetState"
	ClassAuthorizationState                     = "AuthorizationState"
	ClassInputFile                              = "InputFile"
	ClassThumbnailFormat                        = "ThumbnailFormat"
	ClassMaskPoint                              = "MaskPoint"
	ClassStickerFormat                          = "StickerFormat"
	ClassStickerType                            = "StickerType"
	ClassStickerFullType                        = "StickerFullType"
	ClassPollType                               = "PollType"
	ClassUserType                               = "UserType"
	ClassChatPhotoStickerType                   = "ChatPhotoStickerType"
	ClassInputChatPhoto                         = "InputChatPhoto"
	ClassChatMemberStatus                       = "ChatMemberStatus"
	ClassChatMembersFilter                      = "ChatMembersFilter"
	ClassSupergroupMembersFilter                = "SupergroupMembersFilter"
	ClassSecretChatState                        = "SecretChatState"
	ClassMessageSender                          = "MessageSender"
	ClassMessageForwardOrigin                   = "MessageForwardOrigin"
	ClassReactionType                           = "ReactionType"
	ClassMessageSendingState                    = "MessageSendingState"
	ClassMessageSource                          = "MessageSource"
	ClassNotificationSettingsScope              = "NotificationSettingsScope"
	ClassChatType                               = "ChatType"
	ClassChatList                               = "ChatList"
	ClassChatSource                             = "ChatSource"
	ClassChatAvailableReactions                 = "ChatAvailableReactions"
	ClassPublicChatType                         = "PublicChatType"
	ClassChatActionBar                          = "ChatActionBar"
	ClassKeyboardButtonType                     = "KeyboardButtonType"
	ClassInlineKeyboardButtonType               = "InlineKeyboardButtonType"
	ClassReplyMarkup                            = "ReplyMarkup"
	ClassLoginUrlInfo                           = "LoginUrlInfo"
	ClassRichText                               = "RichText"
	ClassPageBlockHorizontalAlignment           = "PageBlockHorizontalAlignment"
	ClassPageBlockVerticalAlignment             = "PageBlockVerticalAlignment"
	ClassPageBlock                              = "PageBlock"
	ClassInputCredentials                       = "InputCredentials"
	ClassPaymentProvider                        = "PaymentProvider"
	ClassInputInvoice                           = "InputInvoice"
	ClassMessageExtendedMedia                   = "MessageExtendedMedia"
	ClassPassportElementType                    = "PassportElementType"
	ClassPassportElement                        = "PassportElement"
	ClassInputPassportElement                   = "InputPassportElement"
	ClassPassportElementErrorSource             = "PassportElementErrorSource"
	ClassInputPassportElementErrorSource        = "InputPassportElementErrorSource"
	ClassMessageContent                         = "MessageContent"
	ClassTextEntityType                         = "TextEntityType"
	ClassMessageSchedulingState                 = "MessageSchedulingState"
	ClassInputMessageContent                    = "InputMessageContent"
	ClassSearchMessagesFilter                   = "SearchMessagesFilter"
	ClassChatAction                             = "ChatAction"
	ClassUserStatus                             = "UserStatus"
	ClassEmojiCategoryType                      = "EmojiCategoryType"
	ClassCallDiscardReason                      = "CallDiscardReason"
	ClassCallServerType                         = "CallServerType"
	ClassCallState                              = "CallState"
	ClassGroupCallVideoQuality                  = "GroupCallVideoQuality"
	ClassCallProblem                            = "CallProblem"
	ClassFirebaseAuthenticationSettings         = "FirebaseAuthenticationSettings"
	ClassDiceStickers                           = "DiceStickers"
	ClassSpeechRecognitionResult                = "SpeechRecognitionResult"
	ClassInputInlineQueryResult                 = "InputInlineQueryResult"
	ClassInlineQueryResult                      = "InlineQueryResult"
	ClassInlineQueryResultsButtonType           = "InlineQueryResultsButtonType"
	ClassCallbackQueryPayload                   = "CallbackQueryPayload"
	ClassChatEventAction                        = "ChatEventAction"
	ClassLanguagePackStringValue                = "LanguagePackStringValue"
	ClassPremiumLimitType                       = "PremiumLimitType"
	ClassPremiumFeature                         = "PremiumFeature"
	ClassPremiumSource                          = "PremiumSource"
	ClassStorePaymentPurpose                    = "StorePaymentPurpose"
	ClassDeviceToken                            = "DeviceToken"
	ClassBackgroundFill                         = "BackgroundFill"
	ClassBackgroundType                         = "BackgroundType"
	ClassInputBackground                        = "InputBackground"
	ClassCanTransferOwnershipResult             = "CanTransferOwnershipResult"
	ClassCheckChatUsernameResult                = "CheckChatUsernameResult"
	ClassCheckStickerSetNameResult              = "CheckStickerSetNameResult"
	ClassResetPasswordResult                    = "ResetPasswordResult"
	ClassMessageFileType                        = "MessageFileType"
	ClassPushMessageContent                     = "PushMessageContent"
	ClassNotificationType                       = "NotificationType"
	ClassNotificationGroupType                  = "NotificationGroupType"
	ClassOptionValue                            = "OptionValue"
	ClassJsonValue                              = "JsonValue"
	ClassUserPrivacySettingRule                 = "UserPrivacySettingRule"
	ClassUserPrivacySetting                     = "UserPrivacySetting"
	ClassSessionType                            = "SessionType"
	ClassChatReportReason                       = "ChatReportReason"
	ClassTargetChat                             = "TargetChat"
	ClassInternalLinkType                       = "InternalLinkType"
	ClassFileType                               = "FileType"
	ClassNetworkType                            = "NetworkType"
	ClassNetworkStatisticsEntry                 = "NetworkStatisticsEntry"
	ClassAutosaveSettingsScope                  = "AutosaveSettingsScope"
	ClassConnectionState                        = "ConnectionState"
	ClassTopChatCategory                        = "TopChatCategory"
	ClassTMeUrlType                             = "TMeUrlType"
	ClassSuggestedAction                        = "SuggestedAction"
	ClassTextParseMode                          = "TextParseMode"
	ClassProxyType                              = "ProxyType"
	ClassStatisticalGraph                       = "StatisticalGraph"
	ClassChatStatistics                         = "ChatStatistics"
	ClassVectorPathCommand                      = "VectorPathCommand"
	ClassBotCommandScope                        = "BotCommandScope"
	ClassUpdate                                 = "Update"
	ClassLogStream                              = "LogStream"
	ClassError                                  = "Error"
	ClassOk                                     = "Ok"
	ClassAuthenticationCodeInfo                 = "AuthenticationCodeInfo"
	ClassEmailAddressAuthenticationCodeInfo     = "EmailAddressAuthenticationCodeInfo"
	ClassTextEntity                             = "TextEntity"
	ClassTextEntities                           = "TextEntities"
	ClassFormattedText                          = "FormattedText"
	ClassTermsOfService                         = "TermsOfService"
	ClassPasswordState                          = "PasswordState"
	ClassRecoveryEmailAddress                   = "RecoveryEmailAddress"
	ClassTemporaryPasswordState                 = "TemporaryPasswordState"
	ClassLocalFile                              = "LocalFile"
	ClassRemoteFile                             = "RemoteFile"
	ClassFile                                   = "File"
	ClassPhotoSize                              = "PhotoSize"
	ClassMinithumbnail                          = "Minithumbnail"
	ClassThumbnail                              = "Thumbnail"
	ClassMaskPosition                           = "MaskPosition"
	ClassClosedVectorPath                       = "ClosedVectorPath"
	ClassPollOption                             = "PollOption"
	ClassAnimation                              = "Animation"
	ClassAudio                                  = "Audio"
	ClassDocument                               = "Document"
	ClassPhoto                                  = "Photo"
	ClassSticker                                = "Sticker"
	ClassVideo                                  = "Video"
	ClassVideoNote                              = "VideoNote"
	ClassVoiceNote                              = "VoiceNote"
	ClassAnimatedEmoji                          = "AnimatedEmoji"
	ClassContact                                = "Contact"
	ClassLocation                               = "Location"
	ClassVenue                                  = "Venue"
	ClassGame                                   = "Game"
	ClassWebApp                                 = "WebApp"
	ClassPoll                                   = "Poll"
	ClassProfilePhoto                           = "ProfilePhoto"
	ClassChatPhotoInfo                          = "ChatPhotoInfo"
	ClassBotCommand                             = "BotCommand"
	ClassBotCommands                            = "BotCommands"
	ClassBotMenuButton                          = "BotMenuButton"
	ClassChatLocation                           = "ChatLocation"
	ClassChatPhotoSticker                       = "ChatPhotoSticker"
	ClassAnimatedChatPhoto                      = "AnimatedChatPhoto"
	ClassChatPhoto                              = "ChatPhoto"
	ClassChatPhotos                             = "ChatPhotos"
	ClassChatPermissions                        = "ChatPermissions"
	ClassChatAdministratorRights                = "ChatAdministratorRights"
	ClassPremiumPaymentOption                   = "PremiumPaymentOption"
	ClassPremiumStatePaymentOption              = "PremiumStatePaymentOption"
	ClassEmojiStatus                            = "EmojiStatus"
	ClassEmojiStatuses                          = "EmojiStatuses"
	ClassUsernames                              = "Usernames"
	ClassUser                                   = "User"
	ClassBotInfo                                = "BotInfo"
	ClassUserFullInfo                           = "UserFullInfo"
	ClassUsers                                  = "Users"
	ClassChatAdministrator                      = "ChatAdministrator"
	ClassChatAdministrators                     = "ChatAdministrators"
	ClassChatMember                             = "ChatMember"
	ClassChatMembers                            = "ChatMembers"
	ClassChatInviteLink                         = "ChatInviteLink"
	ClassChatInviteLinks                        = "ChatInviteLinks"
	ClassChatInviteLinkCount                    = "ChatInviteLinkCount"
	ClassChatInviteLinkCounts                   = "ChatInviteLinkCounts"
	ClassChatInviteLinkMember                   = "ChatInviteLinkMember"
	ClassChatInviteLinkMembers                  = "ChatInviteLinkMembers"
	ClassChatInviteLinkInfo                     = "ChatInviteLinkInfo"
	ClassChatJoinRequest                        = "ChatJoinRequest"
	ClassChatJoinRequests                       = "ChatJoinRequests"
	ClassChatJoinRequestsInfo                   = "ChatJoinRequestsInfo"
	ClassBasicGroup                             = "BasicGroup"
	ClassBasicGroupFullInfo                     = "BasicGroupFullInfo"
	ClassSupergroup                             = "Supergroup"
	ClassSupergroupFullInfo                     = "SupergroupFullInfo"
	ClassSecretChat                             = "SecretChat"
	ClassMessageSenders                         = "MessageSenders"
	ClassChatMessageSender                      = "ChatMessageSender"
	ClassChatMessageSenders                     = "ChatMessageSenders"
	ClassMessageViewer                          = "MessageViewer"
	ClassMessageViewers                         = "MessageViewers"
	ClassMessageForwardInfo                     = "MessageForwardInfo"
	ClassMessageReplyInfo                       = "MessageReplyInfo"
	ClassMessageReaction                        = "MessageReaction"
	ClassMessageInteractionInfo                 = "MessageInteractionInfo"
	ClassUnreadReaction                         = "UnreadReaction"
	ClassMessage                                = "Message"
	ClassMessages                               = "Messages"
	ClassFoundMessages                          = "FoundMessages"
	ClassFoundChatMessages                      = "FoundChatMessages"
	ClassMessagePosition                        = "MessagePosition"
	ClassMessagePositions                       = "MessagePositions"
	ClassMessageCalendarDay                     = "MessageCalendarDay"
	ClassMessageCalendar                        = "MessageCalendar"
	ClassSponsoredMessage                       = "SponsoredMessage"
	ClassSponsoredMessages                      = "SponsoredMessages"
	ClassFileDownload                           = "FileDownload"
	ClassDownloadedFileCounts                   = "DownloadedFileCounts"
	ClassFoundFileDownloads                     = "FoundFileDownloads"
	ClassChatNotificationSettings               = "ChatNotificationSettings"
	ClassScopeNotificationSettings              = "ScopeNotificationSettings"
	ClassDraftMessage                           = "DraftMessage"
	ClassChatFilter                             = "ChatFilter"
	ClassChatFilterInfo                         = "ChatFilterInfo"
	ClassRecommendedChatFilter                  = "RecommendedChatFilter"
	ClassRecommendedChatFilters                 = "RecommendedChatFilters"
	ClassChatLists                              = "ChatLists"
	ClassChatPosition                           = "ChatPosition"
	ClassVideoChat                              = "VideoChat"
	ClassChat                                   = "Chat"
	ClassChats                                  = "Chats"
	ClassChatNearby                             = "ChatNearby"
	ClassChatsNearby                            = "ChatsNearby"
	ClassKeyboardButton                         = "KeyboardButton"
	ClassInlineKeyboardButton                   = "InlineKeyboardButton"
	ClassFoundWebApp                            = "FoundWebApp"
	ClassWebAppInfo                             = "WebAppInfo"
	ClassMessageThreadInfo                      = "MessageThreadInfo"
	ClassForumTopicIcon                         = "ForumTopicIcon"
	ClassForumTopicInfo                         = "ForumTopicInfo"
	ClassForumTopic                             = "ForumTopic"
	ClassForumTopics                            = "ForumTopics"
	ClassPageBlockCaption                       = "PageBlockCaption"
	ClassPageBlockListItem                      = "PageBlockListItem"
	ClassPageBlockTableCell                     = "PageBlockTableCell"
	ClassPageBlockRelatedArticle                = "PageBlockRelatedArticle"
	ClassWebPageInstantView                     = "WebPageInstantView"
	ClassWebPage                                = "WebPage"
	ClassCountryInfo                            = "CountryInfo"
	ClassCountries                              = "Countries"
	ClassPhoneNumberInfo                        = "PhoneNumberInfo"
	ClassBankCardActionOpenUrl                  = "BankCardActionOpenUrl"
	ClassBankCardInfo                           = "BankCardInfo"
	ClassAddress                                = "Address"
	ClassThemeParameters                        = "ThemeParameters"
	ClassLabeledPricePart                       = "LabeledPricePart"
	ClassInvoice                                = "Invoice"
	ClassOrderInfo                              = "OrderInfo"
	ClassShippingOption                         = "ShippingOption"
	ClassSavedCredentials                       = "SavedCredentials"
	ClassPaymentOption                          = "PaymentOption"
	ClassPaymentForm                            = "PaymentForm"
	ClassValidatedOrderInfo                     = "ValidatedOrderInfo"
	ClassPaymentResult                          = "PaymentResult"
	ClassPaymentReceipt                         = "PaymentReceipt"
	ClassDatedFile                              = "DatedFile"
	ClassDate                                   = "Date"
	ClassPersonalDetails                        = "PersonalDetails"
	ClassIdentityDocument                       = "IdentityDocument"
	ClassInputIdentityDocument                  = "InputIdentityDocument"
	ClassPersonalDocument                       = "PersonalDocument"
	ClassInputPersonalDocument                  = "InputPersonalDocument"
	ClassPassportElements                       = "PassportElements"
	ClassPassportElementError                   = "PassportElementError"
	ClassPassportSuitableElement                = "PassportSuitableElement"
	ClassPassportRequiredElement                = "PassportRequiredElement"
	ClassPassportAuthorizationForm              = "PassportAuthorizationForm"
	ClassPassportElementsWithErrors             = "PassportElementsWithErrors"
	ClassEncryptedCredentials                   = "EncryptedCredentials"
	ClassEncryptedPassportElement               = "EncryptedPassportElement"
	ClassInputPassportElementError              = "InputPassportElementError"
	ClassInputThumbnail                         = "InputThumbnail"
	ClassMessageSendOptions                     = "MessageSendOptions"
	ClassMessageCopyOptions                     = "MessageCopyOptions"
	ClassStickers                               = "Stickers"
	ClassEmojis                                 = "Emojis"
	ClassStickerSet                             = "StickerSet"
	ClassStickerSetInfo                         = "StickerSetInfo"
	ClassStickerSets                            = "StickerSets"
	ClassTrendingStickerSets                    = "TrendingStickerSets"
	ClassEmojiCategory                          = "EmojiCategory"
	ClassEmojiCategories                        = "EmojiCategories"
	ClassCallProtocol                           = "CallProtocol"
	ClassCallServer                             = "CallServer"
	ClassCallId                                 = "CallId"
	ClassGroupCallId                            = "GroupCallId"
	ClassGroupCallStream                        = "GroupCallStream"
	ClassGroupCallStreams                       = "GroupCallStreams"
	ClassRtmpUrl                                = "RtmpUrl"
	ClassGroupCallRecentSpeaker                 = "GroupCallRecentSpeaker"
	ClassGroupCall                              = "GroupCall"
	ClassGroupCallVideoSourceGroup              = "GroupCallVideoSourceGroup"
	ClassGroupCallParticipantVideoInfo          = "GroupCallParticipantVideoInfo"
	ClassGroupCallParticipant                   = "GroupCallParticipant"
	ClassCall                                   = "Call"
	ClassPhoneNumberAuthenticationSettings      = "PhoneNumberAuthenticationSettings"
	ClassAddedReaction                          = "AddedReaction"
	ClassAddedReactions                         = "AddedReactions"
	ClassAvailableReaction                      = "AvailableReaction"
	ClassAvailableReactions                     = "AvailableReactions"
	ClassEmojiReaction                          = "EmojiReaction"
	ClassAnimations                             = "Animations"
	ClassImportedContacts                       = "ImportedContacts"
	ClassAttachmentMenuBotColor                 = "AttachmentMenuBotColor"
	ClassAttachmentMenuBot                      = "AttachmentMenuBot"
	ClassSentWebAppMessage                      = "SentWebAppMessage"
	ClassHttpUrl                                = "HttpUrl"
	ClassUserLink                               = "UserLink"
	ClassInlineQueryResultsButton               = "InlineQueryResultsButton"
	ClassInlineQueryResults                     = "InlineQueryResults"
	ClassCallbackQueryAnswer                    = "CallbackQueryAnswer"
	ClassCustomRequestResult                    = "CustomRequestResult"
	ClassGameHighScore                          = "GameHighScore"
	ClassGameHighScores                         = "GameHighScores"
	ClassChatEvent                              = "ChatEvent"
	ClassChatEvents                             = "ChatEvents"
	ClassChatEventLogFilters                    = "ChatEventLogFilters"
	ClassLanguagePackString                     = "LanguagePackString"
	ClassLanguagePackStrings                    = "LanguagePackStrings"
	ClassLanguagePackInfo                       = "LanguagePackInfo"
	ClassLocalizationTargetInfo                 = "LocalizationTargetInfo"
	ClassPremiumLimit                           = "PremiumLimit"
	ClassPremiumFeatures                        = "PremiumFeatures"
	ClassPremiumFeaturePromotionAnimation       = "PremiumFeaturePromotionAnimation"
	ClassPremiumState                           = "PremiumState"
	Class                                       //-To = "https://my.telegram.org"
	ClassPushReceiverId                         = "PushReceiverId"
	ClassBackground                             = "Background"
	ClassBackgrounds                            = "Backgrounds"
	ClassThemeSettings                          = "ThemeSettings"
	ClassChatTheme                              = "ChatTheme"
	ClassHashtags                               = "Hashtags"
	ClassNotificationSound                      = "NotificationSound"
	ClassNotificationSounds                     = "NotificationSounds"
	ClassNotification                           = "Notification"
	ClassNotificationGroup                      = "NotificationGroup"
	ClassJsonObjectMember                       = "JsonObjectMember"
	ClassUserPrivacySettingRules                = "UserPrivacySettingRules"
	ClassAccountTtl                             = "AccountTtl"
	ClassMessageAutoDeleteTime                  = "MessageAutoDeleteTime"
	ClassSession                                = "Session"
	ClassSessions                               = "Sessions"
	ClassConnectedWebsite                       = "ConnectedWebsite"
	ClassConnectedWebsites                      = "ConnectedWebsites"
	ClassMessageLink                            = "MessageLink"
	ClassMessageLinkInfo                        = "MessageLinkInfo"
	ClassFilePart                               = "FilePart"
	ClassStorageStatisticsByFileType            = "StorageStatisticsByFileType"
	ClassStorageStatisticsByChat                = "StorageStatisticsByChat"
	ClassStorageStatistics                      = "StorageStatistics"
	ClassStorageStatisticsFast                  = "StorageStatisticsFast"
	ClassDatabaseStatistics                     = "DatabaseStatistics"
	ClassNetworkStatistics                      = "NetworkStatistics"
	ClassAutoDownloadSettings                   = "AutoDownloadSettings"
	ClassAutoDownloadSettingsPresets            = "AutoDownloadSettingsPresets"
	ClassScopeAutosaveSettings                  = "ScopeAutosaveSettings"
	ClassAutosaveSettingsException              = "AutosaveSettingsException"
	ClassAutosaveSettings                       = "AutosaveSettings"
	ClassTMeUrl                                 = "TMeUrl"
	ClassTMeUrls                                = "TMeUrls"
	ClassCount                                  = "Count"
	ClassText                                   = "Text"
	ClassSeconds                                = "Seconds"
	ClassFileDownloadedPrefixSize               = "FileDownloadedPrefixSize"
	ClassDeepLinkInfo                           = "DeepLinkInfo"
	ClassProxy                                  = "Proxy"
	ClassProxies                                = "Proxies"
	ClassInputSticker                           = "InputSticker"
	ClassDateRange                              = "DateRange"
	ClassStatisticalValue                       = "StatisticalValue"
	ClassChatStatisticsMessageInteractionInfo   = "ChatStatisticsMessageInteractionInfo"
	ClassChatStatisticsMessageSenderInfo        = "ChatStatisticsMessageSenderInfo"
	ClassChatStatisticsAdministratorActionsInfo = "ChatStatisticsAdministratorActionsInfo"
	ClassChatStatisticsInviterInfo              = "ChatStatisticsInviterInfo"
	ClassMessageStatistics                      = "MessageStatistics"
	ClassPoint                                  = "Point"
	ClassUpdates                                = "Updates"
	ClassLogVerbosityLevel                      = "LogVerbosityLevel"
	ClassLogTags                                = "LogTags"
	ClassUserSupportInfo                        = "UserSupportInfo"
	ClassTestInt                                = "TestInt"
	ClassTestString                             = "TestString"
	ClassTestBytes                              = "TestBytes"
	ClassTestVectorInt                          = "TestVectorInt"
	ClassTestVectorIntObject                    = "TestVectorIntObject"
	ClassTestVectorString                       = "TestVectorString"
	ClassTestVectorStringObject                 = "TestVectorStringObject"
)

const (
	TypeError                                                   = "error"
	TypeOk                                                      = "ok"
	TypeAuthenticationCodeTypeTelegramMessage                   = "authenticationCodeTypeTelegramMessage"
	TypeAuthenticationCodeTypeSms                               = "authenticationCodeTypeSms"
	TypeAuthenticationCodeTypeCall                              = "authenticationCodeTypeCall"
	TypeAuthenticationCodeTypeFlashCall                         = "authenticationCodeTypeFlashCall"
	TypeAuthenticationCodeTypeMissedCall                        = "authenticationCodeTypeMissedCall"
	TypeAuthenticationCodeTypeFragment                          = "authenticationCodeTypeFragment"
	TypeAuthenticationCodeTypeFirebaseAndroid                   = "authenticationCodeTypeFirebaseAndroid"
	TypeAuthenticationCodeTypeFirebaseIos                       = "authenticationCodeTypeFirebaseIos"
	TypeAuthenticationCodeInfo                                  = "authenticationCodeInfo"
	TypeEmailAddressAuthenticationCodeInfo                      = "emailAddressAuthenticationCodeInfo"
	TypeEmailAddressAuthenticationCode                          = "emailAddressAuthenticationCode"
	TypeEmailAddressAuthenticationAppleId                       = "emailAddressAuthenticationAppleId"
	TypeEmailAddressAuthenticationGoogleId                      = "emailAddressAuthenticationGoogleId"
	TypeEmailAddressResetStateAvailable                         = "emailAddressResetStateAvailable"
	TypeEmailAddressResetStatePending                           = "emailAddressResetStatePending"
	TypeTextEntity                                              = "textEntity"
	TypeTextEntities                                            = "textEntities"
	TypeFormattedText                                           = "formattedText"
	TypeTermsOfService                                          = "termsOfService"
	TypeAuthorizationStateWaitTdlibParameters                   = "authorizationStateWaitTdlibParameters"
	TypeAuthorizationStateWaitPhoneNumber                       = "authorizationStateWaitPhoneNumber"
	TypeAuthorizationStateWaitEmailAddress                      = "authorizationStateWaitEmailAddress"
	TypeAuthorizationStateWaitEmailCode                         = "authorizationStateWaitEmailCode"
	TypeAuthorizationStateWaitCode                              = "authorizationStateWaitCode"
	TypeAuthorizationStateWaitOtherDeviceConfirmation           = "authorizationStateWaitOtherDeviceConfirmation"
	TypeAuthorizationStateWaitRegistration                      = "authorizationStateWaitRegistration"
	TypeAuthorizationStateWaitPassword                          = "authorizationStateWaitPassword"
	TypeAuthorizationStateReady                                 = "authorizationStateReady"
	TypeAuthorizationStateLoggingOut                            = "authorizationStateLoggingOut"
	TypeAuthorizationStateClosing                               = "authorizationStateClosing"
	TypeAuthorizationStateClosed                                = "authorizationStateClosed"
	TypePasswordState                                           = "passwordState"
	TypeRecoveryEmailAddress                                    = "recoveryEmailAddress"
	TypeTemporaryPasswordState                                  = "temporaryPasswordState"
	TypeLocalFile                                               = "localFile"
	TypeRemoteFile                                              = "remoteFile"
	TypeFile                                                    = "file"
	TypeInputFileId                                             = "inputFileId"
	TypeInputFileRemote                                         = "inputFileRemote"
	TypeInputFileLocal                                          = "inputFileLocal"
	TypeInputFileGenerated                                      = "inputFileGenerated"
	TypePhotoSize                                               = "photoSize"
	TypeMinithumbnail                                           = "minithumbnail"
	TypeThumbnailFormatJpeg                                     = "thumbnailFormatJpeg"
	TypeThumbnailFormatGif                                      = "thumbnailFormatGif"
	TypeThumbnailFormatMpeg4                                    = "thumbnailFormatMpeg4"
	TypeThumbnailFormatPng                                      = "thumbnailFormatPng"
	TypeThumbnailFormatTgs                                      = "thumbnailFormatTgs"
	TypeThumbnailFormatWebm                                     = "thumbnailFormatWebm"
	TypeThumbnailFormatWebp                                     = "thumbnailFormatWebp"
	TypeThumbnail                                               = "thumbnail"
	TypeMaskPointForehead                                       = "maskPointForehead"
	TypeMaskPointEyes                                           = "maskPointEyes"
	TypeMaskPointMouth                                          = "maskPointMouth"
	TypeMaskPointChin                                           = "maskPointChin"
	TypeMaskPosition                                            = "maskPosition"
	TypeStickerFormatWebp                                       = "stickerFormatWebp"
	TypeStickerFormatTgs                                        = "stickerFormatTgs"
	TypeStickerFormatWebm                                       = "stickerFormatWebm"
	TypeStickerTypeRegular                                      = "stickerTypeRegular"
	TypeStickerTypeMask                                         = "stickerTypeMask"
	TypeStickerTypeCustomEmoji                                  = "stickerTypeCustomEmoji"
	TypeStickerFullTypeRegular                                  = "stickerFullTypeRegular"
	TypeStickerFullTypeMask                                     = "stickerFullTypeMask"
	TypeStickerFullTypeCustomEmoji                              = "stickerFullTypeCustomEmoji"
	TypeClosedVectorPath                                        = "closedVectorPath"
	TypePollOption                                              = "pollOption"
	TypePollTypeRegular                                         = "pollTypeRegular"
	TypePollTypeQuiz                                            = "pollTypeQuiz"
	TypeAnimation                                               = "animation"
	TypeAudio                                                   = "audio"
	TypeDocument                                                = "document"
	TypePhoto                                                   = "photo"
	TypeSticker                                                 = "sticker"
	TypeVideo                                                   = "video"
	TypeVideoNote                                               = "videoNote"
	TypeVoiceNote                                               = "voiceNote"
	TypeAnimatedEmoji                                           = "animatedEmoji"
	TypeContact                                                 = "contact"
	TypeLocation                                                = "location"
	TypeVenue                                                   = "venue"
	TypeGame                                                    = "game"
	TypeWebApp                                                  = "webApp"
	TypePoll                                                    = "poll"
	TypeProfilePhoto                                            = "profilePhoto"
	TypeChatPhotoInfo                                           = "chatPhotoInfo"
	TypeUserTypeRegular                                         = "userTypeRegular"
	TypeUserTypeDeleted                                         = "userTypeDeleted"
	TypeUserTypeBot                                             = "userTypeBot"
	TypeUserTypeUnknown                                         = "userTypeUnknown"
	TypeBotCommand                                              = "botCommand"
	TypeBotCommands                                             = "botCommands"
	TypeBotMenuButton                                           = "botMenuButton"
	TypeChatLocation                                            = "chatLocation"
	TypeChatPhotoStickerTypeRegularOrMask                       = "chatPhotoStickerTypeRegularOrMask"
	TypeChatPhotoStickerTypeCustomEmoji                         = "chatPhotoStickerTypeCustomEmoji"
	TypeChatPhotoSticker                                        = "chatPhotoSticker"
	TypeAnimatedChatPhoto                                       = "animatedChatPhoto"
	TypeChatPhoto                                               = "chatPhoto"
	TypeChatPhotos                                              = "chatPhotos"
	TypeInputChatPhotoPrevious                                  = "inputChatPhotoPrevious"
	TypeInputChatPhotoStatic                                    = "inputChatPhotoStatic"
	TypeInputChatPhotoAnimation                                 = "inputChatPhotoAnimation"
	TypeInputChatPhotoSticker                                   = "inputChatPhotoSticker"
	TypeChatPermissions                                         = "chatPermissions"
	TypeChatAdministratorRights                                 = "chatAdministratorRights"
	TypePremiumPaymentOption                                    = "premiumPaymentOption"
	TypePremiumStatePaymentOption                               = "premiumStatePaymentOption"
	TypeEmojiStatus                                             = "emojiStatus"
	TypeEmojiStatuses                                           = "emojiStatuses"
	TypeUsernames                                               = "usernames"
	TypeUser                                                    = "user"
	TypeBotInfo                                                 = "botInfo"
	TypeUserFullInfo                                            = "userFullInfo"
	TypeUsers                                                   = "users"
	TypeChatAdministrator                                       = "chatAdministrator"
	TypeChatAdministrators                                      = "chatAdministrators"
	TypeChatMemberStatusCreator                                 = "chatMemberStatusCreator"
	TypeChatMemberStatusAdministrator                           = "chatMemberStatusAdministrator"
	TypeChatMemberStatusMember                                  = "chatMemberStatusMember"
	TypeChatMemberStatusRestricted                              = "chatMemberStatusRestricted"
	TypeChatMemberStatusLeft                                    = "chatMemberStatusLeft"
	TypeChatMemberStatusBanned                                  = "chatMemberStatusBanned"
	TypeChatMember                                              = "chatMember"
	TypeChatMembers                                             = "chatMembers"
	TypeChatMembersFilterContacts                               = "chatMembersFilterContacts"
	TypeChatMembersFilterAdministrators                         = "chatMembersFilterAdministrators"
	TypeChatMembersFilterMembers                                = "chatMembersFilterMembers"
	TypeChatMembersFilterMention                                = "chatMembersFilterMention"
	TypeChatMembersFilterRestricted                             = "chatMembersFilterRestricted"
	TypeChatMembersFilterBanned                                 = "chatMembersFilterBanned"
	TypeChatMembersFilterBots                                   = "chatMembersFilterBots"
	TypeSupergroupMembersFilterRecent                           = "supergroupMembersFilterRecent"
	TypeSupergroupMembersFilterContacts                         = "supergroupMembersFilterContacts"
	TypeSupergroupMembersFilterAdministrators                   = "supergroupMembersFilterAdministrators"
	TypeSupergroupMembersFilterSearch                           = "supergroupMembersFilterSearch"
	TypeSupergroupMembersFilterRestricted                       = "supergroupMembersFilterRestricted"
	TypeSupergroupMembersFilterBanned                           = "supergroupMembersFilterBanned"
	TypeSupergroupMembersFilterMention                          = "supergroupMembersFilterMention"
	TypeSupergroupMembersFilterBots                             = "supergroupMembersFilterBots"
	TypeChatInviteLink                                          = "chatInviteLink"
	TypeChatInviteLinks                                         = "chatInviteLinks"
	TypeChatInviteLinkCount                                     = "chatInviteLinkCount"
	TypeChatInviteLinkCounts                                    = "chatInviteLinkCounts"
	TypeChatInviteLinkMember                                    = "chatInviteLinkMember"
	TypeChatInviteLinkMembers                                   = "chatInviteLinkMembers"
	TypeChatInviteLinkInfo                                      = "chatInviteLinkInfo"
	TypeChatJoinRequest                                         = "chatJoinRequest"
	TypeChatJoinRequests                                        = "chatJoinRequests"
	TypeChatJoinRequestsInfo                                    = "chatJoinRequestsInfo"
	TypeBasicGroup                                              = "basicGroup"
	TypeBasicGroupFullInfo                                      = "basicGroupFullInfo"
	TypeSupergroup                                              = "supergroup"
	TypeSupergroupFullInfo                                      = "supergroupFullInfo"
	TypeSecretChatStatePending                                  = "secretChatStatePending"
	TypeSecretChatStateReady                                    = "secretChatStateReady"
	TypeSecretChatStateClosed                                   = "secretChatStateClosed"
	TypeSecretChat                                              = "secretChat"
	TypeMessageSenderUser                                       = "messageSenderUser"
	TypeMessageSenderChat                                       = "messageSenderChat"
	TypeMessageSenders                                          = "messageSenders"
	TypeChatMessageSender                                       = "chatMessageSender"
	TypeChatMessageSenders                                      = "chatMessageSenders"
	TypeMessageViewer                                           = "messageViewer"
	TypeMessageViewers                                          = "messageViewers"
	TypeMessageForwardOriginUser                                = "messageForwardOriginUser"
	TypeMessageForwardOriginChat                                = "messageForwardOriginChat"
	TypeMessageForwardOriginHiddenUser                          = "messageForwardOriginHiddenUser"
	TypeMessageForwardOriginChannel                             = "messageForwardOriginChannel"
	TypeMessageForwardOriginMessageImport                       = "messageForwardOriginMessageImport"
	TypeReactionTypeEmoji                                       = "reactionTypeEmoji"
	TypeReactionTypeCustomEmoji                                 = "reactionTypeCustomEmoji"
	TypeMessageForwardInfo                                      = "messageForwardInfo"
	TypeMessageReplyInfo                                        = "messageReplyInfo"
	TypeMessageReaction                                         = "messageReaction"
	TypeMessageInteractionInfo                                  = "messageInteractionInfo"
	TypeUnreadReaction                                          = "unreadReaction"
	TypeMessageSendingStatePending                              = "messageSendingStatePending"
	TypeMessageSendingStateFailed                               = "messageSendingStateFailed"
	TypeMessage                                                 = "message"
	TypeMessages                                                = "messages"
	TypeFoundMessages                                           = "foundMessages"
	TypeFoundChatMessages                                       = "foundChatMessages"
	TypeMessagePosition                                         = "messagePosition"
	TypeMessagePositions                                        = "messagePositions"
	TypeMessageCalendarDay                                      = "messageCalendarDay"
	TypeMessageCalendar                                         = "messageCalendar"
	TypeMessageSourceChatHistory                                = "messageSourceChatHistory"
	TypeMessageSourceMessageThreadHistory                       = "messageSourceMessageThreadHistory"
	TypeMessageSourceForumTopicHistory                          = "messageSourceForumTopicHistory"
	TypeMessageSourceHistoryPreview                             = "messageSourceHistoryPreview"
	TypeMessageSourceChatList                                   = "messageSourceChatList"
	TypeMessageSourceSearch                                     = "messageSourceSearch"
	TypeMessageSourceChatEventLog                               = "messageSourceChatEventLog"
	TypeMessageSourceNotification                               = "messageSourceNotification"
	TypeMessageSourceOther                                      = "messageSourceOther"
	TypeSponsoredMessage                                        = "sponsoredMessage"
	TypeSponsoredMessages                                       = "sponsoredMessages"
	TypeFileDownload                                            = "fileDownload"
	TypeDownloadedFileCounts                                    = "downloadedFileCounts"
	TypeFoundFileDownloads                                      = "foundFileDownloads"
	TypeNotificationSettingsScopePrivateChats                   = "notificationSettingsScopePrivateChats"
	TypeNotificationSettingsScopeGroupChats                     = "notificationSettingsScopeGroupChats"
	TypeNotificationSettingsScopeChannelChats                   = "notificationSettingsScopeChannelChats"
	TypeChatNotificationSettings                                = "chatNotificationSettings"
	TypeScopeNotificationSettings                               = "scopeNotificationSettings"
	TypeDraftMessage                                            = "draftMessage"
	TypeChatTypePrivate                                         = "chatTypePrivate"
	TypeChatTypeBasicGroup                                      = "chatTypeBasicGroup"
	TypeChatTypeSupergroup                                      = "chatTypeSupergroup"
	TypeChatTypeSecret                                          = "chatTypeSecret"
	TypeChatFilter                                              = "chatFilter"
	TypeChatFilterInfo                                          = "chatFilterInfo"
	TypeRecommendedChatFilter                                   = "recommendedChatFilter"
	TypeRecommendedChatFilters                                  = "recommendedChatFilters"
	TypeChatListMain                                            = "chatListMain"
	TypeChatListArchive                                         = "chatListArchive"
	TypeChatListFilter                                          = "chatListFilter"
	TypeChatLists                                               = "chatLists"
	TypeChatSourceMtprotoProxy                                  = "chatSourceMtprotoProxy"
	TypeChatSourcePublicServiceAnnouncement                     = "chatSourcePublicServiceAnnouncement"
	TypeChatPosition                                            = "chatPosition"
	TypeChatAvailableReactionsAll                               = "chatAvailableReactionsAll"
	TypeChatAvailableReactionsSome                              = "chatAvailableReactionsSome"
	TypeVideoChat                                               = "videoChat"
	TypeChat                                                    = "chat"
	TypeChats                                                   = "chats"
	TypeChatNearby                                              = "chatNearby"
	TypeChatsNearby                                             = "chatsNearby"
	TypePublicChatTypeHasUsername                               = "publicChatTypeHasUsername"
	TypePublicChatTypeIsLocationBased                           = "publicChatTypeIsLocationBased"
	TypeChatActionBarReportSpam                                 = "chatActionBarReportSpam"
	TypeChatActionBarReportUnrelatedLocation                    = "chatActionBarReportUnrelatedLocation"
	TypeChatActionBarInviteMembers                              = "chatActionBarInviteMembers"
	TypeChatActionBarReportAddBlock                             = "chatActionBarReportAddBlock"
	TypeChatActionBarAddContact                                 = "chatActionBarAddContact"
	TypeChatActionBarSharePhoneNumber                           = "chatActionBarSharePhoneNumber"
	TypeChatActionBarJoinRequest                                = "chatActionBarJoinRequest"
	TypeKeyboardButtonTypeText                                  = "keyboardButtonTypeText"
	TypeKeyboardButtonTypeRequestPhoneNumber                    = "keyboardButtonTypeRequestPhoneNumber"
	TypeKeyboardButtonTypeRequestLocation                       = "keyboardButtonTypeRequestLocation"
	TypeKeyboardButtonTypeRequestPoll                           = "keyboardButtonTypeRequestPoll"
	TypeKeyboardButtonTypeRequestUser                           = "keyboardButtonTypeRequestUser"
	TypeKeyboardButtonTypeRequestChat                           = "keyboardButtonTypeRequestChat"
	TypeKeyboardButtonTypeWebApp                                = "keyboardButtonTypeWebApp"
	TypeKeyboardButton                                          = "keyboardButton"
	TypeInlineKeyboardButtonTypeUrl                             = "inlineKeyboardButtonTypeUrl"
	TypeInlineKeyboardButtonTypeLoginUrl                        = "inlineKeyboardButtonTypeLoginUrl"
	TypeInlineKeyboardButtonTypeWebApp                          = "inlineKeyboardButtonTypeWebApp"
	TypeInlineKeyboardButtonTypeCallback                        = "inlineKeyboardButtonTypeCallback"
	TypeInlineKeyboardButtonTypeCallbackWithPassword            = "inlineKeyboardButtonTypeCallbackWithPassword"
	TypeInlineKeyboardButtonTypeCallbackGame                    = "inlineKeyboardButtonTypeCallbackGame"
	TypeInlineKeyboardButtonTypeSwitchInline                    = "inlineKeyboardButtonTypeSwitchInline"
	TypeInlineKeyboardButtonTypeBuy                             = "inlineKeyboardButtonTypeBuy"
	TypeInlineKeyboardButtonTypeUser                            = "inlineKeyboardButtonTypeUser"
	TypeInlineKeyboardButton                                    = "inlineKeyboardButton"
	TypeReplyMarkupRemoveKeyboard                               = "replyMarkupRemoveKeyboard"
	TypeReplyMarkupForceReply                                   = "replyMarkupForceReply"
	TypeReplyMarkupShowKeyboard                                 = "replyMarkupShowKeyboard"
	TypeReplyMarkupInlineKeyboard                               = "replyMarkupInlineKeyboard"
	TypeLoginUrlInfoOpen                                        = "loginUrlInfoOpen"
	TypeLoginUrlInfoRequestConfirmation                         = "loginUrlInfoRequestConfirmation"
	TypeFoundWebApp                                             = "foundWebApp"
	TypeWebAppInfo                                              = "webAppInfo"
	TypeMessageThreadInfo                                       = "messageThreadInfo"
	TypeForumTopicIcon                                          = "forumTopicIcon"
	TypeForumTopicInfo                                          = "forumTopicInfo"
	TypeForumTopic                                              = "forumTopic"
	TypeForumTopics                                             = "forumTopics"
	TypeRichTextPlain                                           = "richTextPlain"
	TypeRichTextBold                                            = "richTextBold"
	TypeRichTextItalic                                          = "richTextItalic"
	TypeRichTextUnderline                                       = "richTextUnderline"
	TypeRichTextStrikethrough                                   = "richTextStrikethrough"
	TypeRichTextFixed                                           = "richTextFixed"
	TypeRichTextUrl                                             = "richTextUrl"
	TypeRichTextEmailAddress                                    = "richTextEmailAddress"
	TypeRichTextSubscript                                       = "richTextSubscript"
	TypeRichTextSuperscript                                     = "richTextSuperscript"
	TypeRichTextMarked                                          = "richTextMarked"
	TypeRichTextPhoneNumber                                     = "richTextPhoneNumber"
	TypeRichTextIcon                                            = "richTextIcon"
	TypeRichTextReference                                       = "richTextReference"
	TypeRichTextAnchor                                          = "richTextAnchor"
	TypeRichTextAnchorLink                                      = "richTextAnchorLink"
	TypeRichTexts                                               = "richTexts"
	TypePageBlockCaption                                        = "pageBlockCaption"
	TypePageBlockListItem                                       = "pageBlockListItem"
	TypePageBlockHorizontalAlignmentLeft                        = "pageBlockHorizontalAlignmentLeft"
	TypePageBlockHorizontalAlignmentCenter                      = "pageBlockHorizontalAlignmentCenter"
	TypePageBlockHorizontalAlignmentRight                       = "pageBlockHorizontalAlignmentRight"
	TypePageBlockVerticalAlignmentTop                           = "pageBlockVerticalAlignmentTop"
	TypePageBlockVerticalAlignmentMiddle                        = "pageBlockVerticalAlignmentMiddle"
	TypePageBlockVerticalAlignmentBottom                        = "pageBlockVerticalAlignmentBottom"
	TypePageBlockTableCell                                      = "pageBlockTableCell"
	TypePageBlockRelatedArticle                                 = "pageBlockRelatedArticle"
	TypePageBlockTitle                                          = "pageBlockTitle"
	TypePageBlockSubtitle                                       = "pageBlockSubtitle"
	TypePageBlockAuthorDate                                     = "pageBlockAuthorDate"
	TypePageBlockHeader                                         = "pageBlockHeader"
	TypePageBlockSubheader                                      = "pageBlockSubheader"
	TypePageBlockKicker                                         = "pageBlockKicker"
	TypePageBlockParagraph                                      = "pageBlockParagraph"
	TypePageBlockPreformatted                                   = "pageBlockPreformatted"
	TypePageBlockFooter                                         = "pageBlockFooter"
	TypePageBlockDivider                                        = "pageBlockDivider"
	TypePageBlockAnchor                                         = "pageBlockAnchor"
	TypePageBlockList                                           = "pageBlockList"
	TypePageBlockBlockQuote                                     = "pageBlockBlockQuote"
	TypePageBlockPullQuote                                      = "pageBlockPullQuote"
	TypePageBlockAnimation                                      = "pageBlockAnimation"
	TypePageBlockAudio                                          = "pageBlockAudio"
	TypePageBlockPhoto                                          = "pageBlockPhoto"
	TypePageBlockVideo                                          = "pageBlockVideo"
	TypePageBlockVoiceNote                                      = "pageBlockVoiceNote"
	TypePageBlockCover                                          = "pageBlockCover"
	TypePageBlockEmbedded                                       = "pageBlockEmbedded"
	TypePageBlockEmbeddedPost                                   = "pageBlockEmbeddedPost"
	TypePageBlockCollage                                        = "pageBlockCollage"
	TypePageBlockSlideshow                                      = "pageBlockSlideshow"
	TypePageBlockChatLink                                       = "pageBlockChatLink"
	TypePageBlockTable                                          = "pageBlockTable"
	TypePageBlockDetails                                        = "pageBlockDetails"
	TypePageBlockRelatedArticles                                = "pageBlockRelatedArticles"
	TypePageBlockMap                                            = "pageBlockMap"
	TypeWebPageInstantView                                      = "webPageInstantView"
	TypeWebPage                                                 = "webPage"
	TypeCountryInfo                                             = "countryInfo"
	TypeCountries                                               = "countries"
	TypePhoneNumberInfo                                         = "phoneNumberInfo"
	TypeBankCardActionOpenUrl                                   = "bankCardActionOpenUrl"
	TypeBankCardInfo                                            = "bankCardInfo"
	TypeAddress                                                 = "address"
	TypeThemeParameters                                         = "themeParameters"
	TypeLabeledPricePart                                        = "labeledPricePart"
	TypeInvoice                                                 = "invoice"
	TypeOrderInfo                                               = "orderInfo"
	TypeShippingOption                                          = "shippingOption"
	TypeSavedCredentials                                        = "savedCredentials"
	TypeInputCredentialsSaved                                   = "inputCredentialsSaved"
	TypeInputCredentialsNew                                     = "inputCredentialsNew"
	TypeInputCredentialsApplePay                                = "inputCredentialsApplePay"
	TypeInputCredentialsGooglePay                               = "inputCredentialsGooglePay"
	TypePaymentProviderSmartGlocal                              = "paymentProviderSmartGlocal"
	TypePaymentProviderStripe                                   = "paymentProviderStripe"
	TypePaymentProviderOther                                    = "paymentProviderOther"
	TypePaymentOption                                           = "paymentOption"
	TypePaymentForm                                             = "paymentForm"
	TypeValidatedOrderInfo                                      = "validatedOrderInfo"
	TypePaymentResult                                           = "paymentResult"
	TypePaymentReceipt                                          = "paymentReceipt"
	TypeInputInvoiceMessage                                     = "inputInvoiceMessage"
	TypeInputInvoiceName                                        = "inputInvoiceName"
	TypeMessageExtendedMediaPreview                             = "messageExtendedMediaPreview"
	TypeMessageExtendedMediaPhoto                               = "messageExtendedMediaPhoto"
	TypeMessageExtendedMediaVideo                               = "messageExtendedMediaVideo"
	TypeMessageExtendedMediaUnsupported                         = "messageExtendedMediaUnsupported"
	TypeDatedFile                                               = "datedFile"
	TypePassportElementTypePersonalDetails                      = "passportElementTypePersonalDetails"
	TypePassportElementTypePassport                             = "passportElementTypePassport"
	TypePassportElementTypeDriverLicense                        = "passportElementTypeDriverLicense"
	TypePassportElementTypeIdentityCard                         = "passportElementTypeIdentityCard"
	TypePassportElementTypeInternalPassport                     = "passportElementTypeInternalPassport"
	TypePassportElementTypeAddress                              = "passportElementTypeAddress"
	TypePassportElementTypeUtilityBill                          = "passportElementTypeUtilityBill"
	TypePassportElementTypeBankStatement                        = "passportElementTypeBankStatement"
	TypePassportElementTypeRentalAgreement                      = "passportElementTypeRentalAgreement"
	TypePassportElementTypePassportRegistration                 = "passportElementTypePassportRegistration"
	TypePassportElementTypeTemporaryRegistration                = "passportElementTypeTemporaryRegistration"
	TypePassportElementTypePhoneNumber                          = "passportElementTypePhoneNumber"
	TypePassportElementTypeEmailAddress                         = "passportElementTypeEmailAddress"
	TypeDate                                                    = "date"
	TypePersonalDetails                                         = "personalDetails"
	TypeIdentityDocument                                        = "identityDocument"
	TypeInputIdentityDocument                                   = "inputIdentityDocument"
	TypePersonalDocument                                        = "personalDocument"
	TypeInputPersonalDocument                                   = "inputPersonalDocument"
	TypePassportElementPersonalDetails                          = "passportElementPersonalDetails"
	TypePassportElementPassport                                 = "passportElementPassport"
	TypePassportElementDriverLicense                            = "passportElementDriverLicense"
	TypePassportElementIdentityCard                             = "passportElementIdentityCard"
	TypePassportElementInternalPassport                         = "passportElementInternalPassport"
	TypePassportElementAddress                                  = "passportElementAddress"
	TypePassportElementUtilityBill                              = "passportElementUtilityBill"
	TypePassportElementBankStatement                            = "passportElementBankStatement"
	TypePassportElementRentalAgreement                          = "passportElementRentalAgreement"
	TypePassportElementPassportRegistration                     = "passportElementPassportRegistration"
	TypePassportElementTemporaryRegistration                    = "passportElementTemporaryRegistration"
	TypePassportElementPhoneNumber                              = "passportElementPhoneNumber"
	TypePassportElementEmailAddress                             = "passportElementEmailAddress"
	TypeInputPassportElementPersonalDetails                     = "inputPassportElementPersonalDetails"
	TypeInputPassportElementPassport                            = "inputPassportElementPassport"
	TypeInputPassportElementDriverLicense                       = "inputPassportElementDriverLicense"
	TypeInputPassportElementIdentityCard                        = "inputPassportElementIdentityCard"
	TypeInputPassportElementInternalPassport                    = "inputPassportElementInternalPassport"
	TypeInputPassportElementAddress                             = "inputPassportElementAddress"
	TypeInputPassportElementUtilityBill                         = "inputPassportElementUtilityBill"
	TypeInputPassportElementBankStatement                       = "inputPassportElementBankStatement"
	TypeInputPassportElementRentalAgreement                     = "inputPassportElementRentalAgreement"
	TypeInputPassportElementPassportRegistration                = "inputPassportElementPassportRegistration"
	TypeInputPassportElementTemporaryRegistration               = "inputPassportElementTemporaryRegistration"
	TypeInputPassportElementPhoneNumber                         = "inputPassportElementPhoneNumber"
	TypeInputPassportElementEmailAddress                        = "inputPassportElementEmailAddress"
	TypePassportElements                                        = "passportElements"
	TypePassportElementErrorSourceUnspecified                   = "passportElementErrorSourceUnspecified"
	TypePassportElementErrorSourceDataField                     = "passportElementErrorSourceDataField"
	TypePassportElementErrorSourceFrontSide                     = "passportElementErrorSourceFrontSide"
	TypePassportElementErrorSourceReverseSide                   = "passportElementErrorSourceReverseSide"
	TypePassportElementErrorSourceSelfie                        = "passportElementErrorSourceSelfie"
	TypePassportElementErrorSourceTranslationFile               = "passportElementErrorSourceTranslationFile"
	TypePassportElementErrorSourceTranslationFiles              = "passportElementErrorSourceTranslationFiles"
	TypePassportElementErrorSourceFile                          = "passportElementErrorSourceFile"
	TypePassportElementErrorSourceFiles                         = "passportElementErrorSourceFiles"
	TypePassportElementError                                    = "passportElementError"
	TypePassportSuitableElement                                 = "passportSuitableElement"
	TypePassportRequiredElement                                 = "passportRequiredElement"
	TypePassportAuthorizationForm                               = "passportAuthorizationForm"
	TypePassportElementsWithErrors                              = "passportElementsWithErrors"
	TypeEncryptedCredentials                                    = "encryptedCredentials"
	TypeEncryptedPassportElement                                = "encryptedPassportElement"
	TypeInputPassportElementErrorSourceUnspecified              = "inputPassportElementErrorSourceUnspecified"
	TypeInputPassportElementErrorSourceDataField                = "inputPassportElementErrorSourceDataField"
	TypeInputPassportElementErrorSourceFrontSide                = "inputPassportElementErrorSourceFrontSide"
	TypeInputPassportElementErrorSourceReverseSide              = "inputPassportElementErrorSourceReverseSide"
	TypeInputPassportElementErrorSourceSelfie                   = "inputPassportElementErrorSourceSelfie"
	TypeInputPassportElementErrorSourceTranslationFile          = "inputPassportElementErrorSourceTranslationFile"
	TypeInputPassportElementErrorSourceTranslationFiles         = "inputPassportElementErrorSourceTranslationFiles"
	TypeInputPassportElementErrorSourceFile                     = "inputPassportElementErrorSourceFile"
	TypeInputPassportElementErrorSourceFiles                    = "inputPassportElementErrorSourceFiles"
	TypeInputPassportElementError                               = "inputPassportElementError"
	TypeMessageText                                             = "messageText"
	TypeMessageAnimation                                        = "messageAnimation"
	TypeMessageAudio                                            = "messageAudio"
	TypeMessageDocument                                         = "messageDocument"
	TypeMessagePhoto                                            = "messagePhoto"
	TypeMessageExpiredPhoto                                     = "messageExpiredPhoto"
	TypeMessageSticker                                          = "messageSticker"
	TypeMessageVideo                                            = "messageVideo"
	TypeMessageExpiredVideo                                     = "messageExpiredVideo"
	TypeMessageVideoNote                                        = "messageVideoNote"
	TypeMessageVoiceNote                                        = "messageVoiceNote"
	TypeMessageLocation                                         = "messageLocation"
	TypeMessageVenue                                            = "messageVenue"
	TypeMessageContact                                          = "messageContact"
	TypeMessageAnimatedEmoji                                    = "messageAnimatedEmoji"
	TypeMessageDice                                             = "messageDice"
	TypeMessageGame                                             = "messageGame"
	TypeMessagePoll                                             = "messagePoll"
	TypeMessageInvoice                                          = "messageInvoice"
	TypeMessageCall                                             = "messageCall"
	TypeMessageVideoChatScheduled                               = "messageVideoChatScheduled"
	TypeMessageVideoChatStarted                                 = "messageVideoChatStarted"
	TypeMessageVideoChatEnded                                   = "messageVideoChatEnded"
	TypeMessageInviteVideoChatParticipants                      = "messageInviteVideoChatParticipants"
	TypeMessageBasicGroupChatCreate                             = "messageBasicGroupChatCreate"
	TypeMessageSupergroupChatCreate                             = "messageSupergroupChatCreate"
	TypeMessageChatChangeTitle                                  = "messageChatChangeTitle"
	TypeMessageChatChangePhoto                                  = "messageChatChangePhoto"
	TypeMessageChatDeletePhoto                                  = "messageChatDeletePhoto"
	TypeMessageChatAddMembers                                   = "messageChatAddMembers"
	TypeMessageChatJoinByLink                                   = "messageChatJoinByLink"
	TypeMessageChatJoinByRequest                                = "messageChatJoinByRequest"
	TypeMessageChatDeleteMember                                 = "messageChatDeleteMember"
	TypeMessageChatUpgradeTo                                    = "messageChatUpgradeTo"
	TypeMessageChatUpgradeFrom                                  = "messageChatUpgradeFrom"
	TypeMessagePinMessage                                       = "messagePinMessage"
	TypeMessageScreenshotTaken                                  = "messageScreenshotTaken"
	TypeMessageChatSetTheme                                     = "messageChatSetTheme"
	TypeMessageChatSetMessageAutoDeleteTime                     = "messageChatSetMessageAutoDeleteTime"
	TypeMessageForumTopicCreated                                = "messageForumTopicCreated"
	TypeMessageForumTopicEdited                                 = "messageForumTopicEdited"
	TypeMessageForumTopicIsClosedToggled                        = "messageForumTopicIsClosedToggled"
	TypeMessageForumTopicIsHiddenToggled                        = "messageForumTopicIsHiddenToggled"
	TypeMessageSuggestProfilePhoto                              = "messageSuggestProfilePhoto"
	TypeMessageCustomServiceAction                              = "messageCustomServiceAction"
	TypeMessageGameScore                                        = "messageGameScore"
	TypeMessagePaymentSuccessful                                = "messagePaymentSuccessful"
	TypeMessagePaymentSuccessfulBot                             = "messagePaymentSuccessfulBot"
	TypeMessageGiftedPremium                                    = "messageGiftedPremium"
	TypeMessageContactRegistered                                = "messageContactRegistered"
	TypeMessageUserShared                                       = "messageUserShared"
	TypeMessageChatShared                                       = "messageChatShared"
	TypeMessageWebsiteConnected                                 = "messageWebsiteConnected"
	TypeMessageBotWriteAccessAllowed                            = "messageBotWriteAccessAllowed"
	TypeMessageWebAppDataSent                                   = "messageWebAppDataSent"
	TypeMessageWebAppDataReceived                               = "messageWebAppDataReceived"
	TypeMessagePassportDataSent                                 = "messagePassportDataSent"
	TypeMessagePassportDataReceived                             = "messagePassportDataReceived"
	TypeMessageProximityAlertTriggered                          = "messageProximityAlertTriggered"
	TypeMessageUnsupported                                      = "messageUnsupported"
	TypeTextEntityTypeMention                                   = "textEntityTypeMention"
	TypeTextEntityTypeHashtag                                   = "textEntityTypeHashtag"
	TypeTextEntityTypeCashtag                                   = "textEntityTypeCashtag"
	TypeTextEntityTypeBotCommand                                = "textEntityTypeBotCommand"
	TypeTextEntityTypeUrl                                       = "textEntityTypeUrl"
	TypeTextEntityTypeEmailAddress                              = "textEntityTypeEmailAddress"
	TypeTextEntityTypePhoneNumber                               = "textEntityTypePhoneNumber"
	TypeTextEntityTypeBankCardNumber                            = "textEntityTypeBankCardNumber"
	TypeTextEntityTypeBold                                      = "textEntityTypeBold"
	TypeTextEntityTypeItalic                                    = "textEntityTypeItalic"
	TypeTextEntityTypeUnderline                                 = "textEntityTypeUnderline"
	TypeTextEntityTypeStrikethrough                             = "textEntityTypeStrikethrough"
	TypeTextEntityTypeSpoiler                                   = "textEntityTypeSpoiler"
	TypeTextEntityTypeCode                                      = "textEntityTypeCode"
	TypeTextEntityTypePre                                       = "textEntityTypePre"
	TypeTextEntityTypePreCode                                   = "textEntityTypePreCode"
	TypeTextEntityTypeTextUrl                                   = "textEntityTypeTextUrl"
	TypeTextEntityTypeMentionName                               = "textEntityTypeMentionName"
	TypeTextEntityTypeCustomEmoji                               = "textEntityTypeCustomEmoji"
	TypeTextEntityTypeMediaTimestamp                            = "textEntityTypeMediaTimestamp"
	TypeInputThumbnail                                          = "inputThumbnail"
	TypeMessageSchedulingStateSendAtDate                        = "messageSchedulingStateSendAtDate"
	TypeMessageSchedulingStateSendWhenOnline                    = "messageSchedulingStateSendWhenOnline"
	TypeMessageSendOptions                                      = "messageSendOptions"
	TypeMessageCopyOptions                                      = "messageCopyOptions"
	TypeInputMessageText                                        = "inputMessageText"
	TypeInputMessageAnimation                                   = "inputMessageAnimation"
	TypeInputMessageAudio                                       = "inputMessageAudio"
	TypeInputMessageDocument                                    = "inputMessageDocument"
	TypeInputMessagePhoto                                       = "inputMessagePhoto"
	TypeInputMessageSticker                                     = "inputMessageSticker"
	TypeInputMessageVideo                                       = "inputMessageVideo"
	TypeInputMessageVideoNote                                   = "inputMessageVideoNote"
	TypeInputMessageVoiceNote                                   = "inputMessageVoiceNote"
	TypeInputMessageLocation                                    = "inputMessageLocation"
	TypeInputMessageVenue                                       = "inputMessageVenue"
	TypeInputMessageContact                                     = "inputMessageContact"
	TypeInputMessageDice                                        = "inputMessageDice"
	TypeInputMessageGame                                        = "inputMessageGame"
	TypeInputMessageInvoice                                     = "inputMessageInvoice"
	TypeInputMessagePoll                                        = "inputMessagePoll"
	TypeInputMessageForwarded                                   = "inputMessageForwarded"
	TypeSearchMessagesFilterEmpty                               = "searchMessagesFilterEmpty"
	TypeSearchMessagesFilterAnimation                           = "searchMessagesFilterAnimation"
	TypeSearchMessagesFilterAudio                               = "searchMessagesFilterAudio"
	TypeSearchMessagesFilterDocument                            = "searchMessagesFilterDocument"
	TypeSearchMessagesFilterPhoto                               = "searchMessagesFilterPhoto"
	TypeSearchMessagesFilterVideo                               = "searchMessagesFilterVideo"
	TypeSearchMessagesFilterVoiceNote                           = "searchMessagesFilterVoiceNote"
	TypeSearchMessagesFilterPhotoAndVideo                       = "searchMessagesFilterPhotoAndVideo"
	TypeSearchMessagesFilterUrl                                 = "searchMessagesFilterUrl"
	TypeSearchMessagesFilterChatPhoto                           = "searchMessagesFilterChatPhoto"
	TypeSearchMessagesFilterVideoNote                           = "searchMessagesFilterVideoNote"
	TypeSearchMessagesFilterVoiceAndVideoNote                   = "searchMessagesFilterVoiceAndVideoNote"
	TypeSearchMessagesFilterMention                             = "searchMessagesFilterMention"
	TypeSearchMessagesFilterUnreadMention                       = "searchMessagesFilterUnreadMention"
	TypeSearchMessagesFilterUnreadReaction                      = "searchMessagesFilterUnreadReaction"
	TypeSearchMessagesFilterFailedToSend                        = "searchMessagesFilterFailedToSend"
	TypeSearchMessagesFilterPinned                              = "searchMessagesFilterPinned"
	TypeChatActionTyping                                        = "chatActionTyping"
	TypeChatActionRecordingVideo                                = "chatActionRecordingVideo"
	TypeChatActionUploadingVideo                                = "chatActionUploadingVideo"
	TypeChatActionRecordingVoiceNote                            = "chatActionRecordingVoiceNote"
	TypeChatActionUploadingVoiceNote                            = "chatActionUploadingVoiceNote"
	TypeChatActionUploadingPhoto                                = "chatActionUploadingPhoto"
	TypeChatActionUploadingDocument                             = "chatActionUploadingDocument"
	TypeChatActionChoosingSticker                               = "chatActionChoosingSticker"
	TypeChatActionChoosingLocation                              = "chatActionChoosingLocation"
	TypeChatActionChoosingContact                               = "chatActionChoosingContact"
	TypeChatActionStartPlayingGame                              = "chatActionStartPlayingGame"
	TypeChatActionRecordingVideoNote                            = "chatActionRecordingVideoNote"
	TypeChatActionUploadingVideoNote                            = "chatActionUploadingVideoNote"
	TypeChatActionWatchingAnimations                            = "chatActionWatchingAnimations"
	TypeChatActionCancel                                        = "chatActionCancel"
	TypeUserStatusEmpty                                         = "userStatusEmpty"
	TypeUserStatusOnline                                        = "userStatusOnline"
	TypeUserStatusOffline                                       = "userStatusOffline"
	TypeUserStatusRecently                                      = "userStatusRecently"
	TypeUserStatusLastWeek                                      = "userStatusLastWeek"
	TypeUserStatusLastMonth                                     = "userStatusLastMonth"
	TypeStickers                                                = "stickers"
	TypeEmojis                                                  = "emojis"
	TypeStickerSet                                              = "stickerSet"
	TypeStickerSetInfo                                          = "stickerSetInfo"
	TypeStickerSets                                             = "stickerSets"
	TypeTrendingStickerSets                                     = "trendingStickerSets"
	TypeEmojiCategory                                           = "emojiCategory"
	TypeEmojiCategories                                         = "emojiCategories"
	TypeEmojiCategoryTypeDefault                                = "emojiCategoryTypeDefault"
	TypeEmojiCategoryTypeEmojiStatus                            = "emojiCategoryTypeEmojiStatus"
	TypeEmojiCategoryTypeChatPhoto                              = "emojiCategoryTypeChatPhoto"
	TypeCallDiscardReasonEmpty                                  = "callDiscardReasonEmpty"
	TypeCallDiscardReasonMissed                                 = "callDiscardReasonMissed"
	TypeCallDiscardReasonDeclined                               = "callDiscardReasonDeclined"
	TypeCallDiscardReasonDisconnected                           = "callDiscardReasonDisconnected"
	TypeCallDiscardReasonHungUp                                 = "callDiscardReasonHungUp"
	TypeCallProtocol                                            = "callProtocol"
	TypeCallServerTypeTelegramReflector                         = "callServerTypeTelegramReflector"
	TypeCallServerTypeWebrtc                                    = "callServerTypeWebrtc"
	TypeCallServer                                              = "callServer"
	TypeCallId                                                  = "callId"
	TypeGroupCallId                                             = "groupCallId"
	TypeCallStatePending                                        = "callStatePending"
	TypeCallStateExchangingKeys                                 = "callStateExchangingKeys"
	TypeCallStateReady                                          = "callStateReady"
	TypeCallStateHangingUp                                      = "callStateHangingUp"
	TypeCallStateDiscarded                                      = "callStateDiscarded"
	TypeCallStateError                                          = "callStateError"
	TypeGroupCallVideoQualityThumbnail                          = "groupCallVideoQualityThumbnail"
	TypeGroupCallVideoQualityMedium                             = "groupCallVideoQualityMedium"
	TypeGroupCallVideoQualityFull                               = "groupCallVideoQualityFull"
	TypeGroupCallStream                                         = "groupCallStream"
	TypeGroupCallStreams                                        = "groupCallStreams"
	TypeRtmpUrl                                                 = "rtmpUrl"
	TypeGroupCallRecentSpeaker                                  = "groupCallRecentSpeaker"
	TypeGroupCall                                               = "groupCall"
	TypeGroupCallVideoSourceGroup                               = "groupCallVideoSourceGroup"
	TypeGroupCallParticipantVideoInfo                           = "groupCallParticipantVideoInfo"
	TypeGroupCallParticipant                                    = "groupCallParticipant"
	TypeCallProblemEcho                                         = "callProblemEcho"
	TypeCallProblemNoise                                        = "callProblemNoise"
	TypeCallProblemInterruptions                                = "callProblemInterruptions"
	TypeCallProblemDistortedSpeech                              = "callProblemDistortedSpeech"
	TypeCallProblemSilentLocal                                  = "callProblemSilentLocal"
	TypeCallProblemSilentRemote                                 = "callProblemSilentRemote"
	TypeCallProblemDropped                                      = "callProblemDropped"
	TypeCallProblemDistortedVideo                               = "callProblemDistortedVideo"
	TypeCallProblemPixelatedVideo                               = "callProblemPixelatedVideo"
	TypeCall                                                    = "call"
	TypeFirebaseAuthenticationSettingsAndroid                   = "firebaseAuthenticationSettingsAndroid"
	TypeFirebaseAuthenticationSettingsIos                       = "firebaseAuthenticationSettingsIos"
	TypePhoneNumberAuthenticationSettings                       = "phoneNumberAuthenticationSettings"
	TypeAddedReaction                                           = "addedReaction"
	TypeAddedReactions                                          = "addedReactions"
	TypeAvailableReaction                                       = "availableReaction"
	TypeAvailableReactions                                      = "availableReactions"
	TypeEmojiReaction                                           = "emojiReaction"
	TypeAnimations                                              = "animations"
	TypeDiceStickersRegular                                     = "diceStickersRegular"
	TypeDiceStickersSlotMachine                                 = "diceStickersSlotMachine"
	TypeImportedContacts                                        = "importedContacts"
	TypeSpeechRecognitionResultPending                          = "speechRecognitionResultPending"
	TypeSpeechRecognitionResultText                             = "speechRecognitionResultText"
	TypeSpeechRecognitionResultError                            = "speechRecognitionResultError"
	TypeAttachmentMenuBotColor                                  = "attachmentMenuBotColor"
	TypeAttachmentMenuBot                                       = "attachmentMenuBot"
	TypeSentWebAppMessage                                       = "sentWebAppMessage"
	TypeHttpUrl                                                 = "httpUrl"
	TypeUserLink                                                = "userLink"
	TypeInputInlineQueryResultAnimation                         = "inputInlineQueryResultAnimation"
	TypeInputInlineQueryResultArticle                           = "inputInlineQueryResultArticle"
	TypeInputInlineQueryResultAudio                             = "inputInlineQueryResultAudio"
	TypeInputInlineQueryResultContact                           = "inputInlineQueryResultContact"
	TypeInputInlineQueryResultDocument                          = "inputInlineQueryResultDocument"
	TypeInputInlineQueryResultGame                              = "inputInlineQueryResultGame"
	TypeInputInlineQueryResultLocation                          = "inputInlineQueryResultLocation"
	TypeInputInlineQueryResultPhoto                             = "inputInlineQueryResultPhoto"
	TypeInputInlineQueryResultSticker                           = "inputInlineQueryResultSticker"
	TypeInputInlineQueryResultVenue                             = "inputInlineQueryResultVenue"
	TypeInputInlineQueryResultVideo                             = "inputInlineQueryResultVideo"
	TypeInputInlineQueryResultVoiceNote                         = "inputInlineQueryResultVoiceNote"
	TypeInlineQueryResultArticle                                = "inlineQueryResultArticle"
	TypeInlineQueryResultContact                                = "inlineQueryResultContact"
	TypeInlineQueryResultLocation                               = "inlineQueryResultLocation"
	TypeInlineQueryResultVenue                                  = "inlineQueryResultVenue"
	TypeInlineQueryResultGame                                   = "inlineQueryResultGame"
	TypeInlineQueryResultAnimation                              = "inlineQueryResultAnimation"
	TypeInlineQueryResultAudio                                  = "inlineQueryResultAudio"
	TypeInlineQueryResultDocument                               = "inlineQueryResultDocument"
	TypeInlineQueryResultPhoto                                  = "inlineQueryResultPhoto"
	TypeInlineQueryResultSticker                                = "inlineQueryResultSticker"
	TypeInlineQueryResultVideo                                  = "inlineQueryResultVideo"
	TypeInlineQueryResultVoiceNote                              = "inlineQueryResultVoiceNote"
	TypeInlineQueryResultsButtonTypeStartBot                    = "inlineQueryResultsButtonTypeStartBot"
	TypeInlineQueryResultsButtonTypeWebApp                      = "inlineQueryResultsButtonTypeWebApp"
	TypeInlineQueryResultsButton                                = "inlineQueryResultsButton"
	TypeInlineQueryResults                                      = "inlineQueryResults"
	TypeCallbackQueryPayloadData                                = "callbackQueryPayloadData"
	TypeCallbackQueryPayloadDataWithPassword                    = "callbackQueryPayloadDataWithPassword"
	TypeCallbackQueryPayloadGame                                = "callbackQueryPayloadGame"
	TypeCallbackQueryAnswer                                     = "callbackQueryAnswer"
	TypeCustomRequestResult                                     = "customRequestResult"
	TypeGameHighScore                                           = "gameHighScore"
	TypeGameHighScores                                          = "gameHighScores"
	TypeChatEventMessageEdited                                  = "chatEventMessageEdited"
	TypeChatEventMessageDeleted                                 = "chatEventMessageDeleted"
	TypeChatEventMessagePinned                                  = "chatEventMessagePinned"
	TypeChatEventMessageUnpinned                                = "chatEventMessageUnpinned"
	TypeChatEventPollStopped                                    = "chatEventPollStopped"
	TypeChatEventMemberJoined                                   = "chatEventMemberJoined"
	TypeChatEventMemberJoinedByInviteLink                       = "chatEventMemberJoinedByInviteLink"
	TypeChatEventMemberJoinedByRequest                          = "chatEventMemberJoinedByRequest"
	TypeChatEventMemberInvited                                  = "chatEventMemberInvited"
	TypeChatEventMemberLeft                                     = "chatEventMemberLeft"
	TypeChatEventMemberPromoted                                 = "chatEventMemberPromoted"
	TypeChatEventMemberRestricted                               = "chatEventMemberRestricted"
	TypeChatEventAvailableReactionsChanged                      = "chatEventAvailableReactionsChanged"
	TypeChatEventDescriptionChanged                             = "chatEventDescriptionChanged"
	TypeChatEventLinkedChatChanged                              = "chatEventLinkedChatChanged"
	TypeChatEventLocationChanged                                = "chatEventLocationChanged"
	TypeChatEventMessageAutoDeleteTimeChanged                   = "chatEventMessageAutoDeleteTimeChanged"
	TypeChatEventPermissionsChanged                             = "chatEventPermissionsChanged"
	TypeChatEventPhotoChanged                                   = "chatEventPhotoChanged"
	TypeChatEventSlowModeDelayChanged                           = "chatEventSlowModeDelayChanged"
	TypeChatEventStickerSetChanged                              = "chatEventStickerSetChanged"
	TypeChatEventTitleChanged                                   = "chatEventTitleChanged"
	TypeChatEventUsernameChanged                                = "chatEventUsernameChanged"
	TypeChatEventActiveUsernamesChanged                         = "chatEventActiveUsernamesChanged"
	TypeChatEventHasProtectedContentToggled                     = "chatEventHasProtectedContentToggled"
	TypeChatEventInvitesToggled                                 = "chatEventInvitesToggled"
	TypeChatEventIsAllHistoryAvailableToggled                   = "chatEventIsAllHistoryAvailableToggled"
	TypeChatEventHasAggressiveAntiSpamEnabledToggled            = "chatEventHasAggressiveAntiSpamEnabledToggled"
	TypeChatEventSignMessagesToggled                            = "chatEventSignMessagesToggled"
	TypeChatEventInviteLinkEdited                               = "chatEventInviteLinkEdited"
	TypeChatEventInviteLinkRevoked                              = "chatEventInviteLinkRevoked"
	TypeChatEventInviteLinkDeleted                              = "chatEventInviteLinkDeleted"
	TypeChatEventVideoChatCreated                               = "chatEventVideoChatCreated"
	TypeChatEventVideoChatEnded                                 = "chatEventVideoChatEnded"
	TypeChatEventVideoChatMuteNewParticipantsToggled            = "chatEventVideoChatMuteNewParticipantsToggled"
	TypeChatEventVideoChatParticipantIsMutedToggled             = "chatEventVideoChatParticipantIsMutedToggled"
	TypeChatEventVideoChatParticipantVolumeLevelChanged         = "chatEventVideoChatParticipantVolumeLevelChanged"
	TypeChatEventIsForumToggled                                 = "chatEventIsForumToggled"
	TypeChatEventForumTopicCreated                              = "chatEventForumTopicCreated"
	TypeChatEventForumTopicEdited                               = "chatEventForumTopicEdited"
	TypeChatEventForumTopicToggleIsClosed                       = "chatEventForumTopicToggleIsClosed"
	TypeChatEventForumTopicToggleIsHidden                       = "chatEventForumTopicToggleIsHidden"
	TypeChatEventForumTopicDeleted                              = "chatEventForumTopicDeleted"
	TypeChatEventForumTopicPinned                               = "chatEventForumTopicPinned"
	TypeChatEvent                                               = "chatEvent"
	TypeChatEvents                                              = "chatEvents"
	TypeChatEventLogFilters                                     = "chatEventLogFilters"
	TypeLanguagePackStringValueOrdinary                         = "languagePackStringValueOrdinary"
	TypeLanguagePackStringValuePluralized                       = "languagePackStringValuePluralized"
	TypeLanguagePackStringValueDeleted                          = "languagePackStringValueDeleted"
	TypeLanguagePackString                                      = "languagePackString"
	TypeLanguagePackStrings                                     = "languagePackStrings"
	TypeLanguagePackInfo                                        = "languagePackInfo"
	TypeLocalizationTargetInfo                                  = "localizationTargetInfo"
	TypePremiumLimitTypeSupergroupCount                         = "premiumLimitTypeSupergroupCount"
	TypePremiumLimitTypePinnedChatCount                         = "premiumLimitTypePinnedChatCount"
	TypePremiumLimitTypeCreatedPublicChatCount                  = "premiumLimitTypeCreatedPublicChatCount"
	TypePremiumLimitTypeSavedAnimationCount                     = "premiumLimitTypeSavedAnimationCount"
	TypePremiumLimitTypeFavoriteStickerCount                    = "premiumLimitTypeFavoriteStickerCount"
	TypePremiumLimitTypeChatFilterCount                         = "premiumLimitTypeChatFilterCount"
	TypePremiumLimitTypeChatFilterChosenChatCount               = "premiumLimitTypeChatFilterChosenChatCount"
	TypePremiumLimitTypePinnedArchivedChatCount                 = "premiumLimitTypePinnedArchivedChatCount"
	TypePremiumLimitTypeCaptionLength                           = "premiumLimitTypeCaptionLength"
	TypePremiumLimitTypeBioLength                               = "premiumLimitTypeBioLength"
	TypePremiumFeatureIncreasedLimits                           = "premiumFeatureIncreasedLimits"
	TypePremiumFeatureIncreasedUploadFileSize                   = "premiumFeatureIncreasedUploadFileSize"
	TypePremiumFeatureImprovedDownloadSpeed                     = "premiumFeatureImprovedDownloadSpeed"
	TypePremiumFeatureVoiceRecognition                          = "premiumFeatureVoiceRecognition"
	TypePremiumFeatureDisabledAds                               = "premiumFeatureDisabledAds"
	TypePremiumFeatureUniqueReactions                           = "premiumFeatureUniqueReactions"
	TypePremiumFeatureUniqueStickers                            = "premiumFeatureUniqueStickers"
	TypePremiumFeatureCustomEmoji                               = "premiumFeatureCustomEmoji"
	TypePremiumFeatureAdvancedChatManagement                    = "premiumFeatureAdvancedChatManagement"
	TypePremiumFeatureProfileBadge                              = "premiumFeatureProfileBadge"
	TypePremiumFeatureEmojiStatus                               = "premiumFeatureEmojiStatus"
	TypePremiumFeatureAnimatedProfilePhoto                      = "premiumFeatureAnimatedProfilePhoto"
	TypePremiumFeatureForumTopicIcon                            = "premiumFeatureForumTopicIcon"
	TypePremiumFeatureAppIcons                                  = "premiumFeatureAppIcons"
	TypePremiumFeatureRealTimeChatTranslation                   = "premiumFeatureRealTimeChatTranslation"
	TypePremiumLimit                                            = "premiumLimit"
	TypePremiumFeatures                                         = "premiumFeatures"
	TypePremiumSourceLimitExceeded                              = "premiumSourceLimitExceeded"
	TypePremiumSourceFeature                                    = "premiumSourceFeature"
	TypePremiumSourceLink                                       = "premiumSourceLink"
	TypePremiumSourceSettings                                   = "premiumSourceSettings"
	TypePremiumFeaturePromotionAnimation                        = "premiumFeaturePromotionAnimation"
	TypePremiumState                                            = "premiumState"
	TypeStorePaymentPurposePremiumSubscription                  = "storePaymentPurposePremiumSubscription"
	TypeStorePaymentPurposeGiftedPremium                        = "storePaymentPurposeGiftedPremium"
	TypeDeviceTokenFirebaseCloudMessaging                       = "deviceTokenFirebaseCloudMessaging"
	TypeDeviceTokenApplePush                                    = "deviceTokenApplePush"
	TypeDeviceTokenApplePushVoIP                                = "deviceTokenApplePushVoIP"
	TypeDeviceTokenWindowsPush                                  = "deviceTokenWindowsPush"
	TypeDeviceTokenMicrosoftPush                                = "deviceTokenMicrosoftPush"
	TypeDeviceTokenMicrosoftPushVoIP                            = "deviceTokenMicrosoftPushVoIP"
	TypeDeviceTokenWebPush                                      = "deviceTokenWebPush"
	TypeDeviceTokenSimplePush                                   = "deviceTokenSimplePush"
	TypeDeviceTokenUbuntuPush                                   = "deviceTokenUbuntuPush"
	TypeDeviceTokenBlackBerryPush                               = "deviceTokenBlackBerryPush"
	TypeDeviceTokenTizenPush                                    = "deviceTokenTizenPush"
	TypeDeviceTokenHuaweiPush                                   = "deviceTokenHuaweiPush"
	TypePushReceiverId                                          = "pushReceiverId"
	TypeBackgroundFillSolid                                     = "backgroundFillSolid"
	TypeBackgroundFillGradient                                  = "backgroundFillGradient"
	TypeBackgroundFillFreeformGradient                          = "backgroundFillFreeformGradient"
	TypeBackgroundTypeWallpaper                                 = "backgroundTypeWallpaper"
	TypeBackgroundTypePattern                                   = "backgroundTypePattern"
	TypeBackgroundTypeFill                                      = "backgroundTypeFill"
	TypeBackground                                              = "background"
	TypeBackgrounds                                             = "backgrounds"
	TypeInputBackgroundLocal                                    = "inputBackgroundLocal"
	TypeInputBackgroundRemote                                   = "inputBackgroundRemote"
	TypeThemeSettings                                           = "themeSettings"
	TypeChatTheme                                               = "chatTheme"
	TypeHashtags                                                = "hashtags"
	TypeCanTransferOwnershipResultOk                            = "canTransferOwnershipResultOk"
	TypeCanTransferOwnershipResultPasswordNeeded                = "canTransferOwnershipResultPasswordNeeded"
	TypeCanTransferOwnershipResultPasswordTooFresh              = "canTransferOwnershipResultPasswordTooFresh"
	TypeCanTransferOwnershipResultSessionTooFresh               = "canTransferOwnershipResultSessionTooFresh"
	TypeCheckChatUsernameResultOk                               = "checkChatUsernameResultOk"
	TypeCheckChatUsernameResultUsernameInvalid                  = "checkChatUsernameResultUsernameInvalid"
	TypeCheckChatUsernameResultUsernameOccupied                 = "checkChatUsernameResultUsernameOccupied"
	TypeCheckChatUsernameResultUsernamePurchasable              = "checkChatUsernameResultUsernamePurchasable"
	TypeCheckChatUsernameResultPublicChatsTooMany               = "checkChatUsernameResultPublicChatsTooMany"
	TypeCheckChatUsernameResultPublicGroupsUnavailable          = "checkChatUsernameResultPublicGroupsUnavailable"
	TypeCheckStickerSetNameResultOk                             = "checkStickerSetNameResultOk"
	TypeCheckStickerSetNameResultNameInvalid                    = "checkStickerSetNameResultNameInvalid"
	TypeCheckStickerSetNameResultNameOccupied                   = "checkStickerSetNameResultNameOccupied"
	TypeResetPasswordResultOk                                   = "resetPasswordResultOk"
	TypeResetPasswordResultPending                              = "resetPasswordResultPending"
	TypeResetPasswordResultDeclined                             = "resetPasswordResultDeclined"
	TypeMessageFileTypePrivate                                  = "messageFileTypePrivate"
	TypeMessageFileTypeGroup                                    = "messageFileTypeGroup"
	TypeMessageFileTypeUnknown                                  = "messageFileTypeUnknown"
	TypePushMessageContentHidden                                = "pushMessageContentHidden"
	TypePushMessageContentAnimation                             = "pushMessageContentAnimation"
	TypePushMessageContentAudio                                 = "pushMessageContentAudio"
	TypePushMessageContentContact                               = "pushMessageContentContact"
	TypePushMessageContentContactRegistered                     = "pushMessageContentContactRegistered"
	TypePushMessageContentDocument                              = "pushMessageContentDocument"
	TypePushMessageContentGame                                  = "pushMessageContentGame"
	TypePushMessageContentGameScore                             = "pushMessageContentGameScore"
	TypePushMessageContentInvoice                               = "pushMessageContentInvoice"
	TypePushMessageContentLocation                              = "pushMessageContentLocation"
	TypePushMessageContentPhoto                                 = "pushMessageContentPhoto"
	TypePushMessageContentPoll                                  = "pushMessageContentPoll"
	TypePushMessageContentScreenshotTaken                       = "pushMessageContentScreenshotTaken"
	TypePushMessageContentSticker                               = "pushMessageContentSticker"
	TypePushMessageContentText                                  = "pushMessageContentText"
	TypePushMessageContentVideo                                 = "pushMessageContentVideo"
	TypePushMessageContentVideoNote                             = "pushMessageContentVideoNote"
	TypePushMessageContentVoiceNote                             = "pushMessageContentVoiceNote"
	TypePushMessageContentBasicGroupChatCreate                  = "pushMessageContentBasicGroupChatCreate"
	TypePushMessageContentChatAddMembers                        = "pushMessageContentChatAddMembers"
	TypePushMessageContentChatChangePhoto                       = "pushMessageContentChatChangePhoto"
	TypePushMessageContentChatChangeTitle                       = "pushMessageContentChatChangeTitle"
	TypePushMessageContentChatSetTheme                          = "pushMessageContentChatSetTheme"
	TypePushMessageContentChatDeleteMember                      = "pushMessageContentChatDeleteMember"
	TypePushMessageContentChatJoinByLink                        = "pushMessageContentChatJoinByLink"
	TypePushMessageContentChatJoinByRequest                     = "pushMessageContentChatJoinByRequest"
	TypePushMessageContentRecurringPayment                      = "pushMessageContentRecurringPayment"
	TypePushMessageContentSuggestProfilePhoto                   = "pushMessageContentSuggestProfilePhoto"
	TypePushMessageContentMessageForwards                       = "pushMessageContentMessageForwards"
	TypePushMessageContentMediaAlbum                            = "pushMessageContentMediaAlbum"
	TypeNotificationTypeNewMessage                              = "notificationTypeNewMessage"
	TypeNotificationTypeNewSecretChat                           = "notificationTypeNewSecretChat"
	TypeNotificationTypeNewCall                                 = "notificationTypeNewCall"
	TypeNotificationTypeNewPushMessage                          = "notificationTypeNewPushMessage"
	TypeNotificationGroupTypeMessages                           = "notificationGroupTypeMessages"
	TypeNotificationGroupTypeMentions                           = "notificationGroupTypeMentions"
	TypeNotificationGroupTypeSecretChat                         = "notificationGroupTypeSecretChat"
	TypeNotificationGroupTypeCalls                              = "notificationGroupTypeCalls"
	TypeNotificationSound                                       = "notificationSound"
	TypeNotificationSounds                                      = "notificationSounds"
	TypeNotification                                            = "notification"
	TypeNotificationGroup                                       = "notificationGroup"
	TypeOptionValueBoolean                                      = "optionValueBoolean"
	TypeOptionValueEmpty                                        = "optionValueEmpty"
	TypeOptionValueInteger                                      = "optionValueInteger"
	TypeOptionValueString                                       = "optionValueString"
	TypeJsonObjectMember                                        = "jsonObjectMember"
	TypeJsonValueNull                                           = "jsonValueNull"
	TypeJsonValueBoolean                                        = "jsonValueBoolean"
	TypeJsonValueNumber                                         = "jsonValueNumber"
	TypeJsonValueString                                         = "jsonValueString"
	TypeJsonValueArray                                          = "jsonValueArray"
	TypeJsonValueObject                                         = "jsonValueObject"
	TypeUserPrivacySettingRuleAllowAll                          = "userPrivacySettingRuleAllowAll"
	TypeUserPrivacySettingRuleAllowContacts                     = "userPrivacySettingRuleAllowContacts"
	TypeUserPrivacySettingRuleAllowUsers                        = "userPrivacySettingRuleAllowUsers"
	TypeUserPrivacySettingRuleAllowChatMembers                  = "userPrivacySettingRuleAllowChatMembers"
	TypeUserPrivacySettingRuleRestrictAll                       = "userPrivacySettingRuleRestrictAll"
	TypeUserPrivacySettingRuleRestrictContacts                  = "userPrivacySettingRuleRestrictContacts"
	TypeUserPrivacySettingRuleRestrictUsers                     = "userPrivacySettingRuleRestrictUsers"
	TypeUserPrivacySettingRuleRestrictChatMembers               = "userPrivacySettingRuleRestrictChatMembers"
	TypeUserPrivacySettingRules                                 = "userPrivacySettingRules"
	TypeUserPrivacySettingShowStatus                            = "userPrivacySettingShowStatus"
	TypeUserPrivacySettingShowProfilePhoto                      = "userPrivacySettingShowProfilePhoto"
	TypeUserPrivacySettingShowLinkInForwardedMessages           = "userPrivacySettingShowLinkInForwardedMessages"
	TypeUserPrivacySettingShowPhoneNumber                       = "userPrivacySettingShowPhoneNumber"
	TypeUserPrivacySettingAllowChatInvites                      = "userPrivacySettingAllowChatInvites"
	TypeUserPrivacySettingAllowCalls                            = "userPrivacySettingAllowCalls"
	TypeUserPrivacySettingAllowPeerToPeerCalls                  = "userPrivacySettingAllowPeerToPeerCalls"
	TypeUserPrivacySettingAllowFindingByPhoneNumber             = "userPrivacySettingAllowFindingByPhoneNumber"
	TypeUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"
	TypeAccountTtl                                              = "accountTtl"
	TypeMessageAutoDeleteTime                                   = "messageAutoDeleteTime"
	TypeSessionTypeAndroid                                      = "sessionTypeAndroid"
	TypeSessionTypeApple                                        = "sessionTypeApple"
	TypeSessionTypeBrave                                        = "sessionTypeBrave"
	TypeSessionTypeChrome                                       = "sessionTypeChrome"
	TypeSessionTypeEdge                                         = "sessionTypeEdge"
	TypeSessionTypeFirefox                                      = "sessionTypeFirefox"
	TypeSessionTypeIpad                                         = "sessionTypeIpad"
	TypeSessionTypeIphone                                       = "sessionTypeIphone"
	TypeSessionTypeLinux                                        = "sessionTypeLinux"
	TypeSessionTypeMac                                          = "sessionTypeMac"
	TypeSessionTypeOpera                                        = "sessionTypeOpera"
	TypeSessionTypeSafari                                       = "sessionTypeSafari"
	TypeSessionTypeUbuntu                                       = "sessionTypeUbuntu"
	TypeSessionTypeUnknown                                      = "sessionTypeUnknown"
	TypeSessionTypeVivaldi                                      = "sessionTypeVivaldi"
	TypeSessionTypeWindows                                      = "sessionTypeWindows"
	TypeSessionTypeXbox                                         = "sessionTypeXbox"
	TypeSession                                                 = "session"
	TypeSessions                                                = "sessions"
	TypeConnectedWebsite                                        = "connectedWebsite"
	TypeConnectedWebsites                                       = "connectedWebsites"
	TypeChatReportReasonSpam                                    = "chatReportReasonSpam"
	TypeChatReportReasonViolence                                = "chatReportReasonViolence"
	TypeChatReportReasonPornography                             = "chatReportReasonPornography"
	TypeChatReportReasonChildAbuse                              = "chatReportReasonChildAbuse"
	TypeChatReportReasonCopyright                               = "chatReportReasonCopyright"
	TypeChatReportReasonUnrelatedLocation                       = "chatReportReasonUnrelatedLocation"
	TypeChatReportReasonFake                                    = "chatReportReasonFake"
	TypeChatReportReasonIllegalDrugs                            = "chatReportReasonIllegalDrugs"
	TypeChatReportReasonPersonalDetails                         = "chatReportReasonPersonalDetails"
	TypeChatReportReasonCustom                                  = "chatReportReasonCustom"
	TypeTargetChatCurrent                                       = "targetChatCurrent"
	TypeTargetChatChosen                                        = "targetChatChosen"
	TypeTargetChatInternalLink                                  = "targetChatInternalLink"
	TypeInternalLinkTypeActiveSessions                          = "internalLinkTypeActiveSessions"
	TypeInternalLinkTypeAttachmentMenuBot                       = "internalLinkTypeAttachmentMenuBot"
	TypeInternalLinkTypeAuthenticationCode                      = "internalLinkTypeAuthenticationCode"
	TypeInternalLinkTypeBackground                              = "internalLinkTypeBackground"
	TypeInternalLinkTypeBotAddToChannel                         = "internalLinkTypeBotAddToChannel"
	TypeInternalLinkTypeBotStart                                = "internalLinkTypeBotStart"
	TypeInternalLinkTypeBotStartInGroup                         = "internalLinkTypeBotStartInGroup"
	TypeInternalLinkTypeChangePhoneNumber                       = "internalLinkTypeChangePhoneNumber"
	TypeInternalLinkTypeChatInvite                              = "internalLinkTypeChatInvite"
	TypeInternalLinkTypeDefaultMessageAutoDeleteTimerSettings   = "internalLinkTypeDefaultMessageAutoDeleteTimerSettings"
	TypeInternalLinkTypeEditProfileSettings                     = "internalLinkTypeEditProfileSettings"
	TypeInternalLinkTypeFilterSettings                          = "internalLinkTypeFilterSettings"
	TypeInternalLinkTypeGame                                    = "internalLinkTypeGame"
	TypeInternalLinkTypeInstantView                             = "internalLinkTypeInstantView"
	TypeInternalLinkTypeInvoice                                 = "internalLinkTypeInvoice"
	TypeInternalLinkTypeLanguagePack                            = "internalLinkTypeLanguagePack"
	TypeInternalLinkTypeLanguageSettings                        = "internalLinkTypeLanguageSettings"
	TypeInternalLinkTypeMessage                                 = "internalLinkTypeMessage"
	TypeInternalLinkTypeMessageDraft                            = "internalLinkTypeMessageDraft"
	TypeInternalLinkTypePassportDataRequest                     = "internalLinkTypePassportDataRequest"
	TypeInternalLinkTypePhoneNumberConfirmation                 = "internalLinkTypePhoneNumberConfirmation"
	TypeInternalLinkTypePremiumFeatures                         = "internalLinkTypePremiumFeatures"
	TypeInternalLinkTypePrivacyAndSecuritySettings              = "internalLinkTypePrivacyAndSecuritySettings"
	TypeInternalLinkTypeProxy                                   = "internalLinkTypeProxy"
	TypeInternalLinkTypePublicChat                              = "internalLinkTypePublicChat"
	TypeInternalLinkTypeQrCodeAuthentication                    = "internalLinkTypeQrCodeAuthentication"
	TypeInternalLinkTypeRestorePurchases                        = "internalLinkTypeRestorePurchases"
	TypeInternalLinkTypeSettings                                = "internalLinkTypeSettings"
	TypeInternalLinkTypeStickerSet                              = "internalLinkTypeStickerSet"
	TypeInternalLinkTypeTheme                                   = "internalLinkTypeTheme"
	TypeInternalLinkTypeThemeSettings                           = "internalLinkTypeThemeSettings"
	TypeInternalLinkTypeUnknownDeepLink                         = "internalLinkTypeUnknownDeepLink"
	TypeInternalLinkTypeUnsupportedProxy                        = "internalLinkTypeUnsupportedProxy"
	TypeInternalLinkTypeUserPhoneNumber                         = "internalLinkTypeUserPhoneNumber"
	TypeInternalLinkTypeUserToken                               = "internalLinkTypeUserToken"
	TypeInternalLinkTypeVideoChat                               = "internalLinkTypeVideoChat"
	TypeInternalLinkTypeWebApp                                  = "internalLinkTypeWebApp"
	TypeMessageLink                                             = "messageLink"
	TypeMessageLinkInfo                                         = "messageLinkInfo"
	TypeFilePart                                                = "filePart"
	TypeFileTypeNone                                            = "fileTypeNone"
	TypeFileTypeAnimation                                       = "fileTypeAnimation"
	TypeFileTypeAudio                                           = "fileTypeAudio"
	TypeFileTypeDocument                                        = "fileTypeDocument"
	TypeFileTypeNotificationSound                               = "fileTypeNotificationSound"
	TypeFileTypePhoto                                           = "fileTypePhoto"
	TypeFileTypeProfilePhoto                                    = "fileTypeProfilePhoto"
	TypeFileTypeSecret                                          = "fileTypeSecret"
	TypeFileTypeSecretThumbnail                                 = "fileTypeSecretThumbnail"
	TypeFileTypeSecure                                          = "fileTypeSecure"
	TypeFileTypeSticker                                         = "fileTypeSticker"
	TypeFileTypeThumbnail                                       = "fileTypeThumbnail"
	TypeFileTypeUnknown                                         = "fileTypeUnknown"
	TypeFileTypeVideo                                           = "fileTypeVideo"
	TypeFileTypeVideoNote                                       = "fileTypeVideoNote"
	TypeFileTypeVoiceNote                                       = "fileTypeVoiceNote"
	TypeFileTypeWallpaper                                       = "fileTypeWallpaper"
	TypeStorageStatisticsByFileType                             = "storageStatisticsByFileType"
	TypeStorageStatisticsByChat                                 = "storageStatisticsByChat"
	TypeStorageStatistics                                       = "storageStatistics"
	TypeStorageStatisticsFast                                   = "storageStatisticsFast"
	TypeDatabaseStatistics                                      = "databaseStatistics"
	TypeNetworkTypeNone                                         = "networkTypeNone"
	TypeNetworkTypeMobile                                       = "networkTypeMobile"
	TypeNetworkTypeMobileRoaming                                = "networkTypeMobileRoaming"
	TypeNetworkTypeWiFi                                         = "networkTypeWiFi"
	TypeNetworkTypeOther                                        = "networkTypeOther"
	TypeNetworkStatisticsEntryFile                              = "networkStatisticsEntryFile"
	TypeNetworkStatisticsEntryCall                              = "networkStatisticsEntryCall"
	TypeNetworkStatistics                                       = "networkStatistics"
	TypeAutoDownloadSettings                                    = "autoDownloadSettings"
	TypeAutoDownloadSettingsPresets                             = "autoDownloadSettingsPresets"
	TypeAutosaveSettingsScopePrivateChats                       = "autosaveSettingsScopePrivateChats"
	TypeAutosaveSettingsScopeGroupChats                         = "autosaveSettingsScopeGroupChats"
	TypeAutosaveSettingsScopeChannelChats                       = "autosaveSettingsScopeChannelChats"
	TypeAutosaveSettingsScopeChat                               = "autosaveSettingsScopeChat"
	TypeScopeAutosaveSettings                                   = "scopeAutosaveSettings"
	TypeAutosaveSettingsException                               = "autosaveSettingsException"
	TypeAutosaveSettings                                        = "autosaveSettings"
	TypeConnectionStateWaitingForNetwork                        = "connectionStateWaitingForNetwork"
	TypeConnectionStateConnectingToProxy                        = "connectionStateConnectingToProxy"
	TypeConnectionStateConnecting                               = "connectionStateConnecting"
	TypeConnectionStateUpdating                                 = "connectionStateUpdating"
	TypeConnectionStateReady                                    = "connectionStateReady"
	TypeTopChatCategoryUsers                                    = "topChatCategoryUsers"
	TypeTopChatCategoryBots                                     = "topChatCategoryBots"
	TypeTopChatCategoryGroups                                   = "topChatCategoryGroups"
	TypeTopChatCategoryChannels                                 = "topChatCategoryChannels"
	TypeTopChatCategoryInlineBots                               = "topChatCategoryInlineBots"
	TypeTopChatCategoryCalls                                    = "topChatCategoryCalls"
	TypeTopChatCategoryForwardChats                             = "topChatCategoryForwardChats"
	TypeTMeUrlTypeUser                                          = "tMeUrlTypeUser"
	TypeTMeUrlTypeSupergroup                                    = "tMeUrlTypeSupergroup"
	TypeTMeUrlTypeChatInvite                                    = "tMeUrlTypeChatInvite"
	TypeTMeUrlTypeStickerSet                                    = "tMeUrlTypeStickerSet"
	TypeTMeUrl                                                  = "tMeUrl"
	TypeTMeUrls                                                 = "tMeUrls"
	TypeSuggestedActionEnableArchiveAndMuteNewChats             = "suggestedActionEnableArchiveAndMuteNewChats"
	TypeSuggestedActionCheckPassword                            = "suggestedActionCheckPassword"
	TypeSuggestedActionCheckPhoneNumber                         = "suggestedActionCheckPhoneNumber"
	TypeSuggestedActionViewChecksHint                           = "suggestedActionViewChecksHint"
	TypeSuggestedActionConvertToBroadcastGroup                  = "suggestedActionConvertToBroadcastGroup"
	TypeSuggestedActionSetPassword                              = "suggestedActionSetPassword"
	TypeSuggestedActionUpgradePremium                           = "suggestedActionUpgradePremium"
	TypeSuggestedActionSubscribeToAnnualPremium                 = "suggestedActionSubscribeToAnnualPremium"
	TypeCount                                                   = "count"
	TypeText                                                    = "text"
	TypeSeconds                                                 = "seconds"
	TypeFileDownloadedPrefixSize                                = "fileDownloadedPrefixSize"
	TypeDeepLinkInfo                                            = "deepLinkInfo"
	TypeTextParseModeMarkdown                                   = "textParseModeMarkdown"
	TypeTextParseModeHTML                                       = "textParseModeHTML"
	TypeProxyTypeSocks5                                         = "proxyTypeSocks5"
	TypeProxyTypeHttp                                           = "proxyTypeHttp"
	TypeProxyTypeMtproto                                        = "proxyTypeMtproto"
	TypeProxy                                                   = "proxy"
	TypeProxies                                                 = "proxies"
	TypeInputSticker                                            = "inputSticker"
	TypeDateRange                                               = "dateRange"
	TypeStatisticalValue                                        = "statisticalValue"
	TypeStatisticalGraphData                                    = "statisticalGraphData"
	TypeStatisticalGraphAsync                                   = "statisticalGraphAsync"
	TypeStatisticalGraphError                                   = "statisticalGraphError"
	TypeChatStatisticsMessageInteractionInfo                    = "chatStatisticsMessageInteractionInfo"
	TypeChatStatisticsMessageSenderInfo                         = "chatStatisticsMessageSenderInfo"
	TypeChatStatisticsAdministratorActionsInfo                  = "chatStatisticsAdministratorActionsInfo"
	TypeChatStatisticsInviterInfo                               = "chatStatisticsInviterInfo"
	TypeChatStatisticsSupergroup                                = "chatStatisticsSupergroup"
	TypeChatStatisticsChannel                                   = "chatStatisticsChannel"
	TypeMessageStatistics                                       = "messageStatistics"
	TypePoint                                                   = "point"
	TypeVectorPathCommandLine                                   = "vectorPathCommandLine"
	TypeVectorPathCommandCubicBezierCurve                       = "vectorPathCommandCubicBezierCurve"
	TypeBotCommandScopeDefault                                  = "botCommandScopeDefault"
	TypeBotCommandScopeAllPrivateChats                          = "botCommandScopeAllPrivateChats"
	TypeBotCommandScopeAllGroupChats                            = "botCommandScopeAllGroupChats"
	TypeBotCommandScopeAllChatAdministrators                    = "botCommandScopeAllChatAdministrators"
	TypeBotCommandScopeChat                                     = "botCommandScopeChat"
	TypeBotCommandScopeChatAdministrators                       = "botCommandScopeChatAdministrators"
	TypeBotCommandScopeChatMember                               = "botCommandScopeChatMember"
	TypeUpdateAuthorizationState                                = "updateAuthorizationState"
	TypeUpdateNewMessage                                        = "updateNewMessage"
	TypeUpdateMessageSendAcknowledged                           = "updateMessageSendAcknowledged"
	TypeUpdateMessageSendSucceeded                              = "updateMessageSendSucceeded"
	TypeUpdateMessageSendFailed                                 = "updateMessageSendFailed"
	TypeUpdateMessageContent                                    = "updateMessageContent"
	TypeUpdateMessageEdited                                     = "updateMessageEdited"
	TypeUpdateMessageIsPinned                                   = "updateMessageIsPinned"
	TypeUpdateMessageInteractionInfo                            = "updateMessageInteractionInfo"
	TypeUpdateMessageContentOpened                              = "updateMessageContentOpened"
	TypeUpdateMessageMentionRead                                = "updateMessageMentionRead"
	TypeUpdateMessageUnreadReactions                            = "updateMessageUnreadReactions"
	TypeUpdateMessageLiveLocationViewed                         = "updateMessageLiveLocationViewed"
	TypeUpdateNewChat                                           = "updateNewChat"
	TypeUpdateChatTitle                                         = "updateChatTitle"
	TypeUpdateChatPhoto                                         = "updateChatPhoto"
	TypeUpdateChatPermissions                                   = "updateChatPermissions"
	TypeUpdateChatLastMessage                                   = "updateChatLastMessage"
	TypeUpdateChatPosition                                      = "updateChatPosition"
	TypeUpdateChatReadInbox                                     = "updateChatReadInbox"
	TypeUpdateChatReadOutbox                                    = "updateChatReadOutbox"
	TypeUpdateChatActionBar                                     = "updateChatActionBar"
	TypeUpdateChatAvailableReactions                            = "updateChatAvailableReactions"
	TypeUpdateChatDraftMessage                                  = "updateChatDraftMessage"
	TypeUpdateChatMessageSender                                 = "updateChatMessageSender"
	TypeUpdateChatMessageAutoDeleteTime                         = "updateChatMessageAutoDeleteTime"
	TypeUpdateChatNotificationSettings                          = "updateChatNotificationSettings"
	TypeUpdateChatPendingJoinRequests                           = "updateChatPendingJoinRequests"
	TypeUpdateChatReplyMarkup                                   = "updateChatReplyMarkup"
	TypeUpdateChatTheme                                         = "updateChatTheme"
	TypeUpdateChatUnreadMentionCount                            = "updateChatUnreadMentionCount"
	TypeUpdateChatUnreadReactionCount                           = "updateChatUnreadReactionCount"
	TypeUpdateChatVideoChat                                     = "updateChatVideoChat"
	TypeUpdateChatDefaultDisableNotification                    = "updateChatDefaultDisableNotification"
	TypeUpdateChatHasProtectedContent                           = "updateChatHasProtectedContent"
	TypeUpdateChatIsTranslatable                                = "updateChatIsTranslatable"
	TypeUpdateChatIsMarkedAsUnread                              = "updateChatIsMarkedAsUnread"
	TypeUpdateChatIsBlocked                                     = "updateChatIsBlocked"
	TypeUpdateChatHasScheduledMessages                          = "updateChatHasScheduledMessages"
	TypeUpdateChatFilters                                       = "updateChatFilters"
	TypeUpdateChatOnlineMemberCount                             = "updateChatOnlineMemberCount"
	TypeUpdateForumTopicInfo                                    = "updateForumTopicInfo"
	TypeUpdateScopeNotificationSettings                         = "updateScopeNotificationSettings"
	TypeUpdateNotification                                      = "updateNotification"
	TypeUpdateNotificationGroup                                 = "updateNotificationGroup"
	TypeUpdateActiveNotifications                               = "updateActiveNotifications"
	TypeUpdateHavePendingNotifications                          = "updateHavePendingNotifications"
	TypeUpdateDeleteMessages                                    = "updateDeleteMessages"
	TypeUpdateChatAction                                        = "updateChatAction"
	TypeUpdateUserStatus                                        = "updateUserStatus"
	TypeUpdateUser                                              = "updateUser"
	TypeUpdateBasicGroup                                        = "updateBasicGroup"
	TypeUpdateSupergroup                                        = "updateSupergroup"
	TypeUpdateSecretChat                                        = "updateSecretChat"
	TypeUpdateUserFullInfo                                      = "updateUserFullInfo"
	TypeUpdateBasicGroupFullInfo                                = "updateBasicGroupFullInfo"
	TypeUpdateSupergroupFullInfo                                = "updateSupergroupFullInfo"
	TypeUpdateServiceNotification                               = "updateServiceNotification"
	TypeUpdateFile                                              = "updateFile"
	TypeUpdateFileGenerationStart                               = "updateFileGenerationStart"
	TypeUpdateFileGenerationStop                                = "updateFileGenerationStop"
	TypeUpdateFileDownloads                                     = "updateFileDownloads"
	TypeUpdateFileAddedToDownloads                              = "updateFileAddedToDownloads"
	TypeUpdateFileDownload                                      = "updateFileDownload"
	TypeUpdateFileRemovedFromDownloads                          = "updateFileRemovedFromDownloads"
	TypeUpdateCall                                              = "updateCall"
	TypeUpdateGroupCall                                         = "updateGroupCall"
	TypeUpdateGroupCallParticipant                              = "updateGroupCallParticipant"
	TypeUpdateNewCallSignalingData                              = "updateNewCallSignalingData"
	TypeUpdateUserPrivacySettingRules                           = "updateUserPrivacySettingRules"
	TypeUpdateUnreadMessageCount                                = "updateUnreadMessageCount"
	TypeUpdateUnreadChatCount                                   = "updateUnreadChatCount"
	TypeUpdateOption                                            = "updateOption"
	TypeUpdateStickerSet                                        = "updateStickerSet"
	TypeUpdateInstalledStickerSets                              = "updateInstalledStickerSets"
	TypeUpdateTrendingStickerSets                               = "updateTrendingStickerSets"
	TypeUpdateRecentStickers                                    = "updateRecentStickers"
	TypeUpdateFavoriteStickers                                  = "updateFavoriteStickers"
	TypeUpdateSavedAnimations                                   = "updateSavedAnimations"
	TypeUpdateSavedNotificationSounds                           = "updateSavedNotificationSounds"
	TypeUpdateSelectedBackground                                = "updateSelectedBackground"
	TypeUpdateChatThemes                                        = "updateChatThemes"
	TypeUpdateLanguagePackStrings                               = "updateLanguagePackStrings"
	TypeUpdateConnectionState                                   = "updateConnectionState"
	TypeUpdateTermsOfService                                    = "updateTermsOfService"
	TypeUpdateUsersNearby                                       = "updateUsersNearby"
	TypeUpdateAttachmentMenuBots                                = "updateAttachmentMenuBots"
	TypeUpdateWebAppMessageSent                                 = "updateWebAppMessageSent"
	TypeUpdateActiveEmojiReactions                              = "updateActiveEmojiReactions"
	TypeUpdateDefaultReactionType                               = "updateDefaultReactionType"
	TypeUpdateDiceEmojis                                        = "updateDiceEmojis"
	TypeUpdateAnimatedEmojiMessageClicked                       = "updateAnimatedEmojiMessageClicked"
	TypeUpdateAnimationSearchParameters                         = "updateAnimationSearchParameters"
	TypeUpdateSuggestedActions                                  = "updateSuggestedActions"
	TypeUpdateAddChatMembersPrivacyForbidden                    = "updateAddChatMembersPrivacyForbidden"
	TypeUpdateAutosaveSettings                                  = "updateAutosaveSettings"
	TypeUpdateNewInlineQuery                                    = "updateNewInlineQuery"
	TypeUpdateNewChosenInlineResult                             = "updateNewChosenInlineResult"
	TypeUpdateNewCallbackQuery                                  = "updateNewCallbackQuery"
	TypeUpdateNewInlineCallbackQuery                            = "updateNewInlineCallbackQuery"
	TypeUpdateNewShippingQuery                                  = "updateNewShippingQuery"
	TypeUpdateNewPreCheckoutQuery                               = "updateNewPreCheckoutQuery"
	TypeUpdateNewCustomEvent                                    = "updateNewCustomEvent"
	TypeUpdateNewCustomQuery                                    = "updateNewCustomQuery"
	TypeUpdatePoll                                              = "updatePoll"
	TypeUpdatePollAnswer                                        = "updatePollAnswer"
	TypeUpdateChatMember                                        = "updateChatMember"
	TypeUpdateNewChatJoinRequest                                = "updateNewChatJoinRequest"
	TypeUpdates                                                 = "updates"
	TypeLogStreamDefault                                        = "logStreamDefault"
	TypeLogStreamFile                                           = "logStreamFile"
	TypeLogStreamEmpty                                          = "logStreamEmpty"
	TypeLogVerbosityLevel                                       = "logVerbosityLevel"
	TypeLogTags                                                 = "logTags"
	TypeUserSupportInfo                                         = "userSupportInfo"
	TypeTestInt                                                 = "testInt"
	TypeTestString                                              = "testString"
	TypeTestBytes                                               = "testBytes"
	TypeTestVectorInt                                           = "testVectorInt"
	TypeTestVectorIntObject                                     = "testVectorIntObject"
	TypeTestVectorString                                        = "testVectorString"
	TypeTestVectorStringObject                                  = "testVectorStringObject"
)

// Provides information about the method by which an authentication code is delivered to the user
type AuthenticationCodeType interface {
	AuthenticationCodeTypeType() string
}

// Contains authentication data for a email address
type EmailAddressAuthentication interface {
	EmailAddressAuthenticationType() string
}

// Describes reset state of a email address
type EmailAddressResetState interface {
	EmailAddressResetStateType() string
}

// Represents the current authorization state of the TDLib client
type AuthorizationState interface {
	AuthorizationStateType() string
}

// Points to a file
type InputFile interface {
	InputFileType() string
}

// Describes format of a thumbnail
type ThumbnailFormat interface {
	ThumbnailFormatType() string
}

// Part of the face, relative to which a mask is placed
type MaskPoint interface {
	MaskPointType() string
}

// Describes format of a sticker
type StickerFormat interface {
	StickerFormatType() string
}

// Describes type of a sticker
type StickerType interface {
	StickerTypeType() string
}

// Contains full information about sticker type
type StickerFullType interface {
	StickerFullTypeType() string
}

// Describes the type of a poll
type PollType interface {
	PollTypeType() string
}

// Represents the type of a user. The following types are possible: regular users, deleted users and bots
type UserType interface {
	UserTypeType() string
}

// Describes type of a sticker, which was used to create a chat photo
type ChatPhotoStickerType interface {
	ChatPhotoStickerTypeType() string
}

// Describes a photo to be set as a user profile or chat photo
type InputChatPhoto interface {
	InputChatPhotoType() string
}

// Provides information about the status of a member in a chat
type ChatMemberStatus interface {
	ChatMemberStatusType() string
}

// Specifies the kind of chat members to return in searchChatMembers
type ChatMembersFilter interface {
	ChatMembersFilterType() string
}

// Specifies the kind of chat members to return in getSupergroupMembers
type SupergroupMembersFilter interface {
	SupergroupMembersFilterType() string
}

// Describes the current secret chat state
type SecretChatState interface {
	SecretChatStateType() string
}

// Contains information about the sender of a message
type MessageSender interface {
	MessageSenderType() string
}

// Contains information about the origin of a forwarded message
type MessageForwardOrigin interface {
	MessageForwardOriginType() string
}

// Describes type of message reaction
type ReactionType interface {
	ReactionTypeType() string
}

// Contains information about the sending state of the message
type MessageSendingState interface {
	MessageSendingStateType() string
}

// Describes source of a message
type MessageSource interface {
	MessageSourceType() string
}

// Describes the types of chats to which notification settings are relevant
type NotificationSettingsScope interface {
	NotificationSettingsScopeType() string
}

// Describes the type of a chat
type ChatType interface {
	ChatTypeType() string
}

// Describes a list of chats
type ChatList interface {
	ChatListType() string
}

// Describes a reason why an external chat is shown in a chat list
type ChatSource interface {
	ChatSourceType() string
}

// Describes reactions available in the chat
type ChatAvailableReactions interface {
	ChatAvailableReactionsType() string
}

// Describes a type of public chats
type PublicChatType interface {
	PublicChatTypeType() string
}

// Describes actions which must be possible to do through a chat action bar
type ChatActionBar interface {
	ChatActionBarType() string
}

// Describes a keyboard button type
type KeyboardButtonType interface {
	KeyboardButtonTypeType() string
}

// Describes the type of an inline keyboard button
type InlineKeyboardButtonType interface {
	InlineKeyboardButtonTypeType() string
}

// Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots
type ReplyMarkup interface {
	ReplyMarkupType() string
}

// Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl
type LoginUrlInfo interface {
	LoginUrlInfoType() string
}

// Describes a text object inside an instant-view web page
type RichText interface {
	RichTextType() string
}

// Describes a horizontal alignment of a table cell content
type PageBlockHorizontalAlignment interface {
	PageBlockHorizontalAlignmentType() string
}

// Describes a Vertical alignment of a table cell content
type PageBlockVerticalAlignment interface {
	PageBlockVerticalAlignmentType() string
}

// Describes a block of an instant view web page
type PageBlock interface {
	PageBlockType() string
}

// Contains information about the payment method chosen by the user
type InputCredentials interface {
	InputCredentialsType() string
}

// Contains information about a payment provider
type PaymentProvider interface {
	PaymentProviderType() string
}

// Describes an invoice to process
type InputInvoice interface {
	InputInvoiceType() string
}

// Describes a media, which is attached to an invoice
type MessageExtendedMedia interface {
	MessageExtendedMediaType() string
}

// Contains the type of a Telegram Passport element
type PassportElementType interface {
	PassportElementTypeType() string
}

// Contains information about a Telegram Passport element
type PassportElement interface {
	PassportElementType() string
}

// Contains information about a Telegram Passport element to be saved
type InputPassportElement interface {
	InputPassportElementType() string
}

// Contains the description of an error in a Telegram Passport element
type PassportElementErrorSource interface {
	PassportElementErrorSourceType() string
}

// Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementErrorSource interface {
	InputPassportElementErrorSourceType() string
}

// Contains the content of a message
type MessageContent interface {
	MessageContentType() string
}

// Represents a part of the text which must be formatted differently
type TextEntityType interface {
	TextEntityTypeType() string
}

// Contains information about the time when a scheduled message will be sent
type MessageSchedulingState interface {
	MessageSchedulingStateType() string
}

// The content of a message to send
type InputMessageContent interface {
	InputMessageContentType() string
}

// Represents a filter for message search results
type SearchMessagesFilter interface {
	SearchMessagesFilterType() string
}

// Describes the different types of activity in a chat
type ChatAction interface {
	ChatActionType() string
}

// Describes the last time the user was online
type UserStatus interface {
	UserStatusType() string
}

// Describes type of an emoji category
type EmojiCategoryType interface {
	EmojiCategoryTypeType() string
}

// Describes the reason why a call was discarded
type CallDiscardReason interface {
	CallDiscardReasonType() string
}

// Describes the type of a call server
type CallServerType interface {
	CallServerTypeType() string
}

// Describes the current call state
type CallState interface {
	CallStateType() string
}

// Describes the quality of a group call video
type GroupCallVideoQuality interface {
	GroupCallVideoQualityType() string
}

// Describes the exact type of a problem with a call
type CallProblem interface {
	CallProblemType() string
}

// Contains settings for Firebase Authentication in the official applications
type FirebaseAuthenticationSettings interface {
	FirebaseAuthenticationSettingsType() string
}

// Contains animated stickers which must be used for dice animation rendering
type DiceStickers interface {
	DiceStickersType() string
}

// Describes result of speech recognition in a voice note
type SpeechRecognitionResult interface {
	SpeechRecognitionResultType() string
}

// Represents a single result of an inline query; for bots only
type InputInlineQueryResult interface {
	InputInlineQueryResultType() string
}

// Represents a single result of an inline query
type InlineQueryResult interface {
	InlineQueryResultType() string
}

// Represents a type of a button in results of inline query
type InlineQueryResultsButtonType interface {
	InlineQueryResultsButtonTypeType() string
}

// Represents a payload of a callback query
type CallbackQueryPayload interface {
	CallbackQueryPayloadType() string
}

// Represents a chat event
type ChatEventAction interface {
	ChatEventActionType() string
}

// Represents the value of a string in a language pack
type LanguagePackStringValue interface {
	LanguagePackStringValueType() string
}

// Describes type of a limit, increased for Premium users
type PremiumLimitType interface {
	PremiumLimitTypeType() string
}

// Describes a feature available to Premium users
type PremiumFeature interface {
	PremiumFeatureType() string
}

// Describes a source from which the Premium features screen is opened
type PremiumSource interface {
	PremiumSourceType() string
}

// Describes a purpose of an in-store payment
type StorePaymentPurpose interface {
	StorePaymentPurposeType() string
}

// Represents a data needed to subscribe for push notifications through registerDevice method.
type DeviceToken interface {
	DeviceTokenType() string
}

// Describes a fill of a background
type BackgroundFill interface {
	BackgroundFillType() string
}

// Describes the type of a background
type BackgroundType interface {
	BackgroundTypeType() string
}

// Contains information about background to set
type InputBackground interface {
	InputBackgroundType() string
}

// Represents result of checking whether the current session can be used to transfer a chat ownership to another user
type CanTransferOwnershipResult interface {
	CanTransferOwnershipResultType() string
}

// Represents result of checking whether a username can be set for a chat
type CheckChatUsernameResult interface {
	CheckChatUsernameResultType() string
}

// Represents result of checking whether a name can be used for a new sticker set
type CheckStickerSetNameResult interface {
	CheckStickerSetNameResultType() string
}

// Represents result of 2-step verification password reset
type ResetPasswordResult interface {
	ResetPasswordResultType() string
}

// Contains information about a file with messages exported from another app
type MessageFileType interface {
	MessageFileTypeType() string
}

// Contains content of a push message notification
type PushMessageContent interface {
	PushMessageContentType() string
}

// Contains detailed information about a notification
type NotificationType interface {
	NotificationTypeType() string
}

// Describes the type of notifications in a notification group
type NotificationGroupType interface {
	NotificationGroupTypeType() string
}

// Represents the value of an option
type OptionValue interface {
	OptionValueType() string
}

// Represents a JSON value
type JsonValue interface {
	JsonValueType() string
}

// Represents a single rule for managing privacy settings
type UserPrivacySettingRule interface {
	UserPrivacySettingRuleType() string
}

// Describes available user privacy settings
type UserPrivacySetting interface {
	UserPrivacySettingType() string
}

// Represents the type of a session
type SessionType interface {
	SessionTypeType() string
}

// Describes the reason why a chat is reported
type ChatReportReason interface {
	ChatReportReasonType() string
}

// Describes the target chat to be opened
type TargetChat interface {
	TargetChatType() string
}

// Describes an internal https://t.me or tg: link, which must be processed by the application in a special way
type InternalLinkType interface {
	InternalLinkTypeType() string
}

// Represents the type of a file
type FileType interface {
	FileTypeType() string
}

// Represents the type of a network
type NetworkType interface {
	NetworkTypeType() string
}

// Contains statistics about network usage
type NetworkStatisticsEntry interface {
	NetworkStatisticsEntryType() string
}

// Describes scope of autosave settings
type AutosaveSettingsScope interface {
	AutosaveSettingsScopeType() string
}

// Describes the current state of the connection to Telegram servers
type ConnectionState interface {
	ConnectionStateType() string
}

// Represents the categories of chats for which a list of frequently used chats can be retrieved
type TopChatCategory interface {
	TopChatCategoryType() string
}

// Describes the type of a URL linking to an internal Telegram entity
type TMeUrlType interface {
	TMeUrlTypeType() string
}

// Describes an action suggested to the current user
type SuggestedAction interface {
	SuggestedActionType() string
}

// Describes the way the text needs to be parsed for text entities
type TextParseMode interface {
	TextParseModeType() string
}

// Describes the type of a proxy server
type ProxyType interface {
	ProxyTypeType() string
}

// Describes a statistical graph
type StatisticalGraph interface {
	StatisticalGraphType() string
}

// Contains a detailed statistics about a chat
type ChatStatistics interface {
	ChatStatisticsType() string
}

// Represents a vector path command
type VectorPathCommand interface {
	VectorPathCommandType() string
}

// Represents the scope to which bot commands are relevant
type BotCommandScope interface {
	BotCommandScopeType() string
}

// Contains notifications about data changes
type Update interface {
	UpdateType() string
}

// Describes a stream to which TDLib internal log is written
type LogStream interface {
	LogStreamType() string
}

// An object of this type can be returned on every function call, in case of an error
type Error struct {
	meta
	// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
	Code int32 `json:"code"`
	// Error message; subject to future changes
	Message string `json:"message"`
}

func (entity *Error) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Error

	return json.Marshal((*stub)(entity))
}

func (*Error) GetClass() string {
	return ClassError
}

func (*Error) GetType() string {
	return TypeError
}

// An object of this type is returned on a successful function call for certain functions
type Ok struct {
	meta
}

func (entity *Ok) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Ok

	return json.Marshal((*stub)(entity))
}

func (*Ok) GetClass() string {
	return ClassOk
}

func (*Ok) GetType() string {
	return TypeOk
}

// An authentication code is delivered via a private Telegram message, which can be viewed from another active session
type AuthenticationCodeTypeTelegramMessage struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeTelegramMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeTelegramMessage

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeTelegramMessage) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeTelegramMessage) GetType() string {
	return TypeAuthenticationCodeTypeTelegramMessage
}

func (*AuthenticationCodeTypeTelegramMessage) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeTelegramMessage
}

// An authentication code is delivered via an SMS message to the specified phone number; applications may not receive this type of code
type AuthenticationCodeTypeSms struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeSms) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeSms

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeSms) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeSms) GetType() string {
	return TypeAuthenticationCodeTypeSms
}

func (*AuthenticationCodeTypeSms) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeSms
}

// An authentication code is delivered via a phone call to the specified phone number
type AuthenticationCodeTypeCall struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeCall) GetType() string {
	return TypeAuthenticationCodeTypeCall
}

func (*AuthenticationCodeTypeCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeCall
}

// An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically
type AuthenticationCodeTypeFlashCall struct {
	meta
	// Pattern of the phone number from which the call will be made
	Pattern string `json:"pattern"`
}

func (entity *AuthenticationCodeTypeFlashCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFlashCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFlashCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFlashCall) GetType() string {
	return TypeAuthenticationCodeTypeFlashCall
}

func (*AuthenticationCodeTypeFlashCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFlashCall
}

// An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user
type AuthenticationCodeTypeMissedCall struct {
	meta
	// Prefix of the phone number from which the call will be made
	PhoneNumberPrefix string `json:"phone_number_prefix"`
	// Number of digits in the code, excluding the prefix
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeMissedCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeMissedCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeMissedCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeMissedCall) GetType() string {
	return TypeAuthenticationCodeTypeMissedCall
}

func (*AuthenticationCodeTypeMissedCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeMissedCall
}

// An authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT
type AuthenticationCodeTypeFragment struct {
	meta
	// URL to open to receive the code
	Url string `json:"url"`
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeFragment) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFragment

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFragment) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFragment) GetType() string {
	return TypeAuthenticationCodeTypeFragment
}

func (*AuthenticationCodeTypeFragment) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFragment
}

// An authentication code is delivered via Firebase Authentication to the official Android application
type AuthenticationCodeTypeFirebaseAndroid struct {
	meta
	// Nonce to pass to the SafetyNet Attestation API
	Nonce []byte `json:"nonce"`
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeFirebaseAndroid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFirebaseAndroid

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFirebaseAndroid) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFirebaseAndroid) GetType() string {
	return TypeAuthenticationCodeTypeFirebaseAndroid
}

func (*AuthenticationCodeTypeFirebaseAndroid) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFirebaseAndroid
}

// An authentication code is delivered via Firebase Authentication to the official iOS application
type AuthenticationCodeTypeFirebaseIos struct {
	meta
	// Receipt of successful application token validation to compare with receipt from push notification
	Receipt string `json:"receipt"`
	// Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds
	PushTimeout int32 `json:"push_timeout"`
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeFirebaseIos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFirebaseIos

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFirebaseIos) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFirebaseIos) GetType() string {
	return TypeAuthenticationCodeTypeFirebaseIos
}

func (*AuthenticationCodeTypeFirebaseIos) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFirebaseIos
}

// Information about the authentication code that was sent
type AuthenticationCodeInfo struct {
	meta
	// A phone number that is being authenticated
	PhoneNumber string `json:"phone_number"`
	// The way the code was sent to the user
	Type AuthenticationCodeType `json:"type"`
	// The way the next code will be sent to the user; may be null
	NextType AuthenticationCodeType `json:"next_type"`
	// Timeout before the code can be re-sent, in seconds
	Timeout int32 `json:"timeout"`
}

func (entity *AuthenticationCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeInfo) GetClass() string {
	return ClassAuthenticationCodeInfo
}

func (*AuthenticationCodeInfo) GetType() string {
	return TypeAuthenticationCodeInfo
}

func (authenticationCodeInfo *AuthenticationCodeInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PhoneNumber string          `json:"phone_number"`
		Type        json.RawMessage `json:"type"`
		NextType    json.RawMessage `json:"next_type"`
		Timeout     int32           `json:"timeout"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	authenticationCodeInfo.PhoneNumber = tmp.PhoneNumber
	authenticationCodeInfo.Timeout = tmp.Timeout

	fieldType, _ := UnmarshalAuthenticationCodeType(tmp.Type)
	authenticationCodeInfo.Type = fieldType

	fieldNextType, _ := UnmarshalAuthenticationCodeType(tmp.NextType)
	authenticationCodeInfo.NextType = fieldNextType

	return nil
}

// Information about the email address authentication code that was sent
type EmailAddressAuthenticationCodeInfo struct {
	meta
	// Pattern of the email address to which an authentication code was sent
	EmailAddressPattern string `json:"email_address_pattern"`
	// Length of the code; 0 if unknown
	Length int32 `json:"length"`
}

func (entity *EmailAddressAuthenticationCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationCodeInfo) GetClass() string {
	return ClassEmailAddressAuthenticationCodeInfo
}

func (*EmailAddressAuthenticationCodeInfo) GetType() string {
	return TypeEmailAddressAuthenticationCodeInfo
}

// An authentication code delivered to a user's email address
type EmailAddressAuthenticationCode struct {
	meta
	// The code
	Code string `json:"code"`
}

func (entity *EmailAddressAuthenticationCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationCode

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationCode) GetClass() string {
	return ClassEmailAddressAuthentication
}

func (*EmailAddressAuthenticationCode) GetType() string {
	return TypeEmailAddressAuthenticationCode
}

func (*EmailAddressAuthenticationCode) EmailAddressAuthenticationType() string {
	return TypeEmailAddressAuthenticationCode
}

// An authentication token received through Apple ID
type EmailAddressAuthenticationAppleId struct {
	meta
	// The token
	Token string `json:"token"`
}

func (entity *EmailAddressAuthenticationAppleId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationAppleId

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationAppleId) GetClass() string {
	return ClassEmailAddressAuthentication
}

func (*EmailAddressAuthenticationAppleId) GetType() string {
	return TypeEmailAddressAuthenticationAppleId
}

func (*EmailAddressAuthenticationAppleId) EmailAddressAuthenticationType() string {
	return TypeEmailAddressAuthenticationAppleId
}

// An authentication token received through Google ID
type EmailAddressAuthenticationGoogleId struct {
	meta
	// The token
	Token string `json:"token"`
}

func (entity *EmailAddressAuthenticationGoogleId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationGoogleId

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationGoogleId) GetClass() string {
	return ClassEmailAddressAuthentication
}

func (*EmailAddressAuthenticationGoogleId) GetType() string {
	return TypeEmailAddressAuthenticationGoogleId
}

func (*EmailAddressAuthenticationGoogleId) EmailAddressAuthenticationType() string {
	return TypeEmailAddressAuthenticationGoogleId
}

// Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number
type EmailAddressResetStateAvailable struct {
	meta
	// Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
	WaitPeriod int32 `json:"wait_period"`
}

func (entity *EmailAddressResetStateAvailable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressResetStateAvailable

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressResetStateAvailable) GetClass() string {
	return ClassEmailAddressResetState
}

func (*EmailAddressResetStateAvailable) GetType() string {
	return TypeEmailAddressResetStateAvailable
}

func (*EmailAddressResetStateAvailable) EmailAddressResetStateType() string {
	return TypeEmailAddressResetStateAvailable
}

// Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible
type EmailAddressResetStatePending struct {
	meta
	// Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
	ResetIn int32 `json:"reset_in"`
}

func (entity *EmailAddressResetStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressResetStatePending

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressResetStatePending) GetClass() string {
	return ClassEmailAddressResetState
}

func (*EmailAddressResetStatePending) GetType() string {
	return TypeEmailAddressResetStatePending
}

func (*EmailAddressResetStatePending) EmailAddressResetStateType() string {
	return TypeEmailAddressResetStatePending
}

// Represents a part of the text that needs to be formatted in some unusual way
type TextEntity struct {
	meta
	// Offset of the entity, in UTF-16 code units
	Offset int32 `json:"offset"`
	// Length of the entity, in UTF-16 code units
	Length int32 `json:"length"`
	// Type of the entity
	Type TextEntityType `json:"type"`
}

func (entity *TextEntity) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntity

	return json.Marshal((*stub)(entity))
}

func (*TextEntity) GetClass() string {
	return ClassTextEntity
}

func (*TextEntity) GetType() string {
	return TypeTextEntity
}

func (textEntity *TextEntity) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Offset int32           `json:"offset"`
		Length int32           `json:"length"`
		Type   json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	textEntity.Offset = tmp.Offset
	textEntity.Length = tmp.Length

	fieldType, _ := UnmarshalTextEntityType(tmp.Type)
	textEntity.Type = fieldType

	return nil
}

// Contains a list of text entities
type TextEntities struct {
	meta
	// List of text entities
	Entities []*TextEntity `json:"entities"`
}

func (entity *TextEntities) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntities

	return json.Marshal((*stub)(entity))
}

func (*TextEntities) GetClass() string {
	return ClassTextEntities
}

func (*TextEntities) GetType() string {
	return TypeTextEntities
}

// A text with some entities
type FormattedText struct {
	meta
	// The text
	Text string `json:"text"`
	// Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
	Entities []*TextEntity `json:"entities"`
}

func (entity *FormattedText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FormattedText

	return json.Marshal((*stub)(entity))
}

func (*FormattedText) GetClass() string {
	return ClassFormattedText
}

func (*FormattedText) GetType() string {
	return TypeFormattedText
}

// Contains Telegram terms of service
type TermsOfService struct {
	meta
	// Text of the terms of service
	Text *FormattedText `json:"text"`
	// The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
	MinUserAge int32 `json:"min_user_age"`
	// True, if a blocking popup with terms of service must be shown to the user
	ShowPopup bool `json:"show_popup"`
}

func (entity *TermsOfService) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TermsOfService

	return json.Marshal((*stub)(entity))
}

func (*TermsOfService) GetClass() string {
	return ClassTermsOfService
}

func (*TermsOfService) GetType() string {
	return TypeTermsOfService
}

// Initialization parameters are needed. Call setTdlibParameters to provide them
type AuthorizationStateWaitTdlibParameters struct {
	meta
}

func (entity *AuthorizationStateWaitTdlibParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitTdlibParameters

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitTdlibParameters) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitTdlibParameters) GetType() string {
	return TypeAuthorizationStateWaitTdlibParameters
}

func (*AuthorizationStateWaitTdlibParameters) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitTdlibParameters
}

// TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
type AuthorizationStateWaitPhoneNumber struct {
	meta
}

func (entity *AuthorizationStateWaitPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitPhoneNumber) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitPhoneNumber) GetType() string {
	return TypeAuthorizationStateWaitPhoneNumber
}

func (*AuthorizationStateWaitPhoneNumber) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitPhoneNumber
}

// TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed
type AuthorizationStateWaitEmailAddress struct {
	meta
	// True, if authorization through Apple ID is allowed
	AllowAppleId bool `json:"allow_apple_id"`
	// True, if authorization through Google ID is allowed
	AllowGoogleId bool `json:"allow_google_id"`
}

func (entity *AuthorizationStateWaitEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitEmailAddress) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitEmailAddress) GetType() string {
	return TypeAuthorizationStateWaitEmailAddress
}

func (*AuthorizationStateWaitEmailAddress) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitEmailAddress
}

// TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code
type AuthorizationStateWaitEmailCode struct {
	meta
	// True, if authorization through Apple ID is allowed
	AllowAppleId bool `json:"allow_apple_id"`
	// True, if authorization through Google ID is allowed
	AllowGoogleId bool `json:"allow_google_id"`
	// Information about the sent authentication code
	CodeInfo *EmailAddressAuthenticationCodeInfo `json:"code_info"`
	// Reset state of the email address; may be null if the email address can't be reset
	EmailAddressResetState EmailAddressResetState `json:"email_address_reset_state"`
}

func (entity *AuthorizationStateWaitEmailCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitEmailCode

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitEmailCode) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitEmailCode) GetType() string {
	return TypeAuthorizationStateWaitEmailCode
}

func (*AuthorizationStateWaitEmailCode) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitEmailCode
}

func (authorizationStateWaitEmailCode *AuthorizationStateWaitEmailCode) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AllowAppleId           bool                                `json:"allow_apple_id"`
		AllowGoogleId          bool                                `json:"allow_google_id"`
		CodeInfo               *EmailAddressAuthenticationCodeInfo `json:"code_info"`
		EmailAddressResetState json.RawMessage                     `json:"email_address_reset_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	authorizationStateWaitEmailCode.AllowAppleId = tmp.AllowAppleId
	authorizationStateWaitEmailCode.AllowGoogleId = tmp.AllowGoogleId
	authorizationStateWaitEmailCode.CodeInfo = tmp.CodeInfo

	fieldEmailAddressResetState, _ := UnmarshalEmailAddressResetState(tmp.EmailAddressResetState)
	authorizationStateWaitEmailCode.EmailAddressResetState = fieldEmailAddressResetState

	return nil
}

// TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code
type AuthorizationStateWaitCode struct {
	meta
	// Information about the authorization code that was sent
	CodeInfo *AuthenticationCodeInfo `json:"code_info"`
}

func (entity *AuthorizationStateWaitCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitCode

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitCode) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitCode) GetType() string {
	return TypeAuthorizationStateWaitCode
}

func (*AuthorizationStateWaitCode) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitCode
}

// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
type AuthorizationStateWaitOtherDeviceConfirmation struct {
	meta
	// A tg:// URL for the QR code. The link will be updated frequently
	Link string `json:"link"`
}

func (entity *AuthorizationStateWaitOtherDeviceConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitOtherDeviceConfirmation

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) GetType() string {
	return TypeAuthorizationStateWaitOtherDeviceConfirmation
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitOtherDeviceConfirmation
}

// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data
type AuthorizationStateWaitRegistration struct {
	meta
	// Telegram terms of service
	TermsOfService *TermsOfService `json:"terms_of_service"`
}

func (entity *AuthorizationStateWaitRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitRegistration

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitRegistration) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitRegistration) GetType() string {
	return TypeAuthorizationStateWaitRegistration
}

func (*AuthorizationStateWaitRegistration) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitRegistration
}

// The user has been authorized, but needs to enter a 2-step verification password to start using the application. Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week
type AuthorizationStateWaitPassword struct {
	meta
	// Hint for the password; may be empty
	PasswordHint string `json:"password_hint"`
	// True, if a recovery email address has been set up
	HasRecoveryEmailAddress bool `json:"has_recovery_email_address"`
	// True, if some Telegram Passport elements were saved
	HasPassportData bool `json:"has_passport_data"`
	// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
	RecoveryEmailAddressPattern string `json:"recovery_email_address_pattern"`
}

func (entity *AuthorizationStateWaitPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitPassword

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitPassword) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitPassword) GetType() string {
	return TypeAuthorizationStateWaitPassword
}

func (*AuthorizationStateWaitPassword) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitPassword
}

// The user has been successfully authorized. TDLib is now ready to answer general requests
type AuthorizationStateReady struct {
	meta
}

func (entity *AuthorizationStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateReady

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateReady) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateReady) GetType() string {
	return TypeAuthorizationStateReady
}

func (*AuthorizationStateReady) AuthorizationStateType() string {
	return TypeAuthorizationStateReady
}

// The user is currently logging out
type AuthorizationStateLoggingOut struct {
	meta
}

func (entity *AuthorizationStateLoggingOut) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateLoggingOut

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateLoggingOut) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateLoggingOut) GetType() string {
	return TypeAuthorizationStateLoggingOut
}

func (*AuthorizationStateLoggingOut) AuthorizationStateType() string {
	return TypeAuthorizationStateLoggingOut
}

// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
type AuthorizationStateClosing struct {
	meta
}

func (entity *AuthorizationStateClosing) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateClosing

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateClosing) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateClosing) GetType() string {
	return TypeAuthorizationStateClosing
}

func (*AuthorizationStateClosing) AuthorizationStateType() string {
	return TypeAuthorizationStateClosing
}

// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one must create a new instance of the TDLib client
type AuthorizationStateClosed struct {
	meta
}

func (entity *AuthorizationStateClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateClosed

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateClosed) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateClosed) GetType() string {
	return TypeAuthorizationStateClosed
}

func (*AuthorizationStateClosed) AuthorizationStateType() string {
	return TypeAuthorizationStateClosed
}

// Represents the current state of 2-step verification
type PasswordState struct {
	meta
	// True, if a 2-step verification password is set
	HasPassword bool `json:"has_password"`
	// Hint for the password; may be empty
	PasswordHint string `json:"password_hint"`
	// True, if a recovery email is set
	HasRecoveryEmailAddress bool `json:"has_recovery_email_address"`
	// True, if some Telegram Passport elements were saved
	HasPassportData bool `json:"has_passport_data"`
	// Information about the recovery email address to which the confirmation email was sent; may be null
	RecoveryEmailAddressCodeInfo *EmailAddressAuthenticationCodeInfo `json:"recovery_email_address_code_info"`
	// Pattern of the email address set up for logging in
	LoginEmailAddressPattern string `json:"login_email_address_pattern"`
	// If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
	PendingResetDate int32 `json:"pending_reset_date"`
}

func (entity *PasswordState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PasswordState

	return json.Marshal((*stub)(entity))
}

func (*PasswordState) GetClass() string {
	return ClassPasswordState
}

func (*PasswordState) GetType() string {
	return TypePasswordState
}

// Contains information about the current recovery email address
type RecoveryEmailAddress struct {
	meta
	// Recovery email address
	RecoveryEmailAddress string `json:"recovery_email_address"`
}

func (entity *RecoveryEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecoveryEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*RecoveryEmailAddress) GetClass() string {
	return ClassRecoveryEmailAddress
}

func (*RecoveryEmailAddress) GetType() string {
	return TypeRecoveryEmailAddress
}

// Returns information about the availability of a temporary password, which can be used for payments
type TemporaryPasswordState struct {
	meta
	// True, if a temporary password is available
	HasPassword bool `json:"has_password"`
	// Time left before the temporary password expires, in seconds
	ValidFor int32 `json:"valid_for"`
}

func (entity *TemporaryPasswordState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TemporaryPasswordState

	return json.Marshal((*stub)(entity))
}

func (*TemporaryPasswordState) GetClass() string {
	return ClassTemporaryPasswordState
}

func (*TemporaryPasswordState) GetType() string {
	return TypeTemporaryPasswordState
}

// Represents a local file
type LocalFile struct {
	meta
	// Local path to the locally available file part; may be empty
	Path string `json:"path"`
	// True, if it is possible to download or generate the file
	CanBeDownloaded bool `json:"can_be_downloaded"`
	// True, if the file can be deleted
	CanBeDeleted bool `json:"can_be_deleted"`
	// True, if the file is currently being downloaded (or a local copy is being generated by some other means)
	IsDownloadingActive bool `json:"is_downloading_active"`
	// True, if the local copy is fully available
	IsDownloadingCompleted bool `json:"is_downloading_completed"`
	// Download will be started from this offset. downloaded_prefix_size is calculated from this offset
	DownloadOffset int64 `json:"download_offset"`
	// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
	DownloadedPrefixSize int64 `json:"downloaded_prefix_size"`
	// Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
	DownloadedSize int64 `json:"downloaded_size"`
}

func (entity *LocalFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocalFile

	return json.Marshal((*stub)(entity))
}

func (*LocalFile) GetClass() string {
	return ClassLocalFile
}

func (*LocalFile) GetType() string {
	return TypeLocalFile
}

// Represents a remote file
type RemoteFile struct {
	meta
	// Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
	Id string `json:"id"`
	// Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
	UniqueId string `json:"unique_id"`
	// True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
	IsUploadingActive bool `json:"is_uploading_active"`
	// True, if a remote copy is fully available
	IsUploadingCompleted bool `json:"is_uploading_completed"`
	// Size of the remote available part of the file, in bytes; 0 if unknown
	UploadedSize int64 `json:"uploaded_size"`
}

func (entity *RemoteFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RemoteFile

	return json.Marshal((*stub)(entity))
}

func (*RemoteFile) GetClass() string {
	return ClassRemoteFile
}

func (*RemoteFile) GetType() string {
	return TypeRemoteFile
}

// Represents a file
type File struct {
	meta
	// Unique file identifier
	Id int32 `json:"id"`
	// File size, in bytes; 0 if unknown
	Size int64 `json:"size"`
	// Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
	ExpectedSize int64 `json:"expected_size"`
	// Information about the local copy of the file
	Local *LocalFile `json:"local"`
	// Information about the remote copy of the file
	Remote *RemoteFile `json:"remote"`
}

func (entity *File) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub File

	return json.Marshal((*stub)(entity))
}

func (*File) GetClass() string {
	return ClassFile
}

func (*File) GetType() string {
	return TypeFile
}

// A file defined by its unique ID
type InputFileId struct {
	meta
	// Unique file identifier
	Id int32 `json:"id"`
}

func (entity *InputFileId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileId

	return json.Marshal((*stub)(entity))
}

func (*InputFileId) GetClass() string {
	return ClassInputFile
}

func (*InputFileId) GetType() string {
	return TypeInputFileId
}

func (*InputFileId) InputFileType() string {
	return TypeInputFileId
}

// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
type InputFileRemote struct {
	meta
	// Remote file identifier
	Id string `json:"id"`
}

func (entity *InputFileRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileRemote

	return json.Marshal((*stub)(entity))
}

func (*InputFileRemote) GetClass() string {
	return ClassInputFile
}

func (*InputFileRemote) GetType() string {
	return TypeInputFileRemote
}

func (*InputFileRemote) InputFileType() string {
	return TypeInputFileRemote
}

// A file defined by a local path
type InputFileLocal struct {
	meta
	// Local path to the file
	Path string `json:"path"`
}

func (entity *InputFileLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileLocal

	return json.Marshal((*stub)(entity))
}

func (*InputFileLocal) GetClass() string {
	return ClassInputFile
}

func (*InputFileLocal) GetType() string {
	return TypeInputFileLocal
}

func (*InputFileLocal) InputFileType() string {
	return TypeInputFileLocal
}

// A file generated by the application
type InputFileGenerated struct {
	meta
	// Local path to a file from which the file is generated; may be empty if there is no such file
	OriginalPath string `json:"original_path"`
	// String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
	Conversion string `json:"conversion"`
	// Expected size of the generated file, in bytes; 0 if unknown
	ExpectedSize int64 `json:"expected_size"`
}

func (entity *InputFileGenerated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileGenerated

	return json.Marshal((*stub)(entity))
}

func (*InputFileGenerated) GetClass() string {
	return ClassInputFile
}

func (*InputFileGenerated) GetType() string {
	return TypeInputFileGenerated
}

func (*InputFileGenerated) InputFileType() string {
	return TypeInputFileGenerated
}

// Describes an image in JPEG format
type PhotoSize struct {
	meta
	// Image type (see https://core.telegram.org/constructor/photoSize)
	Type string `json:"type"`
	// Information about the image file
	Photo *File `json:"photo"`
	// Image width
	Width int32 `json:"width"`
	// Image height
	Height int32 `json:"height"`
	// Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
	ProgressiveSizes []int32 `json:"progressive_sizes"`
}

func (entity *PhotoSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhotoSize

	return json.Marshal((*stub)(entity))
}

func (*PhotoSize) GetClass() string {
	return ClassPhotoSize
}

func (*PhotoSize) GetType() string {
	return TypePhotoSize
}

// Thumbnail image of a very poor quality and low resolution
type Minithumbnail struct {
	meta
	// Thumbnail width, usually doesn't exceed 40
	Width int32 `json:"width"`
	// Thumbnail height, usually doesn't exceed 40
	Height int32 `json:"height"`
	// The thumbnail in JPEG format
	Data []byte `json:"data"`
}

func (entity *Minithumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Minithumbnail

	return json.Marshal((*stub)(entity))
}

func (*Minithumbnail) GetClass() string {
	return ClassMinithumbnail
}

func (*Minithumbnail) GetType() string {
	return TypeMinithumbnail
}

// The thumbnail is in JPEG format
type ThumbnailFormatJpeg struct {
	meta
}

func (entity *ThumbnailFormatJpeg) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatJpeg

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatJpeg) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatJpeg) GetType() string {
	return TypeThumbnailFormatJpeg
}

func (*ThumbnailFormatJpeg) ThumbnailFormatType() string {
	return TypeThumbnailFormatJpeg
}

// The thumbnail is in static GIF format. It will be used only for some bot inline results
type ThumbnailFormatGif struct {
	meta
}

func (entity *ThumbnailFormatGif) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatGif

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatGif) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatGif) GetType() string {
	return TypeThumbnailFormatGif
}

func (*ThumbnailFormatGif) ThumbnailFormatType() string {
	return TypeThumbnailFormatGif
}

// The thumbnail is in MPEG4 format. It will be used only for some animations and videos
type ThumbnailFormatMpeg4 struct {
	meta
}

func (entity *ThumbnailFormatMpeg4) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatMpeg4

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatMpeg4) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatMpeg4) GetType() string {
	return TypeThumbnailFormatMpeg4
}

func (*ThumbnailFormatMpeg4) ThumbnailFormatType() string {
	return TypeThumbnailFormatMpeg4
}

// The thumbnail is in PNG format. It will be used only for background patterns
type ThumbnailFormatPng struct {
	meta
}

func (entity *ThumbnailFormatPng) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatPng

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatPng) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatPng) GetType() string {
	return TypeThumbnailFormatPng
}

func (*ThumbnailFormatPng) ThumbnailFormatType() string {
	return TypeThumbnailFormatPng
}

// The thumbnail is in TGS format. It will be used only for TGS sticker sets
type ThumbnailFormatTgs struct {
	meta
}

func (entity *ThumbnailFormatTgs) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatTgs

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatTgs) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatTgs) GetType() string {
	return TypeThumbnailFormatTgs
}

func (*ThumbnailFormatTgs) ThumbnailFormatType() string {
	return TypeThumbnailFormatTgs
}

// The thumbnail is in WEBM format. It will be used only for WEBM sticker sets
type ThumbnailFormatWebm struct {
	meta
}

func (entity *ThumbnailFormatWebm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatWebm

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatWebm) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatWebm) GetType() string {
	return TypeThumbnailFormatWebm
}

func (*ThumbnailFormatWebm) ThumbnailFormatType() string {
	return TypeThumbnailFormatWebm
}

// The thumbnail is in WEBP format. It will be used only for some stickers
type ThumbnailFormatWebp struct {
	meta
}

func (entity *ThumbnailFormatWebp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatWebp

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatWebp) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatWebp) GetType() string {
	return TypeThumbnailFormatWebp
}

func (*ThumbnailFormatWebp) ThumbnailFormatType() string {
	return TypeThumbnailFormatWebp
}

// Represents a thumbnail
type Thumbnail struct {
	meta
	// Thumbnail format
	Format ThumbnailFormat `json:"format"`
	// Thumbnail width
	Width int32 `json:"width"`
	// Thumbnail height
	Height int32 `json:"height"`
	// The thumbnail
	File *File `json:"file"`
}

func (entity *Thumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Thumbnail

	return json.Marshal((*stub)(entity))
}

func (*Thumbnail) GetClass() string {
	return ClassThumbnail
}

func (*Thumbnail) GetType() string {
	return TypeThumbnail
}

func (thumbnail *Thumbnail) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Format json.RawMessage `json:"format"`
		Width  int32           `json:"width"`
		Height int32           `json:"height"`
		File   *File           `json:"file"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	thumbnail.Width = tmp.Width
	thumbnail.Height = tmp.Height
	thumbnail.File = tmp.File

	fieldFormat, _ := UnmarshalThumbnailFormat(tmp.Format)
	thumbnail.Format = fieldFormat

	return nil
}

// The mask is placed relatively to the forehead
type MaskPointForehead struct {
	meta
}

func (entity *MaskPointForehead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointForehead

	return json.Marshal((*stub)(entity))
}

func (*MaskPointForehead) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointForehead) GetType() string {
	return TypeMaskPointForehead
}

func (*MaskPointForehead) MaskPointType() string {
	return TypeMaskPointForehead
}

// The mask is placed relatively to the eyes
type MaskPointEyes struct {
	meta
}

func (entity *MaskPointEyes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointEyes

	return json.Marshal((*stub)(entity))
}

func (*MaskPointEyes) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointEyes) GetType() string {
	return TypeMaskPointEyes
}

func (*MaskPointEyes) MaskPointType() string {
	return TypeMaskPointEyes
}

// The mask is placed relatively to the mouth
type MaskPointMouth struct {
	meta
}

func (entity *MaskPointMouth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointMouth

	return json.Marshal((*stub)(entity))
}

func (*MaskPointMouth) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointMouth) GetType() string {
	return TypeMaskPointMouth
}

func (*MaskPointMouth) MaskPointType() string {
	return TypeMaskPointMouth
}

// The mask is placed relatively to the chin
type MaskPointChin struct {
	meta
}

func (entity *MaskPointChin) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointChin

	return json.Marshal((*stub)(entity))
}

func (*MaskPointChin) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointChin) GetType() string {
	return TypeMaskPointChin
}

func (*MaskPointChin) MaskPointType() string {
	return TypeMaskPointChin
}

// Position on a photo where a mask is placed
type MaskPosition struct {
	meta
	// Part of the face, relative to which the mask is placed
	Point MaskPoint `json:"point"`
	// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
	XShift float64 `json:"x_shift"`
	// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
	YShift float64 `json:"y_shift"`
	// Mask scaling coefficient. (For example, 2.0 means a doubled size)
	Scale float64 `json:"scale"`
}

func (entity *MaskPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPosition

	return json.Marshal((*stub)(entity))
}

func (*MaskPosition) GetClass() string {
	return ClassMaskPosition
}

func (*MaskPosition) GetType() string {
	return TypeMaskPosition
}

func (maskPosition *MaskPosition) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Point  json.RawMessage `json:"point"`
		XShift float64         `json:"x_shift"`
		YShift float64         `json:"y_shift"`
		Scale  float64         `json:"scale"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	maskPosition.XShift = tmp.XShift
	maskPosition.YShift = tmp.YShift
	maskPosition.Scale = tmp.Scale

	fieldPoint, _ := UnmarshalMaskPoint(tmp.Point)
	maskPosition.Point = fieldPoint

	return nil
}

// The sticker is an image in WEBP format
type StickerFormatWebp struct {
	meta
}

func (entity *StickerFormatWebp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFormatWebp

	return json.Marshal((*stub)(entity))
}

func (*StickerFormatWebp) GetClass() string {
	return ClassStickerFormat
}

func (*StickerFormatWebp) GetType() string {
	return TypeStickerFormatWebp
}

func (*StickerFormatWebp) StickerFormatType() string {
	return TypeStickerFormatWebp
}

// The sticker is an animation in TGS format
type StickerFormatTgs struct {
	meta
}

func (entity *StickerFormatTgs) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFormatTgs

	return json.Marshal((*stub)(entity))
}

func (*StickerFormatTgs) GetClass() string {
	return ClassStickerFormat
}

func (*StickerFormatTgs) GetType() string {
	return TypeStickerFormatTgs
}

func (*StickerFormatTgs) StickerFormatType() string {
	return TypeStickerFormatTgs
}

// The sticker is a video in WEBM format
type StickerFormatWebm struct {
	meta
}

func (entity *StickerFormatWebm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFormatWebm

	return json.Marshal((*stub)(entity))
}

func (*StickerFormatWebm) GetClass() string {
	return ClassStickerFormat
}

func (*StickerFormatWebm) GetType() string {
	return TypeStickerFormatWebm
}

func (*StickerFormatWebm) StickerFormatType() string {
	return TypeStickerFormatWebm
}

// The sticker is a regular sticker
type StickerTypeRegular struct {
	meta
}

func (entity *StickerTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*StickerTypeRegular) GetClass() string {
	return ClassStickerType
}

func (*StickerTypeRegular) GetType() string {
	return TypeStickerTypeRegular
}

func (*StickerTypeRegular) StickerTypeType() string {
	return TypeStickerTypeRegular
}

// The sticker is a mask in WEBP format to be placed on photos or videos
type StickerTypeMask struct {
	meta
}

func (entity *StickerTypeMask) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerTypeMask

	return json.Marshal((*stub)(entity))
}

func (*StickerTypeMask) GetClass() string {
	return ClassStickerType
}

func (*StickerTypeMask) GetType() string {
	return TypeStickerTypeMask
}

func (*StickerTypeMask) StickerTypeType() string {
	return TypeStickerTypeMask
}

// The sticker is a custom emoji to be used inside message text and caption
type StickerTypeCustomEmoji struct {
	meta
}

func (entity *StickerTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*StickerTypeCustomEmoji) GetClass() string {
	return ClassStickerType
}

func (*StickerTypeCustomEmoji) GetType() string {
	return TypeStickerTypeCustomEmoji
}

func (*StickerTypeCustomEmoji) StickerTypeType() string {
	return TypeStickerTypeCustomEmoji
}

// The sticker is a regular sticker
type StickerFullTypeRegular struct {
	meta
	// Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
	PremiumAnimation *File `json:"premium_animation"`
}

func (entity *StickerFullTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFullTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*StickerFullTypeRegular) GetClass() string {
	return ClassStickerFullType
}

func (*StickerFullTypeRegular) GetType() string {
	return TypeStickerFullTypeRegular
}

func (*StickerFullTypeRegular) StickerFullTypeType() string {
	return TypeStickerFullTypeRegular
}

// The sticker is a mask in WEBP format to be placed on photos or videos
type StickerFullTypeMask struct {
	meta
	// Position where the mask is placed; may be null
	MaskPosition *MaskPosition `json:"mask_position"`
}

func (entity *StickerFullTypeMask) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFullTypeMask

	return json.Marshal((*stub)(entity))
}

func (*StickerFullTypeMask) GetClass() string {
	return ClassStickerFullType
}

func (*StickerFullTypeMask) GetType() string {
	return TypeStickerFullTypeMask
}

func (*StickerFullTypeMask) StickerFullTypeType() string {
	return TypeStickerFullTypeMask
}

// The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji
type StickerFullTypeCustomEmoji struct {
	meta
	// Identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
	// True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
	NeedsRepainting bool `json:"needs_repainting"`
}

func (entity *StickerFullTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFullTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*StickerFullTypeCustomEmoji) GetClass() string {
	return ClassStickerFullType
}

func (*StickerFullTypeCustomEmoji) GetType() string {
	return TypeStickerFullTypeCustomEmoji
}

func (*StickerFullTypeCustomEmoji) StickerFullTypeType() string {
	return TypeStickerFullTypeCustomEmoji
}

// Represents a closed vector path. The path begins at the end point of the last command
type ClosedVectorPath struct {
	meta
	// List of vector path commands
	Commands []VectorPathCommand `json:"commands"`
}

func (entity *ClosedVectorPath) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ClosedVectorPath

	return json.Marshal((*stub)(entity))
}

func (*ClosedVectorPath) GetClass() string {
	return ClassClosedVectorPath
}

func (*ClosedVectorPath) GetType() string {
	return TypeClosedVectorPath
}

func (closedVectorPath *ClosedVectorPath) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Commands []json.RawMessage `json:"commands"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldCommands, _ := UnmarshalListOfVectorPathCommand(tmp.Commands)
	closedVectorPath.Commands = fieldCommands

	return nil
}

// Describes one answer option of a poll
type PollOption struct {
	meta
	// Option text; 1-100 characters
	Text string `json:"text"`
	// Number of voters for this option, available only for closed or voted polls
	VoterCount int32 `json:"voter_count"`
	// The percentage of votes for this option; 0-100
	VotePercentage int32 `json:"vote_percentage"`
	// True, if the option was chosen by the user
	IsChosen bool `json:"is_chosen"`
	// True, if the option is being chosen by a pending setPollAnswer request
	IsBeingChosen bool `json:"is_being_chosen"`
}

func (entity *PollOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollOption

	return json.Marshal((*stub)(entity))
}

func (*PollOption) GetClass() string {
	return ClassPollOption
}

func (*PollOption) GetType() string {
	return TypePollOption
}

// A regular poll
type PollTypeRegular struct {
	meta
	// True, if multiple answer options can be chosen simultaneously
	AllowMultipleAnswers bool `json:"allow_multiple_answers"`
}

func (entity *PollTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*PollTypeRegular) GetClass() string {
	return ClassPollType
}

func (*PollTypeRegular) GetType() string {
	return TypePollTypeRegular
}

func (*PollTypeRegular) PollTypeType() string {
	return TypePollTypeRegular
}

// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
type PollTypeQuiz struct {
	meta
	// 0-based identifier of the correct answer option; -1 for a yet unanswered poll
	CorrectOptionId int32 `json:"correct_option_id"`
	// Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
	Explanation *FormattedText `json:"explanation"`
}

func (entity *PollTypeQuiz) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollTypeQuiz

	return json.Marshal((*stub)(entity))
}

func (*PollTypeQuiz) GetClass() string {
	return ClassPollType
}

func (*PollTypeQuiz) GetType() string {
	return TypePollTypeQuiz
}

func (*PollTypeQuiz) PollTypeType() string {
	return TypePollTypeQuiz
}

// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
type Animation struct {
	meta
	// Duration of the animation, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Width of the animation
	Width int32 `json:"width"`
	// Height of the animation
	Height int32 `json:"height"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file, usually "image/gif" or "video/mp4"
	MimeType string `json:"mime_type"`
	// True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// Animation minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Animation thumbnail in JPEG or MPEG4 format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the animation
	Animation *File `json:"animation"`
}

func (entity *Animation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Animation

	return json.Marshal((*stub)(entity))
}

func (*Animation) GetClass() string {
	return ClassAnimation
}

func (*Animation) GetType() string {
	return TypeAnimation
}

// Describes an audio file. Audio is usually in MP3 or M4A format
type Audio struct {
	meta
	// Duration of the audio, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Title of the audio; as defined by the sender
	Title string `json:"title"`
	// Performer of the audio; as defined by the sender
	Performer string `json:"performer"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// The MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// The minithumbnail of the album cover; may be null
	AlbumCoverMinithumbnail *Minithumbnail `json:"album_cover_minithumbnail"`
	// The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
	AlbumCoverThumbnail *Thumbnail `json:"album_cover_thumbnail"`
	// Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
	ExternalAlbumCovers []*Thumbnail `json:"external_album_covers"`
	// File containing the audio
	Audio *File `json:"audio"`
}

func (entity *Audio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Audio

	return json.Marshal((*stub)(entity))
}

func (*Audio) GetClass() string {
	return ClassAudio
}

func (*Audio) GetType() string {
	return TypeAudio
}

// Describes a document of any type
type Document struct {
	meta
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// Document minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the document
	Document *File `json:"document"`
}

func (entity *Document) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Document

	return json.Marshal((*stub)(entity))
}

func (*Document) GetClass() string {
	return ClassDocument
}

func (*Document) GetType() string {
	return TypeDocument
}

// Describes a photo
type Photo struct {
	meta
	// True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// Photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Available variants of the photo, in different sizes
	Sizes []*PhotoSize `json:"sizes"`
}

func (entity *Photo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Photo

	return json.Marshal((*stub)(entity))
}

func (*Photo) GetClass() string {
	return ClassPhoto
}

func (*Photo) GetType() string {
	return TypePhoto
}

// Describes a sticker
type Sticker struct {
	meta
	// Unique sticker identifier within the set; 0 if none
	Id JsonInt64 `json:"id"`
	// The identifier of the sticker set to which the sticker belongs; 0 if none
	SetId JsonInt64 `json:"set_id"`
	// Sticker width; as defined by the sender
	Width int32 `json:"width"`
	// Sticker height; as defined by the sender
	Height int32 `json:"height"`
	// Emoji corresponding to the sticker
	Emoji string `json:"emoji"`
	// Sticker format
	Format StickerFormat `json:"format"`
	// Sticker's full type
	FullType StickerFullType `json:"full_type"`
	// Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
	Outline []*ClosedVectorPath `json:"outline"`
	// Sticker thumbnail in WEBP or JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the sticker
	Sticker *File `json:"sticker"`
}

func (entity *Sticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Sticker

	return json.Marshal((*stub)(entity))
}

func (*Sticker) GetClass() string {
	return ClassSticker
}

func (*Sticker) GetType() string {
	return TypeSticker
}

func (sticker *Sticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id        JsonInt64           `json:"id"`
		SetId     JsonInt64           `json:"set_id"`
		Width     int32               `json:"width"`
		Height    int32               `json:"height"`
		Emoji     string              `json:"emoji"`
		Format    json.RawMessage     `json:"format"`
		FullType  json.RawMessage     `json:"full_type"`
		Outline   []*ClosedVectorPath `json:"outline"`
		Thumbnail *Thumbnail          `json:"thumbnail"`
		Sticker   *File               `json:"sticker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	sticker.Id = tmp.Id
	sticker.SetId = tmp.SetId
	sticker.Width = tmp.Width
	sticker.Height = tmp.Height
	sticker.Emoji = tmp.Emoji
	sticker.Outline = tmp.Outline
	sticker.Thumbnail = tmp.Thumbnail
	sticker.Sticker = tmp.Sticker

	fieldFormat, _ := UnmarshalStickerFormat(tmp.Format)
	sticker.Format = fieldFormat

	fieldFullType, _ := UnmarshalStickerFullType(tmp.FullType)
	sticker.FullType = fieldFullType

	return nil
}

// Describes a video file
type Video struct {
	meta
	// Duration of the video, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Video width; as defined by the sender
	Width int32 `json:"width"`
	// Video height; as defined by the sender
	Height int32 `json:"height"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// True, if the video is supposed to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *Video) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Video

	return json.Marshal((*stub)(entity))
}

func (*Video) GetClass() string {
	return ClassVideo
}

func (*Video) GetType() string {
	return TypeVideo
}

// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
type VideoNote struct {
	meta
	// Duration of the video, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
	Waveform []byte `json:"waveform"`
	// Video width and height; as defined by the sender
	Length int32 `json:"length"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail in JPEG format; as defined by the sender; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Result of speech recognition in the video note; may be null
	SpeechRecognitionResult SpeechRecognitionResult `json:"speech_recognition_result"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *VideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VideoNote

	return json.Marshal((*stub)(entity))
}

func (*VideoNote) GetClass() string {
	return ClassVideoNote
}

func (*VideoNote) GetType() string {
	return TypeVideoNote
}

func (videoNote *VideoNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Duration                int32           `json:"duration"`
		Waveform                []byte          `json:"waveform"`
		Length                  int32           `json:"length"`
		Minithumbnail           *Minithumbnail  `json:"minithumbnail"`
		Thumbnail               *Thumbnail      `json:"thumbnail"`
		SpeechRecognitionResult json.RawMessage `json:"speech_recognition_result"`
		Video                   *File           `json:"video"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	videoNote.Duration = tmp.Duration
	videoNote.Waveform = tmp.Waveform
	videoNote.Length = tmp.Length
	videoNote.Minithumbnail = tmp.Minithumbnail
	videoNote.Thumbnail = tmp.Thumbnail
	videoNote.Video = tmp.Video

	fieldSpeechRecognitionResult, _ := UnmarshalSpeechRecognitionResult(tmp.SpeechRecognitionResult)
	videoNote.SpeechRecognitionResult = fieldSpeechRecognitionResult

	return nil
}

// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
type VoiceNote struct {
	meta
	// Duration of the voice note, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// A waveform representation of the voice note in 5-bit format
	Waveform []byte `json:"waveform"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// Result of speech recognition in the voice note; may be null
	SpeechRecognitionResult SpeechRecognitionResult `json:"speech_recognition_result"`
	// File containing the voice note
	Voice *File `json:"voice"`
}

func (entity *VoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VoiceNote

	return json.Marshal((*stub)(entity))
}

func (*VoiceNote) GetClass() string {
	return ClassVoiceNote
}

func (*VoiceNote) GetType() string {
	return TypeVoiceNote
}

func (voiceNote *VoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Duration                int32           `json:"duration"`
		Waveform                []byte          `json:"waveform"`
		MimeType                string          `json:"mime_type"`
		SpeechRecognitionResult json.RawMessage `json:"speech_recognition_result"`
		Voice                   *File           `json:"voice"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	voiceNote.Duration = tmp.Duration
	voiceNote.Waveform = tmp.Waveform
	voiceNote.MimeType = tmp.MimeType
	voiceNote.Voice = tmp.Voice

	fieldSpeechRecognitionResult, _ := UnmarshalSpeechRecognitionResult(tmp.SpeechRecognitionResult)
	voiceNote.SpeechRecognitionResult = fieldSpeechRecognitionResult

	return nil
}

// Describes an animated or custom representation of an emoji
type AnimatedEmoji struct {
	meta
	// Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs
	Sticker *Sticker `json:"sticker"`
	// Expected width of the sticker, which can be used if the sticker is null
	StickerWidth int32 `json:"sticker_width"`
	// Expected height of the sticker, which can be used if the sticker is null
	StickerHeight int32 `json:"sticker_height"`
	// Emoji modifier fitzpatrick type; 0-6; 0 if none
	FitzpatrickType int32 `json:"fitzpatrick_type"`
	// File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
	Sound *File `json:"sound"`
}

func (entity *AnimatedEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AnimatedEmoji

	return json.Marshal((*stub)(entity))
}

func (*AnimatedEmoji) GetClass() string {
	return ClassAnimatedEmoji
}

func (*AnimatedEmoji) GetType() string {
	return TypeAnimatedEmoji
}

// Describes a user contact
type Contact struct {
	meta
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// First name of the user; 1-255 characters in length
	FirstName string `json:"first_name"`
	// Last name of the user
	LastName string `json:"last_name"`
	// Additional data about the user in a form of vCard; 0-2048 bytes in length
	Vcard string `json:"vcard"`
	// Identifier of the user, if known; 0 otherwise
	UserId int64 `json:"user_id"`
}

func (entity *Contact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Contact

	return json.Marshal((*stub)(entity))
}

func (*Contact) GetClass() string {
	return ClassContact
}

func (*Contact) GetType() string {
	return TypeContact
}

// Describes a location on planet Earth
type Location struct {
	meta
	// Latitude of the location in degrees; as defined by the sender
	Latitude float64 `json:"latitude"`
	// Longitude of the location, in degrees; as defined by the sender
	Longitude float64 `json:"longitude"`
	// The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
	HorizontalAccuracy float64 `json:"horizontal_accuracy"`
}

func (entity *Location) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Location

	return json.Marshal((*stub)(entity))
}

func (*Location) GetClass() string {
	return ClassLocation
}

func (*Location) GetType() string {
	return TypeLocation
}

// Describes a venue
type Venue struct {
	meta
	// Venue location; as defined by the sender
	Location *Location `json:"location"`
	// Venue name; as defined by the sender
	Title string `json:"title"`
	// Venue address; as defined by the sender
	Address string `json:"address"`
	// Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
	Provider string `json:"provider"`
	// Identifier of the venue in the provider database; as defined by the sender
	Id string `json:"id"`
	// Type of the venue in the provider database; as defined by the sender
	Type string `json:"type"`
}

func (entity *Venue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Venue

	return json.Marshal((*stub)(entity))
}

func (*Venue) GetClass() string {
	return ClassVenue
}

func (*Venue) GetType() string {
	return TypeVenue
}

// Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
type Game struct {
	meta
	// Unique game identifier
	Id JsonInt64 `json:"id"`
	// Game short name
	ShortName string `json:"short_name"`
	// Game title
	Title string `json:"title"`
	// Game text, usually containing scoreboards for a game
	Text *FormattedText `json:"text"`
	// Game description
	Description string `json:"description"`
	// Game photo
	Photo *Photo `json:"photo"`
	// Game animation; may be null
	Animation *Animation `json:"animation"`
}

func (entity *Game) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Game

	return json.Marshal((*stub)(entity))
}

func (*Game) GetClass() string {
	return ClassGame
}

func (*Game) GetType() string {
	return TypeGame
}

// Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
type WebApp struct {
	meta
	// Web App short name
	ShortName string `json:"short_name"`
	// Web App title
	Title string `json:"title"`
	// Web App description
	Description string `json:"description"`
	// Web App photo
	Photo *Photo `json:"photo"`
	// Web App animation; may be null
	Animation *Animation `json:"animation"`
}

func (entity *WebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebApp

	return json.Marshal((*stub)(entity))
}

func (*WebApp) GetClass() string {
	return ClassWebApp
}

func (*WebApp) GetType() string {
	return TypeWebApp
}

// Describes a poll
type Poll struct {
	meta
	// Unique poll identifier
	Id JsonInt64 `json:"id"`
	// Poll question; 1-300 characters
	Question string `json:"question"`
	// List of poll answer options
	Options []*PollOption `json:"options"`
	// Total number of voters, participating in the poll
	TotalVoterCount int32 `json:"total_voter_count"`
	// User identifiers of recent voters, if the poll is non-anonymous
	RecentVoterUserIds []int64 `json:"recent_voter_user_ids"`
	// True, if the poll is anonymous
	IsAnonymous bool `json:"is_anonymous"`
	// Type of the poll
	Type PollType `json:"type"`
	// Amount of time the poll will be active after creation, in seconds
	OpenPeriod int32 `json:"open_period"`
	// Point in time (Unix timestamp) when the poll will automatically be closed
	CloseDate int32 `json:"close_date"`
	// True, if the poll is closed
	IsClosed bool `json:"is_closed"`
}

func (entity *Poll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Poll

	return json.Marshal((*stub)(entity))
}

func (*Poll) GetClass() string {
	return ClassPoll
}

func (*Poll) GetType() string {
	return TypePoll
}

func (poll *Poll) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                 JsonInt64       `json:"id"`
		Question           string          `json:"question"`
		Options            []*PollOption   `json:"options"`
		TotalVoterCount    int32           `json:"total_voter_count"`
		RecentVoterUserIds []int64         `json:"recent_voter_user_ids"`
		IsAnonymous        bool            `json:"is_anonymous"`
		Type               json.RawMessage `json:"type"`
		OpenPeriod         int32           `json:"open_period"`
		CloseDate          int32           `json:"close_date"`
		IsClosed           bool            `json:"is_closed"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	poll.Id = tmp.Id
	poll.Question = tmp.Question
	poll.Options = tmp.Options
	poll.TotalVoterCount = tmp.TotalVoterCount
	poll.RecentVoterUserIds = tmp.RecentVoterUserIds
	poll.IsAnonymous = tmp.IsAnonymous
	poll.OpenPeriod = tmp.OpenPeriod
	poll.CloseDate = tmp.CloseDate
	poll.IsClosed = tmp.IsClosed

	fieldType, _ := UnmarshalPollType(tmp.Type)
	poll.Type = fieldType

	return nil
}

// Describes a user profile photo
type ProfilePhoto struct {
	meta
	// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
	Id JsonInt64 `json:"id"`
	// A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
	Small *File `json:"small"`
	// A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
	Big *File `json:"big"`
	// User profile photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// True, if the photo has animated variant
	HasAnimation bool `json:"has_animation"`
	// True, if the photo is visible only for the current user
	IsPersonal bool `json:"is_personal"`
}

func (entity *ProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*ProfilePhoto) GetClass() string {
	return ClassProfilePhoto
}

func (*ProfilePhoto) GetType() string {
	return TypeProfilePhoto
}

// Contains basic information about the photo of a chat
type ChatPhotoInfo struct {
	meta
	// A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
	Small *File `json:"small"`
	// A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
	Big *File `json:"big"`
	// Chat photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// True, if the photo has animated variant
	HasAnimation bool `json:"has_animation"`
	// True, if the photo is visible only for the current user
	IsPersonal bool `json:"is_personal"`
}

func (entity *ChatPhotoInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoInfo) GetClass() string {
	return ClassChatPhotoInfo
}

func (*ChatPhotoInfo) GetType() string {
	return TypeChatPhotoInfo
}

// A regular user
type UserTypeRegular struct {
	meta
}

func (entity *UserTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*UserTypeRegular) GetClass() string {
	return ClassUserType
}

func (*UserTypeRegular) GetType() string {
	return TypeUserTypeRegular
}

func (*UserTypeRegular) UserTypeType() string {
	return TypeUserTypeRegular
}

// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
type UserTypeDeleted struct {
	meta
}

func (entity *UserTypeDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeDeleted

	return json.Marshal((*stub)(entity))
}

func (*UserTypeDeleted) GetClass() string {
	return ClassUserType
}

func (*UserTypeDeleted) GetType() string {
	return TypeUserTypeDeleted
}

func (*UserTypeDeleted) UserTypeType() string {
	return TypeUserTypeDeleted
}

// A bot (see https://core.telegram.org/bots)
type UserTypeBot struct {
	meta
	// True, if the bot can be invited to basic group and supergroup chats
	CanJoinGroups bool `json:"can_join_groups"`
	// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
	CanReadAllGroupMessages bool `json:"can_read_all_group_messages"`
	// True, if the bot supports inline queries
	IsInline bool `json:"is_inline"`
	// Placeholder for inline queries (displayed on the application input field)
	InlineQueryPlaceholder string `json:"inline_query_placeholder"`
	// True, if the location of the user is expected to be sent with every inline query to this bot
	NeedLocation bool `json:"need_location"`
	// True, if the bot can be added to attachment menu
	CanBeAddedToAttachmentMenu bool `json:"can_be_added_to_attachment_menu"`
}

func (entity *UserTypeBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeBot

	return json.Marshal((*stub)(entity))
}

func (*UserTypeBot) GetClass() string {
	return ClassUserType
}

func (*UserTypeBot) GetType() string {
	return TypeUserTypeBot
}

func (*UserTypeBot) UserTypeType() string {
	return TypeUserTypeBot
}

// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
type UserTypeUnknown struct {
	meta
}

func (entity *UserTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*UserTypeUnknown) GetClass() string {
	return ClassUserType
}

func (*UserTypeUnknown) GetType() string {
	return TypeUserTypeUnknown
}

func (*UserTypeUnknown) UserTypeType() string {
	return TypeUserTypeUnknown
}

// Represents a command supported by a bot
type BotCommand struct {
	meta
	// Text of the bot command
	Command string `json:"command"`
	// Description of the bot command
	Description string `json:"description"`
}

func (entity *BotCommand) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommand

	return json.Marshal((*stub)(entity))
}

func (*BotCommand) GetClass() string {
	return ClassBotCommand
}

func (*BotCommand) GetType() string {
	return TypeBotCommand
}

// Contains a list of bot commands
type BotCommands struct {
	meta
	// Bot's user identifier
	BotUserId int64 `json:"bot_user_id"`
	// List of bot commands
	Commands []*BotCommand `json:"commands"`
}

func (entity *BotCommands) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommands

	return json.Marshal((*stub)(entity))
}

func (*BotCommands) GetClass() string {
	return ClassBotCommands
}

func (*BotCommands) GetType() string {
	return TypeBotCommands
}

// Describes a button to be shown instead of bot commands menu button
type BotMenuButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// URL to be passed to openWebApp
	Url string `json:"url"`
}

func (entity *BotMenuButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotMenuButton

	return json.Marshal((*stub)(entity))
}

func (*BotMenuButton) GetClass() string {
	return ClassBotMenuButton
}

func (*BotMenuButton) GetType() string {
	return TypeBotMenuButton
}

// Represents a location to which a chat is connected
type ChatLocation struct {
	meta
	// The location
	Location *Location `json:"location"`
	// Location address; 1-64 characters, as defined by the chat owner
	Address string `json:"address"`
}

func (entity *ChatLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatLocation) GetClass() string {
	return ClassChatLocation
}

func (*ChatLocation) GetType() string {
	return TypeChatLocation
}

// Information about the sticker, which was used to create the chat photo
type ChatPhotoStickerTypeRegularOrMask struct {
	meta
	// Sticker set identifier
	StickerSetId JsonInt64 `json:"sticker_set_id"`
	// Identifier of the sticker in the set
	StickerId JsonInt64 `json:"sticker_id"`
}

func (entity *ChatPhotoStickerTypeRegularOrMask) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoStickerTypeRegularOrMask

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoStickerTypeRegularOrMask) GetClass() string {
	return ClassChatPhotoStickerType
}

func (*ChatPhotoStickerTypeRegularOrMask) GetType() string {
	return TypeChatPhotoStickerTypeRegularOrMask
}

func (*ChatPhotoStickerTypeRegularOrMask) ChatPhotoStickerTypeType() string {
	return TypeChatPhotoStickerTypeRegularOrMask
}

// Information about the custom emoji, which was used to create the chat photo
type ChatPhotoStickerTypeCustomEmoji struct {
	meta
	// Identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *ChatPhotoStickerTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoStickerTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoStickerTypeCustomEmoji) GetClass() string {
	return ClassChatPhotoStickerType
}

func (*ChatPhotoStickerTypeCustomEmoji) GetType() string {
	return TypeChatPhotoStickerTypeCustomEmoji
}

func (*ChatPhotoStickerTypeCustomEmoji) ChatPhotoStickerTypeType() string {
	return TypeChatPhotoStickerTypeCustomEmoji
}

// Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it
type ChatPhotoSticker struct {
	meta
	// Type of the sticker
	Type ChatPhotoStickerType `json:"type"`
	// The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
	BackgroundFill BackgroundFill `json:"background_fill"`
}

func (entity *ChatPhotoSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoSticker

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoSticker) GetClass() string {
	return ClassChatPhotoSticker
}

func (*ChatPhotoSticker) GetType() string {
	return TypeChatPhotoSticker
}

func (chatPhotoSticker *ChatPhotoSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type           json.RawMessage `json:"type"`
		BackgroundFill json.RawMessage `json:"background_fill"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldType, _ := UnmarshalChatPhotoStickerType(tmp.Type)
	chatPhotoSticker.Type = fieldType

	fieldBackgroundFill, _ := UnmarshalBackgroundFill(tmp.BackgroundFill)
	chatPhotoSticker.BackgroundFill = fieldBackgroundFill

	return nil
}

// Animated variant of a chat photo in MPEG4 format
type AnimatedChatPhoto struct {
	meta
	// Animation width and height
	Length int32 `json:"length"`
	// Information about the animation file
	File *File `json:"file"`
	// Timestamp of the frame, used as a static chat photo
	MainFrameTimestamp float64 `json:"main_frame_timestamp"`
}

func (entity *AnimatedChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AnimatedChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*AnimatedChatPhoto) GetClass() string {
	return ClassAnimatedChatPhoto
}

func (*AnimatedChatPhoto) GetType() string {
	return TypeAnimatedChatPhoto
}

// Describes a chat or user profile photo
type ChatPhoto struct {
	meta
	// Unique photo identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the photo has been added
	AddedDate int32 `json:"added_date"`
	// Photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Available variants of the photo in JPEG format, in different size
	Sizes []*PhotoSize `json:"sizes"`
	// A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
	Animation *AnimatedChatPhoto `json:"animation"`
	// A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
	SmallAnimation *AnimatedChatPhoto `json:"small_animation"`
	// Sticker-based version of the chat photo; may be null
	Sticker *ChatPhotoSticker `json:"sticker"`
}

func (entity *ChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*ChatPhoto) GetClass() string {
	return ClassChatPhoto
}

func (*ChatPhoto) GetType() string {
	return TypeChatPhoto
}

// Contains a list of chat or user profile photos
type ChatPhotos struct {
	meta
	// Total number of photos
	TotalCount int32 `json:"total_count"`
	// List of photos
	Photos []*ChatPhoto `json:"photos"`
}

func (entity *ChatPhotos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotos

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotos) GetClass() string {
	return ClassChatPhotos
}

func (*ChatPhotos) GetType() string {
	return TypeChatPhotos
}

// A previously used profile photo of the current user
type InputChatPhotoPrevious struct {
	meta
	// Identifier of the current user's profile photo to reuse
	ChatPhotoId JsonInt64 `json:"chat_photo_id"`
}

func (entity *InputChatPhotoPrevious) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoPrevious

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoPrevious) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoPrevious) GetType() string {
	return TypeInputChatPhotoPrevious
}

func (*InputChatPhotoPrevious) InputChatPhotoType() string {
	return TypeInputChatPhotoPrevious
}

// A static photo in JPEG format
type InputChatPhotoStatic struct {
	meta
	// Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
	Photo InputFile `json:"photo"`
}

func (entity *InputChatPhotoStatic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoStatic

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoStatic) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoStatic) GetType() string {
	return TypeInputChatPhotoStatic
}

func (*InputChatPhotoStatic) InputChatPhotoType() string {
	return TypeInputChatPhotoStatic
}

func (inputChatPhotoStatic *InputChatPhotoStatic) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Photo json.RawMessage `json:"photo"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldPhoto, _ := UnmarshalInputFile(tmp.Photo)
	inputChatPhotoStatic.Photo = fieldPhoto

	return nil
}

// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size
type InputChatPhotoAnimation struct {
	meta
	// Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
	Animation InputFile `json:"animation"`
	// Timestamp of the frame, which will be used as static chat photo
	MainFrameTimestamp float64 `json:"main_frame_timestamp"`
}

func (entity *InputChatPhotoAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoAnimation) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoAnimation) GetType() string {
	return TypeInputChatPhotoAnimation
}

func (*InputChatPhotoAnimation) InputChatPhotoType() string {
	return TypeInputChatPhotoAnimation
}

func (inputChatPhotoAnimation *InputChatPhotoAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Animation          json.RawMessage `json:"animation"`
		MainFrameTimestamp float64         `json:"main_frame_timestamp"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputChatPhotoAnimation.MainFrameTimestamp = tmp.MainFrameTimestamp

	fieldAnimation, _ := UnmarshalInputFile(tmp.Animation)
	inputChatPhotoAnimation.Animation = fieldAnimation

	return nil
}

// A sticker on a custom background
type InputChatPhotoSticker struct {
	meta
	// Information about the sticker
	Sticker *ChatPhotoSticker `json:"sticker"`
}

func (entity *InputChatPhotoSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoSticker

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoSticker) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoSticker) GetType() string {
	return TypeInputChatPhotoSticker
}

func (*InputChatPhotoSticker) InputChatPhotoType() string {
	return TypeInputChatPhotoSticker
}

// Describes actions that a user is allowed to take in a chat
type ChatPermissions struct {
	meta
	// True, if the user can send text messages, contacts, invoices, locations, and venues
	CanSendBasicMessages bool `json:"can_send_basic_messages"`
	// True, if the user can send music files
	CanSendAudios bool `json:"can_send_audios"`
	// True, if the user can send documents
	CanSendDocuments bool `json:"can_send_documents"`
	// True, if the user can send audio photos
	CanSendPhotos bool `json:"can_send_photos"`
	// True, if the user can send audio videos
	CanSendVideos bool `json:"can_send_videos"`
	// True, if the user can send video notes
	CanSendVideoNotes bool `json:"can_send_video_notes"`
	// True, if the user can send voice notes
	CanSendVoiceNotes bool `json:"can_send_voice_notes"`
	// True, if the user can send polls
	CanSendPolls bool `json:"can_send_polls"`
	// True, if the user can send animations, games, stickers, and dice and use inline bots
	CanSendOtherMessages bool `json:"can_send_other_messages"`
	// True, if the user may add a web page preview to their messages
	CanAddWebPagePreviews bool `json:"can_add_web_page_previews"`
	// True, if the user can change the chat title, photo, and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// True, if the user can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// True, if the user can pin messages
	CanPinMessages bool `json:"can_pin_messages"`
	// True, if the user can manage topics
	CanManageTopics bool `json:"can_manage_topics"`
}

func (entity *ChatPermissions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPermissions

	return json.Marshal((*stub)(entity))
}

func (*ChatPermissions) GetClass() string {
	return ClassChatPermissions
}

func (*ChatPermissions) GetType() string {
	return TypeChatPermissions
}

// Describes rights of the administrator
type ChatAdministratorRights struct {
	meta
	// True, if the administrator can get chat event log, get chat statistics, get message statistics in channels, get channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
	CanManageChat bool `json:"can_manage_chat"`
	// True, if the administrator can change the chat title, photo, and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// True, if the administrator can create channel posts; applicable to channels only
	CanPostMessages bool `json:"can_post_messages"`
	// True, if the administrator can edit messages of other users and pin messages; applicable to channels only
	CanEditMessages bool `json:"can_edit_messages"`
	// True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`
	// True, if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// True, if the administrator can restrict, ban, or unban chat members; always true for channels
	CanRestrictMembers bool `json:"can_restrict_members"`
	// True, if the administrator can pin messages; applicable to basic groups and supergroups only
	CanPinMessages bool `json:"can_pin_messages"`
	// True, if the administrator can manage topics; applicable to forum supergroups only
	CanManageTopics bool `json:"can_manage_topics"`
	// True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
	CanPromoteMembers bool `json:"can_promote_members"`
	// True, if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats"`
	// True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
	IsAnonymous bool `json:"is_anonymous"`
}

func (entity *ChatAdministratorRights) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministratorRights

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministratorRights) GetClass() string {
	return ClassChatAdministratorRights
}

func (*ChatAdministratorRights) GetType() string {
	return TypeChatAdministratorRights
}

// Describes an option for buying Telegram Premium to a user
type PremiumPaymentOption struct {
	meta
	// ISO 4217 currency code for Telegram Premium subscription payment
	Currency string `json:"currency"`
	// The amount to pay, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// The discount associated with this option, as a percentage
	DiscountPercentage int32 `json:"discount_percentage"`
	// Number of month the Telegram Premium subscription will be active
	MonthCount int32 `json:"month_count"`
	// Identifier of the store product associated with the option
	StoreProductId string `json:"store_product_id"`
	// An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
	PaymentLink InternalLinkType `json:"payment_link"`
}

func (entity *PremiumPaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumPaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PremiumPaymentOption) GetClass() string {
	return ClassPremiumPaymentOption
}

func (*PremiumPaymentOption) GetType() string {
	return TypePremiumPaymentOption
}

func (premiumPaymentOption *PremiumPaymentOption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Currency           string          `json:"currency"`
		Amount             int64           `json:"amount"`
		DiscountPercentage int32           `json:"discount_percentage"`
		MonthCount         int32           `json:"month_count"`
		StoreProductId     string          `json:"store_product_id"`
		PaymentLink        json.RawMessage `json:"payment_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumPaymentOption.Currency = tmp.Currency
	premiumPaymentOption.Amount = tmp.Amount
	premiumPaymentOption.DiscountPercentage = tmp.DiscountPercentage
	premiumPaymentOption.MonthCount = tmp.MonthCount
	premiumPaymentOption.StoreProductId = tmp.StoreProductId

	fieldPaymentLink, _ := UnmarshalInternalLinkType(tmp.PaymentLink)
	premiumPaymentOption.PaymentLink = fieldPaymentLink

	return nil
}

// Describes an option for buying or upgrading Telegram Premium for self
type PremiumStatePaymentOption struct {
	meta
	// Information about the payment option
	PaymentOption *PremiumPaymentOption `json:"payment_option"`
	// True, if this is the currently used Telegram Premium subscription option
	IsCurrent bool `json:"is_current"`
	// True, if the payment option can be used to upgrade the existing Telegram Premium subscription
	IsUpgrade bool `json:"is_upgrade"`
	// Identifier of the last in-store transaction for the currently used option
	LastTransactionId string `json:"last_transaction_id"`
}

func (entity *PremiumStatePaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStatePaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PremiumStatePaymentOption) GetClass() string {
	return ClassPremiumStatePaymentOption
}

func (*PremiumStatePaymentOption) GetType() string {
	return TypePremiumStatePaymentOption
}

// Describes a custom emoji to be shown instead of the Telegram Premium badge
type EmojiStatus struct {
	meta
	// Identifier of the custom emoji in stickerFormatTgs format
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *EmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*EmojiStatus) GetClass() string {
	return ClassEmojiStatus
}

func (*EmojiStatus) GetType() string {
	return TypeEmojiStatus
}

// Contains a list of emoji statuses
type EmojiStatuses struct {
	meta
	// The list of emoji statuses
	EmojiStatuses []*EmojiStatus `json:"emoji_statuses"`
}

func (entity *EmojiStatuses) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiStatuses

	return json.Marshal((*stub)(entity))
}

func (*EmojiStatuses) GetClass() string {
	return ClassEmojiStatuses
}

func (*EmojiStatuses) GetType() string {
	return TypeEmojiStatuses
}

// Describes usernames assigned to a user, a supergroup, or a channel
type Usernames struct {
	meta
	// List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames or reorderSupergroupActiveUsernames
	ActiveUsernames []string `json:"active_usernames"`
	// List of currently disabled usernames; the username can be activated with toggleUsernameIsActive/toggleSupergroupUsernameIsActive
	DisabledUsernames []string `json:"disabled_usernames"`
	// The active username, which can be changed with setUsername/setSupergroupUsername
	EditableUsername string `json:"editable_username"`
}

func (entity *Usernames) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Usernames

	return json.Marshal((*stub)(entity))
}

func (*Usernames) GetClass() string {
	return ClassUsernames
}

func (*Usernames) GetType() string {
	return TypeUsernames
}

// Represents a user
type User struct {
	meta
	// User identifier
	Id int64 `json:"id"`
	// First name of the user
	FirstName string `json:"first_name"`
	// Last name of the user
	LastName string `json:"last_name"`
	// Usernames of the user; may be null
	Usernames *Usernames `json:"usernames"`
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Current online status of the user
	Status UserStatus `json:"status"`
	// Profile photo of the user; may be null
	ProfilePhoto *ProfilePhoto `json:"profile_photo"`
	// Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
	EmojiStatus *EmojiStatus `json:"emoji_status"`
	// The user is a contact of the current user
	IsContact bool `json:"is_contact"`
	// The user is a contact of the current user and the current user is a contact of the user
	IsMutualContact bool `json:"is_mutual_contact"`
	// True, if the user is verified
	IsVerified bool `json:"is_verified"`
	// True, if the user is a Telegram Premium user
	IsPremium bool `json:"is_premium"`
	// True, if the user is Telegram support account
	IsSupport bool `json:"is_support"`
	// If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// True, if many users reported this user as a scam
	IsScam bool `json:"is_scam"`
	// True, if many users reported this user as a fake account
	IsFake bool `json:"is_fake"`
	// If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
	HaveAccess bool `json:"have_access"`
	// Type of the user
	Type UserType `json:"type"`
	// IETF language tag of the user's language; only available to bots
	LanguageCode string `json:"language_code"`
	// True, if the user added the current bot to attachment menu; only available to bots
	AddedToAttachmentMenu bool `json:"added_to_attachment_menu"`
}

func (entity *User) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub User

	return json.Marshal((*stub)(entity))
}

func (*User) GetClass() string {
	return ClassUser
}

func (*User) GetType() string {
	return TypeUser
}

func (user *User) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                    int64           `json:"id"`
		FirstName             string          `json:"first_name"`
		LastName              string          `json:"last_name"`
		Usernames             *Usernames      `json:"usernames"`
		PhoneNumber           string          `json:"phone_number"`
		Status                json.RawMessage `json:"status"`
		ProfilePhoto          *ProfilePhoto   `json:"profile_photo"`
		EmojiStatus           *EmojiStatus    `json:"emoji_status"`
		IsContact             bool            `json:"is_contact"`
		IsMutualContact       bool            `json:"is_mutual_contact"`
		IsVerified            bool            `json:"is_verified"`
		IsPremium             bool            `json:"is_premium"`
		IsSupport             bool            `json:"is_support"`
		RestrictionReason     string          `json:"restriction_reason"`
		IsScam                bool            `json:"is_scam"`
		IsFake                bool            `json:"is_fake"`
		HaveAccess            bool            `json:"have_access"`
		Type                  json.RawMessage `json:"type"`
		LanguageCode          string          `json:"language_code"`
		AddedToAttachmentMenu bool            `json:"added_to_attachment_menu"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	user.Id = tmp.Id
	user.FirstName = tmp.FirstName
	user.LastName = tmp.LastName
	user.Usernames = tmp.Usernames
	user.PhoneNumber = tmp.PhoneNumber
	user.ProfilePhoto = tmp.ProfilePhoto
	user.EmojiStatus = tmp.EmojiStatus
	user.IsContact = tmp.IsContact
	user.IsMutualContact = tmp.IsMutualContact
	user.IsVerified = tmp.IsVerified
	user.IsPremium = tmp.IsPremium
	user.IsSupport = tmp.IsSupport
	user.RestrictionReason = tmp.RestrictionReason
	user.IsScam = tmp.IsScam
	user.IsFake = tmp.IsFake
	user.HaveAccess = tmp.HaveAccess
	user.LanguageCode = tmp.LanguageCode
	user.AddedToAttachmentMenu = tmp.AddedToAttachmentMenu

	fieldStatus, _ := UnmarshalUserStatus(tmp.Status)
	user.Status = fieldStatus

	fieldType, _ := UnmarshalUserType(tmp.Type)
	user.Type = fieldType

	return nil
}

// Contains information about a bot
type BotInfo struct {
	meta
	// The text that is shown on the bot's profile page and is sent together with the link when users share the bot
	ShortDescription string `json:"short_description"`
	// The text shown in the chat with the bot if the chat is empty
	Description string `json:"description"`
	// Photo shown in the chat with the bot if the chat is empty; may be null
	Photo *Photo `json:"photo"`
	// Animation shown in the chat with the bot if the chat is empty; may be null
	Animation *Animation `json:"animation"`
	// Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
	MenuButton *BotMenuButton `json:"menu_button"`
	// List of the bot commands
	Commands []*BotCommand `json:"commands"`
	// Default administrator rights for adding the bot to basic group and supergroup chats; may be null
	DefaultGroupAdministratorRights *ChatAdministratorRights `json:"default_group_administrator_rights"`
	// Default administrator rights for adding the bot to channels; may be null
	DefaultChannelAdministratorRights *ChatAdministratorRights `json:"default_channel_administrator_rights"`
}

func (entity *BotInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotInfo

	return json.Marshal((*stub)(entity))
}

func (*BotInfo) GetClass() string {
	return ClassBotInfo
}

func (*BotInfo) GetType() string {
	return TypeBotInfo
}

// Contains full information about a user
type UserFullInfo struct {
	meta
	// User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
	PersonalPhoto *ChatPhoto `json:"personal_photo"`
	// User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
	Photo *ChatPhoto `json:"photo"`
	// User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
	PublicPhoto *ChatPhoto `json:"public_photo"`
	// True, if the user is blocked by the current user
	IsBlocked bool `json:"is_blocked"`
	// True, if the user can be called
	CanBeCalled bool `json:"can_be_called"`
	// True, if a video call can be created with the user
	SupportsVideoCalls bool `json:"supports_video_calls"`
	// True, if the user can't be called due to their privacy settings
	HasPrivateCalls bool `json:"has_private_calls"`
	// True, if the user can't be linked in forwarded messages due to their privacy settings
	HasPrivateForwards bool `json:"has_private_forwards"`
	// True, if voice and video notes can't be sent or forwarded to the user
	HasRestrictedVoiceAndVideoNoteMessages bool `json:"has_restricted_voice_and_video_note_messages"`
	// True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
	NeedPhoneNumberPrivacyException bool `json:"need_phone_number_privacy_exception"`
	// A short user bio; may be null for bots
	Bio *FormattedText `json:"bio"`
	// The list of available options for gifting Telegram Premium to the user
	PremiumGiftOptions []*PremiumPaymentOption `json:"premium_gift_options"`
	// Number of group chats where both the other user and the current user are a member; 0 for the current user
	GroupInCommonCount int32 `json:"group_in_common_count"`
	// For bots, information about the bot; may be null
	BotInfo *BotInfo `json:"bot_info"`
}

func (entity *UserFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UserFullInfo) GetClass() string {
	return ClassUserFullInfo
}

func (*UserFullInfo) GetType() string {
	return TypeUserFullInfo
}

// Represents a list of users
type Users struct {
	meta
	// Approximate total number of users found
	TotalCount int32 `json:"total_count"`
	// A list of user identifiers
	UserIds []int64 `json:"user_ids"`
}

func (entity *Users) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Users

	return json.Marshal((*stub)(entity))
}

func (*Users) GetClass() string {
	return ClassUsers
}

func (*Users) GetType() string {
	return TypeUsers
}

// Contains information about a chat administrator
type ChatAdministrator struct {
	meta
	// User identifier of the administrator
	UserId int64 `json:"user_id"`
	// Custom title of the administrator
	CustomTitle string `json:"custom_title"`
	// True, if the user is the owner of the chat
	IsOwner bool `json:"is_owner"`
}

func (entity *ChatAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministrator) GetClass() string {
	return ClassChatAdministrator
}

func (*ChatAdministrator) GetType() string {
	return TypeChatAdministrator
}

// Represents a list of chat administrators
type ChatAdministrators struct {
	meta
	// A list of chat administrators
	Administrators []*ChatAdministrator `json:"administrators"`
}

func (entity *ChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministrators) GetClass() string {
	return ClassChatAdministrators
}

func (*ChatAdministrators) GetType() string {
	return TypeChatAdministrators
}

// The user is the owner of the chat and has all the administrator privileges
type ChatMemberStatusCreator struct {
	meta
	// A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
	CustomTitle string `json:"custom_title"`
	// True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
	IsAnonymous bool `json:"is_anonymous"`
	// True, if the user is a member of the chat
	IsMember bool `json:"is_member"`
}

func (entity *ChatMemberStatusCreator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusCreator

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusCreator) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusCreator) GetType() string {
	return TypeChatMemberStatusCreator
}

func (*ChatMemberStatusCreator) ChatMemberStatusType() string {
	return TypeChatMemberStatusCreator
}

// The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats. In supergroups and channels, there are more detailed options for administrator privileges
type ChatMemberStatusAdministrator struct {
	meta
	// A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
	CustomTitle string `json:"custom_title"`
	// True, if the current user can edit the administrator privileges for the called user
	CanBeEdited bool `json:"can_be_edited"`
	// Rights of the administrator
	Rights *ChatAdministratorRights `json:"rights"`
}

func (entity *ChatMemberStatusAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusAdministrator) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusAdministrator) GetType() string {
	return TypeChatMemberStatusAdministrator
}

func (*ChatMemberStatusAdministrator) ChatMemberStatusType() string {
	return TypeChatMemberStatusAdministrator
}

// The user is a member of the chat, without any additional privileges or restrictions
type ChatMemberStatusMember struct {
	meta
}

func (entity *ChatMemberStatusMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusMember

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusMember) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusMember) GetType() string {
	return TypeChatMemberStatusMember
}

func (*ChatMemberStatusMember) ChatMemberStatusType() string {
	return TypeChatMemberStatusMember
}

// The user is under certain restrictions in the chat. Not supported in basic groups and channels
type ChatMemberStatusRestricted struct {
	meta
	// True, if the user is a member of the chat
	IsMember bool `json:"is_member"`
	// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
	RestrictedUntilDate int32 `json:"restricted_until_date"`
	// User permissions in the chat
	Permissions *ChatPermissions `json:"permissions"`
}

func (entity *ChatMemberStatusRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusRestricted) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusRestricted) GetType() string {
	return TypeChatMemberStatusRestricted
}

func (*ChatMemberStatusRestricted) ChatMemberStatusType() string {
	return TypeChatMemberStatusRestricted
}

// The user or the chat is not a chat member
type ChatMemberStatusLeft struct {
	meta
}

func (entity *ChatMemberStatusLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusLeft

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusLeft) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusLeft) GetType() string {
	return TypeChatMemberStatusLeft
}

func (*ChatMemberStatusLeft) ChatMemberStatusType() string {
	return TypeChatMemberStatusLeft
}

// The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
type ChatMemberStatusBanned struct {
	meta
	// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
	BannedUntilDate int32 `json:"banned_until_date"`
}

func (entity *ChatMemberStatusBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusBanned

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusBanned) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusBanned) GetType() string {
	return TypeChatMemberStatusBanned
}

func (*ChatMemberStatusBanned) ChatMemberStatusType() string {
	return TypeChatMemberStatusBanned
}

// Describes a user or a chat as a member of another chat
type ChatMember struct {
	meta
	// Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
	MemberId MessageSender `json:"member_id"`
	// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
	InviterUserId int64 `json:"inviter_user_id"`
	// Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
	JoinedChatDate int32 `json:"joined_chat_date"`
	// Status of the member in the chat
	Status ChatMemberStatus `json:"status"`
}

func (entity *ChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMember

	return json.Marshal((*stub)(entity))
}

func (*ChatMember) GetClass() string {
	return ClassChatMember
}

func (*ChatMember) GetType() string {
	return TypeChatMember
}

func (chatMember *ChatMember) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MemberId       json.RawMessage `json:"member_id"`
		InviterUserId  int64           `json:"inviter_user_id"`
		JoinedChatDate int32           `json:"joined_chat_date"`
		Status         json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatMember.InviterUserId = tmp.InviterUserId
	chatMember.JoinedChatDate = tmp.JoinedChatDate

	fieldMemberId, _ := UnmarshalMessageSender(tmp.MemberId)
	chatMember.MemberId = fieldMemberId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	chatMember.Status = fieldStatus

	return nil
}

// Contains a list of chat members
type ChatMembers struct {
	meta
	// Approximate total number of chat members found
	TotalCount int32 `json:"total_count"`
	// A list of chat members
	Members []*ChatMember `json:"members"`
}

func (entity *ChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatMembers) GetClass() string {
	return ClassChatMembers
}

func (*ChatMembers) GetType() string {
	return TypeChatMembers
}

// Returns contacts of the user
type ChatMembersFilterContacts struct {
	meta
}

func (entity *ChatMembersFilterContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterContacts

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterContacts) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterContacts) GetType() string {
	return TypeChatMembersFilterContacts
}

func (*ChatMembersFilterContacts) ChatMembersFilterType() string {
	return TypeChatMembersFilterContacts
}

// Returns the owner and administrators
type ChatMembersFilterAdministrators struct {
	meta
}

func (entity *ChatMembersFilterAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterAdministrators

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterAdministrators) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterAdministrators) GetType() string {
	return TypeChatMembersFilterAdministrators
}

func (*ChatMembersFilterAdministrators) ChatMembersFilterType() string {
	return TypeChatMembersFilterAdministrators
}

// Returns all chat members, including restricted chat members
type ChatMembersFilterMembers struct {
	meta
}

func (entity *ChatMembersFilterMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterMembers) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterMembers) GetType() string {
	return TypeChatMembersFilterMembers
}

func (*ChatMembersFilterMembers) ChatMembersFilterType() string {
	return TypeChatMembersFilterMembers
}

// Returns users which can be mentioned in the chat
type ChatMembersFilterMention struct {
	meta
	// If non-zero, the identifier of the current message thread
	MessageThreadId int64 `json:"message_thread_id"`
}

func (entity *ChatMembersFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterMention

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterMention) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterMention) GetType() string {
	return TypeChatMembersFilterMention
}

func (*ChatMembersFilterMention) ChatMembersFilterType() string {
	return TypeChatMembersFilterMention
}

// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
type ChatMembersFilterRestricted struct {
	meta
}

func (entity *ChatMembersFilterRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterRestricted) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterRestricted) GetType() string {
	return TypeChatMembersFilterRestricted
}

func (*ChatMembersFilterRestricted) ChatMembersFilterType() string {
	return TypeChatMembersFilterRestricted
}

// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
type ChatMembersFilterBanned struct {
	meta
}

func (entity *ChatMembersFilterBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterBanned

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterBanned) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterBanned) GetType() string {
	return TypeChatMembersFilterBanned
}

func (*ChatMembersFilterBanned) ChatMembersFilterType() string {
	return TypeChatMembersFilterBanned
}

// Returns bot members of the chat
type ChatMembersFilterBots struct {
	meta
}

func (entity *ChatMembersFilterBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterBots

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterBots) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterBots) GetType() string {
	return TypeChatMembersFilterBots
}

func (*ChatMembersFilterBots) ChatMembersFilterType() string {
	return TypeChatMembersFilterBots
}

// Returns recently active users in reverse chronological order
type SupergroupMembersFilterRecent struct {
	meta
}

func (entity *SupergroupMembersFilterRecent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterRecent

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterRecent) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterRecent) GetType() string {
	return TypeSupergroupMembersFilterRecent
}

func (*SupergroupMembersFilterRecent) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterRecent
}

// Returns contacts of the user, which are members of the supergroup or channel
type SupergroupMembersFilterContacts struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterContacts

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterContacts) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterContacts) GetType() string {
	return TypeSupergroupMembersFilterContacts
}

func (*SupergroupMembersFilterContacts) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterContacts
}

// Returns the owner and administrators
type SupergroupMembersFilterAdministrators struct {
	meta
}

func (entity *SupergroupMembersFilterAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterAdministrators

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterAdministrators) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterAdministrators) GetType() string {
	return TypeSupergroupMembersFilterAdministrators
}

func (*SupergroupMembersFilterAdministrators) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterAdministrators
}

// Used to search for supergroup or channel members via a (string) query
type SupergroupMembersFilterSearch struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterSearch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterSearch

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterSearch) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterSearch) GetType() string {
	return TypeSupergroupMembersFilterSearch
}

func (*SupergroupMembersFilterSearch) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterSearch
}

// Returns restricted supergroup members; can be used only by administrators
type SupergroupMembersFilterRestricted struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterRestricted

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterRestricted) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterRestricted) GetType() string {
	return TypeSupergroupMembersFilterRestricted
}

func (*SupergroupMembersFilterRestricted) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterRestricted
}

// Returns users banned from the supergroup or channel; can be used only by administrators
type SupergroupMembersFilterBanned struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterBanned

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterBanned) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterBanned) GetType() string {
	return TypeSupergroupMembersFilterBanned
}

func (*SupergroupMembersFilterBanned) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterBanned
}

// Returns users which can be mentioned in the supergroup
type SupergroupMembersFilterMention struct {
	meta
	// Query to search for
	Query string `json:"query"`
	// If non-zero, the identifier of the current message thread
	MessageThreadId int64 `json:"message_thread_id"`
}

func (entity *SupergroupMembersFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterMention

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterMention) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterMention) GetType() string {
	return TypeSupergroupMembersFilterMention
}

func (*SupergroupMembersFilterMention) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterMention
}

// Returns bot members of the supergroup or channel
type SupergroupMembersFilterBots struct {
	meta
}

func (entity *SupergroupMembersFilterBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterBots

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterBots) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterBots) GetType() string {
	return TypeSupergroupMembersFilterBots
}

func (*SupergroupMembersFilterBots) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterBots
}

// Contains a chat invite link
type ChatInviteLink struct {
	meta
	// Chat invite link
	InviteLink string `json:"invite_link"`
	// Name of the link
	Name string `json:"name"`
	// User identifier of an administrator created the link
	CreatorUserId int64 `json:"creator_user_id"`
	// Point in time (Unix timestamp) when the link was created
	Date int32 `json:"date"`
	// Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
	EditDate int32 `json:"edit_date"`
	// Point in time (Unix timestamp) when the link will expire; 0 if never
	ExpirationDate int32 `json:"expiration_date"`
	// The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
	MemberLimit int32 `json:"member_limit"`
	// Number of chat members, which joined the chat using the link
	MemberCount int32 `json:"member_count"`
	// Number of pending join requests created using this link
	PendingJoinRequestCount int32 `json:"pending_join_request_count"`
	// True, if the link only creates join request. If true, total number of joining members will be unlimited
	CreatesJoinRequest bool `json:"creates_join_request"`
	// True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
	IsPrimary bool `json:"is_primary"`
	// True, if the link was revoked
	IsRevoked bool `json:"is_revoked"`
}

func (entity *ChatInviteLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLink

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLink) GetClass() string {
	return ClassChatInviteLink
}

func (*ChatInviteLink) GetType() string {
	return TypeChatInviteLink
}

// Contains a list of chat invite links
type ChatInviteLinks struct {
	meta
	// Approximate total number of chat invite links found
	TotalCount int32 `json:"total_count"`
	// List of invite links
	InviteLinks []*ChatInviteLink `json:"invite_links"`
}

func (entity *ChatInviteLinks) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinks

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinks) GetClass() string {
	return ClassChatInviteLinks
}

func (*ChatInviteLinks) GetType() string {
	return TypeChatInviteLinks
}

// Describes a chat administrator with a number of active and revoked chat invite links
type ChatInviteLinkCount struct {
	meta
	// Administrator's user identifier
	UserId int64 `json:"user_id"`
	// Number of active invite links
	InviteLinkCount int32 `json:"invite_link_count"`
	// Number of revoked invite links
	RevokedInviteLinkCount int32 `json:"revoked_invite_link_count"`
}

func (entity *ChatInviteLinkCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkCount

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkCount) GetClass() string {
	return ClassChatInviteLinkCount
}

func (*ChatInviteLinkCount) GetType() string {
	return TypeChatInviteLinkCount
}

// Contains a list of chat invite link counts
type ChatInviteLinkCounts struct {
	meta
	// List of invite link counts
	InviteLinkCounts []*ChatInviteLinkCount `json:"invite_link_counts"`
}

func (entity *ChatInviteLinkCounts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkCounts

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkCounts) GetClass() string {
	return ClassChatInviteLinkCounts
}

func (*ChatInviteLinkCounts) GetType() string {
	return TypeChatInviteLinkCounts
}

// Describes a chat member joined a chat via an invite link
type ChatInviteLinkMember struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Point in time (Unix timestamp) when the user joined the chat
	JoinedChatDate int32 `json:"joined_chat_date"`
	// User identifier of the chat administrator, approved user join request
	ApproverUserId int64 `json:"approver_user_id"`
}

func (entity *ChatInviteLinkMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkMember

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkMember) GetClass() string {
	return ClassChatInviteLinkMember
}

func (*ChatInviteLinkMember) GetType() string {
	return TypeChatInviteLinkMember
}

// Contains a list of chat members joined a chat via an invite link
type ChatInviteLinkMembers struct {
	meta
	// Approximate total number of chat members found
	TotalCount int32 `json:"total_count"`
	// List of chat members, joined a chat via an invite link
	Members []*ChatInviteLinkMember `json:"members"`
}

func (entity *ChatInviteLinkMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkMembers) GetClass() string {
	return ClassChatInviteLinkMembers
}

func (*ChatInviteLinkMembers) GetType() string {
	return TypeChatInviteLinkMembers
}

// Contains information about a chat invite link
type ChatInviteLinkInfo struct {
	meta
	// Chat identifier of the invite link; 0 if the user has no access to the chat before joining
	ChatId int64 `json:"chat_id"`
	// If non-zero, the amount of time for which read access to the chat will remain available, in seconds
	AccessibleFor int32 `json:"accessible_for"`
	// Type of the chat
	Type ChatType `json:"type"`
	// Title of the chat
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
	// Chat description
	Description string `json:"description"`
	// Number of members in the chat
	MemberCount int32 `json:"member_count"`
	// User identifiers of some chat members that may be known to the current user
	MemberUserIds []int64 `json:"member_user_ids"`
	// True, if the link only creates join request
	CreatesJoinRequest bool `json:"creates_join_request"`
	// True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
	IsPublic bool `json:"is_public"`
}

func (entity *ChatInviteLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkInfo) GetClass() string {
	return ClassChatInviteLinkInfo
}

func (*ChatInviteLinkInfo) GetType() string {
	return TypeChatInviteLinkInfo
}

func (chatInviteLinkInfo *ChatInviteLinkInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId             int64           `json:"chat_id"`
		AccessibleFor      int32           `json:"accessible_for"`
		Type               json.RawMessage `json:"type"`
		Title              string          `json:"title"`
		Photo              *ChatPhotoInfo  `json:"photo"`
		Description        string          `json:"description"`
		MemberCount        int32           `json:"member_count"`
		MemberUserIds      []int64         `json:"member_user_ids"`
		CreatesJoinRequest bool            `json:"creates_join_request"`
		IsPublic           bool            `json:"is_public"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatInviteLinkInfo.ChatId = tmp.ChatId
	chatInviteLinkInfo.AccessibleFor = tmp.AccessibleFor
	chatInviteLinkInfo.Title = tmp.Title
	chatInviteLinkInfo.Photo = tmp.Photo
	chatInviteLinkInfo.Description = tmp.Description
	chatInviteLinkInfo.MemberCount = tmp.MemberCount
	chatInviteLinkInfo.MemberUserIds = tmp.MemberUserIds
	chatInviteLinkInfo.CreatesJoinRequest = tmp.CreatesJoinRequest
	chatInviteLinkInfo.IsPublic = tmp.IsPublic

	fieldType, _ := UnmarshalChatType(tmp.Type)
	chatInviteLinkInfo.Type = fieldType

	return nil
}

// Describes a user that sent a join request and waits for administrator approval
type ChatJoinRequest struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Point in time (Unix timestamp) when the user sent the join request
	Date int32 `json:"date"`
	// A short bio of the user
	Bio string `json:"bio"`
}

func (entity *ChatJoinRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatJoinRequest

	return json.Marshal((*stub)(entity))
}

func (*ChatJoinRequest) GetClass() string {
	return ClassChatJoinRequest
}

func (*ChatJoinRequest) GetType() string {
	return TypeChatJoinRequest
}

// Contains a list of requests to join a chat
type ChatJoinRequests struct {
	meta
	// Approximate total number of requests found
	TotalCount int32 `json:"total_count"`
	// List of the requests
	Requests []*ChatJoinRequest `json:"requests"`
}

func (entity *ChatJoinRequests) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatJoinRequests

	return json.Marshal((*stub)(entity))
}

func (*ChatJoinRequests) GetClass() string {
	return ClassChatJoinRequests
}

func (*ChatJoinRequests) GetType() string {
	return TypeChatJoinRequests
}

// Contains information about pending join requests for a chat
type ChatJoinRequestsInfo struct {
	meta
	// Total number of pending join requests
	TotalCount int32 `json:"total_count"`
	// Identifiers of at most 3 users sent the newest pending join requests
	UserIds []int64 `json:"user_ids"`
}

func (entity *ChatJoinRequestsInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatJoinRequestsInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatJoinRequestsInfo) GetClass() string {
	return ClassChatJoinRequestsInfo
}

func (*ChatJoinRequestsInfo) GetType() string {
	return TypeChatJoinRequestsInfo
}

// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
type BasicGroup struct {
	meta
	// Group identifier
	Id int64 `json:"id"`
	// Number of members in the group
	MemberCount int32 `json:"member_count"`
	// Status of the current user in the group
	Status ChatMemberStatus `json:"status"`
	// True, if the group is active
	IsActive bool `json:"is_active"`
	// Identifier of the supergroup to which this group was upgraded; 0 if none
	UpgradedToSupergroupId int64 `json:"upgraded_to_supergroup_id"`
}

func (entity *BasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BasicGroup

	return json.Marshal((*stub)(entity))
}

func (*BasicGroup) GetClass() string {
	return ClassBasicGroup
}

func (*BasicGroup) GetType() string {
	return TypeBasicGroup
}

func (basicGroup *BasicGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                     int64           `json:"id"`
		MemberCount            int32           `json:"member_count"`
		Status                 json.RawMessage `json:"status"`
		IsActive               bool            `json:"is_active"`
		UpgradedToSupergroupId int64           `json:"upgraded_to_supergroup_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	basicGroup.Id = tmp.Id
	basicGroup.MemberCount = tmp.MemberCount
	basicGroup.IsActive = tmp.IsActive
	basicGroup.UpgradedToSupergroupId = tmp.UpgradedToSupergroupId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	basicGroup.Status = fieldStatus

	return nil
}

// Contains full information about a basic group
type BasicGroupFullInfo struct {
	meta
	// Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
	Photo *ChatPhoto `json:"photo"`
	// Group description. Updated only after the basic group is opened
	Description string `json:"description"`
	// User identifier of the creator of the group; 0 if unknown
	CreatorUserId int64 `json:"creator_user_id"`
	// Group members
	Members []*ChatMember `json:"members"`
	// True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
	CanHideMembers bool `json:"can_hide_members"`
	// True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
	CanToggleAggressiveAntiSpam bool `json:"can_toggle_aggressive_anti_spam"`
	// Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
	InviteLink *ChatInviteLink `json:"invite_link"`
	// List of commands of bots in the group
	BotCommands []*BotCommands `json:"bot_commands"`
}

func (entity *BasicGroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BasicGroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*BasicGroupFullInfo) GetClass() string {
	return ClassBasicGroupFullInfo
}

func (*BasicGroupFullInfo) GetType() string {
	return TypeBasicGroupFullInfo
}

// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
type Supergroup struct {
	meta
	// Supergroup or channel identifier
	Id int64 `json:"id"`
	// Usernames of the supergroup or channel; may be null
	Usernames *Usernames `json:"usernames"`
	// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
	Date int32 `json:"date"`
	// Status of the current user in the supergroup or channel; custom title will always be empty
	Status ChatMemberStatus `json:"status"`
	// Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon, or getUserPrivacySettingRules
	MemberCount int32 `json:"member_count"`
	// True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
	HasLinkedChat bool `json:"has_linked_chat"`
	// True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
	HasLocation bool `json:"has_location"`
	// True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels
	SignMessages bool `json:"sign_messages"`
	// True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
	JoinToSendMessages bool `json:"join_to_send_messages"`
	// True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
	JoinByRequest bool `json:"join_by_request"`
	// True, if the slow mode is enabled in the supergroup
	IsSlowModeEnabled bool `json:"is_slow_mode_enabled"`
	// True, if the supergroup is a channel
	IsChannel bool `json:"is_channel"`
	// True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
	IsBroadcastGroup bool `json:"is_broadcast_group"`
	// True, if the supergroup must be shown as a forum by default
	IsForum bool `json:"is_forum"`
	// True, if the supergroup or channel is verified
	IsVerified bool `json:"is_verified"`
	// If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// True, if many users reported this supergroup or channel as a scam
	IsScam bool `json:"is_scam"`
	// True, if many users reported this supergroup or channel as a fake account
	IsFake bool `json:"is_fake"`
}

func (entity *Supergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Supergroup

	return json.Marshal((*stub)(entity))
}

func (*Supergroup) GetClass() string {
	return ClassSupergroup
}

func (*Supergroup) GetType() string {
	return TypeSupergroup
}

func (supergroup *Supergroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                 int64           `json:"id"`
		Usernames          *Usernames      `json:"usernames"`
		Date               int32           `json:"date"`
		Status             json.RawMessage `json:"status"`
		MemberCount        int32           `json:"member_count"`
		HasLinkedChat      bool            `json:"has_linked_chat"`
		HasLocation        bool            `json:"has_location"`
		SignMessages       bool            `json:"sign_messages"`
		JoinToSendMessages bool            `json:"join_to_send_messages"`
		JoinByRequest      bool            `json:"join_by_request"`
		IsSlowModeEnabled  bool            `json:"is_slow_mode_enabled"`
		IsChannel          bool            `json:"is_channel"`
		IsBroadcastGroup   bool            `json:"is_broadcast_group"`
		IsForum            bool            `json:"is_forum"`
		IsVerified         bool            `json:"is_verified"`
		RestrictionReason  string          `json:"restriction_reason"`
		IsScam             bool            `json:"is_scam"`
		IsFake             bool            `json:"is_fake"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	supergroup.Id = tmp.Id
	supergroup.Usernames = tmp.Usernames
	supergroup.Date = tmp.Date
	supergroup.MemberCount = tmp.MemberCount
	supergroup.HasLinkedChat = tmp.HasLinkedChat
	supergroup.HasLocation = tmp.HasLocation
	supergroup.SignMessages = tmp.SignMessages
	supergroup.JoinToSendMessages = tmp.JoinToSendMessages
	supergroup.JoinByRequest = tmp.JoinByRequest
	supergroup.IsSlowModeEnabled = tmp.IsSlowModeEnabled
	supergroup.IsChannel = tmp.IsChannel
	supergroup.IsBroadcastGroup = tmp.IsBroadcastGroup
	supergroup.IsForum = tmp.IsForum
	supergroup.IsVerified = tmp.IsVerified
	supergroup.RestrictionReason = tmp.RestrictionReason
	supergroup.IsScam = tmp.IsScam
	supergroup.IsFake = tmp.IsFake

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	supergroup.Status = fieldStatus

	return nil
}

// Contains full information about a supergroup or channel
type SupergroupFullInfo struct {
	meta
	// Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
	Photo *ChatPhoto `json:"photo"`
	// Supergroup or channel description
	Description string `json:"description"`
	// Number of members in the supergroup or channel; 0 if unknown
	MemberCount int32 `json:"member_count"`
	// Number of privileged users in the supergroup or channel; 0 if unknown
	AdministratorCount int32 `json:"administrator_count"`
	// Number of restricted users in the supergroup; 0 if unknown
	RestrictedCount int32 `json:"restricted_count"`
	// Number of users banned from chat; 0 if unknown
	BannedCount int32 `json:"banned_count"`
	// Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
	LinkedChatId int64 `json:"linked_chat_id"`
	// Delay between consecutive sent messages for non-administrator supergroup members, in seconds
	SlowModeDelay int32 `json:"slow_mode_delay"`
	// Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
	SlowModeDelayExpiresIn float64 `json:"slow_mode_delay_expires_in"`
	// True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
	CanGetMembers bool `json:"can_get_members"`
	// True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
	HasHiddenMembers bool `json:"has_hidden_members"`
	// True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
	CanHideMembers bool `json:"can_hide_members"`
	// True, if the chat username can be changed
	CanSetUsername bool `json:"can_set_username"`
	// True, if the supergroup sticker set can be changed
	CanSetStickerSet bool `json:"can_set_sticker_set"`
	// True, if the supergroup location can be changed
	CanSetLocation bool `json:"can_set_location"`
	// True, if the supergroup or channel statistics are available
	CanGetStatistics bool `json:"can_get_statistics"`
	// True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
	CanToggleAggressiveAntiSpam bool `json:"can_toggle_aggressive_anti_spam"`
	// True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
	IsAllHistoryAvailable bool `json:"is_all_history_available"`
	// True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
	HasAggressiveAntiSpamEnabled bool `json:"has_aggressive_anti_spam_enabled"`
	// Identifier of the supergroup sticker set; 0 if none
	StickerSetId JsonInt64 `json:"sticker_set_id"`
	// Location to which the supergroup is connected; may be null
	Location *ChatLocation `json:"location"`
	// Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
	InviteLink *ChatInviteLink `json:"invite_link"`
	// List of commands of bots in the group
	BotCommands []*BotCommands `json:"bot_commands"`
	// Identifier of the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromBasicGroupId int64 `json:"upgraded_from_basic_group_id"`
	// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromMaxMessageId int64 `json:"upgraded_from_max_message_id"`
}

func (entity *SupergroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*SupergroupFullInfo) GetClass() string {
	return ClassSupergroupFullInfo
}

func (*SupergroupFullInfo) GetType() string {
	return TypeSupergroupFullInfo
}

// The secret chat is not yet created; waiting for the other user to get online
type SecretChatStatePending struct {
	meta
}

func (entity *SecretChatStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStatePending

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStatePending) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStatePending) GetType() string {
	return TypeSecretChatStatePending
}

func (*SecretChatStatePending) SecretChatStateType() string {
	return TypeSecretChatStatePending
}

// The secret chat is ready to use
type SecretChatStateReady struct {
	meta
}

func (entity *SecretChatStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStateReady

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStateReady) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStateReady) GetType() string {
	return TypeSecretChatStateReady
}

func (*SecretChatStateReady) SecretChatStateType() string {
	return TypeSecretChatStateReady
}

// The secret chat is closed
type SecretChatStateClosed struct {
	meta
}

func (entity *SecretChatStateClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStateClosed

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStateClosed) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStateClosed) GetType() string {
	return TypeSecretChatStateClosed
}

func (*SecretChatStateClosed) SecretChatStateType() string {
	return TypeSecretChatStateClosed
}

// Represents a secret chat
type SecretChat struct {
	meta
	// Secret chat identifier
	Id int32 `json:"id"`
	// Identifier of the chat partner
	UserId int64 `json:"user_id"`
	// State of the secret chat
	State SecretChatState `json:"state"`
	// True, if the chat was created by the current user; false otherwise
	IsOutbound bool `json:"is_outbound"`
	// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
	KeyHash []byte `json:"key_hash"`
	// Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
	Layer int32 `json:"layer"`
}

func (entity *SecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChat

	return json.Marshal((*stub)(entity))
}

func (*SecretChat) GetClass() string {
	return ClassSecretChat
}

func (*SecretChat) GetType() string {
	return TypeSecretChat
}

func (secretChat *SecretChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         int32           `json:"id"`
		UserId     int64           `json:"user_id"`
		State      json.RawMessage `json:"state"`
		IsOutbound bool            `json:"is_outbound"`
		KeyHash    []byte          `json:"key_hash"`
		Layer      int32           `json:"layer"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	secretChat.Id = tmp.Id
	secretChat.UserId = tmp.UserId
	secretChat.IsOutbound = tmp.IsOutbound
	secretChat.KeyHash = tmp.KeyHash
	secretChat.Layer = tmp.Layer

	fieldState, _ := UnmarshalSecretChatState(tmp.State)
	secretChat.State = fieldState

	return nil
}

// The message was sent by a known user
type MessageSenderUser struct {
	meta
	// Identifier of the user that sent the message
	UserId int64 `json:"user_id"`
}

func (entity *MessageSenderUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSenderUser

	return json.Marshal((*stub)(entity))
}

func (*MessageSenderUser) GetClass() string {
	return ClassMessageSender
}

func (*MessageSenderUser) GetType() string {
	return TypeMessageSenderUser
}

func (*MessageSenderUser) MessageSenderType() string {
	return TypeMessageSenderUser
}

// The message was sent on behalf of a chat
type MessageSenderChat struct {
	meta
	// Identifier of the chat that sent the message
	ChatId int64 `json:"chat_id"`
}

func (entity *MessageSenderChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSenderChat

	return json.Marshal((*stub)(entity))
}

func (*MessageSenderChat) GetClass() string {
	return ClassMessageSender
}

func (*MessageSenderChat) GetType() string {
	return TypeMessageSenderChat
}

func (*MessageSenderChat) MessageSenderType() string {
	return TypeMessageSenderChat
}

// Represents a list of message senders
type MessageSenders struct {
	meta
	// Approximate total number of messages senders found
	TotalCount int32 `json:"total_count"`
	// List of message senders
	Senders []MessageSender `json:"senders"`
}

func (entity *MessageSenders) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSenders

	return json.Marshal((*stub)(entity))
}

func (*MessageSenders) GetClass() string {
	return ClassMessageSenders
}

func (*MessageSenders) GetType() string {
	return TypeMessageSenders
}

func (messageSenders *MessageSenders) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TotalCount int32             `json:"total_count"`
		Senders    []json.RawMessage `json:"senders"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageSenders.TotalCount = tmp.TotalCount

	fieldSenders, _ := UnmarshalListOfMessageSender(tmp.Senders)
	messageSenders.Senders = fieldSenders

	return nil
}

// Represents a message sender, which can be used to send messages in a chat
type ChatMessageSender struct {
	meta
	// Available message senders
	Sender MessageSender `json:"sender"`
	// True, if Telegram Premium is needed to use the message sender
	NeedsPremium bool `json:"needs_premium"`
}

func (entity *ChatMessageSender) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMessageSender

	return json.Marshal((*stub)(entity))
}

func (*ChatMessageSender) GetClass() string {
	return ClassChatMessageSender
}

func (*ChatMessageSender) GetType() string {
	return TypeChatMessageSender
}

func (chatMessageSender *ChatMessageSender) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sender       json.RawMessage `json:"sender"`
		NeedsPremium bool            `json:"needs_premium"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatMessageSender.NeedsPremium = tmp.NeedsPremium

	fieldSender, _ := UnmarshalMessageSender(tmp.Sender)
	chatMessageSender.Sender = fieldSender

	return nil
}

// Represents a list of message senders, which can be used to send messages in a chat
type ChatMessageSenders struct {
	meta
	// List of available message senders
	Senders []*ChatMessageSender `json:"senders"`
}

func (entity *ChatMessageSenders) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMessageSenders

	return json.Marshal((*stub)(entity))
}

func (*ChatMessageSenders) GetClass() string {
	return ClassChatMessageSenders
}

func (*ChatMessageSenders) GetType() string {
	return TypeChatMessageSenders
}

// Represents a viewer of a message
type MessageViewer struct {
	meta
	// User identifier of the viewer
	UserId int64 `json:"user_id"`
	// Approximate point in time (Unix timestamp) when the message was viewed
	ViewDate int32 `json:"view_date"`
}

func (entity *MessageViewer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageViewer

	return json.Marshal((*stub)(entity))
}

func (*MessageViewer) GetClass() string {
	return ClassMessageViewer
}

func (*MessageViewer) GetType() string {
	return TypeMessageViewer
}

// Represents a list of message viewers
type MessageViewers struct {
	meta
	// List of message viewers
	Viewers []*MessageViewer `json:"viewers"`
}

func (entity *MessageViewers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageViewers

	return json.Marshal((*stub)(entity))
}

func (*MessageViewers) GetClass() string {
	return ClassMessageViewers
}

func (*MessageViewers) GetType() string {
	return TypeMessageViewers
}

// The message was originally sent by a known user
type MessageForwardOriginUser struct {
	meta
	// Identifier of the user that originally sent the message
	SenderUserId int64 `json:"sender_user_id"`
}

func (entity *MessageForwardOriginUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginUser

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginUser) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginUser) GetType() string {
	return TypeMessageForwardOriginUser
}

func (*MessageForwardOriginUser) MessageForwardOriginType() string {
	return TypeMessageForwardOriginUser
}

// The message was originally sent on behalf of a chat
type MessageForwardOriginChat struct {
	meta
	// Identifier of the chat that originally sent the message
	SenderChatId int64 `json:"sender_chat_id"`
	// For messages originally sent by an anonymous chat administrator, original message author signature
	AuthorSignature string `json:"author_signature"`
}

func (entity *MessageForwardOriginChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginChat

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginChat) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginChat) GetType() string {
	return TypeMessageForwardOriginChat
}

func (*MessageForwardOriginChat) MessageForwardOriginType() string {
	return TypeMessageForwardOriginChat
}

// The message was originally sent by a user, which is hidden by their privacy settings
type MessageForwardOriginHiddenUser struct {
	meta
	// Name of the sender
	SenderName string `json:"sender_name"`
}

func (entity *MessageForwardOriginHiddenUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginHiddenUser

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginHiddenUser) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginHiddenUser) GetType() string {
	return TypeMessageForwardOriginHiddenUser
}

func (*MessageForwardOriginHiddenUser) MessageForwardOriginType() string {
	return TypeMessageForwardOriginHiddenUser
}

// The message was originally a post in a channel
type MessageForwardOriginChannel struct {
	meta
	// Identifier of the chat from which the message was originally forwarded
	ChatId int64 `json:"chat_id"`
	// Message identifier of the original message
	MessageId int64 `json:"message_id"`
	// Original post author signature
	AuthorSignature string `json:"author_signature"`
}

func (entity *MessageForwardOriginChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginChannel

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginChannel) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginChannel) GetType() string {
	return TypeMessageForwardOriginChannel
}

func (*MessageForwardOriginChannel) MessageForwardOriginType() string {
	return TypeMessageForwardOriginChannel
}

// The message was imported from an exported message history
type MessageForwardOriginMessageImport struct {
	meta
	// Name of the sender
	SenderName string `json:"sender_name"`
}

func (entity *MessageForwardOriginMessageImport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginMessageImport

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginMessageImport) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginMessageImport) GetType() string {
	return TypeMessageForwardOriginMessageImport
}

func (*MessageForwardOriginMessageImport) MessageForwardOriginType() string {
	return TypeMessageForwardOriginMessageImport
}

// A reaction with an emoji
type ReactionTypeEmoji struct {
	meta
	// Text representation of the reaction
	Emoji string `json:"emoji"`
}

func (entity *ReactionTypeEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionTypeEmoji

	return json.Marshal((*stub)(entity))
}

func (*ReactionTypeEmoji) GetClass() string {
	return ClassReactionType
}

func (*ReactionTypeEmoji) GetType() string {
	return TypeReactionTypeEmoji
}

func (*ReactionTypeEmoji) ReactionTypeType() string {
	return TypeReactionTypeEmoji
}

// A reaction with a custom emoji
type ReactionTypeCustomEmoji struct {
	meta
	// Unique identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *ReactionTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*ReactionTypeCustomEmoji) GetClass() string {
	return ClassReactionType
}

func (*ReactionTypeCustomEmoji) GetType() string {
	return TypeReactionTypeCustomEmoji
}

func (*ReactionTypeCustomEmoji) ReactionTypeType() string {
	return TypeReactionTypeCustomEmoji
}

// Contains information about a forwarded message
type MessageForwardInfo struct {
	meta
	// Origin of a forwarded message
	Origin MessageForwardOrigin `json:"origin"`
	// Point in time (Unix timestamp) when the message was originally sent
	Date int32 `json:"date"`
	// The type of a public service announcement for the forwarded message
	PublicServiceAnnouncementType string `json:"public_service_announcement_type"`
	// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
	FromChatId int64 `json:"from_chat_id"`
	// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
	FromMessageId int64 `json:"from_message_id"`
}

func (entity *MessageForwardInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardInfo) GetClass() string {
	return ClassMessageForwardInfo
}

func (*MessageForwardInfo) GetType() string {
	return TypeMessageForwardInfo
}

func (messageForwardInfo *MessageForwardInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Origin                        json.RawMessage `json:"origin"`
		Date                          int32           `json:"date"`
		PublicServiceAnnouncementType string          `json:"public_service_announcement_type"`
		FromChatId                    int64           `json:"from_chat_id"`
		FromMessageId                 int64           `json:"from_message_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageForwardInfo.Date = tmp.Date
	messageForwardInfo.PublicServiceAnnouncementType = tmp.PublicServiceAnnouncementType
	messageForwardInfo.FromChatId = tmp.FromChatId
	messageForwardInfo.FromMessageId = tmp.FromMessageId

	fieldOrigin, _ := UnmarshalMessageForwardOrigin(tmp.Origin)
	messageForwardInfo.Origin = fieldOrigin

	return nil
}

// Contains information about replies to a message
type MessageReplyInfo struct {
	meta
	// Number of times the message was directly or indirectly replied
	ReplyCount int32 `json:"reply_count"`
	// Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
	RecentReplierIds []MessageSender `json:"recent_replier_ids"`
	// Identifier of the last read incoming reply to the message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing reply to the message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Identifier of the last reply to the message
	LastMessageId int64 `json:"last_message_id"`
}

func (entity *MessageReplyInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReplyInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageReplyInfo) GetClass() string {
	return ClassMessageReplyInfo
}

func (*MessageReplyInfo) GetType() string {
	return TypeMessageReplyInfo
}

func (messageReplyInfo *MessageReplyInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReplyCount              int32             `json:"reply_count"`
		RecentReplierIds        []json.RawMessage `json:"recent_replier_ids"`
		LastReadInboxMessageId  int64             `json:"last_read_inbox_message_id"`
		LastReadOutboxMessageId int64             `json:"last_read_outbox_message_id"`
		LastMessageId           int64             `json:"last_message_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageReplyInfo.ReplyCount = tmp.ReplyCount
	messageReplyInfo.LastReadInboxMessageId = tmp.LastReadInboxMessageId
	messageReplyInfo.LastReadOutboxMessageId = tmp.LastReadOutboxMessageId
	messageReplyInfo.LastMessageId = tmp.LastMessageId

	fieldRecentReplierIds, _ := UnmarshalListOfMessageSender(tmp.RecentReplierIds)
	messageReplyInfo.RecentReplierIds = fieldRecentReplierIds

	return nil
}

// Contains information about a reaction to a message
type MessageReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// Number of times the reaction was added
	TotalCount int32 `json:"total_count"`
	// True, if the reaction is chosen by the current user
	IsChosen bool `json:"is_chosen"`
	// Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
	RecentSenderIds []MessageSender `json:"recent_sender_ids"`
}

func (entity *MessageReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReaction

	return json.Marshal((*stub)(entity))
}

func (*MessageReaction) GetClass() string {
	return ClassMessageReaction
}

func (*MessageReaction) GetType() string {
	return TypeMessageReaction
}

func (messageReaction *MessageReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type            json.RawMessage   `json:"type"`
		TotalCount      int32             `json:"total_count"`
		IsChosen        bool              `json:"is_chosen"`
		RecentSenderIds []json.RawMessage `json:"recent_sender_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageReaction.TotalCount = tmp.TotalCount
	messageReaction.IsChosen = tmp.IsChosen

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	messageReaction.Type = fieldType

	fieldRecentSenderIds, _ := UnmarshalListOfMessageSender(tmp.RecentSenderIds)
	messageReaction.RecentSenderIds = fieldRecentSenderIds

	return nil
}

// Contains information about interactions with a message
type MessageInteractionInfo struct {
	meta
	// Number of times the message was viewed
	ViewCount int32 `json:"view_count"`
	// Number of times the message was forwarded
	ForwardCount int32 `json:"forward_count"`
	// Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
	ReplyInfo *MessageReplyInfo `json:"reply_info"`
	// The list of reactions added to the message
	Reactions []*MessageReaction `json:"reactions"`
}

func (entity *MessageInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageInteractionInfo) GetClass() string {
	return ClassMessageInteractionInfo
}

func (*MessageInteractionInfo) GetType() string {
	return TypeMessageInteractionInfo
}

// Contains information about an unread reaction to a message
type UnreadReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// Identifier of the sender, added the reaction
	SenderId MessageSender `json:"sender_id"`
	// True, if the reaction was added with a big animation
	IsBig bool `json:"is_big"`
}

func (entity *UnreadReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UnreadReaction

	return json.Marshal((*stub)(entity))
}

func (*UnreadReaction) GetClass() string {
	return ClassUnreadReaction
}

func (*UnreadReaction) GetType() string {
	return TypeUnreadReaction
}

func (unreadReaction *UnreadReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type     json.RawMessage `json:"type"`
		SenderId json.RawMessage `json:"sender_id"`
		IsBig    bool            `json:"is_big"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	unreadReaction.IsBig = tmp.IsBig

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	unreadReaction.Type = fieldType

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	unreadReaction.SenderId = fieldSenderId

	return nil
}

// The message is being sent now, but has not yet been delivered to the server
type MessageSendingStatePending struct {
	meta
	// Non-persistent message sending identifier, specified by the application
	SendingId int32 `json:"sending_id"`
}

func (entity *MessageSendingStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendingStatePending

	return json.Marshal((*stub)(entity))
}

func (*MessageSendingStatePending) GetClass() string {
	return ClassMessageSendingState
}

func (*MessageSendingStatePending) GetType() string {
	return TypeMessageSendingStatePending
}

func (*MessageSendingStatePending) MessageSendingStateType() string {
	return TypeMessageSendingStatePending
}

// The message failed to be sent
type MessageSendingStateFailed struct {
	meta
	// An error code; 0 if unknown
	ErrorCode int32 `json:"error_code"`
	// Error message
	ErrorMessage string `json:"error_message"`
	// True, if the message can be re-sent
	CanRetry bool `json:"can_retry"`
	// True, if the message can be re-sent only on behalf of a different sender
	NeedAnotherSender bool `json:"need_another_sender"`
	// Time left before the message can be re-sent, in seconds. No update is sent when this field changes
	RetryAfter float64 `json:"retry_after"`
}

func (entity *MessageSendingStateFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendingStateFailed

	return json.Marshal((*stub)(entity))
}

func (*MessageSendingStateFailed) GetClass() string {
	return ClassMessageSendingState
}

func (*MessageSendingStateFailed) GetType() string {
	return TypeMessageSendingStateFailed
}

func (*MessageSendingStateFailed) MessageSendingStateType() string {
	return TypeMessageSendingStateFailed
}

// Describes a message
type Message struct {
	meta
	// Message identifier; unique for the chat to which the message belongs
	Id int64 `json:"id"`
	// Identifier of the sender of the message
	SenderId MessageSender `json:"sender_id"`
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The sending state of the message; may be null
	SendingState MessageSendingState `json:"sending_state"`
	// The scheduling state of the message; may be null
	SchedulingState MessageSchedulingState `json:"scheduling_state"`
	// True, if the message is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the message is pinned
	IsPinned bool `json:"is_pinned"`
	// True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
	CanBeEdited bool `json:"can_be_edited"`
	// True, if the message can be forwarded
	CanBeForwarded bool `json:"can_be_forwarded"`
	// True, if content of the message can be saved locally or copied
	CanBeSaved bool `json:"can_be_saved"`
	// True, if the message can be deleted only for the current user while other users will continue to see it
	CanBeDeletedOnlyForSelf bool `json:"can_be_deleted_only_for_self"`
	// True, if the message can be deleted for all users
	CanBeDeletedForAllUsers bool `json:"can_be_deleted_for_all_users"`
	// True, if the list of added reactions is available through getMessageAddedReactions
	CanGetAddedReactions bool `json:"can_get_added_reactions"`
	// True, if the message statistics are available through getMessageStatistics
	CanGetStatistics bool `json:"can_get_statistics"`
	// True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
	CanGetMessageThread bool `json:"can_get_message_thread"`
	// True, if chat members already viewed the message can be received through getMessageViewers
	CanGetViewers bool `json:"can_get_viewers"`
	// True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink
	CanGetMediaTimestampLinks bool `json:"can_get_media_timestamp_links"`
	// True, if reactions on the message can be reported through reportMessageReactions
	CanReportReactions bool `json:"can_report_reactions"`
	// True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
	HasTimestampedMedia bool `json:"has_timestamped_media"`
	// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
	IsChannelPost bool `json:"is_channel_post"`
	// True, if the message is a forum topic message
	IsTopicMessage bool `json:"is_topic_message"`
	// True, if the message contains an unread mention for the current user
	ContainsUnreadMention bool `json:"contains_unread_mention"`
	// Point in time (Unix timestamp) when the message was sent
	Date int32 `json:"date"`
	// Point in time (Unix timestamp) when the message was last edited
	EditDate int32 `json:"edit_date"`
	// Information about the initial message sender; may be null
	ForwardInfo *MessageForwardInfo `json:"forward_info"`
	// Information about interactions with the message; may be null
	InteractionInfo *MessageInteractionInfo `json:"interaction_info"`
	// Information about unread reactions added to the message
	UnreadReactions []*UnreadReaction `json:"unread_reactions"`
	// If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
	ReplyInChatId int64 `json:"reply_in_chat_id"`
	// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
	ReplyToMessageId int64 `json:"reply_to_message_id"`
	// If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
	MessageThreadId int64 `json:"message_thread_id"`
	// The message's self-destruct time, in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the time expires
	SelfDestructTime int32 `json:"self_destruct_time"`
	// Time left before the message self-destruct timer expires, in seconds. If the self-destruct timer isn't started yet, equals to the value of the self_destruct_time field
	SelfDestructIn float64 `json:"self_destruct_in"`
	// Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never. TDLib will send updateDeleteMessages or updateMessageContent once the time expires
	AutoDeleteIn float64 `json:"auto_delete_in"`
	// If non-zero, the user identifier of the bot through which this message was sent
	ViaBotUserId int64 `json:"via_bot_user_id"`
	// For channel posts and anonymous group messages, optional author signature
	AuthorSignature string `json:"author_signature"`
	// Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
	MediaAlbumId JsonInt64 `json:"media_album_id"`
	// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// Content of the message
	Content MessageContent `json:"content"`
	// Reply markup for the message; may be null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *Message) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Message

	return json.Marshal((*stub)(entity))
}

func (*Message) GetClass() string {
	return ClassMessage
}

func (*Message) GetType() string {
	return TypeMessage
}

func (message *Message) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                        int64                   `json:"id"`
		SenderId                  json.RawMessage         `json:"sender_id"`
		ChatId                    int64                   `json:"chat_id"`
		SendingState              json.RawMessage         `json:"sending_state"`
		SchedulingState           json.RawMessage         `json:"scheduling_state"`
		IsOutgoing                bool                    `json:"is_outgoing"`
		IsPinned                  bool                    `json:"is_pinned"`
		CanBeEdited               bool                    `json:"can_be_edited"`
		CanBeForwarded            bool                    `json:"can_be_forwarded"`
		CanBeSaved                bool                    `json:"can_be_saved"`
		CanBeDeletedOnlyForSelf   bool                    `json:"can_be_deleted_only_for_self"`
		CanBeDeletedForAllUsers   bool                    `json:"can_be_deleted_for_all_users"`
		CanGetAddedReactions      bool                    `json:"can_get_added_reactions"`
		CanGetStatistics          bool                    `json:"can_get_statistics"`
		CanGetMessageThread       bool                    `json:"can_get_message_thread"`
		CanGetViewers             bool                    `json:"can_get_viewers"`
		CanGetMediaTimestampLinks bool                    `json:"can_get_media_timestamp_links"`
		CanReportReactions        bool                    `json:"can_report_reactions"`
		HasTimestampedMedia       bool                    `json:"has_timestamped_media"`
		IsChannelPost             bool                    `json:"is_channel_post"`
		IsTopicMessage            bool                    `json:"is_topic_message"`
		ContainsUnreadMention     bool                    `json:"contains_unread_mention"`
		Date                      int32                   `json:"date"`
		EditDate                  int32                   `json:"edit_date"`
		ForwardInfo               *MessageForwardInfo     `json:"forward_info"`
		InteractionInfo           *MessageInteractionInfo `json:"interaction_info"`
		UnreadReactions           []*UnreadReaction       `json:"unread_reactions"`
		ReplyInChatId             int64                   `json:"reply_in_chat_id"`
		ReplyToMessageId          int64                   `json:"reply_to_message_id"`
		MessageThreadId           int64                   `json:"message_thread_id"`
		SelfDestructTime          int32                   `json:"self_destruct_time"`
		SelfDestructIn            float64                 `json:"self_destruct_in"`
		AutoDeleteIn              float64                 `json:"auto_delete_in"`
		ViaBotUserId              int64                   `json:"via_bot_user_id"`
		AuthorSignature           string                  `json:"author_signature"`
		MediaAlbumId              JsonInt64               `json:"media_album_id"`
		RestrictionReason         string                  `json:"restriction_reason"`
		Content                   json.RawMessage         `json:"content"`
		ReplyMarkup               json.RawMessage         `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	message.Id = tmp.Id
	message.ChatId = tmp.ChatId
	message.IsOutgoing = tmp.IsOutgoing
	message.IsPinned = tmp.IsPinned
	message.CanBeEdited = tmp.CanBeEdited
	message.CanBeForwarded = tmp.CanBeForwarded
	message.CanBeSaved = tmp.CanBeSaved
	message.CanBeDeletedOnlyForSelf = tmp.CanBeDeletedOnlyForSelf
	message.CanBeDeletedForAllUsers = tmp.CanBeDeletedForAllUsers
	message.CanGetAddedReactions = tmp.CanGetAddedReactions
	message.CanGetStatistics = tmp.CanGetStatistics
	message.CanGetMessageThread = tmp.CanGetMessageThread
	message.CanGetViewers = tmp.CanGetViewers
	message.CanGetMediaTimestampLinks = tmp.CanGetMediaTimestampLinks
	message.CanReportReactions = tmp.CanReportReactions
	message.HasTimestampedMedia = tmp.HasTimestampedMedia
	message.IsChannelPost = tmp.IsChannelPost
	message.IsTopicMessage = tmp.IsTopicMessage
	message.ContainsUnreadMention = tmp.ContainsUnreadMention
	message.Date = tmp.Date
	message.EditDate = tmp.EditDate
	message.ForwardInfo = tmp.ForwardInfo
	message.InteractionInfo = tmp.InteractionInfo
	message.UnreadReactions = tmp.UnreadReactions
	message.ReplyInChatId = tmp.ReplyInChatId
	message.ReplyToMessageId = tmp.ReplyToMessageId
	message.MessageThreadId = tmp.MessageThreadId
	message.SelfDestructTime = tmp.SelfDestructTime
	message.SelfDestructIn = tmp.SelfDestructIn
	message.AutoDeleteIn = tmp.AutoDeleteIn
	message.ViaBotUserId = tmp.ViaBotUserId
	message.AuthorSignature = tmp.AuthorSignature
	message.MediaAlbumId = tmp.MediaAlbumId
	message.RestrictionReason = tmp.RestrictionReason

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	message.SenderId = fieldSenderId

	fieldSendingState, _ := UnmarshalMessageSendingState(tmp.SendingState)
	message.SendingState = fieldSendingState

	fieldSchedulingState, _ := UnmarshalMessageSchedulingState(tmp.SchedulingState)
	message.SchedulingState = fieldSchedulingState

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	message.Content = fieldContent

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	message.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Contains a list of messages
type Messages struct {
	meta
	// Approximate total number of messages found
	TotalCount int32 `json:"total_count"`
	// List of messages; messages may be null
	Messages []*Message `json:"messages"`
}

func (entity *Messages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Messages

	return json.Marshal((*stub)(entity))
}

func (*Messages) GetClass() string {
	return ClassMessages
}

func (*Messages) GetType() string {
	return TypeMessages
}

// Contains a list of messages found by a search
type FoundMessages struct {
	meta
	// Approximate total number of messages found; -1 if unknown
	TotalCount int32 `json:"total_count"`
	// List of messages
	Messages []*Message `json:"messages"`
	// The offset for the next request. If empty, there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundMessages

	return json.Marshal((*stub)(entity))
}

func (*FoundMessages) GetClass() string {
	return ClassFoundMessages
}

func (*FoundMessages) GetType() string {
	return TypeFoundMessages
}

// Contains a list of messages found by a search in a given chat
type FoundChatMessages struct {
	meta
	// Approximate total number of messages found; -1 if unknown
	TotalCount int32 `json:"total_count"`
	// List of messages
	Messages []*Message `json:"messages"`
	// The offset for the next request. If 0, there are no more results
	NextFromMessageId int64 `json:"next_from_message_id"`
}

func (entity *FoundChatMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundChatMessages

	return json.Marshal((*stub)(entity))
}

func (*FoundChatMessages) GetClass() string {
	return ClassFoundChatMessages
}

func (*FoundChatMessages) GetType() string {
	return TypeFoundChatMessages
}

// Contains information about a message in a specific position
type MessagePosition struct {
	meta
	// 0-based message position in the full list of suitable messages
	Position int32 `json:"position"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Point in time (Unix timestamp) when the message was sent
	Date int32 `json:"date"`
}

func (entity *MessagePosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePosition

	return json.Marshal((*stub)(entity))
}

func (*MessagePosition) GetClass() string {
	return ClassMessagePosition
}

func (*MessagePosition) GetType() string {
	return TypeMessagePosition
}

// Contains a list of message positions
type MessagePositions struct {
	meta
	// Total number of messages found
	TotalCount int32 `json:"total_count"`
	// List of message positions
	Positions []*MessagePosition `json:"positions"`
}

func (entity *MessagePositions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePositions

	return json.Marshal((*stub)(entity))
}

func (*MessagePositions) GetClass() string {
	return ClassMessagePositions
}

func (*MessagePositions) GetType() string {
	return TypeMessagePositions
}

// Contains information about found messages sent on a specific day
type MessageCalendarDay struct {
	meta
	// Total number of found messages sent on the day
	TotalCount int32 `json:"total_count"`
	// First message sent on the day
	Message *Message `json:"message"`
}

func (entity *MessageCalendarDay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCalendarDay

	return json.Marshal((*stub)(entity))
}

func (*MessageCalendarDay) GetClass() string {
	return ClassMessageCalendarDay
}

func (*MessageCalendarDay) GetType() string {
	return TypeMessageCalendarDay
}

// Contains information about found messages, split by days according to the option "utc_time_offset"
type MessageCalendar struct {
	meta
	// Total number of found messages
	TotalCount int32 `json:"total_count"`
	// Information about messages sent
	Days []*MessageCalendarDay `json:"days"`
}

func (entity *MessageCalendar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCalendar

	return json.Marshal((*stub)(entity))
}

func (*MessageCalendar) GetClass() string {
	return ClassMessageCalendar
}

func (*MessageCalendar) GetType() string {
	return TypeMessageCalendar
}

// The message is from a chat history
type MessageSourceChatHistory struct {
	meta
}

func (entity *MessageSourceChatHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceChatHistory

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceChatHistory) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceChatHistory) GetType() string {
	return TypeMessageSourceChatHistory
}

func (*MessageSourceChatHistory) MessageSourceType() string {
	return TypeMessageSourceChatHistory
}

// The message is from a message thread history
type MessageSourceMessageThreadHistory struct {
	meta
}

func (entity *MessageSourceMessageThreadHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceMessageThreadHistory

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceMessageThreadHistory) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceMessageThreadHistory) GetType() string {
	return TypeMessageSourceMessageThreadHistory
}

func (*MessageSourceMessageThreadHistory) MessageSourceType() string {
	return TypeMessageSourceMessageThreadHistory
}

// The message is from a forum topic history
type MessageSourceForumTopicHistory struct {
	meta
}

func (entity *MessageSourceForumTopicHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceForumTopicHistory

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceForumTopicHistory) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceForumTopicHistory) GetType() string {
	return TypeMessageSourceForumTopicHistory
}

func (*MessageSourceForumTopicHistory) MessageSourceType() string {
	return TypeMessageSourceForumTopicHistory
}

// The message is from chat, message thread or forum topic history preview
type MessageSourceHistoryPreview struct {
	meta
}

func (entity *MessageSourceHistoryPreview) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceHistoryPreview

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceHistoryPreview) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceHistoryPreview) GetType() string {
	return TypeMessageSourceHistoryPreview
}

func (*MessageSourceHistoryPreview) MessageSourceType() string {
	return TypeMessageSourceHistoryPreview
}

// The message is from a chat list or a forum topic list
type MessageSourceChatList struct {
	meta
}

func (entity *MessageSourceChatList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceChatList

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceChatList) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceChatList) GetType() string {
	return TypeMessageSourceChatList
}

func (*MessageSourceChatList) MessageSourceType() string {
	return TypeMessageSourceChatList
}

// The message is from search results, including file downloads, local file list, outgoing document messages, calendar
type MessageSourceSearch struct {
	meta
}

func (entity *MessageSourceSearch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceSearch

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceSearch) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceSearch) GetType() string {
	return TypeMessageSourceSearch
}

func (*MessageSourceSearch) MessageSourceType() string {
	return TypeMessageSourceSearch
}

// The message is from a chat event log
type MessageSourceChatEventLog struct {
	meta
}

func (entity *MessageSourceChatEventLog) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceChatEventLog

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceChatEventLog) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceChatEventLog) GetType() string {
	return TypeMessageSourceChatEventLog
}

func (*MessageSourceChatEventLog) MessageSourceType() string {
	return TypeMessageSourceChatEventLog
}

// The message is from a notification
type MessageSourceNotification struct {
	meta
}

func (entity *MessageSourceNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceNotification

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceNotification) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceNotification) GetType() string {
	return TypeMessageSourceNotification
}

func (*MessageSourceNotification) MessageSourceType() string {
	return TypeMessageSourceNotification
}

// The message is from some other source
type MessageSourceOther struct {
	meta
}

func (entity *MessageSourceOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceOther

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceOther) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceOther) GetType() string {
	return TypeMessageSourceOther
}

func (*MessageSourceOther) MessageSourceType() string {
	return TypeMessageSourceOther
}

// Describes a sponsored message
type SponsoredMessage struct {
	meta
	// Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
	MessageId int64 `json:"message_id"`
	// True, if the message needs to be labeled as "recommended" instead of "sponsored"
	IsRecommended bool `json:"is_recommended"`
	// Sponsor chat identifier; 0 if the sponsor chat is accessible through an invite link
	SponsorChatId int64 `json:"sponsor_chat_id"`
	// Information about the sponsor chat; may be null unless sponsor_chat_id == 0
	SponsorChatInfo *ChatInviteLinkInfo `json:"sponsor_chat_info"`
	// True, if the sponsor's chat photo must be shown
	ShowChatPhoto bool `json:"show_chat_photo"`
	// An internal link to be opened when the sponsored message is clicked; may be null if the sponsor chat needs to be opened instead
	Link InternalLinkType `json:"link"`
	// Content of the message. Currently, can be only of the type messageText
	Content MessageContent `json:"content"`
	// If non-empty, information about the sponsor to be shown along with the message
	SponsorInfo string `json:"sponsor_info"`
	// If non-empty, additional information about the sponsored message to be shown along with the message
	AdditionalInfo string `json:"additional_info"`
}

func (entity *SponsoredMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SponsoredMessage

	return json.Marshal((*stub)(entity))
}

func (*SponsoredMessage) GetClass() string {
	return ClassSponsoredMessage
}

func (*SponsoredMessage) GetType() string {
	return TypeSponsoredMessage
}

func (sponsoredMessage *SponsoredMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageId       int64               `json:"message_id"`
		IsRecommended   bool                `json:"is_recommended"`
		SponsorChatId   int64               `json:"sponsor_chat_id"`
		SponsorChatInfo *ChatInviteLinkInfo `json:"sponsor_chat_info"`
		ShowChatPhoto   bool                `json:"show_chat_photo"`
		Link            json.RawMessage     `json:"link"`
		Content         json.RawMessage     `json:"content"`
		SponsorInfo     string              `json:"sponsor_info"`
		AdditionalInfo  string              `json:"additional_info"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	sponsoredMessage.MessageId = tmp.MessageId
	sponsoredMessage.IsRecommended = tmp.IsRecommended
	sponsoredMessage.SponsorChatId = tmp.SponsorChatId
	sponsoredMessage.SponsorChatInfo = tmp.SponsorChatInfo
	sponsoredMessage.ShowChatPhoto = tmp.ShowChatPhoto
	sponsoredMessage.SponsorInfo = tmp.SponsorInfo
	sponsoredMessage.AdditionalInfo = tmp.AdditionalInfo

	fieldLink, _ := UnmarshalInternalLinkType(tmp.Link)
	sponsoredMessage.Link = fieldLink

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	sponsoredMessage.Content = fieldContent

	return nil
}

// Contains a list of sponsored messages
type SponsoredMessages struct {
	meta
	// List of sponsored messages
	Messages []*SponsoredMessage `json:"messages"`
	// The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
	MessagesBetween int32 `json:"messages_between"`
}

func (entity *SponsoredMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SponsoredMessages

	return json.Marshal((*stub)(entity))
}

func (*SponsoredMessages) GetClass() string {
	return ClassSponsoredMessages
}

func (*SponsoredMessages) GetType() string {
	return TypeSponsoredMessages
}

// Describes a file added to file download list
type FileDownload struct {
	meta
	// File identifier
	FileId int32 `json:"file_id"`
	// The message with the file
	Message *Message `json:"message"`
	// Point in time (Unix timestamp) when the file was added to the download list
	AddDate int32 `json:"add_date"`
	// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
	CompleteDate int32 `json:"complete_date"`
	// True, if downloading of the file is paused
	IsPaused bool `json:"is_paused"`
}

func (entity *FileDownload) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileDownload

	return json.Marshal((*stub)(entity))
}

func (*FileDownload) GetClass() string {
	return ClassFileDownload
}

func (*FileDownload) GetType() string {
	return TypeFileDownload
}

// Contains number of being downloaded and recently downloaded files found
type DownloadedFileCounts struct {
	meta
	// Number of active file downloads found, including paused
	ActiveCount int32 `json:"active_count"`
	// Number of paused file downloads found
	PausedCount int32 `json:"paused_count"`
	// Number of completed file downloads found
	CompletedCount int32 `json:"completed_count"`
}

func (entity *DownloadedFileCounts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DownloadedFileCounts

	return json.Marshal((*stub)(entity))
}

func (*DownloadedFileCounts) GetClass() string {
	return ClassDownloadedFileCounts
}

func (*DownloadedFileCounts) GetType() string {
	return TypeDownloadedFileCounts
}

// Contains a list of downloaded files, found by a search
type FoundFileDownloads struct {
	meta
	// Total number of suitable files, ignoring offset
	TotalCounts *DownloadedFileCounts `json:"total_counts"`
	// The list of files
	Files []*FileDownload `json:"files"`
	// The offset for the next request. If empty, there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundFileDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundFileDownloads

	return json.Marshal((*stub)(entity))
}

func (*FoundFileDownloads) GetClass() string {
	return ClassFoundFileDownloads
}

func (*FoundFileDownloads) GetType() string {
	return TypeFoundFileDownloads
}

// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
type NotificationSettingsScopePrivateChats struct {
	meta
}

func (entity *NotificationSettingsScopePrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopePrivateChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopePrivateChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopePrivateChats) GetType() string {
	return TypeNotificationSettingsScopePrivateChats
}

func (*NotificationSettingsScopePrivateChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopePrivateChats
}

// Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
type NotificationSettingsScopeGroupChats struct {
	meta
}

func (entity *NotificationSettingsScopeGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopeGroupChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopeGroupChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopeGroupChats) GetType() string {
	return TypeNotificationSettingsScopeGroupChats
}

func (*NotificationSettingsScopeGroupChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopeGroupChats
}

// Notification settings applied to all channel chats when the corresponding chat setting has a default value
type NotificationSettingsScopeChannelChats struct {
	meta
}

func (entity *NotificationSettingsScopeChannelChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopeChannelChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopeChannelChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopeChannelChats) GetType() string {
	return TypeNotificationSettingsScopeChannelChats
}

func (*NotificationSettingsScopeChannelChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopeChannelChats
}

// Contains information about notification settings for a chat or a forum topic
type ChatNotificationSettings struct {
	meta
	// If true, mute_for is ignored and the value for the relevant type of chat or the forum chat is used instead
	UseDefaultMuteFor bool `json:"use_default_mute_for"`
	// Time left before notifications will be unmuted, in seconds
	MuteFor int32 `json:"mute_for"`
	// If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
	UseDefaultSound bool `json:"use_default_sound"`
	// Identifier of the notification sound to be played; 0 if sound is disabled
	SoundId JsonInt64 `json:"sound_id"`
	// If true, show_preview is ignored and the value for the relevant type of chat or the forum chat is used instead
	UseDefaultShowPreview bool `json:"use_default_show_preview"`
	// True, if message content must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
	// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat or the forum chat is used instead
	UseDefaultDisablePinnedMessageNotifications bool `json:"use_default_disable_pinned_message_notifications"`
	// If true, notifications for incoming pinned messages will be created as for an ordinary unread message
	DisablePinnedMessageNotifications bool `json:"disable_pinned_message_notifications"`
	// If true, disable_mention_notifications is ignored and the value for the relevant type of chat or the forum chat is used instead
	UseDefaultDisableMentionNotifications bool `json:"use_default_disable_mention_notifications"`
	// If true, notifications for messages with mentions will be created as for an ordinary unread message
	DisableMentionNotifications bool `json:"disable_mention_notifications"`
}

func (entity *ChatNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ChatNotificationSettings) GetClass() string {
	return ClassChatNotificationSettings
}

func (*ChatNotificationSettings) GetType() string {
	return TypeChatNotificationSettings
}

// Contains information about notification settings for several chats
type ScopeNotificationSettings struct {
	meta
	// Time left before notifications will be unmuted, in seconds
	MuteFor int32 `json:"mute_for"`
	// Identifier of the notification sound to be played; 0 if sound is disabled
	SoundId JsonInt64 `json:"sound_id"`
	// True, if message content must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
	// True, if notifications for incoming pinned messages will be created as for an ordinary unread message
	DisablePinnedMessageNotifications bool `json:"disable_pinned_message_notifications"`
	// True, if notifications for messages with mentions will be created as for an ordinary unread message
	DisableMentionNotifications bool `json:"disable_mention_notifications"`
}

func (entity *ScopeNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ScopeNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ScopeNotificationSettings) GetClass() string {
	return ClassScopeNotificationSettings
}

func (*ScopeNotificationSettings) GetType() string {
	return TypeScopeNotificationSettings
}

// Contains information about a message draft
type DraftMessage struct {
	meta
	// Identifier of the replied message; 0 if none
	ReplyToMessageId int64 `json:"reply_to_message_id"`
	// Point in time (Unix timestamp) when the draft was created
	Date int32 `json:"date"`
	// Content of the message draft; must be of the type inputMessageText
	InputMessageText InputMessageContent `json:"input_message_text"`
}

func (entity *DraftMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DraftMessage

	return json.Marshal((*stub)(entity))
}

func (*DraftMessage) GetClass() string {
	return ClassDraftMessage
}

func (*DraftMessage) GetType() string {
	return TypeDraftMessage
}

func (draftMessage *DraftMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReplyToMessageId int64           `json:"reply_to_message_id"`
		Date             int32           `json:"date"`
		InputMessageText json.RawMessage `json:"input_message_text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	draftMessage.ReplyToMessageId = tmp.ReplyToMessageId
	draftMessage.Date = tmp.Date

	fieldInputMessageText, _ := UnmarshalInputMessageContent(tmp.InputMessageText)
	draftMessage.InputMessageText = fieldInputMessageText

	return nil
}

// An ordinary chat with a user
type ChatTypePrivate struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
}

func (entity *ChatTypePrivate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypePrivate

	return json.Marshal((*stub)(entity))
}

func (*ChatTypePrivate) GetClass() string {
	return ClassChatType
}

func (*ChatTypePrivate) GetType() string {
	return TypeChatTypePrivate
}

func (*ChatTypePrivate) ChatTypeType() string {
	return TypeChatTypePrivate
}

// A basic group (a chat with 0-200 other users)
type ChatTypeBasicGroup struct {
	meta
	// Basic group identifier
	BasicGroupId int64 `json:"basic_group_id"`
}

func (entity *ChatTypeBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeBasicGroup) GetClass() string {
	return ClassChatType
}

func (*ChatTypeBasicGroup) GetType() string {
	return TypeChatTypeBasicGroup
}

func (*ChatTypeBasicGroup) ChatTypeType() string {
	return TypeChatTypeBasicGroup
}

// A supergroup or channel (with unlimited members)
type ChatTypeSupergroup struct {
	meta
	// Supergroup or channel identifier
	SupergroupId int64 `json:"supergroup_id"`
	// True, if the supergroup is a channel
	IsChannel bool `json:"is_channel"`
}

func (entity *ChatTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeSupergroup) GetClass() string {
	return ClassChatType
}

func (*ChatTypeSupergroup) GetType() string {
	return TypeChatTypeSupergroup
}

func (*ChatTypeSupergroup) ChatTypeType() string {
	return TypeChatTypeSupergroup
}

// A secret chat with a user
type ChatTypeSecret struct {
	meta
	// Secret chat identifier
	SecretChatId int32 `json:"secret_chat_id"`
	// User identifier of the secret chat peer
	UserId int64 `json:"user_id"`
}

func (entity *ChatTypeSecret) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeSecret

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeSecret) GetClass() string {
	return ClassChatType
}

func (*ChatTypeSecret) GetType() string {
	return TypeChatTypeSecret
}

func (*ChatTypeSecret) ChatTypeType() string {
	return TypeChatTypeSecret
}

// Represents a filter of user chats
type ChatFilter struct {
	meta
	// The title of the filter; 1-12 characters without line feeds
	Title string `json:"title"`
	// The chosen icon name for short filter representation. If non-empty, must be one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette". If empty, use getChatFilterDefaultIconName to get default icon name for the filter
	IconName string `json:"icon_name"`
	// The chat identifiers of pinned chats in the filtered chat list. There can be up to getOption("chat_filter_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	PinnedChatIds []int64 `json:"pinned_chat_ids"`
	// The chat identifiers of always included chats in the filtered chat list. There can be up to getOption("chat_filter_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	IncludedChatIds []int64 `json:"included_chat_ids"`
	// The chat identifiers of always excluded chats in the filtered chat list. There can be up to getOption("chat_filter_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	ExcludedChatIds []int64 `json:"excluded_chat_ids"`
	// True, if muted chats need to be excluded
	ExcludeMuted bool `json:"exclude_muted"`
	// True, if read chats need to be excluded
	ExcludeRead bool `json:"exclude_read"`
	// True, if archived chats need to be excluded
	ExcludeArchived bool `json:"exclude_archived"`
	// True, if contacts need to be included
	IncludeContacts bool `json:"include_contacts"`
	// True, if non-contact users need to be included
	IncludeNonContacts bool `json:"include_non_contacts"`
	// True, if bots need to be included
	IncludeBots bool `json:"include_bots"`
	// True, if basic groups and supergroups need to be included
	IncludeGroups bool `json:"include_groups"`
	// True, if channels need to be included
	IncludeChannels bool `json:"include_channels"`
}

func (entity *ChatFilter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFilter

	return json.Marshal((*stub)(entity))
}

func (*ChatFilter) GetClass() string {
	return ClassChatFilter
}

func (*ChatFilter) GetType() string {
	return TypeChatFilter
}

// Contains basic information about a chat filter
type ChatFilterInfo struct {
	meta
	// Unique chat filter identifier
	Id int32 `json:"id"`
	// The title of the filter; 1-12 characters without line feeds
	Title string `json:"title"`
	// The chosen or default icon name for short filter representation. One of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
	IconName string `json:"icon_name"`
}

func (entity *ChatFilterInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFilterInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatFilterInfo) GetClass() string {
	return ClassChatFilterInfo
}

func (*ChatFilterInfo) GetType() string {
	return TypeChatFilterInfo
}

// Describes a recommended chat filter
type RecommendedChatFilter struct {
	meta
	// The chat filter
	Filter *ChatFilter `json:"filter"`
	// Chat filter description
	Description string `json:"description"`
}

func (entity *RecommendedChatFilter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecommendedChatFilter

	return json.Marshal((*stub)(entity))
}

func (*RecommendedChatFilter) GetClass() string {
	return ClassRecommendedChatFilter
}

func (*RecommendedChatFilter) GetType() string {
	return TypeRecommendedChatFilter
}

// Contains a list of recommended chat filters
type RecommendedChatFilters struct {
	meta
	// List of recommended chat filters
	ChatFilters []*RecommendedChatFilter `json:"chat_filters"`
}

func (entity *RecommendedChatFilters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecommendedChatFilters

	return json.Marshal((*stub)(entity))
}

func (*RecommendedChatFilters) GetClass() string {
	return ClassRecommendedChatFilters
}

func (*RecommendedChatFilters) GetType() string {
	return TypeRecommendedChatFilters
}

// A main list of chats
type ChatListMain struct {
	meta
}

func (entity *ChatListMain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListMain

	return json.Marshal((*stub)(entity))
}

func (*ChatListMain) GetClass() string {
	return ClassChatList
}

func (*ChatListMain) GetType() string {
	return TypeChatListMain
}

func (*ChatListMain) ChatListType() string {
	return TypeChatListMain
}

// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
type ChatListArchive struct {
	meta
}

func (entity *ChatListArchive) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListArchive

	return json.Marshal((*stub)(entity))
}

func (*ChatListArchive) GetClass() string {
	return ClassChatList
}

func (*ChatListArchive) GetType() string {
	return TypeChatListArchive
}

func (*ChatListArchive) ChatListType() string {
	return TypeChatListArchive
}

// A list of chats belonging to a chat filter
type ChatListFilter struct {
	meta
	// Chat filter identifier
	ChatFilterId int32 `json:"chat_filter_id"`
}

func (entity *ChatListFilter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListFilter

	return json.Marshal((*stub)(entity))
}

func (*ChatListFilter) GetClass() string {
	return ClassChatList
}

func (*ChatListFilter) GetType() string {
	return TypeChatListFilter
}

func (*ChatListFilter) ChatListType() string {
	return TypeChatListFilter
}

// Contains a list of chat lists
type ChatLists struct {
	meta
	// List of chat lists
	ChatLists []ChatList `json:"chat_lists"`
}

func (entity *ChatLists) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatLists

	return json.Marshal((*stub)(entity))
}

func (*ChatLists) GetClass() string {
	return ClassChatLists
}

func (*ChatLists) GetType() string {
	return TypeChatLists
}

func (chatLists *ChatLists) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatLists []json.RawMessage `json:"chat_lists"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldChatLists, _ := UnmarshalListOfChatList(tmp.ChatLists)
	chatLists.ChatLists = fieldChatLists

	return nil
}

// The chat is sponsored by the user's MTProxy server
type ChatSourceMtprotoProxy struct {
	meta
}

func (entity *ChatSourceMtprotoProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatSourceMtprotoProxy

	return json.Marshal((*stub)(entity))
}

func (*ChatSourceMtprotoProxy) GetClass() string {
	return ClassChatSource
}

func (*ChatSourceMtprotoProxy) GetType() string {
	return TypeChatSourceMtprotoProxy
}

func (*ChatSourceMtprotoProxy) ChatSourceType() string {
	return TypeChatSourceMtprotoProxy
}

// The chat contains a public service announcement
type ChatSourcePublicServiceAnnouncement struct {
	meta
	// The type of the announcement
	Type string `json:"type"`
	// The text of the announcement
	Text string `json:"text"`
}

func (entity *ChatSourcePublicServiceAnnouncement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatSourcePublicServiceAnnouncement

	return json.Marshal((*stub)(entity))
}

func (*ChatSourcePublicServiceAnnouncement) GetClass() string {
	return ClassChatSource
}

func (*ChatSourcePublicServiceAnnouncement) GetType() string {
	return TypeChatSourcePublicServiceAnnouncement
}

func (*ChatSourcePublicServiceAnnouncement) ChatSourceType() string {
	return TypeChatSourcePublicServiceAnnouncement
}

// Describes a position of a chat in a chat list
type ChatPosition struct {
	meta
	// The chat list
	List ChatList `json:"list"`
	// A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
	Order JsonInt64 `json:"order"`
	// True, if the chat is pinned in the chat list
	IsPinned bool `json:"is_pinned"`
	// Source of the chat in the chat list; may be null
	Source ChatSource `json:"source"`
}

func (entity *ChatPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPosition

	return json.Marshal((*stub)(entity))
}

func (*ChatPosition) GetClass() string {
	return ClassChatPosition
}

func (*ChatPosition) GetType() string {
	return TypeChatPosition
}

func (chatPosition *ChatPosition) UnmarshalJSON(data []byte) error {
	var tmp struct {
		List     json.RawMessage `json:"list"`
		Order    JsonInt64       `json:"order"`
		IsPinned bool            `json:"is_pinned"`
		Source   json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatPosition.Order = tmp.Order
	chatPosition.IsPinned = tmp.IsPinned

	fieldList, _ := UnmarshalChatList(tmp.List)
	chatPosition.List = fieldList

	fieldSource, _ := UnmarshalChatSource(tmp.Source)
	chatPosition.Source = fieldSource

	return nil
}

// All reactions are available in the chat
type ChatAvailableReactionsAll struct {
	meta
}

func (entity *ChatAvailableReactionsAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAvailableReactionsAll

	return json.Marshal((*stub)(entity))
}

func (*ChatAvailableReactionsAll) GetClass() string {
	return ClassChatAvailableReactions
}

func (*ChatAvailableReactionsAll) GetType() string {
	return TypeChatAvailableReactionsAll
}

func (*ChatAvailableReactionsAll) ChatAvailableReactionsType() string {
	return TypeChatAvailableReactionsAll
}

// Only specific reactions are available in the chat
type ChatAvailableReactionsSome struct {
	meta
	// The list of reactions
	Reactions []ReactionType `json:"reactions"`
}

func (entity *ChatAvailableReactionsSome) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAvailableReactionsSome

	return json.Marshal((*stub)(entity))
}

func (*ChatAvailableReactionsSome) GetClass() string {
	return ClassChatAvailableReactions
}

func (*ChatAvailableReactionsSome) GetType() string {
	return TypeChatAvailableReactionsSome
}

func (*ChatAvailableReactionsSome) ChatAvailableReactionsType() string {
	return TypeChatAvailableReactionsSome
}

func (chatAvailableReactionsSome *ChatAvailableReactionsSome) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Reactions []json.RawMessage `json:"reactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldReactions, _ := UnmarshalListOfReactionType(tmp.Reactions)
	chatAvailableReactionsSome.Reactions = fieldReactions

	return nil
}

// Describes a video chat
type VideoChat struct {
	meta
	// Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
	// True, if the video chat has participants
	HasParticipants bool `json:"has_participants"`
	// Default group call participant identifier to join the video chat; may be null
	DefaultParticipantId MessageSender `json:"default_participant_id"`
}

func (entity *VideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VideoChat

	return json.Marshal((*stub)(entity))
}

func (*VideoChat) GetClass() string {
	return ClassVideoChat
}

func (*VideoChat) GetType() string {
	return TypeVideoChat
}

func (videoChat *VideoChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		GroupCallId          int32           `json:"group_call_id"`
		HasParticipants      bool            `json:"has_participants"`
		DefaultParticipantId json.RawMessage `json:"default_participant_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	videoChat.GroupCallId = tmp.GroupCallId
	videoChat.HasParticipants = tmp.HasParticipants

	fieldDefaultParticipantId, _ := UnmarshalMessageSender(tmp.DefaultParticipantId)
	videoChat.DefaultParticipantId = fieldDefaultParticipantId

	return nil
}

// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
type Chat struct {
	meta
	// Chat unique identifier
	Id int64 `json:"id"`
	// Type of the chat
	Type ChatType `json:"type"`
	// Chat title
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
	// Actions that non-administrator chat members are allowed to take in the chat
	Permissions *ChatPermissions `json:"permissions"`
	// Last message in the chat; may be null
	LastMessage *Message `json:"last_message"`
	// Positions of the chat in chat lists
	Positions []*ChatPosition `json:"positions"`
	// Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
	MessageSenderId MessageSender `json:"message_sender_id"`
	// True, if chat content can't be saved locally, forwarded, or copied
	HasProtectedContent bool `json:"has_protected_content"`
	// True, if translation of all messages in the chat must be suggested to the user
	IsTranslatable bool `json:"is_translatable"`
	// True, if the chat is marked as unread
	IsMarkedAsUnread bool `json:"is_marked_as_unread"`
	// True, if the chat is blocked by the current user and private messages from the chat can't be received
	IsBlocked bool `json:"is_blocked"`
	// True, if the chat has scheduled messages
	HasScheduledMessages bool `json:"has_scheduled_messages"`
	// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
	CanBeDeletedOnlyForSelf bool `json:"can_be_deleted_only_for_self"`
	// True, if the chat messages can be deleted for all users
	CanBeDeletedForAllUsers bool `json:"can_be_deleted_for_all_users"`
	// True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
	CanBeReported bool `json:"can_be_reported"`
	// Default value of the disable_notification parameter, used when a message is sent to the chat
	DefaultDisableNotification bool `json:"default_disable_notification"`
	// Number of unread messages in the chat
	UnreadCount int32 `json:"unread_count"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Number of unread messages with a mention/reply in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
	// Number of messages with unread reactions in the chat
	UnreadReactionCount int32 `json:"unread_reaction_count"`
	// Notification settings for the chat
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
	// Types of reaction, available in the chat
	AvailableReactions ChatAvailableReactions `json:"available_reactions"`
	// Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"`
	// If non-empty, name of a theme, set for the chat
	ThemeName string `json:"theme_name"`
	// Information about actions which must be possible to do through the chat action bar; may be null
	ActionBar ChatActionBar `json:"action_bar"`
	// Information about video chat of the chat
	VideoChat *VideoChat `json:"video_chat"`
	// Information about pending join requests; may be null
	PendingJoinRequests *ChatJoinRequestsInfo `json:"pending_join_requests"`
	// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	ReplyMarkupMessageId int64 `json:"reply_markup_message_id"`
	// A draft of a message in the chat; may be null
	DraftMessage *DraftMessage `json:"draft_message"`
	// Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
	ClientData string `json:"client_data"`
}

func (entity *Chat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Chat

	return json.Marshal((*stub)(entity))
}

func (*Chat) GetClass() string {
	return ClassChat
}

func (*Chat) GetType() string {
	return TypeChat
}

func (chat *Chat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                         int64                     `json:"id"`
		Type                       json.RawMessage           `json:"type"`
		Title                      string                    `json:"title"`
		Photo                      *ChatPhotoInfo            `json:"photo"`
		Permissions                *ChatPermissions          `json:"permissions"`
		LastMessage                *Message                  `json:"last_message"`
		Positions                  []*ChatPosition           `json:"positions"`
		MessageSenderId            json.RawMessage           `json:"message_sender_id"`
		HasProtectedContent        bool                      `json:"has_protected_content"`
		IsTranslatable             bool                      `json:"is_translatable"`
		IsMarkedAsUnread           bool                      `json:"is_marked_as_unread"`
		IsBlocked                  bool                      `json:"is_blocked"`
		HasScheduledMessages       bool                      `json:"has_scheduled_messages"`
		CanBeDeletedOnlyForSelf    bool                      `json:"can_be_deleted_only_for_self"`
		CanBeDeletedForAllUsers    bool                      `json:"can_be_deleted_for_all_users"`
		CanBeReported              bool                      `json:"can_be_reported"`
		DefaultDisableNotification bool                      `json:"default_disable_notification"`
		UnreadCount                int32                     `json:"unread_count"`
		LastReadInboxMessageId     int64                     `json:"last_read_inbox_message_id"`
		LastReadOutboxMessageId    int64                     `json:"last_read_outbox_message_id"`
		UnreadMentionCount         int32                     `json:"unread_mention_count"`
		UnreadReactionCount        int32                     `json:"unread_reaction_count"`
		NotificationSettings       *ChatNotificationSettings `json:"notification_settings"`
		AvailableReactions         json.RawMessage           `json:"available_reactions"`
		MessageAutoDeleteTime      int32                     `json:"message_auto_delete_time"`
		ThemeName                  string                    `json:"theme_name"`
		ActionBar                  json.RawMessage           `json:"action_bar"`
		VideoChat                  *VideoChat                `json:"video_chat"`
		PendingJoinRequests        *ChatJoinRequestsInfo     `json:"pending_join_requests"`
		ReplyMarkupMessageId       int64                     `json:"reply_markup_message_id"`
		DraftMessage               *DraftMessage             `json:"draft_message"`
		ClientData                 string                    `json:"client_data"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chat.Id = tmp.Id
	chat.Title = tmp.Title
	chat.Photo = tmp.Photo
	chat.Permissions = tmp.Permissions
	chat.LastMessage = tmp.LastMessage
	chat.Positions = tmp.Positions
	chat.HasProtectedContent = tmp.HasProtectedContent
	chat.IsTranslatable = tmp.IsTranslatable
	chat.IsMarkedAsUnread = tmp.IsMarkedAsUnread
	chat.IsBlocked = tmp.IsBlocked
	chat.HasScheduledMessages = tmp.HasScheduledMessages
	chat.CanBeDeletedOnlyForSelf = tmp.CanBeDeletedOnlyForSelf
	chat.CanBeDeletedForAllUsers = tmp.CanBeDeletedForAllUsers
	chat.CanBeReported = tmp.CanBeReported
	chat.DefaultDisableNotification = tmp.DefaultDisableNotification
	chat.UnreadCount = tmp.UnreadCount
	chat.LastReadInboxMessageId = tmp.LastReadInboxMessageId
	chat.LastReadOutboxMessageId = tmp.LastReadOutboxMessageId
	chat.UnreadMentionCount = tmp.UnreadMentionCount
	chat.UnreadReactionCount = tmp.UnreadReactionCount
	chat.NotificationSettings = tmp.NotificationSettings
	chat.MessageAutoDeleteTime = tmp.MessageAutoDeleteTime
	chat.ThemeName = tmp.ThemeName
	chat.VideoChat = tmp.VideoChat
	chat.PendingJoinRequests = tmp.PendingJoinRequests
	chat.ReplyMarkupMessageId = tmp.ReplyMarkupMessageId
	chat.DraftMessage = tmp.DraftMessage
	chat.ClientData = tmp.ClientData

	fieldType, _ := UnmarshalChatType(tmp.Type)
	chat.Type = fieldType

	fieldMessageSenderId, _ := UnmarshalMessageSender(tmp.MessageSenderId)
	chat.MessageSenderId = fieldMessageSenderId

	fieldAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.AvailableReactions)
	chat.AvailableReactions = fieldAvailableReactions

	fieldActionBar, _ := UnmarshalChatActionBar(tmp.ActionBar)
	chat.ActionBar = fieldActionBar

	return nil
}

// Represents a list of chats
type Chats struct {
	meta
	// Approximate total number of chats found
	TotalCount int32 `json:"total_count"`
	// List of chat identifiers
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *Chats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Chats

	return json.Marshal((*stub)(entity))
}

func (*Chats) GetClass() string {
	return ClassChats
}

func (*Chats) GetType() string {
	return TypeChats
}

// Describes a chat located nearby
type ChatNearby struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Distance to the chat location, in meters
	Distance int32 `json:"distance"`
}

func (entity *ChatNearby) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatNearby

	return json.Marshal((*stub)(entity))
}

func (*ChatNearby) GetClass() string {
	return ClassChatNearby
}

func (*ChatNearby) GetType() string {
	return TypeChatNearby
}

// Represents a list of chats located nearby
type ChatsNearby struct {
	meta
	// List of users nearby
	UsersNearby []*ChatNearby `json:"users_nearby"`
	// List of location-based supergroups nearby
	SupergroupsNearby []*ChatNearby `json:"supergroups_nearby"`
}

func (entity *ChatsNearby) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatsNearby

	return json.Marshal((*stub)(entity))
}

func (*ChatsNearby) GetClass() string {
	return ClassChatsNearby
}

func (*ChatsNearby) GetType() string {
	return TypeChatsNearby
}

// The chat is public, because it has an active username
type PublicChatTypeHasUsername struct {
	meta
}

func (entity *PublicChatTypeHasUsername) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicChatTypeHasUsername

	return json.Marshal((*stub)(entity))
}

func (*PublicChatTypeHasUsername) GetClass() string {
	return ClassPublicChatType
}

func (*PublicChatTypeHasUsername) GetType() string {
	return TypePublicChatTypeHasUsername
}

func (*PublicChatTypeHasUsername) PublicChatTypeType() string {
	return TypePublicChatTypeHasUsername
}

// The chat is public, because it is a location-based supergroup
type PublicChatTypeIsLocationBased struct {
	meta
}

func (entity *PublicChatTypeIsLocationBased) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicChatTypeIsLocationBased

	return json.Marshal((*stub)(entity))
}

func (*PublicChatTypeIsLocationBased) GetClass() string {
	return ClassPublicChatType
}

func (*PublicChatTypeIsLocationBased) GetType() string {
	return TypePublicChatTypeIsLocationBased
}

func (*PublicChatTypeIsLocationBased) PublicChatTypeType() string {
	return TypePublicChatTypeIsLocationBased
}

// The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
type ChatActionBarReportSpam struct {
	meta
	// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
	CanUnarchive bool `json:"can_unarchive"`
}

func (entity *ChatActionBarReportSpam) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportSpam

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportSpam) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportSpam) GetType() string {
	return TypeChatActionBarReportSpam
}

func (*ChatActionBarReportSpam) ChatActionBarType() string {
	return TypeChatActionBarReportSpam
}

// The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason chatReportReasonUnrelatedLocation
type ChatActionBarReportUnrelatedLocation struct {
	meta
}

func (entity *ChatActionBarReportUnrelatedLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportUnrelatedLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportUnrelatedLocation) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportUnrelatedLocation) GetType() string {
	return TypeChatActionBarReportUnrelatedLocation
}

func (*ChatActionBarReportUnrelatedLocation) ChatActionBarType() string {
	return TypeChatActionBarReportUnrelatedLocation
}

// The chat is a recently created group chat to which new members can be invited
type ChatActionBarInviteMembers struct {
	meta
}

func (entity *ChatActionBarInviteMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarInviteMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarInviteMembers) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarInviteMembers) GetType() string {
	return TypeChatActionBarInviteMembers
}

func (*ChatActionBarInviteMembers) ChatActionBarType() string {
	return TypeChatActionBarInviteMembers
}

// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method toggleMessageSenderIsBlocked, or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
type ChatActionBarReportAddBlock struct {
	meta
	// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
	CanUnarchive bool `json:"can_unarchive"`
	// If non-negative, the current user was found by the peer through searchChatsNearby and this is the distance between the users
	Distance int32 `json:"distance"`
}

func (entity *ChatActionBarReportAddBlock) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportAddBlock

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportAddBlock) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportAddBlock) GetType() string {
	return TypeChatActionBarReportAddBlock
}

func (*ChatActionBarReportAddBlock) ChatActionBarType() string {
	return TypeChatActionBarReportAddBlock
}

// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
type ChatActionBarAddContact struct {
	meta
}

func (entity *ChatActionBarAddContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarAddContact

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarAddContact) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarAddContact) GetType() string {
	return TypeChatActionBarAddContact
}

func (*ChatActionBarAddContact) ChatActionBarType() string {
	return TypeChatActionBarAddContact
}

// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
type ChatActionBarSharePhoneNumber struct {
	meta
}

func (entity *ChatActionBarSharePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarSharePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarSharePhoneNumber) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarSharePhoneNumber) GetType() string {
	return TypeChatActionBarSharePhoneNumber
}

func (*ChatActionBarSharePhoneNumber) ChatActionBarType() string {
	return TypeChatActionBarSharePhoneNumber
}

// The chat is a private chat with an administrator of a chat to which the user sent join request
type ChatActionBarJoinRequest struct {
	meta
	// Title of the chat to which the join request was sent
	Title string `json:"title"`
	// True, if the join request was sent to a channel chat
	IsChannel bool `json:"is_channel"`
	// Point in time (Unix timestamp) when the join request was sent
	RequestDate int32 `json:"request_date"`
}

func (entity *ChatActionBarJoinRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarJoinRequest

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarJoinRequest) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarJoinRequest) GetType() string {
	return TypeChatActionBarJoinRequest
}

func (*ChatActionBarJoinRequest) ChatActionBarType() string {
	return TypeChatActionBarJoinRequest
}

// A simple button, with text that must be sent when the button is pressed
type KeyboardButtonTypeText struct {
	meta
}

func (entity *KeyboardButtonTypeText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeText

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeText) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeText) GetType() string {
	return TypeKeyboardButtonTypeText
}

func (*KeyboardButtonTypeText) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeText
}

// A button that sends the user's phone number when pressed; available only in private chats
type KeyboardButtonTypeRequestPhoneNumber struct {
	meta
}

func (entity *KeyboardButtonTypeRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestPhoneNumber) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestPhoneNumber) GetType() string {
	return TypeKeyboardButtonTypeRequestPhoneNumber
}

func (*KeyboardButtonTypeRequestPhoneNumber) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestPhoneNumber
}

// A button that sends the user's location when pressed; available only in private chats
type KeyboardButtonTypeRequestLocation struct {
	meta
}

func (entity *KeyboardButtonTypeRequestLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestLocation

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestLocation) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestLocation) GetType() string {
	return TypeKeyboardButtonTypeRequestLocation
}

func (*KeyboardButtonTypeRequestLocation) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestLocation
}

// A button that allows the user to create and send a poll when pressed; available only in private chats
type KeyboardButtonTypeRequestPoll struct {
	meta
	// If true, only regular polls must be allowed to create
	ForceRegular bool `json:"force_regular"`
	// If true, only polls in quiz mode must be allowed to create
	ForceQuiz bool `json:"force_quiz"`
}

func (entity *KeyboardButtonTypeRequestPoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestPoll

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestPoll) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestPoll) GetType() string {
	return TypeKeyboardButtonTypeRequestPoll
}

func (*KeyboardButtonTypeRequestPoll) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestPoll
}

// A button that requests a user to be shared by the current user; available only in private chats. Use the method shareUserWithBot to complete the request
type KeyboardButtonTypeRequestUser struct {
	meta
	// Unique button identifier
	Id int32 `json:"id"`
	// True, if the shared user must or must not be a bot
	RestrictUserIsBot bool `json:"restrict_user_is_bot"`
	// True, if the shared user must be a bot; otherwise, the shared user must no be a bot. Ignored if restrict_user_is_bot is false
	UserIsBot bool `json:"user_is_bot"`
	// True, if the shared user must or must not be a Telegram Premium user
	RestrictUserIsPremium bool `json:"restrict_user_is_premium"`
	// True, if the shared user must be a Telegram Premium user; otherwise, the shared user must no be a Telegram Premium user. Ignored if restrict_user_is_premium is false
	UserIsPremium bool `json:"user_is_premium"`
}

func (entity *KeyboardButtonTypeRequestUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestUser

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestUser) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestUser) GetType() string {
	return TypeKeyboardButtonTypeRequestUser
}

func (*KeyboardButtonTypeRequestUser) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestUser
}

// A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request
type KeyboardButtonTypeRequestChat struct {
	meta
	// Unique button identifier
	Id int32 `json:"id"`
	// True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
	ChatIsChannel bool `json:"chat_is_channel"`
	// True, if the chat must or must not be a forum supergroup
	RestrictChatIsForum bool `json:"restrict_chat_is_forum"`
	// True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
	ChatIsForum bool `json:"chat_is_forum"`
	// True, if the chat must or must not have a username
	RestrictChatHasUsername bool `json:"restrict_chat_has_username"`
	// True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
	ChatHasUsername bool `json:"chat_has_username"`
	// True, if the chat must be created by the current user
	ChatIsCreated bool `json:"chat_is_created"`
	// Expected user administrator rights in the chat; may be null if they aren't restricted
	UserAdministratorRights *ChatAdministratorRights `json:"user_administrator_rights"`
	// Expected bot administrator rights in the chat; may be null if they aren't restricted
	BotAdministratorRights *ChatAdministratorRights `json:"bot_administrator_rights"`
	// True, if the bot must be a member of the chat; for basic group and supergroup chats only
	BotIsMember bool `json:"bot_is_member"`
}

func (entity *KeyboardButtonTypeRequestChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestChat

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestChat) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestChat) GetType() string {
	return TypeKeyboardButtonTypeRequestChat
}

func (*KeyboardButtonTypeRequestChat) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestChat
}

// A button that opens a Web App by calling getWebAppUrl
type KeyboardButtonTypeWebApp struct {
	meta
	// An HTTP URL to pass to getWebAppUrl
	Url string `json:"url"`
}

func (entity *KeyboardButtonTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeWebApp) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeWebApp) GetType() string {
	return TypeKeyboardButtonTypeWebApp
}

func (*KeyboardButtonTypeWebApp) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeWebApp
}

// Represents a single button in a bot keyboard
type KeyboardButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// Type of the button
	Type KeyboardButtonType `json:"type"`
}

func (entity *KeyboardButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButton

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButton) GetClass() string {
	return ClassKeyboardButton
}

func (*KeyboardButton) GetType() string {
	return TypeKeyboardButton
}

func (keyboardButton *KeyboardButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	keyboardButton.Text = tmp.Text

	fieldType, _ := UnmarshalKeyboardButtonType(tmp.Type)
	keyboardButton.Type = fieldType

	return nil
}

// A button that opens a specified URL
type InlineKeyboardButtonTypeUrl struct {
	meta
	// HTTP or tg:// URL to open
	Url string `json:"url"`
}

func (entity *InlineKeyboardButtonTypeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeUrl

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeUrl) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeUrl) GetType() string {
	return TypeInlineKeyboardButtonTypeUrl
}

func (*InlineKeyboardButtonTypeUrl) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeUrl
}

// A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo
type InlineKeyboardButtonTypeLoginUrl struct {
	meta
	// An HTTP URL to pass to getLoginUrlInfo
	Url string `json:"url"`
	// Unique button identifier
	Id int64 `json:"id"`
	// If non-empty, new text of the button in forwarded messages
	ForwardText string `json:"forward_text"`
}

func (entity *InlineKeyboardButtonTypeLoginUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeLoginUrl

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeLoginUrl) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeLoginUrl) GetType() string {
	return TypeInlineKeyboardButtonTypeLoginUrl
}

func (*InlineKeyboardButtonTypeLoginUrl) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeLoginUrl
}

// A button that opens a Web App by calling openWebApp
type InlineKeyboardButtonTypeWebApp struct {
	meta
	// An HTTP URL to pass to openWebApp
	Url string `json:"url"`
}

func (entity *InlineKeyboardButtonTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeWebApp) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeWebApp) GetType() string {
	return TypeInlineKeyboardButtonTypeWebApp
}

func (*InlineKeyboardButtonTypeWebApp) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeWebApp
}

// A button that sends a callback query to a bot
type InlineKeyboardButtonTypeCallback struct {
	meta
	// Data to be sent to the bot via a callback query
	Data []byte `json:"data"`
}

func (entity *InlineKeyboardButtonTypeCallback) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallback

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallback) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallback) GetType() string {
	return TypeInlineKeyboardButtonTypeCallback
}

func (*InlineKeyboardButtonTypeCallback) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallback
}

// A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot
type InlineKeyboardButtonTypeCallbackWithPassword struct {
	meta
	// Data to be sent to the bot via a callback query
	Data []byte `json:"data"`
}

func (entity *InlineKeyboardButtonTypeCallbackWithPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallbackWithPassword

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallbackWithPassword) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallbackWithPassword) GetType() string {
	return TypeInlineKeyboardButtonTypeCallbackWithPassword
}

func (*InlineKeyboardButtonTypeCallbackWithPassword) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallbackWithPassword
}

// A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
type InlineKeyboardButtonTypeCallbackGame struct {
	meta
}

func (entity *InlineKeyboardButtonTypeCallbackGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallbackGame

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallbackGame) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallbackGame) GetType() string {
	return TypeInlineKeyboardButtonTypeCallbackGame
}

func (*InlineKeyboardButtonTypeCallbackGame) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallbackGame
}

// A button that forces an inline query to the bot to be inserted in the input field
type InlineKeyboardButtonTypeSwitchInline struct {
	meta
	// Inline query to be sent to the bot
	Query string `json:"query"`
	// True, if the inline query must be sent from the current chat
	InCurrentChat bool `json:"in_current_chat"`
}

func (entity *InlineKeyboardButtonTypeSwitchInline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeSwitchInline

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeSwitchInline) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeSwitchInline) GetType() string {
	return TypeInlineKeyboardButtonTypeSwitchInline
}

func (*InlineKeyboardButtonTypeSwitchInline) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeSwitchInline
}

// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
type InlineKeyboardButtonTypeBuy struct {
	meta
}

func (entity *InlineKeyboardButtonTypeBuy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeBuy

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeBuy) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeBuy) GetType() string {
	return TypeInlineKeyboardButtonTypeBuy
}

func (*InlineKeyboardButtonTypeBuy) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeBuy
}

// A button with a user reference to be handled in the same way as textEntityTypeMentionName entities
type InlineKeyboardButtonTypeUser struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
}

func (entity *InlineKeyboardButtonTypeUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeUser

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeUser) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeUser) GetType() string {
	return TypeInlineKeyboardButtonTypeUser
}

func (*InlineKeyboardButtonTypeUser) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeUser
}

// Represents a single button in an inline keyboard
type InlineKeyboardButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// Type of the button
	Type InlineKeyboardButtonType `json:"type"`
}

func (entity *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButton

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButton) GetClass() string {
	return ClassInlineKeyboardButton
}

func (*InlineKeyboardButton) GetType() string {
	return TypeInlineKeyboardButton
}

func (inlineKeyboardButton *InlineKeyboardButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineKeyboardButton.Text = tmp.Text

	fieldType, _ := UnmarshalInlineKeyboardButtonType(tmp.Type)
	inlineKeyboardButton.Type = fieldType

	return nil
}

// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent
type ReplyMarkupRemoveKeyboard struct {
	meta
	// True, if the keyboard is removed only for the mentioned users or the target user of a reply
	IsPersonal bool `json:"is_personal"`
}

func (entity *ReplyMarkupRemoveKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupRemoveKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupRemoveKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupRemoveKeyboard) GetType() string {
	return TypeReplyMarkupRemoveKeyboard
}

func (*ReplyMarkupRemoveKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupRemoveKeyboard
}

// Instructs application to force a reply to this message
type ReplyMarkupForceReply struct {
	meta
	// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
	IsPersonal bool `json:"is_personal"`
	// If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
	InputFieldPlaceholder string `json:"input_field_placeholder"`
}

func (entity *ReplyMarkupForceReply) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupForceReply

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupForceReply) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupForceReply) GetType() string {
	return TypeReplyMarkupForceReply
}

func (*ReplyMarkupForceReply) ReplyMarkupType() string {
	return TypeReplyMarkupForceReply
}

// Contains a custom keyboard layout to quickly reply to bots
type ReplyMarkupShowKeyboard struct {
	meta
	// A list of rows of bot keyboard buttons
	Rows [][]*KeyboardButton `json:"rows"`
	// True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden
	IsPersistent bool `json:"is_persistent"`
	// True, if the application needs to resize the keyboard vertically
	ResizeKeyboard bool `json:"resize_keyboard"`
	// True, if the application needs to hide the keyboard after use
	OneTime bool `json:"one_time"`
	// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
	IsPersonal bool `json:"is_personal"`
	// If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
	InputFieldPlaceholder string `json:"input_field_placeholder"`
}

func (entity *ReplyMarkupShowKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupShowKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupShowKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupShowKeyboard) GetType() string {
	return TypeReplyMarkupShowKeyboard
}

func (*ReplyMarkupShowKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupShowKeyboard
}

// Contains an inline keyboard layout
type ReplyMarkupInlineKeyboard struct {
	meta
	// A list of rows of inline keyboard buttons
	Rows [][]*InlineKeyboardButton `json:"rows"`
}

func (entity *ReplyMarkupInlineKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupInlineKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupInlineKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupInlineKeyboard) GetType() string {
	return TypeReplyMarkupInlineKeyboard
}

func (*ReplyMarkupInlineKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupInlineKeyboard
}

// An HTTP URL needs to be open
type LoginUrlInfoOpen struct {
	meta
	// The URL to open
	Url string `json:"url"`
	// True, if there is no need to show an ordinary open URL confirmation
	SkipConfirmation bool `json:"skip_confirmation"`
}

func (entity *LoginUrlInfoOpen) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LoginUrlInfoOpen

	return json.Marshal((*stub)(entity))
}

func (*LoginUrlInfoOpen) GetClass() string {
	return ClassLoginUrlInfo
}

func (*LoginUrlInfoOpen) GetType() string {
	return TypeLoginUrlInfoOpen
}

func (*LoginUrlInfoOpen) LoginUrlInfoType() string {
	return TypeLoginUrlInfoOpen
}

// An authorization confirmation dialog needs to be shown to the user
type LoginUrlInfoRequestConfirmation struct {
	meta
	// An HTTP URL to be opened
	Url string `json:"url"`
	// A domain of the URL
	Domain string `json:"domain"`
	// User identifier of a bot linked with the website
	BotUserId int64 `json:"bot_user_id"`
	// True, if the user must be asked for the permission to the bot to send them messages
	RequestWriteAccess bool `json:"request_write_access"`
}

func (entity *LoginUrlInfoRequestConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LoginUrlInfoRequestConfirmation

	return json.Marshal((*stub)(entity))
}

func (*LoginUrlInfoRequestConfirmation) GetClass() string {
	return ClassLoginUrlInfo
}

func (*LoginUrlInfoRequestConfirmation) GetType() string {
	return TypeLoginUrlInfoRequestConfirmation
}

func (*LoginUrlInfoRequestConfirmation) LoginUrlInfoType() string {
	return TypeLoginUrlInfoRequestConfirmation
}

// Contains information about a Web App found by its short name
type FoundWebApp struct {
	meta
	// The Web App
	WebApp *WebApp `json:"web_app"`
	// True, if the user must be asked for the permission to the bot to send them messages
	RequestWriteAccess bool `json:"request_write_access"`
	// True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
	SkipConfirmation bool `json:"skip_confirmation"`
}

func (entity *FoundWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundWebApp

	return json.Marshal((*stub)(entity))
}

func (*FoundWebApp) GetClass() string {
	return ClassFoundWebApp
}

func (*FoundWebApp) GetType() string {
	return TypeFoundWebApp
}

// Contains information about a Web App
type WebAppInfo struct {
	meta
	// Unique identifier for the Web App launch
	LaunchId JsonInt64 `json:"launch_id"`
	// A Web App URL to open in a web view
	Url string `json:"url"`
}

func (entity *WebAppInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebAppInfo

	return json.Marshal((*stub)(entity))
}

func (*WebAppInfo) GetClass() string {
	return ClassWebAppInfo
}

func (*WebAppInfo) GetType() string {
	return TypeWebAppInfo
}

// Contains information about a message thread
type MessageThreadInfo struct {
	meta
	// Identifier of the chat to which the message thread belongs
	ChatId int64 `json:"chat_id"`
	// Message thread identifier, unique within the chat
	MessageThreadId int64 `json:"message_thread_id"`
	// Information about the message thread; may be null for forum topic threads
	ReplyInfo *MessageReplyInfo `json:"reply_info"`
	// Approximate number of unread messages in the message thread
	UnreadMessageCount int32 `json:"unread_message_count"`
	// The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
	Messages []*Message `json:"messages"`
	// A draft of a message in the message thread; may be null
	DraftMessage *DraftMessage `json:"draft_message"`
}

func (entity *MessageThreadInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageThreadInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageThreadInfo) GetClass() string {
	return ClassMessageThreadInfo
}

func (*MessageThreadInfo) GetType() string {
	return TypeMessageThreadInfo
}

// Describes a forum topic icon
type ForumTopicIcon struct {
	meta
	// Color of the topic icon in RGB format
	Color int32 `json:"color"`
	// Unique identifier of the custom emoji shown on the topic icon; 0 if none
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *ForumTopicIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopicIcon

	return json.Marshal((*stub)(entity))
}

func (*ForumTopicIcon) GetClass() string {
	return ClassForumTopicIcon
}

func (*ForumTopicIcon) GetType() string {
	return TypeForumTopicIcon
}

// Contains basic information about a forum topic
type ForumTopicInfo struct {
	meta
	// Message thread identifier of the topic
	MessageThreadId int64 `json:"message_thread_id"`
	// Name of the topic
	Name string `json:"name"`
	// Icon of the topic
	Icon *ForumTopicIcon `json:"icon"`
	// Date the topic was created
	CreationDate int32 `json:"creation_date"`
	// Identifier of the creator of the topic
	CreatorId MessageSender `json:"creator_id"`
	// True, if the topic is the General topic list
	IsGeneral bool `json:"is_general"`
	// True, if the topic was created by the current user
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the topic is closed
	IsClosed bool `json:"is_closed"`
	// True, if the topic is hidden above the topic list and closed; for General topic only
	IsHidden bool `json:"is_hidden"`
}

func (entity *ForumTopicInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopicInfo

	return json.Marshal((*stub)(entity))
}

func (*ForumTopicInfo) GetClass() string {
	return ClassForumTopicInfo
}

func (*ForumTopicInfo) GetType() string {
	return TypeForumTopicInfo
}

func (forumTopicInfo *ForumTopicInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageThreadId int64           `json:"message_thread_id"`
		Name            string          `json:"name"`
		Icon            *ForumTopicIcon `json:"icon"`
		CreationDate    int32           `json:"creation_date"`
		CreatorId       json.RawMessage `json:"creator_id"`
		IsGeneral       bool            `json:"is_general"`
		IsOutgoing      bool            `json:"is_outgoing"`
		IsClosed        bool            `json:"is_closed"`
		IsHidden        bool            `json:"is_hidden"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	forumTopicInfo.MessageThreadId = tmp.MessageThreadId
	forumTopicInfo.Name = tmp.Name
	forumTopicInfo.Icon = tmp.Icon
	forumTopicInfo.CreationDate = tmp.CreationDate
	forumTopicInfo.IsGeneral = tmp.IsGeneral
	forumTopicInfo.IsOutgoing = tmp.IsOutgoing
	forumTopicInfo.IsClosed = tmp.IsClosed
	forumTopicInfo.IsHidden = tmp.IsHidden

	fieldCreatorId, _ := UnmarshalMessageSender(tmp.CreatorId)
	forumTopicInfo.CreatorId = fieldCreatorId

	return nil
}

// Describes a forum topic
type ForumTopic struct {
	meta
	// Basic information about the topic
	Info *ForumTopicInfo `json:"info"`
	// Last message in the topic; may be null if unknown
	LastMessage *Message `json:"last_message"`
	// True, if the topic is pinned in the topic list
	IsPinned bool `json:"is_pinned"`
	// Number of unread messages in the topic
	UnreadCount int32 `json:"unread_count"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Number of unread messages with a mention/reply in the topic
	UnreadMentionCount int32 `json:"unread_mention_count"`
	// Number of messages with unread reactions in the topic
	UnreadReactionCount int32 `json:"unread_reaction_count"`
	// Notification settings for the topic
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
	// A draft of a message in the topic; may be null
	DraftMessage *DraftMessage `json:"draft_message"`
}

func (entity *ForumTopic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopic

	return json.Marshal((*stub)(entity))
}

func (*ForumTopic) GetClass() string {
	return ClassForumTopic
}

func (*ForumTopic) GetType() string {
	return TypeForumTopic
}

// Describes a list of forum topics
type ForumTopics struct {
	meta
	// Approximate total number of forum topics found
	TotalCount int32 `json:"total_count"`
	// List of forum topics
	Topics []*ForumTopic `json:"topics"`
	// Offset date for the next getForumTopics request
	NextOffsetDate int32 `json:"next_offset_date"`
	// Offset message identifier for the next getForumTopics request
	NextOffsetMessageId int64 `json:"next_offset_message_id"`
	// Offset message thread identifier for the next getForumTopics request
	NextOffsetMessageThreadId int64 `json:"next_offset_message_thread_id"`
}

func (entity *ForumTopics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopics

	return json.Marshal((*stub)(entity))
}

func (*ForumTopics) GetClass() string {
	return ClassForumTopics
}

func (*ForumTopics) GetType() string {
	return TypeForumTopics
}

// A plain text
type RichTextPlain struct {
	meta
	// Text
	Text string `json:"text"`
}

func (entity *RichTextPlain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextPlain

	return json.Marshal((*stub)(entity))
}

func (*RichTextPlain) GetClass() string {
	return ClassRichText
}

func (*RichTextPlain) GetType() string {
	return TypeRichTextPlain
}

func (*RichTextPlain) RichTextType() string {
	return TypeRichTextPlain
}

// A bold rich text
type RichTextBold struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextBold) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextBold

	return json.Marshal((*stub)(entity))
}

func (*RichTextBold) GetClass() string {
	return ClassRichText
}

func (*RichTextBold) GetType() string {
	return TypeRichTextBold
}

func (*RichTextBold) RichTextType() string {
	return TypeRichTextBold
}

func (richTextBold *RichTextBold) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextBold.Text = fieldText

	return nil
}

// An italicized rich text
type RichTextItalic struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextItalic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextItalic

	return json.Marshal((*stub)(entity))
}

func (*RichTextItalic) GetClass() string {
	return ClassRichText
}

func (*RichTextItalic) GetType() string {
	return TypeRichTextItalic
}

func (*RichTextItalic) RichTextType() string {
	return TypeRichTextItalic
}

func (richTextItalic *RichTextItalic) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextItalic.Text = fieldText

	return nil
}

// An underlined rich text
type RichTextUnderline struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextUnderline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextUnderline

	return json.Marshal((*stub)(entity))
}

func (*RichTextUnderline) GetClass() string {
	return ClassRichText
}

func (*RichTextUnderline) GetType() string {
	return TypeRichTextUnderline
}

func (*RichTextUnderline) RichTextType() string {
	return TypeRichTextUnderline
}

func (richTextUnderline *RichTextUnderline) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextUnderline.Text = fieldText

	return nil
}

// A strikethrough rich text
type RichTextStrikethrough struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextStrikethrough) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextStrikethrough

	return json.Marshal((*stub)(entity))
}

func (*RichTextStrikethrough) GetClass() string {
	return ClassRichText
}

func (*RichTextStrikethrough) GetType() string {
	return TypeRichTextStrikethrough
}

func (*RichTextStrikethrough) RichTextType() string {
	return TypeRichTextStrikethrough
}

func (richTextStrikethrough *RichTextStrikethrough) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextStrikethrough.Text = fieldText

	return nil
}

// A fixed-width rich text
type RichTextFixed struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextFixed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextFixed

	return json.Marshal((*stub)(entity))
}

func (*RichTextFixed) GetClass() string {
	return ClassRichText
}

func (*RichTextFixed) GetType() string {
	return TypeRichTextFixed
}

func (*RichTextFixed) RichTextType() string {
	return TypeRichTextFixed
}

func (richTextFixed *RichTextFixed) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextFixed.Text = fieldText

	return nil
}

// A rich text URL link
type RichTextUrl struct {
	meta
	// Text
	Text RichText `json:"text"`
	// URL
	Url string `json:"url"`
	// True, if the URL has cached instant view server-side
	IsCached bool `json:"is_cached"`
}

func (entity *RichTextUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextUrl

	return json.Marshal((*stub)(entity))
}

func (*RichTextUrl) GetClass() string {
	return ClassRichText
}

func (*RichTextUrl) GetType() string {
	return TypeRichTextUrl
}

func (*RichTextUrl) RichTextType() string {
	return TypeRichTextUrl
}

func (richTextUrl *RichTextUrl) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		Url      string          `json:"url"`
		IsCached bool            `json:"is_cached"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextUrl.Url = tmp.Url
	richTextUrl.IsCached = tmp.IsCached

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextUrl.Text = fieldText

	return nil
}

// A rich text email link
type RichTextEmailAddress struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Email address
	EmailAddress string `json:"email_address"`
}

func (entity *RichTextEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*RichTextEmailAddress) GetClass() string {
	return ClassRichText
}

func (*RichTextEmailAddress) GetType() string {
	return TypeRichTextEmailAddress
}

func (*RichTextEmailAddress) RichTextType() string {
	return TypeRichTextEmailAddress
}

func (richTextEmailAddress *RichTextEmailAddress) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text         json.RawMessage `json:"text"`
		EmailAddress string          `json:"email_address"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextEmailAddress.EmailAddress = tmp.EmailAddress

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextEmailAddress.Text = fieldText

	return nil
}

// A subscript rich text
type RichTextSubscript struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextSubscript) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextSubscript

	return json.Marshal((*stub)(entity))
}

func (*RichTextSubscript) GetClass() string {
	return ClassRichText
}

func (*RichTextSubscript) GetType() string {
	return TypeRichTextSubscript
}

func (*RichTextSubscript) RichTextType() string {
	return TypeRichTextSubscript
}

func (richTextSubscript *RichTextSubscript) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextSubscript.Text = fieldText

	return nil
}

// A superscript rich text
type RichTextSuperscript struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextSuperscript) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextSuperscript

	return json.Marshal((*stub)(entity))
}

func (*RichTextSuperscript) GetClass() string {
	return ClassRichText
}

func (*RichTextSuperscript) GetType() string {
	return TypeRichTextSuperscript
}

func (*RichTextSuperscript) RichTextType() string {
	return TypeRichTextSuperscript
}

func (richTextSuperscript *RichTextSuperscript) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextSuperscript.Text = fieldText

	return nil
}

// A marked rich text
type RichTextMarked struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextMarked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextMarked

	return json.Marshal((*stub)(entity))
}

func (*RichTextMarked) GetClass() string {
	return ClassRichText
}

func (*RichTextMarked) GetType() string {
	return TypeRichTextMarked
}

func (*RichTextMarked) RichTextType() string {
	return TypeRichTextMarked
}

func (richTextMarked *RichTextMarked) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextMarked.Text = fieldText

	return nil
}

// A rich text phone number
type RichTextPhoneNumber struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *RichTextPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*RichTextPhoneNumber) GetClass() string {
	return ClassRichText
}

func (*RichTextPhoneNumber) GetType() string {
	return TypeRichTextPhoneNumber
}

func (*RichTextPhoneNumber) RichTextType() string {
	return TypeRichTextPhoneNumber
}

func (richTextPhoneNumber *RichTextPhoneNumber) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text        json.RawMessage `json:"text"`
		PhoneNumber string          `json:"phone_number"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextPhoneNumber.PhoneNumber = tmp.PhoneNumber

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextPhoneNumber.Text = fieldText

	return nil
}

// A small image inside the text
type RichTextIcon struct {
	meta
	// The image represented as a document. The image can be in GIF, JPEG or PNG format
	Document *Document `json:"document"`
	// Width of a bounding box in which the image must be shown; 0 if unknown
	Width int32 `json:"width"`
	// Height of a bounding box in which the image must be shown; 0 if unknown
	Height int32 `json:"height"`
}

func (entity *RichTextIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextIcon

	return json.Marshal((*stub)(entity))
}

func (*RichTextIcon) GetClass() string {
	return ClassRichText
}

func (*RichTextIcon) GetType() string {
	return TypeRichTextIcon
}

func (*RichTextIcon) RichTextType() string {
	return TypeRichTextIcon
}

// A reference to a richTexts object on the same web page
type RichTextReference struct {
	meta
	// The text
	Text RichText `json:"text"`
	// The name of a richTextAnchor object, which is the first element of the target richTexts object
	AnchorName string `json:"anchor_name"`
	// An HTTP URL, opening the reference
	Url string `json:"url"`
}

func (entity *RichTextReference) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextReference

	return json.Marshal((*stub)(entity))
}

func (*RichTextReference) GetClass() string {
	return ClassRichText
}

func (*RichTextReference) GetType() string {
	return TypeRichTextReference
}

func (*RichTextReference) RichTextType() string {
	return TypeRichTextReference
}

func (richTextReference *RichTextReference) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text       json.RawMessage `json:"text"`
		AnchorName string          `json:"anchor_name"`
		Url        string          `json:"url"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextReference.AnchorName = tmp.AnchorName
	richTextReference.Url = tmp.Url

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextReference.Text = fieldText

	return nil
}

// An anchor
type RichTextAnchor struct {
	meta
	// Anchor name
	Name string `json:"name"`
}

func (entity *RichTextAnchor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextAnchor

	return json.Marshal((*stub)(entity))
}

func (*RichTextAnchor) GetClass() string {
	return ClassRichText
}

func (*RichTextAnchor) GetType() string {
	return TypeRichTextAnchor
}

func (*RichTextAnchor) RichTextType() string {
	return TypeRichTextAnchor
}

// A link to an anchor on the same web page
type RichTextAnchorLink struct {
	meta
	// The link text
	Text RichText `json:"text"`
	// The anchor name. If the name is empty, the link must bring back to top
	AnchorName string `json:"anchor_name"`
	// An HTTP URL, opening the anchor
	Url string `json:"url"`
}

func (entity *RichTextAnchorLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextAnchorLink

	return json.Marshal((*stub)(entity))
}

func (*RichTextAnchorLink) GetClass() string {
	return ClassRichText
}

func (*RichTextAnchorLink) GetType() string {
	return TypeRichTextAnchorLink
}

func (*RichTextAnchorLink) RichTextType() string {
	return TypeRichTextAnchorLink
}

func (richTextAnchorLink *RichTextAnchorLink) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text       json.RawMessage `json:"text"`
		AnchorName string          `json:"anchor_name"`
		Url        string          `json:"url"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextAnchorLink.AnchorName = tmp.AnchorName
	richTextAnchorLink.Url = tmp.Url

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextAnchorLink.Text = fieldText

	return nil
}

// A concatenation of rich texts
type RichTexts struct {
	meta
	// Texts
	Texts []RichText `json:"texts"`
}

func (entity *RichTexts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTexts

	return json.Marshal((*stub)(entity))
}

func (*RichTexts) GetClass() string {
	return ClassRichText
}

func (*RichTexts) GetType() string {
	return TypeRichTexts
}

func (*RichTexts) RichTextType() string {
	return TypeRichTexts
}

func (richTexts *RichTexts) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Texts []json.RawMessage `json:"texts"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTexts, _ := UnmarshalListOfRichText(tmp.Texts)
	richTexts.Texts = fieldTexts

	return nil
}

// Contains a caption of an instant view web page block, consisting of a text and a trailing credit
type PageBlockCaption struct {
	meta
	// Content of the caption
	Text RichText `json:"text"`
	// Block credit (like HTML tag <cite>)
	Credit RichText `json:"credit"`
}

func (entity *PageBlockCaption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCaption

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCaption) GetClass() string {
	return ClassPageBlockCaption
}

func (*PageBlockCaption) GetType() string {
	return TypePageBlockCaption
}

func (pageBlockCaption *PageBlockCaption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockCaption.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockCaption.Credit = fieldCredit

	return nil
}

// Describes an item of a list page block
type PageBlockListItem struct {
	meta
	// Item label
	Label string `json:"label"`
	// Item blocks
	PageBlocks []PageBlock `json:"page_blocks"`
}

func (entity *PageBlockListItem) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockListItem

	return json.Marshal((*stub)(entity))
}

func (*PageBlockListItem) GetClass() string {
	return ClassPageBlockListItem
}

func (*PageBlockListItem) GetType() string {
	return TypePageBlockListItem
}

func (pageBlockListItem *PageBlockListItem) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Label      string            `json:"label"`
		PageBlocks []json.RawMessage `json:"page_blocks"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockListItem.Label = tmp.Label

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockListItem.PageBlocks = fieldPageBlocks

	return nil
}

// The content must be left-aligned
type PageBlockHorizontalAlignmentLeft struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentLeft

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentLeft) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentLeft) GetType() string {
	return TypePageBlockHorizontalAlignmentLeft
}

func (*PageBlockHorizontalAlignmentLeft) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentLeft
}

// The content must be center-aligned
type PageBlockHorizontalAlignmentCenter struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentCenter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentCenter

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentCenter) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentCenter) GetType() string {
	return TypePageBlockHorizontalAlignmentCenter
}

func (*PageBlockHorizontalAlignmentCenter) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentCenter
}

// The content must be right-aligned
type PageBlockHorizontalAlignmentRight struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentRight) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentRight

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentRight) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentRight) GetType() string {
	return TypePageBlockHorizontalAlignmentRight
}

func (*PageBlockHorizontalAlignmentRight) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentRight
}

// The content must be top-aligned
type PageBlockVerticalAlignmentTop struct {
	meta
}

func (entity *PageBlockVerticalAlignmentTop) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentTop

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentTop) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentTop) GetType() string {
	return TypePageBlockVerticalAlignmentTop
}

func (*PageBlockVerticalAlignmentTop) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentTop
}

// The content must be middle-aligned
type PageBlockVerticalAlignmentMiddle struct {
	meta
}

func (entity *PageBlockVerticalAlignmentMiddle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentMiddle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentMiddle) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentMiddle) GetType() string {
	return TypePageBlockVerticalAlignmentMiddle
}

func (*PageBlockVerticalAlignmentMiddle) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentMiddle
}

// The content must be bottom-aligned
type PageBlockVerticalAlignmentBottom struct {
	meta
}

func (entity *PageBlockVerticalAlignmentBottom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentBottom

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentBottom) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentBottom) GetType() string {
	return TypePageBlockVerticalAlignmentBottom
}

func (*PageBlockVerticalAlignmentBottom) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentBottom
}

// Represents a cell of a table
type PageBlockTableCell struct {
	meta
	// Cell text; may be null. If the text is null, then the cell must be invisible
	Text RichText `json:"text"`
	// True, if it is a header cell
	IsHeader bool `json:"is_header"`
	// The number of columns the cell spans
	Colspan int32 `json:"colspan"`
	// The number of rows the cell spans
	Rowspan int32 `json:"rowspan"`
	// Horizontal cell content alignment
	Align PageBlockHorizontalAlignment `json:"align"`
	// Vertical cell content alignment
	Valign PageBlockVerticalAlignment `json:"valign"`
}

func (entity *PageBlockTableCell) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTableCell

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTableCell) GetClass() string {
	return ClassPageBlockTableCell
}

func (*PageBlockTableCell) GetType() string {
	return TypePageBlockTableCell
}

func (pageBlockTableCell *PageBlockTableCell) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		IsHeader bool            `json:"is_header"`
		Colspan  int32           `json:"colspan"`
		Rowspan  int32           `json:"rowspan"`
		Align    json.RawMessage `json:"align"`
		Valign   json.RawMessage `json:"valign"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockTableCell.IsHeader = tmp.IsHeader
	pageBlockTableCell.Colspan = tmp.Colspan
	pageBlockTableCell.Rowspan = tmp.Rowspan

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockTableCell.Text = fieldText

	fieldAlign, _ := UnmarshalPageBlockHorizontalAlignment(tmp.Align)
	pageBlockTableCell.Align = fieldAlign

	fieldValign, _ := UnmarshalPageBlockVerticalAlignment(tmp.Valign)
	pageBlockTableCell.Valign = fieldValign

	return nil
}

// Contains information about a related article
type PageBlockRelatedArticle struct {
	meta
	// Related article URL
	Url string `json:"url"`
	// Article title; may be empty
	Title string `json:"title"`
	// Article description; may be empty
	Description string `json:"description"`
	// Article photo; may be null
	Photo *Photo `json:"photo"`
	// Article author; may be empty
	Author string `json:"author"`
	// Point in time (Unix timestamp) when the article was published; 0 if unknown
	PublishDate int32 `json:"publish_date"`
}

func (entity *PageBlockRelatedArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockRelatedArticle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockRelatedArticle) GetClass() string {
	return ClassPageBlockRelatedArticle
}

func (*PageBlockRelatedArticle) GetType() string {
	return TypePageBlockRelatedArticle
}

// The title of a page
type PageBlockTitle struct {
	meta
	// Title
	Title RichText `json:"title"`
}

func (entity *PageBlockTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTitle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTitle) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockTitle) GetType() string {
	return TypePageBlockTitle
}

func (*PageBlockTitle) PageBlockType() string {
	return TypePageBlockTitle
}

func (pageBlockTitle *PageBlockTitle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Title json.RawMessage `json:"title"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTitle, _ := UnmarshalRichText(tmp.Title)
	pageBlockTitle.Title = fieldTitle

	return nil
}

// The subtitle of a page
type PageBlockSubtitle struct {
	meta
	// Subtitle
	Subtitle RichText `json:"subtitle"`
}

func (entity *PageBlockSubtitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSubtitle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSubtitle) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSubtitle) GetType() string {
	return TypePageBlockSubtitle
}

func (*PageBlockSubtitle) PageBlockType() string {
	return TypePageBlockSubtitle
}

func (pageBlockSubtitle *PageBlockSubtitle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Subtitle json.RawMessage `json:"subtitle"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldSubtitle, _ := UnmarshalRichText(tmp.Subtitle)
	pageBlockSubtitle.Subtitle = fieldSubtitle

	return nil
}

// The author and publishing date of a page
type PageBlockAuthorDate struct {
	meta
	// Author
	Author RichText `json:"author"`
	// Point in time (Unix timestamp) when the article was published; 0 if unknown
	PublishDate int32 `json:"publish_date"`
}

func (entity *PageBlockAuthorDate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAuthorDate

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAuthorDate) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAuthorDate) GetType() string {
	return TypePageBlockAuthorDate
}

func (*PageBlockAuthorDate) PageBlockType() string {
	return TypePageBlockAuthorDate
}

func (pageBlockAuthorDate *PageBlockAuthorDate) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Author      json.RawMessage `json:"author"`
		PublishDate int32           `json:"publish_date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockAuthorDate.PublishDate = tmp.PublishDate

	fieldAuthor, _ := UnmarshalRichText(tmp.Author)
	pageBlockAuthorDate.Author = fieldAuthor

	return nil
}

// A header
type PageBlockHeader struct {
	meta
	// Header
	Header RichText `json:"header"`
}

func (entity *PageBlockHeader) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHeader

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHeader) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockHeader) GetType() string {
	return TypePageBlockHeader
}

func (*PageBlockHeader) PageBlockType() string {
	return TypePageBlockHeader
}

func (pageBlockHeader *PageBlockHeader) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header json.RawMessage `json:"header"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockHeader.Header = fieldHeader

	return nil
}

// A subheader
type PageBlockSubheader struct {
	meta
	// Subheader
	Subheader RichText `json:"subheader"`
}

func (entity *PageBlockSubheader) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSubheader

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSubheader) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSubheader) GetType() string {
	return TypePageBlockSubheader
}

func (*PageBlockSubheader) PageBlockType() string {
	return TypePageBlockSubheader
}

func (pageBlockSubheader *PageBlockSubheader) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Subheader json.RawMessage `json:"subheader"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldSubheader, _ := UnmarshalRichText(tmp.Subheader)
	pageBlockSubheader.Subheader = fieldSubheader

	return nil
}

// A kicker
type PageBlockKicker struct {
	meta
	// Kicker
	Kicker RichText `json:"kicker"`
}

func (entity *PageBlockKicker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockKicker

	return json.Marshal((*stub)(entity))
}

func (*PageBlockKicker) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockKicker) GetType() string {
	return TypePageBlockKicker
}

func (*PageBlockKicker) PageBlockType() string {
	return TypePageBlockKicker
}

func (pageBlockKicker *PageBlockKicker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Kicker json.RawMessage `json:"kicker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldKicker, _ := UnmarshalRichText(tmp.Kicker)
	pageBlockKicker.Kicker = fieldKicker

	return nil
}

// A text paragraph
type PageBlockParagraph struct {
	meta
	// Paragraph text
	Text RichText `json:"text"`
}

func (entity *PageBlockParagraph) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockParagraph

	return json.Marshal((*stub)(entity))
}

func (*PageBlockParagraph) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockParagraph) GetType() string {
	return TypePageBlockParagraph
}

func (*PageBlockParagraph) PageBlockType() string {
	return TypePageBlockParagraph
}

func (pageBlockParagraph *PageBlockParagraph) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockParagraph.Text = fieldText

	return nil
}

// A preformatted text paragraph
type PageBlockPreformatted struct {
	meta
	// Paragraph text
	Text RichText `json:"text"`
	// Programming language for which the text needs to be formatted
	Language string `json:"language"`
}

func (entity *PageBlockPreformatted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPreformatted

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPreformatted) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPreformatted) GetType() string {
	return TypePageBlockPreformatted
}

func (*PageBlockPreformatted) PageBlockType() string {
	return TypePageBlockPreformatted
}

func (pageBlockPreformatted *PageBlockPreformatted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		Language string          `json:"language"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockPreformatted.Language = tmp.Language

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockPreformatted.Text = fieldText

	return nil
}

// The footer of a page
type PageBlockFooter struct {
	meta
	// Footer
	Footer RichText `json:"footer"`
}

func (entity *PageBlockFooter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockFooter

	return json.Marshal((*stub)(entity))
}

func (*PageBlockFooter) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockFooter) GetType() string {
	return TypePageBlockFooter
}

func (*PageBlockFooter) PageBlockType() string {
	return TypePageBlockFooter
}

func (pageBlockFooter *PageBlockFooter) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Footer json.RawMessage `json:"footer"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFooter, _ := UnmarshalRichText(tmp.Footer)
	pageBlockFooter.Footer = fieldFooter

	return nil
}

// An empty block separating a page
type PageBlockDivider struct {
	meta
}

func (entity *PageBlockDivider) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockDivider

	return json.Marshal((*stub)(entity))
}

func (*PageBlockDivider) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockDivider) GetType() string {
	return TypePageBlockDivider
}

func (*PageBlockDivider) PageBlockType() string {
	return TypePageBlockDivider
}

// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
type PageBlockAnchor struct {
	meta
	// Name of the anchor
	Name string `json:"name"`
}

func (entity *PageBlockAnchor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAnchor

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAnchor) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAnchor) GetType() string {
	return TypePageBlockAnchor
}

func (*PageBlockAnchor) PageBlockType() string {
	return TypePageBlockAnchor
}

// A list of data blocks
type PageBlockList struct {
	meta
	// The items of the list
	Items []*PageBlockListItem `json:"items"`
}

func (entity *PageBlockList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockList

	return json.Marshal((*stub)(entity))
}

func (*PageBlockList) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockList) GetType() string {
	return TypePageBlockList
}

func (*PageBlockList) PageBlockType() string {
	return TypePageBlockList
}

// A block quote
type PageBlockBlockQuote struct {
	meta
	// Quote text
	Text RichText `json:"text"`
	// Quote credit
	Credit RichText `json:"credit"`
}

func (entity *PageBlockBlockQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockBlockQuote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockBlockQuote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockBlockQuote) GetType() string {
	return TypePageBlockBlockQuote
}

func (*PageBlockBlockQuote) PageBlockType() string {
	return TypePageBlockBlockQuote
}

func (pageBlockBlockQuote *PageBlockBlockQuote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockBlockQuote.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockBlockQuote.Credit = fieldCredit

	return nil
}

// A pull quote
type PageBlockPullQuote struct {
	meta
	// Quote text
	Text RichText `json:"text"`
	// Quote credit
	Credit RichText `json:"credit"`
}

func (entity *PageBlockPullQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPullQuote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPullQuote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPullQuote) GetType() string {
	return TypePageBlockPullQuote
}

func (*PageBlockPullQuote) PageBlockType() string {
	return TypePageBlockPullQuote
}

func (pageBlockPullQuote *PageBlockPullQuote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockPullQuote.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockPullQuote.Credit = fieldCredit

	return nil
}

// An animation
type PageBlockAnimation struct {
	meta
	// Animation file; may be null
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the animation must be played automatically
	NeedAutoplay bool `json:"need_autoplay"`
}

func (entity *PageBlockAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAnimation

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAnimation) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAnimation) GetType() string {
	return TypePageBlockAnimation
}

func (*PageBlockAnimation) PageBlockType() string {
	return TypePageBlockAnimation
}

// An audio file
type PageBlockAudio struct {
	meta
	// Audio file; may be null
	Audio *Audio `json:"audio"`
	// Audio file caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAudio

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAudio) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAudio) GetType() string {
	return TypePageBlockAudio
}

func (*PageBlockAudio) PageBlockType() string {
	return TypePageBlockAudio
}

// A photo
type PageBlockPhoto struct {
	meta
	// Photo file; may be null
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *PageBlockCaption `json:"caption"`
	// URL that needs to be opened when the photo is clicked
	Url string `json:"url"`
}

func (entity *PageBlockPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPhoto

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPhoto) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPhoto) GetType() string {
	return TypePageBlockPhoto
}

func (*PageBlockPhoto) PageBlockType() string {
	return TypePageBlockPhoto
}

// A video
type PageBlockVideo struct {
	meta
	// Video file; may be null
	Video *Video `json:"video"`
	// Video caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the video must be played automatically
	NeedAutoplay bool `json:"need_autoplay"`
	// True, if the video must be looped
	IsLooped bool `json:"is_looped"`
}

func (entity *PageBlockVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVideo

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVideo) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockVideo) GetType() string {
	return TypePageBlockVideo
}

func (*PageBlockVideo) PageBlockType() string {
	return TypePageBlockVideo
}

// A voice note
type PageBlockVoiceNote struct {
	meta
	// Voice note; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// Voice note caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVoiceNote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockVoiceNote) GetType() string {
	return TypePageBlockVoiceNote
}

func (*PageBlockVoiceNote) PageBlockType() string {
	return TypePageBlockVoiceNote
}

// A page cover
type PageBlockCover struct {
	meta
	// Cover
	Cover PageBlock `json:"cover"`
}

func (entity *PageBlockCover) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCover

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCover) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockCover) GetType() string {
	return TypePageBlockCover
}

func (*PageBlockCover) PageBlockType() string {
	return TypePageBlockCover
}

func (pageBlockCover *PageBlockCover) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Cover json.RawMessage `json:"cover"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldCover, _ := UnmarshalPageBlock(tmp.Cover)
	pageBlockCover.Cover = fieldCover

	return nil
}

// An embedded web page
type PageBlockEmbedded struct {
	meta
	// Web page URL, if available
	Url string `json:"url"`
	// HTML-markup of the embedded page
	Html string `json:"html"`
	// Poster photo, if available; may be null
	PosterPhoto *Photo `json:"poster_photo"`
	// Block width; 0 if unknown
	Width int32 `json:"width"`
	// Block height; 0 if unknown
	Height int32 `json:"height"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the block must be full width
	IsFullWidth bool `json:"is_full_width"`
	// True, if scrolling needs to be allowed
	AllowScrolling bool `json:"allow_scrolling"`
}

func (entity *PageBlockEmbedded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockEmbedded

	return json.Marshal((*stub)(entity))
}

func (*PageBlockEmbedded) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockEmbedded) GetType() string {
	return TypePageBlockEmbedded
}

func (*PageBlockEmbedded) PageBlockType() string {
	return TypePageBlockEmbedded
}

// An embedded post
type PageBlockEmbeddedPost struct {
	meta
	// Web page URL
	Url string `json:"url"`
	// Post author
	Author string `json:"author"`
	// Post author photo; may be null
	AuthorPhoto *Photo `json:"author_photo"`
	// Point in time (Unix timestamp) when the post was created; 0 if unknown
	Date int32 `json:"date"`
	// Post content
	PageBlocks []PageBlock `json:"page_blocks"`
	// Post caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockEmbeddedPost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockEmbeddedPost

	return json.Marshal((*stub)(entity))
}

func (*PageBlockEmbeddedPost) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockEmbeddedPost) GetType() string {
	return TypePageBlockEmbeddedPost
}

func (*PageBlockEmbeddedPost) PageBlockType() string {
	return TypePageBlockEmbeddedPost
}

func (pageBlockEmbeddedPost *PageBlockEmbeddedPost) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url         string            `json:"url"`
		Author      string            `json:"author"`
		AuthorPhoto *Photo            `json:"author_photo"`
		Date        int32             `json:"date"`
		PageBlocks  []json.RawMessage `json:"page_blocks"`
		Caption     *PageBlockCaption `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockEmbeddedPost.Url = tmp.Url
	pageBlockEmbeddedPost.Author = tmp.Author
	pageBlockEmbeddedPost.AuthorPhoto = tmp.AuthorPhoto
	pageBlockEmbeddedPost.Date = tmp.Date
	pageBlockEmbeddedPost.Caption = tmp.Caption

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockEmbeddedPost.PageBlocks = fieldPageBlocks

	return nil
}

// A collage
type PageBlockCollage struct {
	meta
	// Collage item contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockCollage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCollage

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCollage) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockCollage) GetType() string {
	return TypePageBlockCollage
}

func (*PageBlockCollage) PageBlockType() string {
	return TypePageBlockCollage
}

func (pageBlockCollage *PageBlockCollage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PageBlocks []json.RawMessage `json:"page_blocks"`
		Caption    *PageBlockCaption `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockCollage.Caption = tmp.Caption

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockCollage.PageBlocks = fieldPageBlocks

	return nil
}

// A slideshow
type PageBlockSlideshow struct {
	meta
	// Slideshow item contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockSlideshow) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSlideshow

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSlideshow) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSlideshow) GetType() string {
	return TypePageBlockSlideshow
}

func (*PageBlockSlideshow) PageBlockType() string {
	return TypePageBlockSlideshow
}

func (pageBlockSlideshow *PageBlockSlideshow) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PageBlocks []json.RawMessage `json:"page_blocks"`
		Caption    *PageBlockCaption `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockSlideshow.Caption = tmp.Caption

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockSlideshow.PageBlocks = fieldPageBlocks

	return nil
}

// A link to a chat
type PageBlockChatLink struct {
	meta
	// Chat title
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
	// Chat username by which all other information about the chat can be resolved
	Username string `json:"username"`
}

func (entity *PageBlockChatLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockChatLink

	return json.Marshal((*stub)(entity))
}

func (*PageBlockChatLink) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockChatLink) GetType() string {
	return TypePageBlockChatLink
}

func (*PageBlockChatLink) PageBlockType() string {
	return TypePageBlockChatLink
}

// A table
type PageBlockTable struct {
	meta
	// Table caption
	Caption RichText `json:"caption"`
	// Table cells
	Cells [][]*PageBlockTableCell `json:"cells"`
	// True, if the table is bordered
	IsBordered bool `json:"is_bordered"`
	// True, if the table is striped
	IsStriped bool `json:"is_striped"`
}

func (entity *PageBlockTable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTable

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTable) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockTable) GetType() string {
	return TypePageBlockTable
}

func (*PageBlockTable) PageBlockType() string {
	return TypePageBlockTable
}

func (pageBlockTable *PageBlockTable) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Caption    json.RawMessage         `json:"caption"`
		Cells      [][]*PageBlockTableCell `json:"cells"`
		IsBordered bool                    `json:"is_bordered"`
		IsStriped  bool                    `json:"is_striped"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockTable.Cells = tmp.Cells
	pageBlockTable.IsBordered = tmp.IsBordered
	pageBlockTable.IsStriped = tmp.IsStriped

	fieldCaption, _ := UnmarshalRichText(tmp.Caption)
	pageBlockTable.Caption = fieldCaption

	return nil
}

// A collapsible block
type PageBlockDetails struct {
	meta
	// Always visible heading for the block
	Header RichText `json:"header"`
	// Block contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// True, if the block is open by default
	IsOpen bool `json:"is_open"`
}

func (entity *PageBlockDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockDetails

	return json.Marshal((*stub)(entity))
}

func (*PageBlockDetails) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockDetails) GetType() string {
	return TypePageBlockDetails
}

func (*PageBlockDetails) PageBlockType() string {
	return TypePageBlockDetails
}

func (pageBlockDetails *PageBlockDetails) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header     json.RawMessage   `json:"header"`
		PageBlocks []json.RawMessage `json:"page_blocks"`
		IsOpen     bool              `json:"is_open"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockDetails.IsOpen = tmp.IsOpen

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockDetails.Header = fieldHeader

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockDetails.PageBlocks = fieldPageBlocks

	return nil
}

// Related articles
type PageBlockRelatedArticles struct {
	meta
	// Block header
	Header RichText `json:"header"`
	// List of related articles
	Articles []*PageBlockRelatedArticle `json:"articles"`
}

func (entity *PageBlockRelatedArticles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockRelatedArticles

	return json.Marshal((*stub)(entity))
}

func (*PageBlockRelatedArticles) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockRelatedArticles) GetType() string {
	return TypePageBlockRelatedArticles
}

func (*PageBlockRelatedArticles) PageBlockType() string {
	return TypePageBlockRelatedArticles
}

func (pageBlockRelatedArticles *PageBlockRelatedArticles) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header   json.RawMessage            `json:"header"`
		Articles []*PageBlockRelatedArticle `json:"articles"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockRelatedArticles.Articles = tmp.Articles

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockRelatedArticles.Header = fieldHeader

	return nil
}

// A map
type PageBlockMap struct {
	meta
	// Location of the map center
	Location *Location `json:"location"`
	// Map zoom level
	Zoom int32 `json:"zoom"`
	// Map width
	Width int32 `json:"width"`
	// Map height
	Height int32 `json:"height"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockMap) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockMap

	return json.Marshal((*stub)(entity))
}

func (*PageBlockMap) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockMap) GetType() string {
	return TypePageBlockMap
}

func (*PageBlockMap) PageBlockType() string {
	return TypePageBlockMap
}

// Describes an instant view page for a web page
type WebPageInstantView struct {
	meta
	// Content of the web page
	PageBlocks []PageBlock `json:"page_blocks"`
	// Number of the instant view views; 0 if unknown
	ViewCount int32 `json:"view_count"`
	// Version of the instant view; currently, can be 1 or 2
	Version int32 `json:"version"`
	// True, if the instant view must be shown from right to left
	IsRtl bool `json:"is_rtl"`
	// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
	IsFull bool `json:"is_full"`
	// An internal link to be opened to leave feedback about the instant view
	FeedbackLink InternalLinkType `json:"feedback_link"`
}

func (entity *WebPageInstantView) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebPageInstantView

	return json.Marshal((*stub)(entity))
}

func (*WebPageInstantView) GetClass() string {
	return ClassWebPageInstantView
}

func (*WebPageInstantView) GetType() string {
	return TypeWebPageInstantView
}

func (webPageInstantView *WebPageInstantView) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PageBlocks   []json.RawMessage `json:"page_blocks"`
		ViewCount    int32             `json:"view_count"`
		Version      int32             `json:"version"`
		IsRtl        bool              `json:"is_rtl"`
		IsFull       bool              `json:"is_full"`
		FeedbackLink json.RawMessage   `json:"feedback_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	webPageInstantView.ViewCount = tmp.ViewCount
	webPageInstantView.Version = tmp.Version
	webPageInstantView.IsRtl = tmp.IsRtl
	webPageInstantView.IsFull = tmp.IsFull

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	webPageInstantView.PageBlocks = fieldPageBlocks

	fieldFeedbackLink, _ := UnmarshalInternalLinkType(tmp.FeedbackLink)
	webPageInstantView.FeedbackLink = fieldFeedbackLink

	return nil
}

// Describes a web page preview
type WebPage struct {
	meta
	// Original URL of the link
	Url string `json:"url"`
	// URL to display
	DisplayUrl string `json:"display_url"`
	// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
	Type string `json:"type"`
	// Short name of the site (e.g., Google Docs, App Store)
	SiteName string `json:"site_name"`
	// Title of the content
	Title string `json:"title"`
	// Description of the content
	Description *FormattedText `json:"description"`
	// Image representing the content; may be null
	Photo *Photo `json:"photo"`
	// URL to show in the embedded preview
	EmbedUrl string `json:"embed_url"`
	// MIME type of the embedded preview, (e.g., text/html or video/mp4)
	EmbedType string `json:"embed_type"`
	// Width of the embedded preview
	EmbedWidth int32 `json:"embed_width"`
	// Height of the embedded preview
	EmbedHeight int32 `json:"embed_height"`
	// Duration of the content, in seconds
	Duration int32 `json:"duration"`
	// Author of the content
	Author string `json:"author"`
	// Preview of the content as an animation, if available; may be null
	Animation *Animation `json:"animation"`
	// Preview of the content as an audio file, if available; may be null
	Audio *Audio `json:"audio"`
	// Preview of the content as a document, if available; may be null
	Document *Document `json:"document"`
	// Preview of the content as a sticker for small WEBP files, if available; may be null
	Sticker *Sticker `json:"sticker"`
	// Preview of the content as a video, if available; may be null
	Video *Video `json:"video"`
	// Preview of the content as a video note, if available; may be null
	VideoNote *VideoNote `json:"video_note"`
	// Preview of the content as a voice note, if available; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// Version of web page instant view (currently, can be 1 or 2); 0 if none
	InstantViewVersion int32 `json:"instant_view_version"`
}

func (entity *WebPage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebPage

	return json.Marshal((*stub)(entity))
}

func (*WebPage) GetClass() string {
	return ClassWebPage
}

func (*WebPage) GetType() string {
	return TypeWebPage
}

// Contains information about a country
type CountryInfo struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// Native name of the country
	Name string `json:"name"`
	// English name of the country
	EnglishName string `json:"english_name"`
	// True, if the country must be hidden from the list of all countries
	IsHidden bool `json:"is_hidden"`
	// List of country calling codes
	CallingCodes []string `json:"calling_codes"`
}

func (entity *CountryInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CountryInfo

	return json.Marshal((*stub)(entity))
}

func (*CountryInfo) GetClass() string {
	return ClassCountryInfo
}

func (*CountryInfo) GetType() string {
	return TypeCountryInfo
}

// Contains information about countries
type Countries struct {
	meta
	// The list of countries
	Countries []*CountryInfo `json:"countries"`
}

func (entity *Countries) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Countries

	return json.Marshal((*stub)(entity))
}

func (*Countries) GetClass() string {
	return ClassCountries
}

func (*Countries) GetType() string {
	return TypeCountries
}

// Contains information about a phone number
type PhoneNumberInfo struct {
	meta
	// Information about the country to which the phone number belongs; may be null
	Country *CountryInfo `json:"country"`
	// The part of the phone number denoting country calling code or its part
	CountryCallingCode string `json:"country_calling_code"`
	// The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
	FormattedPhoneNumber string `json:"formatted_phone_number"`
	// True, if the phone number was bought on Fragment and isn't tied to a SIM card
	IsAnonymous bool `json:"is_anonymous"`
}

func (entity *PhoneNumberInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberInfo

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberInfo) GetClass() string {
	return ClassPhoneNumberInfo
}

func (*PhoneNumberInfo) GetType() string {
	return TypePhoneNumberInfo
}

// Describes an action associated with a bank card number
type BankCardActionOpenUrl struct {
	meta
	// Action text
	Text string `json:"text"`
	// The URL to be opened
	Url string `json:"url"`
}

func (entity *BankCardActionOpenUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BankCardActionOpenUrl

	return json.Marshal((*stub)(entity))
}

func (*BankCardActionOpenUrl) GetClass() string {
	return ClassBankCardActionOpenUrl
}

func (*BankCardActionOpenUrl) GetType() string {
	return TypeBankCardActionOpenUrl
}

// Information about a bank card
type BankCardInfo struct {
	meta
	// Title of the bank card description
	Title string `json:"title"`
	// Actions that can be done with the bank card number
	Actions []*BankCardActionOpenUrl `json:"actions"`
}

func (entity *BankCardInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BankCardInfo

	return json.Marshal((*stub)(entity))
}

func (*BankCardInfo) GetClass() string {
	return ClassBankCardInfo
}

func (*BankCardInfo) GetType() string {
	return TypeBankCardInfo
}

// Describes an address
type Address struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// State, if applicable
	State string `json:"state"`
	// City
	City string `json:"city"`
	// First line of the address
	StreetLine1 string `json:"street_line1"`
	// Second line of the address
	StreetLine2 string `json:"street_line2"`
	// Address postal code
	PostalCode string `json:"postal_code"`
}

func (entity *Address) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Address

	return json.Marshal((*stub)(entity))
}

func (*Address) GetClass() string {
	return ClassAddress
}

func (*Address) GetType() string {
	return TypeAddress
}

// Contains parameters of the application theme
type ThemeParameters struct {
	meta
	// A color of the background in the RGB24 format
	BackgroundColor int32 `json:"background_color"`
	// A secondary color for the background in the RGB24 format
	SecondaryBackgroundColor int32 `json:"secondary_background_color"`
	// A color of text in the RGB24 format
	TextColor int32 `json:"text_color"`
	// A color of hints in the RGB24 format
	HintColor int32 `json:"hint_color"`
	// A color of links in the RGB24 format
	LinkColor int32 `json:"link_color"`
	// A color of the buttons in the RGB24 format
	ButtonColor int32 `json:"button_color"`
	// A color of text on the buttons in the RGB24 format
	ButtonTextColor int32 `json:"button_text_color"`
}

func (entity *ThemeParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThemeParameters

	return json.Marshal((*stub)(entity))
}

func (*ThemeParameters) GetClass() string {
	return ClassThemeParameters
}

func (*ThemeParameters) GetType() string {
	return TypeThemeParameters
}

// Portion of the price of a product (e.g., "delivery cost", "tax amount")
type LabeledPricePart struct {
	meta
	// Label for this portion of the product price
	Label string `json:"label"`
	// Currency amount in the smallest units of the currency
	Amount int64 `json:"amount"`
}

func (entity *LabeledPricePart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LabeledPricePart

	return json.Marshal((*stub)(entity))
}

func (*LabeledPricePart) GetClass() string {
	return ClassLabeledPricePart
}

func (*LabeledPricePart) GetType() string {
	return TypeLabeledPricePart
}

// Product invoice
type Invoice struct {
	meta
	// ISO 4217 currency code
	Currency string `json:"currency"`
	// A list of objects used to calculate the total price of the product
	PriceParts []*LabeledPricePart `json:"price_parts"`
	// The maximum allowed amount of tip in the smallest units of the currency
	MaxTipAmount int64 `json:"max_tip_amount"`
	// Suggested amounts of tip in the smallest units of the currency
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts"`
	// An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
	RecurringPaymentTermsOfServiceUrl string `json:"recurring_payment_terms_of_service_url"`
	// True, if the payment is a test payment
	IsTest bool `json:"is_test"`
	// True, if the user's name is needed for payment
	NeedName bool `json:"need_name"`
	// True, if the user's phone number is needed for payment
	NeedPhoneNumber bool `json:"need_phone_number"`
	// True, if the user's email address is needed for payment
	NeedEmailAddress bool `json:"need_email_address"`
	// True, if the user's shipping address is needed for payment
	NeedShippingAddress bool `json:"need_shipping_address"`
	// True, if the user's phone number will be sent to the provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider"`
	// True, if the user's email address will be sent to the provider
	SendEmailAddressToProvider bool `json:"send_email_address_to_provider"`
	// True, if the total price depends on the shipping method
	IsFlexible bool `json:"is_flexible"`
}

func (entity *Invoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Invoice

	return json.Marshal((*stub)(entity))
}

func (*Invoice) GetClass() string {
	return ClassInvoice
}

func (*Invoice) GetType() string {
	return TypeInvoice
}

// Order information
type OrderInfo struct {
	meta
	// Name of the user
	Name string `json:"name"`
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Email address of the user
	EmailAddress string `json:"email_address"`
	// Shipping address for this order; may be null
	ShippingAddress *Address `json:"shipping_address"`
}

func (entity *OrderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OrderInfo

	return json.Marshal((*stub)(entity))
}

func (*OrderInfo) GetClass() string {
	return ClassOrderInfo
}

func (*OrderInfo) GetType() string {
	return TypeOrderInfo
}

// One shipping option
type ShippingOption struct {
	meta
	// Shipping option identifier
	Id string `json:"id"`
	// Option title
	Title string `json:"title"`
	// A list of objects used to calculate the total shipping costs
	PriceParts []*LabeledPricePart `json:"price_parts"`
}

func (entity *ShippingOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ShippingOption

	return json.Marshal((*stub)(entity))
}

func (*ShippingOption) GetClass() string {
	return ClassShippingOption
}

func (*ShippingOption) GetType() string {
	return TypeShippingOption
}

// Contains information about saved payment credentials
type SavedCredentials struct {
	meta
	// Unique identifier of the saved credentials
	Id string `json:"id"`
	// Title of the saved credentials
	Title string `json:"title"`
}

func (entity *SavedCredentials) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedCredentials

	return json.Marshal((*stub)(entity))
}

func (*SavedCredentials) GetClass() string {
	return ClassSavedCredentials
}

func (*SavedCredentials) GetType() string {
	return TypeSavedCredentials
}

// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
type InputCredentialsSaved struct {
	meta
	// Identifier of the saved credentials
	SavedCredentialsId string `json:"saved_credentials_id"`
}

func (entity *InputCredentialsSaved) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsSaved

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsSaved) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsSaved) GetType() string {
	return TypeInputCredentialsSaved
}

func (*InputCredentialsSaved) InputCredentialsType() string {
	return TypeInputCredentialsSaved
}

// Applies if a user enters new credentials on a payment provider website
type InputCredentialsNew struct {
	meta
	// JSON-encoded data with the credential identifier from the payment provider
	Data string `json:"data"`
	// True, if the credential identifier can be saved on the server side
	AllowSave bool `json:"allow_save"`
}

func (entity *InputCredentialsNew) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsNew

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsNew) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsNew) GetType() string {
	return TypeInputCredentialsNew
}

func (*InputCredentialsNew) InputCredentialsType() string {
	return TypeInputCredentialsNew
}

// Applies if a user enters new credentials using Apple Pay
type InputCredentialsApplePay struct {
	meta
	// JSON-encoded data with the credential identifier
	Data string `json:"data"`
}

func (entity *InputCredentialsApplePay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsApplePay

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsApplePay) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsApplePay) GetType() string {
	return TypeInputCredentialsApplePay
}

func (*InputCredentialsApplePay) InputCredentialsType() string {
	return TypeInputCredentialsApplePay
}

// Applies if a user enters new credentials using Google Pay
type InputCredentialsGooglePay struct {
	meta
	// JSON-encoded data with the credential identifier
	Data string `json:"data"`
}

func (entity *InputCredentialsGooglePay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsGooglePay

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsGooglePay) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsGooglePay) GetType() string {
	return TypeInputCredentialsGooglePay
}

func (*InputCredentialsGooglePay) InputCredentialsType() string {
	return TypeInputCredentialsGooglePay
}

// Smart Glocal payment provider
type PaymentProviderSmartGlocal struct {
	meta
	// Public payment token
	PublicToken string `json:"public_token"`
}

func (entity *PaymentProviderSmartGlocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentProviderSmartGlocal

	return json.Marshal((*stub)(entity))
}

func (*PaymentProviderSmartGlocal) GetClass() string {
	return ClassPaymentProvider
}

func (*PaymentProviderSmartGlocal) GetType() string {
	return TypePaymentProviderSmartGlocal
}

func (*PaymentProviderSmartGlocal) PaymentProviderType() string {
	return TypePaymentProviderSmartGlocal
}

// Stripe payment provider
type PaymentProviderStripe struct {
	meta
	// Stripe API publishable key
	PublishableKey string `json:"publishable_key"`
	// True, if the user country must be provided
	NeedCountry bool `json:"need_country"`
	// True, if the user ZIP/postal code must be provided
	NeedPostalCode bool `json:"need_postal_code"`
	// True, if the cardholder name must be provided
	NeedCardholderName bool `json:"need_cardholder_name"`
}

func (entity *PaymentProviderStripe) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentProviderStripe

	return json.Marshal((*stub)(entity))
}

func (*PaymentProviderStripe) GetClass() string {
	return ClassPaymentProvider
}

func (*PaymentProviderStripe) GetType() string {
	return TypePaymentProviderStripe
}

func (*PaymentProviderStripe) PaymentProviderType() string {
	return TypePaymentProviderStripe
}

// Some other payment provider, for which a web payment form must be shown
type PaymentProviderOther struct {
	meta
	// Payment form URL
	Url string `json:"url"`
}

func (entity *PaymentProviderOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentProviderOther

	return json.Marshal((*stub)(entity))
}

func (*PaymentProviderOther) GetClass() string {
	return ClassPaymentProvider
}

func (*PaymentProviderOther) GetType() string {
	return TypePaymentProviderOther
}

func (*PaymentProviderOther) PaymentProviderType() string {
	return TypePaymentProviderOther
}

// Describes an additional payment option
type PaymentOption struct {
	meta
	// Title for the payment option
	Title string `json:"title"`
	// Payment form URL to be opened in a web view
	Url string `json:"url"`
}

func (entity *PaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PaymentOption) GetClass() string {
	return ClassPaymentOption
}

func (*PaymentOption) GetType() string {
	return TypePaymentOption
}

// Contains information about an invoice payment form
type PaymentForm struct {
	meta
	// The payment form identifier
	Id JsonInt64 `json:"id"`
	// Full information about the invoice
	Invoice *Invoice `json:"invoice"`
	// User identifier of the seller bot
	SellerBotUserId int64 `json:"seller_bot_user_id"`
	// User identifier of the payment provider bot
	PaymentProviderUserId int64 `json:"payment_provider_user_id"`
	// Information about the payment provider
	PaymentProvider PaymentProvider `json:"payment_provider"`
	// The list of additional payment options
	AdditionalPaymentOptions []*PaymentOption `json:"additional_payment_options"`
	// Saved server-side order information; may be null
	SavedOrderInfo *OrderInfo `json:"saved_order_info"`
	// The list of saved payment credentials
	SavedCredentials []*SavedCredentials `json:"saved_credentials"`
	// True, if the user can choose to save credentials
	CanSaveCredentials bool `json:"can_save_credentials"`
	// True, if the user will be able to save credentials, if sets up a 2-step verification password
	NeedPassword bool `json:"need_password"`
	// Product title
	ProductTitle string `json:"product_title"`
	// Product description
	ProductDescription *FormattedText `json:"product_description"`
	// Product photo; may be null
	ProductPhoto *Photo `json:"product_photo"`
}

func (entity *PaymentForm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentForm

	return json.Marshal((*stub)(entity))
}

func (*PaymentForm) GetClass() string {
	return ClassPaymentForm
}

func (*PaymentForm) GetType() string {
	return TypePaymentForm
}

func (paymentForm *PaymentForm) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                       JsonInt64           `json:"id"`
		Invoice                  *Invoice            `json:"invoice"`
		SellerBotUserId          int64               `json:"seller_bot_user_id"`
		PaymentProviderUserId    int64               `json:"payment_provider_user_id"`
		PaymentProvider          json.RawMessage     `json:"payment_provider"`
		AdditionalPaymentOptions []*PaymentOption    `json:"additional_payment_options"`
		SavedOrderInfo           *OrderInfo          `json:"saved_order_info"`
		SavedCredentials         []*SavedCredentials `json:"saved_credentials"`
		CanSaveCredentials       bool                `json:"can_save_credentials"`
		NeedPassword             bool                `json:"need_password"`
		ProductTitle             string              `json:"product_title"`
		ProductDescription       *FormattedText      `json:"product_description"`
		ProductPhoto             *Photo              `json:"product_photo"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	paymentForm.Id = tmp.Id
	paymentForm.Invoice = tmp.Invoice
	paymentForm.SellerBotUserId = tmp.SellerBotUserId
	paymentForm.PaymentProviderUserId = tmp.PaymentProviderUserId
	paymentForm.AdditionalPaymentOptions = tmp.AdditionalPaymentOptions
	paymentForm.SavedOrderInfo = tmp.SavedOrderInfo
	paymentForm.SavedCredentials = tmp.SavedCredentials
	paymentForm.CanSaveCredentials = tmp.CanSaveCredentials
	paymentForm.NeedPassword = tmp.NeedPassword
	paymentForm.ProductTitle = tmp.ProductTitle
	paymentForm.ProductDescription = tmp.ProductDescription
	paymentForm.ProductPhoto = tmp.ProductPhoto

	fieldPaymentProvider, _ := UnmarshalPaymentProvider(tmp.PaymentProvider)
	paymentForm.PaymentProvider = fieldPaymentProvider

	return nil
}

// Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options
type ValidatedOrderInfo struct {
	meta
	// Temporary identifier of the order information
	OrderInfoId string `json:"order_info_id"`
	// Available shipping options
	ShippingOptions []*ShippingOption `json:"shipping_options"`
}

func (entity *ValidatedOrderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ValidatedOrderInfo

	return json.Marshal((*stub)(entity))
}

func (*ValidatedOrderInfo) GetClass() string {
	return ClassValidatedOrderInfo
}

func (*ValidatedOrderInfo) GetType() string {
	return TypeValidatedOrderInfo
}

// Contains the result of a payment request
type PaymentResult struct {
	meta
	// True, if the payment request was successful; otherwise, the verification_url will be non-empty
	Success bool `json:"success"`
	// URL for additional payment credentials verification
	VerificationUrl string `json:"verification_url"`
}

func (entity *PaymentResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentResult

	return json.Marshal((*stub)(entity))
}

func (*PaymentResult) GetClass() string {
	return ClassPaymentResult
}

func (*PaymentResult) GetType() string {
	return TypePaymentResult
}

// Contains information about a successful payment
type PaymentReceipt struct {
	meta
	// Product title
	Title string `json:"title"`
	// Product description
	Description *FormattedText `json:"description"`
	// Product photo; may be null
	Photo *Photo `json:"photo"`
	// Point in time (Unix timestamp) when the payment was made
	Date int32 `json:"date"`
	// User identifier of the seller bot
	SellerBotUserId int64 `json:"seller_bot_user_id"`
	// User identifier of the payment provider bot
	PaymentProviderUserId int64 `json:"payment_provider_user_id"`
	// Information about the invoice
	Invoice *Invoice `json:"invoice"`
	// Order information; may be null
	OrderInfo *OrderInfo `json:"order_info"`
	// Chosen shipping option; may be null
	ShippingOption *ShippingOption `json:"shipping_option"`
	// Title of the saved credentials chosen by the buyer
	CredentialsTitle string `json:"credentials_title"`
	// The amount of tip chosen by the buyer in the smallest units of the currency
	TipAmount int64 `json:"tip_amount"`
}

func (entity *PaymentReceipt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentReceipt

	return json.Marshal((*stub)(entity))
}

func (*PaymentReceipt) GetClass() string {
	return ClassPaymentReceipt
}

func (*PaymentReceipt) GetType() string {
	return TypePaymentReceipt
}

// An invoice from a message of the type messageInvoice
type InputInvoiceMessage struct {
	meta
	// Chat identifier of the message
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *InputInvoiceMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInvoiceMessage

	return json.Marshal((*stub)(entity))
}

func (*InputInvoiceMessage) GetClass() string {
	return ClassInputInvoice
}

func (*InputInvoiceMessage) GetType() string {
	return TypeInputInvoiceMessage
}

func (*InputInvoiceMessage) InputInvoiceType() string {
	return TypeInputInvoiceMessage
}

// An invoice from a link of the type internalLinkTypeInvoice
type InputInvoiceName struct {
	meta
	// Name of the invoice
	Name string `json:"name"`
}

func (entity *InputInvoiceName) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInvoiceName

	return json.Marshal((*stub)(entity))
}

func (*InputInvoiceName) GetClass() string {
	return ClassInputInvoice
}

func (*InputInvoiceName) GetType() string {
	return TypeInputInvoiceName
}

func (*InputInvoiceName) InputInvoiceType() string {
	return TypeInputInvoiceName
}

// The media is hidden until the invoice is paid
type MessageExtendedMediaPreview struct {
	meta
	// Media width; 0 if unknown
	Width int32 `json:"width"`
	// Media height; 0 if unknown
	Height int32 `json:"height"`
	// Media duration; 0 if unknown
	Duration int32 `json:"duration"`
	// Media minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Media caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageExtendedMediaPreview) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExtendedMediaPreview

	return json.Marshal((*stub)(entity))
}

func (*MessageExtendedMediaPreview) GetClass() string {
	return ClassMessageExtendedMedia
}

func (*MessageExtendedMediaPreview) GetType() string {
	return TypeMessageExtendedMediaPreview
}

func (*MessageExtendedMediaPreview) MessageExtendedMediaType() string {
	return TypeMessageExtendedMediaPreview
}

// The media is a photo
type MessageExtendedMediaPhoto struct {
	meta
	// The photo
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageExtendedMediaPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExtendedMediaPhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageExtendedMediaPhoto) GetClass() string {
	return ClassMessageExtendedMedia
}

func (*MessageExtendedMediaPhoto) GetType() string {
	return TypeMessageExtendedMediaPhoto
}

func (*MessageExtendedMediaPhoto) MessageExtendedMediaType() string {
	return TypeMessageExtendedMediaPhoto
}

// The media is a video
type MessageExtendedMediaVideo struct {
	meta
	// The video
	Video *Video `json:"video"`
	// Photo caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageExtendedMediaVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExtendedMediaVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageExtendedMediaVideo) GetClass() string {
	return ClassMessageExtendedMedia
}

func (*MessageExtendedMediaVideo) GetType() string {
	return TypeMessageExtendedMediaVideo
}

func (*MessageExtendedMediaVideo) MessageExtendedMediaType() string {
	return TypeMessageExtendedMediaVideo
}

// The media is unsupported
type MessageExtendedMediaUnsupported struct {
	meta
	// Media caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageExtendedMediaUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExtendedMediaUnsupported

	return json.Marshal((*stub)(entity))
}

func (*MessageExtendedMediaUnsupported) GetClass() string {
	return ClassMessageExtendedMedia
}

func (*MessageExtendedMediaUnsupported) GetType() string {
	return TypeMessageExtendedMediaUnsupported
}

func (*MessageExtendedMediaUnsupported) MessageExtendedMediaType() string {
	return TypeMessageExtendedMediaUnsupported
}

// File with the date it was uploaded
type DatedFile struct {
	meta
	// The file
	File *File `json:"file"`
	// Point in time (Unix timestamp) when the file was uploaded
	Date int32 `json:"date"`
}

func (entity *DatedFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DatedFile

	return json.Marshal((*stub)(entity))
}

func (*DatedFile) GetClass() string {
	return ClassDatedFile
}

func (*DatedFile) GetType() string {
	return TypeDatedFile
}

// A Telegram Passport element containing the user's personal details
type PassportElementTypePersonalDetails struct {
	meta
}

func (entity *PassportElementTypePersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePersonalDetails) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePersonalDetails) GetType() string {
	return TypePassportElementTypePersonalDetails
}

func (*PassportElementTypePersonalDetails) PassportElementTypeType() string {
	return TypePassportElementTypePersonalDetails
}

// A Telegram Passport element containing the user's passport
type PassportElementTypePassport struct {
	meta
}

func (entity *PassportElementTypePassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePassport) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePassport) GetType() string {
	return TypePassportElementTypePassport
}

func (*PassportElementTypePassport) PassportElementTypeType() string {
	return TypePassportElementTypePassport
}

// A Telegram Passport element containing the user's driver license
type PassportElementTypeDriverLicense struct {
	meta
}

func (entity *PassportElementTypeDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeDriverLicense) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeDriverLicense) GetType() string {
	return TypePassportElementTypeDriverLicense
}

func (*PassportElementTypeDriverLicense) PassportElementTypeType() string {
	return TypePassportElementTypeDriverLicense
}

// A Telegram Passport element containing the user's identity card
type PassportElementTypeIdentityCard struct {
	meta
}

func (entity *PassportElementTypeIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeIdentityCard) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeIdentityCard) GetType() string {
	return TypePassportElementTypeIdentityCard
}

func (*PassportElementTypeIdentityCard) PassportElementTypeType() string {
	return TypePassportElementTypeIdentityCard
}

// A Telegram Passport element containing the user's internal passport
type PassportElementTypeInternalPassport struct {
	meta
}

func (entity *PassportElementTypeInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeInternalPassport) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeInternalPassport) GetType() string {
	return TypePassportElementTypeInternalPassport
}

func (*PassportElementTypeInternalPassport) PassportElementTypeType() string {
	return TypePassportElementTypeInternalPassport
}

// A Telegram Passport element containing the user's address
type PassportElementTypeAddress struct {
	meta
}

func (entity *PassportElementTypeAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeAddress) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeAddress) GetType() string {
	return TypePassportElementTypeAddress
}

func (*PassportElementTypeAddress) PassportElementTypeType() string {
	return TypePassportElementTypeAddress
}

// A Telegram Passport element containing the user's utility bill
type PassportElementTypeUtilityBill struct {
	meta
}

func (entity *PassportElementTypeUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeUtilityBill) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeUtilityBill) GetType() string {
	return TypePassportElementTypeUtilityBill
}

func (*PassportElementTypeUtilityBill) PassportElementTypeType() string {
	return TypePassportElementTypeUtilityBill
}

// A Telegram Passport element containing the user's bank statement
type PassportElementTypeBankStatement struct {
	meta
}

func (entity *PassportElementTypeBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeBankStatement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeBankStatement) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeBankStatement) GetType() string {
	return TypePassportElementTypeBankStatement
}

func (*PassportElementTypeBankStatement) PassportElementTypeType() string {
	return TypePassportElementTypeBankStatement
}

// A Telegram Passport element containing the user's rental agreement
type PassportElementTypeRentalAgreement struct {
	meta
}

func (entity *PassportElementTypeRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeRentalAgreement) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeRentalAgreement) GetType() string {
	return TypePassportElementTypeRentalAgreement
}

func (*PassportElementTypeRentalAgreement) PassportElementTypeType() string {
	return TypePassportElementTypeRentalAgreement
}

// A Telegram Passport element containing the registration page of the user's passport
type PassportElementTypePassportRegistration struct {
	meta
}

func (entity *PassportElementTypePassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePassportRegistration) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePassportRegistration) GetType() string {
	return TypePassportElementTypePassportRegistration
}

func (*PassportElementTypePassportRegistration) PassportElementTypeType() string {
	return TypePassportElementTypePassportRegistration
}

// A Telegram Passport element containing the user's temporary registration
type PassportElementTypeTemporaryRegistration struct {
	meta
}

func (entity *PassportElementTypeTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeTemporaryRegistration) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeTemporaryRegistration) GetType() string {
	return TypePassportElementTypeTemporaryRegistration
}

func (*PassportElementTypeTemporaryRegistration) PassportElementTypeType() string {
	return TypePassportElementTypeTemporaryRegistration
}

// A Telegram Passport element containing the user's phone number
type PassportElementTypePhoneNumber struct {
	meta
}

func (entity *PassportElementTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePhoneNumber) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePhoneNumber) GetType() string {
	return TypePassportElementTypePhoneNumber
}

func (*PassportElementTypePhoneNumber) PassportElementTypeType() string {
	return TypePassportElementTypePhoneNumber
}

// A Telegram Passport element containing the user's email address
type PassportElementTypeEmailAddress struct {
	meta
}

func (entity *PassportElementTypeEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeEmailAddress) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeEmailAddress) GetType() string {
	return TypePassportElementTypeEmailAddress
}

func (*PassportElementTypeEmailAddress) PassportElementTypeType() string {
	return TypePassportElementTypeEmailAddress
}

// Represents a date according to the Gregorian calendar
type Date struct {
	meta
	// Day of the month; 1-31
	Day int32 `json:"day"`
	// Month; 1-12
	Month int32 `json:"month"`
	// Year; 1-9999
	Year int32 `json:"year"`
}

func (entity *Date) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Date

	return json.Marshal((*stub)(entity))
}

func (*Date) GetClass() string {
	return ClassDate
}

func (*Date) GetType() string {
	return TypeDate
}

// Contains the user's personal details
type PersonalDetails struct {
	meta
	// First name of the user written in English; 1-255 characters
	FirstName string `json:"first_name"`
	// Middle name of the user written in English; 0-255 characters
	MiddleName string `json:"middle_name"`
	// Last name of the user written in English; 1-255 characters
	LastName string `json:"last_name"`
	// Native first name of the user; 1-255 characters
	NativeFirstName string `json:"native_first_name"`
	// Native middle name of the user; 0-255 characters
	NativeMiddleName string `json:"native_middle_name"`
	// Native last name of the user; 1-255 characters
	NativeLastName string `json:"native_last_name"`
	// Birthdate of the user
	Birthdate *Date `json:"birthdate"`
	// Gender of the user, "male" or "female"
	Gender string `json:"gender"`
	// A two-letter ISO 3166-1 alpha-2 country code of the user's country
	CountryCode string `json:"country_code"`
	// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
	ResidenceCountryCode string `json:"residence_country_code"`
}

func (entity *PersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PersonalDetails) GetClass() string {
	return ClassPersonalDetails
}

func (*PersonalDetails) GetType() string {
	return TypePersonalDetails
}

// An identity document
type IdentityDocument struct {
	meta
	// Document number; 1-24 characters
	Number string `json:"number"`
	// Document expiry date; may be null if not applicable
	ExpiryDate *Date `json:"expiry_date"`
	// Front side of the document
	FrontSide *DatedFile `json:"front_side"`
	// Reverse side of the document; only for driver license and identity card; may be null
	ReverseSide *DatedFile `json:"reverse_side"`
	// Selfie with the document; may be null
	Selfie *DatedFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
}

func (entity *IdentityDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub IdentityDocument

	return json.Marshal((*stub)(entity))
}

func (*IdentityDocument) GetClass() string {
	return ClassIdentityDocument
}

func (*IdentityDocument) GetType() string {
	return TypeIdentityDocument
}

// An identity document to be saved to Telegram Passport
type InputIdentityDocument struct {
	meta
	// Document number; 1-24 characters
	Number string `json:"number"`
	// Document expiry date; pass null if not applicable
	ExpiryDate *Date `json:"expiry_date"`
	// Front side of the document
	FrontSide InputFile `json:"front_side"`
	// Reverse side of the document; only for driver license and identity card; pass null otherwise
	ReverseSide InputFile `json:"reverse_side"`
	// Selfie with the document; pass null if unavailable
	Selfie InputFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []InputFile `json:"translation"`
}

func (entity *InputIdentityDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputIdentityDocument

	return json.Marshal((*stub)(entity))
}

func (*InputIdentityDocument) GetClass() string {
	return ClassInputIdentityDocument
}

func (*InputIdentityDocument) GetType() string {
	return TypeInputIdentityDocument
}

func (inputIdentityDocument *InputIdentityDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Number      string            `json:"number"`
		ExpiryDate  *Date             `json:"expiry_date"`
		FrontSide   json.RawMessage   `json:"front_side"`
		ReverseSide json.RawMessage   `json:"reverse_side"`
		Selfie      json.RawMessage   `json:"selfie"`
		Translation []json.RawMessage `json:"translation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputIdentityDocument.Number = tmp.Number
	inputIdentityDocument.ExpiryDate = tmp.ExpiryDate

	fieldFrontSide, _ := UnmarshalInputFile(tmp.FrontSide)
	inputIdentityDocument.FrontSide = fieldFrontSide

	fieldReverseSide, _ := UnmarshalInputFile(tmp.ReverseSide)
	inputIdentityDocument.ReverseSide = fieldReverseSide

	fieldSelfie, _ := UnmarshalInputFile(tmp.Selfie)
	inputIdentityDocument.Selfie = fieldSelfie

	fieldTranslation, _ := UnmarshalListOfInputFile(tmp.Translation)
	inputIdentityDocument.Translation = fieldTranslation

	return nil
}

// A personal document, containing some information about a user
type PersonalDocument struct {
	meta
	// List of files containing the pages of the document
	Files []*DatedFile `json:"files"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
}

func (entity *PersonalDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PersonalDocument

	return json.Marshal((*stub)(entity))
}

func (*PersonalDocument) GetClass() string {
	return ClassPersonalDocument
}

func (*PersonalDocument) GetType() string {
	return TypePersonalDocument
}

// A personal document to be saved to Telegram Passport
type InputPersonalDocument struct {
	meta
	// List of files containing the pages of the document
	Files []InputFile `json:"files"`
	// List of files containing a certified English translation of the document
	Translation []InputFile `json:"translation"`
}

func (entity *InputPersonalDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPersonalDocument

	return json.Marshal((*stub)(entity))
}

func (*InputPersonalDocument) GetClass() string {
	return ClassInputPersonalDocument
}

func (*InputPersonalDocument) GetType() string {
	return TypeInputPersonalDocument
}

func (inputPersonalDocument *InputPersonalDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Files       []json.RawMessage `json:"files"`
		Translation []json.RawMessage `json:"translation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFiles, _ := UnmarshalListOfInputFile(tmp.Files)
	inputPersonalDocument.Files = fieldFiles

	fieldTranslation, _ := UnmarshalListOfInputFile(tmp.Translation)
	inputPersonalDocument.Translation = fieldTranslation

	return nil
}

// A Telegram Passport element containing the user's personal details
type PassportElementPersonalDetails struct {
	meta
	// Personal details of the user
	PersonalDetails *PersonalDetails `json:"personal_details"`
}

func (entity *PassportElementPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPersonalDetails) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPersonalDetails) GetType() string {
	return TypePassportElementPersonalDetails
}

func (*PassportElementPersonalDetails) PassportElementType() string {
	return TypePassportElementPersonalDetails
}

// A Telegram Passport element containing the user's passport
type PassportElementPassport struct {
	meta
	// Passport
	Passport *IdentityDocument `json:"passport"`
}

func (entity *PassportElementPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPassport) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPassport) GetType() string {
	return TypePassportElementPassport
}

func (*PassportElementPassport) PassportElementType() string {
	return TypePassportElementPassport
}

// A Telegram Passport element containing the user's driver license
type PassportElementDriverLicense struct {
	meta
	// Driver license
	DriverLicense *IdentityDocument `json:"driver_license"`
}

func (entity *PassportElementDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*PassportElementDriverLicense) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementDriverLicense) GetType() string {
	return TypePassportElementDriverLicense
}

func (*PassportElementDriverLicense) PassportElementType() string {
	return TypePassportElementDriverLicense
}

// A Telegram Passport element containing the user's identity card
type PassportElementIdentityCard struct {
	meta
	// Identity card
	IdentityCard *IdentityDocument `json:"identity_card"`
}

func (entity *PassportElementIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*PassportElementIdentityCard) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementIdentityCard) GetType() string {
	return TypePassportElementIdentityCard
}

func (*PassportElementIdentityCard) PassportElementType() string {
	return TypePassportElementIdentityCard
}

// A Telegram Passport element containing the user's internal passport
type PassportElementInternalPassport struct {
	meta
	// Internal passport
	InternalPassport *IdentityDocument `json:"internal_passport"`
}

func (entity *PassportElementInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementInternalPassport) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementInternalPassport) GetType() string {
	return TypePassportElementInternalPassport
}

func (*PassportElementInternalPassport) PassportElementType() string {
	return TypePassportElementInternalPassport
}

// A Telegram Passport element containing the user's address
type PassportElementAddress struct {
	meta
	// Address
	Address *Address `json:"address"`
}

func (entity *PassportElementAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementAddress) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementAddress) GetType() string {
	return TypePassportElementAddress
}

func (*PassportElementAddress) PassportElementType() string {
	return TypePassportElementAddress
}

// A Telegram Passport element containing the user's utility bill
type PassportElementUtilityBill struct {
	meta
	// Utility bill
	UtilityBill *PersonalDocument `json:"utility_bill"`
}

func (entity *PassportElementUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*PassportElementUtilityBill) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementUtilityBill) GetType() string {
	return TypePassportElementUtilityBill
}

func (*PassportElementUtilityBill) PassportElementType() string {
	return TypePassportElementUtilityBill
}

// A Telegram Passport element containing the user's bank statement
type PassportElementBankStatement struct {
	meta
	// Bank statement
	BankStatement *PersonalDocument `json:"bank_statement"`
}

func (entity *PassportElementBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementBankStatement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementBankStatement) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementBankStatement) GetType() string {
	return TypePassportElementBankStatement
}

func (*PassportElementBankStatement) PassportElementType() string {
	return TypePassportElementBankStatement
}

// A Telegram Passport element containing the user's rental agreement
type PassportElementRentalAgreement struct {
	meta
	// Rental agreement
	RentalAgreement *PersonalDocument `json:"rental_agreement"`
}

func (entity *PassportElementRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementRentalAgreement) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementRentalAgreement) GetType() string {
	return TypePassportElementRentalAgreement
}

func (*PassportElementRentalAgreement) PassportElementType() string {
	return TypePassportElementRentalAgreement
}

// A Telegram Passport element containing the user's passport registration pages
type PassportElementPassportRegistration struct {
	meta
	// Passport registration pages
	PassportRegistration *PersonalDocument `json:"passport_registration"`
}

func (entity *PassportElementPassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPassportRegistration) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPassportRegistration) GetType() string {
	return TypePassportElementPassportRegistration
}

func (*PassportElementPassportRegistration) PassportElementType() string {
	return TypePassportElementPassportRegistration
}

// A Telegram Passport element containing the user's temporary registration
type PassportElementTemporaryRegistration struct {
	meta
	// Temporary registration
	TemporaryRegistration *PersonalDocument `json:"temporary_registration"`
}

func (entity *PassportElementTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTemporaryRegistration) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementTemporaryRegistration) GetType() string {
	return TypePassportElementTemporaryRegistration
}

func (*PassportElementTemporaryRegistration) PassportElementType() string {
	return TypePassportElementTemporaryRegistration
}

// A Telegram Passport element containing the user's phone number
type PassportElementPhoneNumber struct {
	meta
	// Phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *PassportElementPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPhoneNumber) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPhoneNumber) GetType() string {
	return TypePassportElementPhoneNumber
}

func (*PassportElementPhoneNumber) PassportElementType() string {
	return TypePassportElementPhoneNumber
}

// A Telegram Passport element containing the user's email address
type PassportElementEmailAddress struct {
	meta
	// Email address
	EmailAddress string `json:"email_address"`
}

func (entity *PassportElementEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementEmailAddress) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementEmailAddress) GetType() string {
	return TypePassportElementEmailAddress
}

func (*PassportElementEmailAddress) PassportElementType() string {
	return TypePassportElementEmailAddress
}

// A Telegram Passport element to be saved containing the user's personal details
type InputPassportElementPersonalDetails struct {
	meta
	// Personal details of the user
	PersonalDetails *PersonalDetails `json:"personal_details"`
}

func (entity *InputPassportElementPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPersonalDetails) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPersonalDetails) GetType() string {
	return TypeInputPassportElementPersonalDetails
}

func (*InputPassportElementPersonalDetails) InputPassportElementType() string {
	return TypeInputPassportElementPersonalDetails
}

// A Telegram Passport element to be saved containing the user's passport
type InputPassportElementPassport struct {
	meta
	// The passport to be saved
	Passport *InputIdentityDocument `json:"passport"`
}

func (entity *InputPassportElementPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPassport

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPassport) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPassport) GetType() string {
	return TypeInputPassportElementPassport
}

func (*InputPassportElementPassport) InputPassportElementType() string {
	return TypeInputPassportElementPassport
}

// A Telegram Passport element to be saved containing the user's driver license
type InputPassportElementDriverLicense struct {
	meta
	// The driver license to be saved
	DriverLicense *InputIdentityDocument `json:"driver_license"`
}

func (entity *InputPassportElementDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementDriverLicense) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementDriverLicense) GetType() string {
	return TypeInputPassportElementDriverLicense
}

func (*InputPassportElementDriverLicense) InputPassportElementType() string {
	return TypeInputPassportElementDriverLicense
}

// A Telegram Passport element to be saved containing the user's identity card
type InputPassportElementIdentityCard struct {
	meta
	// The identity card to be saved
	IdentityCard *InputIdentityDocument `json:"identity_card"`
}

func (entity *InputPassportElementIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementIdentityCard) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementIdentityCard) GetType() string {
	return TypeInputPassportElementIdentityCard
}

func (*InputPassportElementIdentityCard) InputPassportElementType() string {
	return TypeInputPassportElementIdentityCard
}

// A Telegram Passport element to be saved containing the user's internal passport
type InputPassportElementInternalPassport struct {
	meta
	// The internal passport to be saved
	InternalPassport *InputIdentityDocument `json:"internal_passport"`
}

func (entity *InputPassportElementInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementInternalPassport) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementInternalPassport) GetType() string {
	return TypeInputPassportElementInternalPassport
}

func (*InputPassportElementInternalPassport) InputPassportElementType() string {
	return TypeInputPassportElementInternalPassport
}

// A Telegram Passport element to be saved containing the user's address
type InputPassportElementAddress struct {
	meta
	// The address to be saved
	Address *Address `json:"address"`
}

func (entity *InputPassportElementAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementAddress

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementAddress) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementAddress) GetType() string {
	return TypeInputPassportElementAddress
}

func (*InputPassportElementAddress) InputPassportElementType() string {
	return TypeInputPassportElementAddress
}

// A Telegram Passport element to be saved containing the user's utility bill
type InputPassportElementUtilityBill struct {
	meta
	// The utility bill to be saved
	UtilityBill *InputPersonalDocument `json:"utility_bill"`
}

func (entity *InputPassportElementUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementUtilityBill) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementUtilityBill) GetType() string {
	return TypeInputPassportElementUtilityBill
}

func (*InputPassportElementUtilityBill) InputPassportElementType() string {
	return TypeInputPassportElementUtilityBill
}

// A Telegram Passport element to be saved containing the user's bank statement
type InputPassportElementBankStatement struct {
	meta
	// The bank statement to be saved
	BankStatement *InputPersonalDocument `json:"bank_statement"`
}

func (entity *InputPassportElementBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementBankStatement

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementBankStatement) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementBankStatement) GetType() string {
	return TypeInputPassportElementBankStatement
}

func (*InputPassportElementBankStatement) InputPassportElementType() string {
	return TypeInputPassportElementBankStatement
}

// A Telegram Passport element to be saved containing the user's rental agreement
type InputPassportElementRentalAgreement struct {
	meta
	// The rental agreement to be saved
	RentalAgreement *InputPersonalDocument `json:"rental_agreement"`
}

func (entity *InputPassportElementRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementRentalAgreement) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementRentalAgreement) GetType() string {
	return TypeInputPassportElementRentalAgreement
}

func (*InputPassportElementRentalAgreement) InputPassportElementType() string {
	return TypeInputPassportElementRentalAgreement
}

// A Telegram Passport element to be saved containing the user's passport registration
type InputPassportElementPassportRegistration struct {
	meta
	// The passport registration page to be saved
	PassportRegistration *InputPersonalDocument `json:"passport_registration"`
}

func (entity *InputPassportElementPassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPassportRegistration) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPassportRegistration) GetType() string {
	return TypeInputPassportElementPassportRegistration
}

func (*InputPassportElementPassportRegistration) InputPassportElementType() string {
	return TypeInputPassportElementPassportRegistration
}

// A Telegram Passport element to be saved containing the user's temporary registration
type InputPassportElementTemporaryRegistration struct {
	meta
	// The temporary registration document to be saved
	TemporaryRegistration *InputPersonalDocument `json:"temporary_registration"`
}

func (entity *InputPassportElementTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementTemporaryRegistration) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementTemporaryRegistration) GetType() string {
	return TypeInputPassportElementTemporaryRegistration
}

func (*InputPassportElementTemporaryRegistration) InputPassportElementType() string {
	return TypeInputPassportElementTemporaryRegistration
}

// A Telegram Passport element to be saved containing the user's phone number
type InputPassportElementPhoneNumber struct {
	meta
	// The phone number to be saved
	PhoneNumber string `json:"phone_number"`
}

func (entity *InputPassportElementPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPhoneNumber) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPhoneNumber) GetType() string {
	return TypeInputPassportElementPhoneNumber
}

func (*InputPassportElementPhoneNumber) InputPassportElementType() string {
	return TypeInputPassportElementPhoneNumber
}

// A Telegram Passport element to be saved containing the user's email address
type InputPassportElementEmailAddress struct {
	meta
	// The email address to be saved
	EmailAddress string `json:"email_address"`
}

func (entity *InputPassportElementEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementEmailAddress) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementEmailAddress) GetType() string {
	return TypeInputPassportElementEmailAddress
}

func (*InputPassportElementEmailAddress) InputPassportElementType() string {
	return TypeInputPassportElementEmailAddress
}

// Contains information about saved Telegram Passport elements
type PassportElements struct {
	meta
	// Telegram Passport elements
	Elements []PassportElement `json:"elements"`
}

func (entity *PassportElements) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElements

	return json.Marshal((*stub)(entity))
}

func (*PassportElements) GetClass() string {
	return ClassPassportElements
}

func (*PassportElements) GetType() string {
	return TypePassportElements
}

func (passportElements *PassportElements) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Elements []json.RawMessage `json:"elements"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldElements, _ := UnmarshalListOfPassportElement(tmp.Elements)
	passportElements.Elements = fieldElements

	return nil
}

// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type PassportElementErrorSourceUnspecified struct {
	meta
}

func (entity *PassportElementErrorSourceUnspecified) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceUnspecified

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceUnspecified) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceUnspecified) GetType() string {
	return TypePassportElementErrorSourceUnspecified
}

func (*PassportElementErrorSourceUnspecified) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceUnspecified
}

// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
type PassportElementErrorSourceDataField struct {
	meta
	// Field name
	FieldName string `json:"field_name"`
}

func (entity *PassportElementErrorSourceDataField) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceDataField

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceDataField) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceDataField) GetType() string {
	return TypePassportElementErrorSourceDataField
}

func (*PassportElementErrorSourceDataField) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceDataField
}

// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
type PassportElementErrorSourceFrontSide struct {
	meta
}

func (entity *PassportElementErrorSourceFrontSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFrontSide

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFrontSide) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFrontSide) GetType() string {
	return TypePassportElementErrorSourceFrontSide
}

func (*PassportElementErrorSourceFrontSide) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFrontSide
}

// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
type PassportElementErrorSourceReverseSide struct {
	meta
}

func (entity *PassportElementErrorSourceReverseSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceReverseSide

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceReverseSide) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceReverseSide) GetType() string {
	return TypePassportElementErrorSourceReverseSide
}

func (*PassportElementErrorSourceReverseSide) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceReverseSide
}

// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
type PassportElementErrorSourceSelfie struct {
	meta
}

func (entity *PassportElementErrorSourceSelfie) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceSelfie

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceSelfie) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceSelfie) GetType() string {
	return TypePassportElementErrorSourceSelfie
}

func (*PassportElementErrorSourceSelfie) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceSelfie
}

// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceTranslationFile struct {
	meta
	// Index of a file with the error
	FileIndex int32 `json:"file_index"`
}

func (entity *PassportElementErrorSourceTranslationFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceTranslationFile

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceTranslationFile) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceTranslationFile) GetType() string {
	return TypePassportElementErrorSourceTranslationFile
}

func (*PassportElementErrorSourceTranslationFile) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceTranslationFile
}

// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
type PassportElementErrorSourceTranslationFiles struct {
	meta
}

func (entity *PassportElementErrorSourceTranslationFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceTranslationFiles

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceTranslationFiles) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceTranslationFiles) GetType() string {
	return TypePassportElementErrorSourceTranslationFiles
}

func (*PassportElementErrorSourceTranslationFiles) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceTranslationFiles
}

// The file contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceFile struct {
	meta
	// Index of a file with the error
	FileIndex int32 `json:"file_index"`
}

func (entity *PassportElementErrorSourceFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFile

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFile) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFile) GetType() string {
	return TypePassportElementErrorSourceFile
}

func (*PassportElementErrorSourceFile) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFile
}

// The list of attached files contains an error. The error will be considered resolved when the list of files changes
type PassportElementErrorSourceFiles struct {
	meta
}

func (entity *PassportElementErrorSourceFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFiles

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFiles) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFiles) GetType() string {
	return TypePassportElementErrorSourceFiles
}

func (*PassportElementErrorSourceFiles) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFiles
}

// Contains the description of an error in a Telegram Passport element
type PassportElementError struct {
	meta
	// Type of the Telegram Passport element which has the error
	Type PassportElementType `json:"type"`
	// Error message
	Message string `json:"message"`
	// Error source
	Source PassportElementErrorSource `json:"source"`
}

func (entity *PassportElementError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementError

	return json.Marshal((*stub)(entity))
}

func (*PassportElementError) GetClass() string {
	return ClassPassportElementError
}

func (*PassportElementError) GetType() string {
	return TypePassportElementError
}

func (passportElementError *PassportElementError) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    json.RawMessage `json:"type"`
		Message string          `json:"message"`
		Source  json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportElementError.Message = tmp.Message

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	passportElementError.Type = fieldType

	fieldSource, _ := UnmarshalPassportElementErrorSource(tmp.Source)
	passportElementError.Source = fieldSource

	return nil
}

// Contains information about a Telegram Passport element that was requested by a service
type PassportSuitableElement struct {
	meta
	// Type of the element
	Type PassportElementType `json:"type"`
	// True, if a selfie is required with the identity document
	IsSelfieRequired bool `json:"is_selfie_required"`
	// True, if a certified English translation is required with the document
	IsTranslationRequired bool `json:"is_translation_required"`
	// True, if personal details must include the user's name in the language of their country of residence
	IsNativeNameRequired bool `json:"is_native_name_required"`
}

func (entity *PassportSuitableElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportSuitableElement

	return json.Marshal((*stub)(entity))
}

func (*PassportSuitableElement) GetClass() string {
	return ClassPassportSuitableElement
}

func (*PassportSuitableElement) GetType() string {
	return TypePassportSuitableElement
}

func (passportSuitableElement *PassportSuitableElement) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type                  json.RawMessage `json:"type"`
		IsSelfieRequired      bool            `json:"is_selfie_required"`
		IsTranslationRequired bool            `json:"is_translation_required"`
		IsNativeNameRequired  bool            `json:"is_native_name_required"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportSuitableElement.IsSelfieRequired = tmp.IsSelfieRequired
	passportSuitableElement.IsTranslationRequired = tmp.IsTranslationRequired
	passportSuitableElement.IsNativeNameRequired = tmp.IsNativeNameRequired

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	passportSuitableElement.Type = fieldType

	return nil
}

// Contains a description of the required Telegram Passport element that was requested by a service
type PassportRequiredElement struct {
	meta
	// List of Telegram Passport elements any of which is enough to provide
	SuitableElements []*PassportSuitableElement `json:"suitable_elements"`
}

func (entity *PassportRequiredElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportRequiredElement

	return json.Marshal((*stub)(entity))
}

func (*PassportRequiredElement) GetClass() string {
	return ClassPassportRequiredElement
}

func (*PassportRequiredElement) GetType() string {
	return TypePassportRequiredElement
}

// Contains information about a Telegram Passport authorization form that was requested
type PassportAuthorizationForm struct {
	meta
	// Unique identifier of the authorization form
	Id int32 `json:"id"`
	// Telegram Passport elements that must be provided to complete the form
	RequiredElements []*PassportRequiredElement `json:"required_elements"`
	// URL for the privacy policy of the service; may be empty
	PrivacyPolicyUrl string `json:"privacy_policy_url"`
}

func (entity *PassportAuthorizationForm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportAuthorizationForm

	return json.Marshal((*stub)(entity))
}

func (*PassportAuthorizationForm) GetClass() string {
	return ClassPassportAuthorizationForm
}

func (*PassportAuthorizationForm) GetType() string {
	return TypePassportAuthorizationForm
}

// Contains information about a Telegram Passport elements and corresponding errors
type PassportElementsWithErrors struct {
	meta
	// Telegram Passport elements
	Elements []PassportElement `json:"elements"`
	// Errors in the elements that are already available
	Errors []*PassportElementError `json:"errors"`
}

func (entity *PassportElementsWithErrors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementsWithErrors

	return json.Marshal((*stub)(entity))
}

func (*PassportElementsWithErrors) GetClass() string {
	return ClassPassportElementsWithErrors
}

func (*PassportElementsWithErrors) GetType() string {
	return TypePassportElementsWithErrors
}

func (passportElementsWithErrors *PassportElementsWithErrors) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Elements []json.RawMessage       `json:"elements"`
		Errors   []*PassportElementError `json:"errors"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportElementsWithErrors.Errors = tmp.Errors

	fieldElements, _ := UnmarshalListOfPassportElement(tmp.Elements)
	passportElementsWithErrors.Elements = fieldElements

	return nil
}

// Contains encrypted Telegram Passport data credentials
type EncryptedCredentials struct {
	meta
	// The encrypted credentials
	Data []byte `json:"data"`
	// The decrypted data hash
	Hash []byte `json:"hash"`
	// Secret for data decryption, encrypted with the service's public key
	Secret []byte `json:"secret"`
}

func (entity *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EncryptedCredentials

	return json.Marshal((*stub)(entity))
}

func (*EncryptedCredentials) GetClass() string {
	return ClassEncryptedCredentials
}

func (*EncryptedCredentials) GetType() string {
	return TypeEncryptedCredentials
}

// Contains information about an encrypted Telegram Passport element; for bots only
type EncryptedPassportElement struct {
	meta
	// Type of Telegram Passport element
	Type PassportElementType `json:"type"`
	// Encrypted JSON-encoded data about the user
	Data []byte `json:"data"`
	// The front side of an identity document
	FrontSide *DatedFile `json:"front_side"`
	// The reverse side of an identity document; may be null
	ReverseSide *DatedFile `json:"reverse_side"`
	// Selfie with the document; may be null
	Selfie *DatedFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
	// List of attached files
	Files []*DatedFile `json:"files"`
	// Unencrypted data, phone number or email address
	Value string `json:"value"`
	// Hash of the entire element
	Hash string `json:"hash"`
}

func (entity *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EncryptedPassportElement

	return json.Marshal((*stub)(entity))
}

func (*EncryptedPassportElement) GetClass() string {
	return ClassEncryptedPassportElement
}

func (*EncryptedPassportElement) GetType() string {
	return TypeEncryptedPassportElement
}

func (encryptedPassportElement *EncryptedPassportElement) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type        json.RawMessage `json:"type"`
		Data        []byte          `json:"data"`
		FrontSide   *DatedFile      `json:"front_side"`
		ReverseSide *DatedFile      `json:"reverse_side"`
		Selfie      *DatedFile      `json:"selfie"`
		Translation []*DatedFile    `json:"translation"`
		Files       []*DatedFile    `json:"files"`
		Value       string          `json:"value"`
		Hash        string          `json:"hash"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	encryptedPassportElement.Data = tmp.Data
	encryptedPassportElement.FrontSide = tmp.FrontSide
	encryptedPassportElement.ReverseSide = tmp.ReverseSide
	encryptedPassportElement.Selfie = tmp.Selfie
	encryptedPassportElement.Translation = tmp.Translation
	encryptedPassportElement.Files = tmp.Files
	encryptedPassportElement.Value = tmp.Value
	encryptedPassportElement.Hash = tmp.Hash

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	encryptedPassportElement.Type = fieldType

	return nil
}

// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type InputPassportElementErrorSourceUnspecified struct {
	meta
	// Current hash of the entire element
	ElementHash []byte `json:"element_hash"`
}

func (entity *InputPassportElementErrorSourceUnspecified) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceUnspecified

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceUnspecified) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceUnspecified) GetType() string {
	return TypeInputPassportElementErrorSourceUnspecified
}

func (*InputPassportElementErrorSourceUnspecified) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceUnspecified
}

// A data field contains an error. The error is considered resolved when the field's value changes
type InputPassportElementErrorSourceDataField struct {
	meta
	// Field name
	FieldName string `json:"field_name"`
	// Current data hash
	DataHash []byte `json:"data_hash"`
}

func (entity *InputPassportElementErrorSourceDataField) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceDataField

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceDataField) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceDataField) GetType() string {
	return TypeInputPassportElementErrorSourceDataField
}

func (*InputPassportElementErrorSourceDataField) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceDataField
}

// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
type InputPassportElementErrorSourceFrontSide struct {
	meta
	// Current hash of the file containing the front side
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceFrontSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFrontSide

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFrontSide) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFrontSide) GetType() string {
	return TypeInputPassportElementErrorSourceFrontSide
}

func (*InputPassportElementErrorSourceFrontSide) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFrontSide
}

// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
type InputPassportElementErrorSourceReverseSide struct {
	meta
	// Current hash of the file containing the reverse side
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceReverseSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceReverseSide

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceReverseSide) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceReverseSide) GetType() string {
	return TypeInputPassportElementErrorSourceReverseSide
}

func (*InputPassportElementErrorSourceReverseSide) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceReverseSide
}

// The selfie contains an error. The error is considered resolved when the file with the selfie changes
type InputPassportElementErrorSourceSelfie struct {
	meta
	// Current hash of the file containing the selfie
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceSelfie) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceSelfie

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceSelfie) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceSelfie) GetType() string {
	return TypeInputPassportElementErrorSourceSelfie
}

func (*InputPassportElementErrorSourceSelfie) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceSelfie
}

// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
type InputPassportElementErrorSourceTranslationFile struct {
	meta
	// Current hash of the file containing the translation
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceTranslationFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceTranslationFile

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceTranslationFile) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceTranslationFile) GetType() string {
	return TypeInputPassportElementErrorSourceTranslationFile
}

func (*InputPassportElementErrorSourceTranslationFile) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceTranslationFile
}

// The translation of the document contains an error. The error is considered resolved when the list of files changes
type InputPassportElementErrorSourceTranslationFiles struct {
	meta
	// Current hashes of all files with the translation
	FileHashes [][]byte `json:"file_hashes"`
}

func (entity *InputPassportElementErrorSourceTranslationFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceTranslationFiles

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceTranslationFiles) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceTranslationFiles) GetType() string {
	return TypeInputPassportElementErrorSourceTranslationFiles
}

func (*InputPassportElementErrorSourceTranslationFiles) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceTranslationFiles
}

// The file contains an error. The error is considered resolved when the file changes
type InputPassportElementErrorSourceFile struct {
	meta
	// Current hash of the file which has the error
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFile

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFile) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFile) GetType() string {
	return TypeInputPassportElementErrorSourceFile
}

func (*InputPassportElementErrorSourceFile) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFile
}

// The list of attached files contains an error. The error is considered resolved when the file list changes
type InputPassportElementErrorSourceFiles struct {
	meta
	// Current hashes of all attached files
	FileHashes [][]byte `json:"file_hashes"`
}

func (entity *InputPassportElementErrorSourceFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFiles

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFiles) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFiles) GetType() string {
	return TypeInputPassportElementErrorSourceFiles
}

func (*InputPassportElementErrorSourceFiles) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFiles
}

// Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementError struct {
	meta
	// Type of Telegram Passport element that has the error
	Type PassportElementType `json:"type"`
	// Error message
	Message string `json:"message"`
	// Error source
	Source InputPassportElementErrorSource `json:"source"`
}

func (entity *InputPassportElementError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementError

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementError) GetClass() string {
	return ClassInputPassportElementError
}

func (*InputPassportElementError) GetType() string {
	return TypeInputPassportElementError
}

func (inputPassportElementError *InputPassportElementError) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    json.RawMessage `json:"type"`
		Message string          `json:"message"`
		Source  json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputPassportElementError.Message = tmp.Message

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	inputPassportElementError.Type = fieldType

	fieldSource, _ := UnmarshalInputPassportElementErrorSource(tmp.Source)
	inputPassportElementError.Source = fieldSource

	return nil
}

// A text message
type MessageText struct {
	meta
	// Text of the message
	Text *FormattedText `json:"text"`
	// A preview of the web page that's mentioned in the text; may be null
	WebPage *WebPage `json:"web_page"`
}

func (entity *MessageText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageText

	return json.Marshal((*stub)(entity))
}

func (*MessageText) GetClass() string {
	return ClassMessageContent
}

func (*MessageText) GetType() string {
	return TypeMessageText
}

func (*MessageText) MessageContentType() string {
	return TypeMessageText
}

// An animation message (GIF-style).
type MessageAnimation struct {
	meta
	// The animation description
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption *FormattedText `json:"caption"`
	// True, if the animation preview must be covered by a spoiler animation
	HasSpoiler bool `json:"has_spoiler"`
	// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAnimation

	return json.Marshal((*stub)(entity))
}

func (*MessageAnimation) GetClass() string {
	return ClassMessageContent
}

func (*MessageAnimation) GetType() string {
	return TypeMessageAnimation
}

func (*MessageAnimation) MessageContentType() string {
	return TypeMessageAnimation
}

// An audio message
type MessageAudio struct {
	meta
	// The audio description
	Audio *Audio `json:"audio"`
	// Audio caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAudio

	return json.Marshal((*stub)(entity))
}

func (*MessageAudio) GetClass() string {
	return ClassMessageContent
}

func (*MessageAudio) GetType() string {
	return TypeMessageAudio
}

func (*MessageAudio) MessageContentType() string {
	return TypeMessageAudio
}

// A document message (general file)
type MessageDocument struct {
	meta
	// The document description
	Document *Document `json:"document"`
	// Document caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageDocument

	return json.Marshal((*stub)(entity))
}

func (*MessageDocument) GetClass() string {
	return ClassMessageContent
}

func (*MessageDocument) GetType() string {
	return TypeMessageDocument
}

func (*MessageDocument) MessageContentType() string {
	return TypeMessageDocument
}

// A photo message
type MessagePhoto struct {
	meta
	// The photo
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *FormattedText `json:"caption"`
	// True, if the photo preview must be covered by a spoiler animation
	HasSpoiler bool `json:"has_spoiler"`
	// True, if the photo must be blurred and must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessagePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessagePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessagePhoto) GetType() string {
	return TypeMessagePhoto
}

func (*MessagePhoto) MessageContentType() string {
	return TypeMessagePhoto
}

// A self-destructed photo message
type MessageExpiredPhoto struct {
	meta
}

func (entity *MessageExpiredPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredPhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredPhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredPhoto) GetType() string {
	return TypeMessageExpiredPhoto
}

func (*MessageExpiredPhoto) MessageContentType() string {
	return TypeMessageExpiredPhoto
}

// A sticker message
type MessageSticker struct {
	meta
	// The sticker description
	Sticker *Sticker `json:"sticker"`
	// True, if premium animation of the sticker must be played
	IsPremium bool `json:"is_premium"`
}

func (entity *MessageSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSticker

	return json.Marshal((*stub)(entity))
}

func (*MessageSticker) GetClass() string {
	return ClassMessageContent
}

func (*MessageSticker) GetType() string {
	return TypeMessageSticker
}

func (*MessageSticker) MessageContentType() string {
	return TypeMessageSticker
}

// A video message
type MessageVideo struct {
	meta
	// The video description
	Video *Video `json:"video"`
	// Video caption
	Caption *FormattedText `json:"caption"`
	// True, if the video preview must be covered by a spoiler animation
	HasSpoiler bool `json:"has_spoiler"`
	// True, if the video thumbnail must be blurred and the video must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageVideo) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideo) GetType() string {
	return TypeMessageVideo
}

func (*MessageVideo) MessageContentType() string {
	return TypeMessageVideo
}

// A self-destructed video message
type MessageExpiredVideo struct {
	meta
}

func (entity *MessageExpiredVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredVideo) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredVideo) GetType() string {
	return TypeMessageExpiredVideo
}

func (*MessageExpiredVideo) MessageContentType() string {
	return TypeMessageExpiredVideo
}

// A video note message
type MessageVideoNote struct {
	meta
	// The video note description
	VideoNote *VideoNote `json:"video_note"`
	// True, if at least one of the recipients has viewed the video note
	IsViewed bool `json:"is_viewed"`
	// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoNote

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoNote) GetType() string {
	return TypeMessageVideoNote
}

func (*MessageVideoNote) MessageContentType() string {
	return TypeMessageVideoNote
}

// A voice note message
type MessageVoiceNote struct {
	meta
	// The voice note description
	VoiceNote *VoiceNote `json:"voice_note"`
	// Voice note caption
	Caption *FormattedText `json:"caption"`
	// True, if at least one of the recipients has listened to the voice note
	IsListened bool `json:"is_listened"`
}

func (entity *MessageVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*MessageVoiceNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageVoiceNote) GetType() string {
	return TypeMessageVoiceNote
}

func (*MessageVoiceNote) MessageContentType() string {
	return TypeMessageVoiceNote
}

// A message with a location
type MessageLocation struct {
	meta
	// The location description
	Location *Location `json:"location"`
	// Time relative to the message send date, for which the location can be updated, in seconds
	LivePeriod int32 `json:"live_period"`
	// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
	ExpiresIn int32 `json:"expires_in"`
	// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
	Heading int32 `json:"heading"`
	// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
	ProximityAlertRadius int32 `json:"proximity_alert_radius"`
}

func (entity *MessageLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLocation

	return json.Marshal((*stub)(entity))
}

func (*MessageLocation) GetClass() string {
	return ClassMessageContent
}

func (*MessageLocation) GetType() string {
	return TypeMessageLocation
}

func (*MessageLocation) MessageContentType() string {
	return TypeMessageLocation
}

// A message with information about a venue
type MessageVenue struct {
	meta
	// The venue description
	Venue *Venue `json:"venue"`
}

func (entity *MessageVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVenue

	return json.Marshal((*stub)(entity))
}

func (*MessageVenue) GetClass() string {
	return ClassMessageContent
}

func (*MessageVenue) GetType() string {
	return TypeMessageVenue
}

func (*MessageVenue) MessageContentType() string {
	return TypeMessageVenue
}

// A message with a user contact
type MessageContact struct {
	meta
	// The contact description
	Contact *Contact `json:"contact"`
}

func (entity *MessageContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageContact

	return json.Marshal((*stub)(entity))
}

func (*MessageContact) GetClass() string {
	return ClassMessageContent
}

func (*MessageContact) GetType() string {
	return TypeMessageContact
}

func (*MessageContact) MessageContentType() string {
	return TypeMessageContact
}

// A message with an animated emoji
type MessageAnimatedEmoji struct {
	meta
	// The animated emoji
	AnimatedEmoji *AnimatedEmoji `json:"animated_emoji"`
	// The corresponding emoji
	Emoji string `json:"emoji"`
}

func (entity *MessageAnimatedEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAnimatedEmoji

	return json.Marshal((*stub)(entity))
}

func (*MessageAnimatedEmoji) GetClass() string {
	return ClassMessageContent
}

func (*MessageAnimatedEmoji) GetType() string {
	return TypeMessageAnimatedEmoji
}

func (*MessageAnimatedEmoji) MessageContentType() string {
	return TypeMessageAnimatedEmoji
}

// A dice message. The dice value is randomly generated by the server
type MessageDice struct {
	meta
	// The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
	InitialState DiceStickers `json:"initial_state"`
	// The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
	FinalState DiceStickers `json:"final_state"`
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`
	// The dice value. If the value is 0, the dice don't have final state yet
	Value int32 `json:"value"`
	// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
	SuccessAnimationFrameNumber int32 `json:"success_animation_frame_number"`
}

func (entity *MessageDice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageDice

	return json.Marshal((*stub)(entity))
}

func (*MessageDice) GetClass() string {
	return ClassMessageContent
}

func (*MessageDice) GetType() string {
	return TypeMessageDice
}

func (*MessageDice) MessageContentType() string {
	return TypeMessageDice
}

func (messageDice *MessageDice) UnmarshalJSON(data []byte) error {
	var tmp struct {
		InitialState                json.RawMessage `json:"initial_state"`
		FinalState                  json.RawMessage `json:"final_state"`
		Emoji                       string          `json:"emoji"`
		Value                       int32           `json:"value"`
		SuccessAnimationFrameNumber int32           `json:"success_animation_frame_number"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageDice.Emoji = tmp.Emoji
	messageDice.Value = tmp.Value
	messageDice.SuccessAnimationFrameNumber = tmp.SuccessAnimationFrameNumber

	fieldInitialState, _ := UnmarshalDiceStickers(tmp.InitialState)
	messageDice.InitialState = fieldInitialState

	fieldFinalState, _ := UnmarshalDiceStickers(tmp.FinalState)
	messageDice.FinalState = fieldFinalState

	return nil
}

// A message with a game
type MessageGame struct {
	meta
	// The game description
	Game *Game `json:"game"`
}

func (entity *MessageGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGame

	return json.Marshal((*stub)(entity))
}

func (*MessageGame) GetClass() string {
	return ClassMessageContent
}

func (*MessageGame) GetType() string {
	return TypeMessageGame
}

func (*MessageGame) MessageContentType() string {
	return TypeMessageGame
}

// A message with a poll
type MessagePoll struct {
	meta
	// The poll description
	Poll *Poll `json:"poll"`
}

func (entity *MessagePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePoll

	return json.Marshal((*stub)(entity))
}

func (*MessagePoll) GetClass() string {
	return ClassMessageContent
}

func (*MessagePoll) GetType() string {
	return TypeMessagePoll
}

func (*MessagePoll) MessageContentType() string {
	return TypeMessagePoll
}

// A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
type MessageInvoice struct {
	meta
	// Product title
	Title string `json:"title"`
	// Product description
	Description *FormattedText `json:"description"`
	// Product photo; may be null
	Photo *Photo `json:"photo"`
	// Currency for the product price
	Currency string `json:"currency"`
	// Product total price in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Unique invoice bot start_parameter to be passed to getInternalLink
	StartParameter string `json:"start_parameter"`
	// True, if the invoice is a test invoice
	IsTest bool `json:"is_test"`
	// True, if the shipping address must be specified
	NeedShippingAddress bool `json:"need_shipping_address"`
	// The identifier of the message with the receipt, after the product has been purchased
	ReceiptMessageId int64 `json:"receipt_message_id"`
	// Extended media attached to the invoice; may be null
	ExtendedMedia MessageExtendedMedia `json:"extended_media"`
}

func (entity *MessageInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInvoice

	return json.Marshal((*stub)(entity))
}

func (*MessageInvoice) GetClass() string {
	return ClassMessageContent
}

func (*MessageInvoice) GetType() string {
	return TypeMessageInvoice
}

func (*MessageInvoice) MessageContentType() string {
	return TypeMessageInvoice
}

func (messageInvoice *MessageInvoice) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Title               string          `json:"title"`
		Description         *FormattedText  `json:"description"`
		Photo               *Photo          `json:"photo"`
		Currency            string          `json:"currency"`
		TotalAmount         int64           `json:"total_amount"`
		StartParameter      string          `json:"start_parameter"`
		IsTest              bool            `json:"is_test"`
		NeedShippingAddress bool            `json:"need_shipping_address"`
		ReceiptMessageId    int64           `json:"receipt_message_id"`
		ExtendedMedia       json.RawMessage `json:"extended_media"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageInvoice.Title = tmp.Title
	messageInvoice.Description = tmp.Description
	messageInvoice.Photo = tmp.Photo
	messageInvoice.Currency = tmp.Currency
	messageInvoice.TotalAmount = tmp.TotalAmount
	messageInvoice.StartParameter = tmp.StartParameter
	messageInvoice.IsTest = tmp.IsTest
	messageInvoice.NeedShippingAddress = tmp.NeedShippingAddress
	messageInvoice.ReceiptMessageId = tmp.ReceiptMessageId

	fieldExtendedMedia, _ := UnmarshalMessageExtendedMedia(tmp.ExtendedMedia)
	messageInvoice.ExtendedMedia = fieldExtendedMedia

	return nil
}

// A message with information about an ended call
type MessageCall struct {
	meta
	// True, if the call was a video call
	IsVideo bool `json:"is_video"`
	// Reason why the call was discarded
	DiscardReason CallDiscardReason `json:"discard_reason"`
	// Call duration, in seconds
	Duration int32 `json:"duration"`
}

func (entity *MessageCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCall

	return json.Marshal((*stub)(entity))
}

func (*MessageCall) GetClass() string {
	return ClassMessageContent
}

func (*MessageCall) GetType() string {
	return TypeMessageCall
}

func (*MessageCall) MessageContentType() string {
	return TypeMessageCall
}

func (messageCall *MessageCall) UnmarshalJSON(data []byte) error {
	var tmp struct {
		IsVideo       bool            `json:"is_video"`
		DiscardReason json.RawMessage `json:"discard_reason"`
		Duration      int32           `json:"duration"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageCall.IsVideo = tmp.IsVideo
	messageCall.Duration = tmp.Duration

	fieldDiscardReason, _ := UnmarshalCallDiscardReason(tmp.DiscardReason)
	messageCall.DiscardReason = fieldDiscardReason

	return nil
}

// A new video chat was scheduled
type MessageVideoChatScheduled struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
	// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
	StartDate int32 `json:"start_date"`
}

func (entity *MessageVideoChatScheduled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoChatScheduled

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoChatScheduled) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoChatScheduled) GetType() string {
	return TypeMessageVideoChatScheduled
}

func (*MessageVideoChatScheduled) MessageContentType() string {
	return TypeMessageVideoChatScheduled
}

// A newly created video chat
type MessageVideoChatStarted struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
}

func (entity *MessageVideoChatStarted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoChatStarted

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoChatStarted) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoChatStarted) GetType() string {
	return TypeMessageVideoChatStarted
}

func (*MessageVideoChatStarted) MessageContentType() string {
	return TypeMessageVideoChatStarted
}

// A message with information about an ended video chat
type MessageVideoChatEnded struct {
	meta
	// Call duration, in seconds
	Duration int32 `json:"duration"`
}

func (entity *MessageVideoChatEnded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoChatEnded

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoChatEnded) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoChatEnded) GetType() string {
	return TypeMessageVideoChatEnded
}

func (*MessageVideoChatEnded) MessageContentType() string {
	return TypeMessageVideoChatEnded
}

// A message with information about an invite to a video chat
type MessageInviteVideoChatParticipants struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
	// Invited user identifiers
	UserIds []int64 `json:"user_ids"`
}

func (entity *MessageInviteVideoChatParticipants) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInviteVideoChatParticipants

	return json.Marshal((*stub)(entity))
}

func (*MessageInviteVideoChatParticipants) GetClass() string {
	return ClassMessageContent
}

func (*MessageInviteVideoChatParticipants) GetType() string {
	return TypeMessageInviteVideoChatParticipants
}

func (*MessageInviteVideoChatParticipants) MessageContentType() string {
	return TypeMessageInviteVideoChatParticipants
}

// A newly created basic group
type MessageBasicGroupChatCreate struct {
	meta
	// Title of the basic group
	Title string `json:"title"`
	// User identifiers of members in the basic group
	MemberUserIds []int64 `json:"member_user_ids"`
}

func (entity *MessageBasicGroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageBasicGroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*MessageBasicGroupChatCreate) GetClass() string {
	return ClassMessageContent
}

func (*MessageBasicGroupChatCreate) GetType() string {
	return TypeMessageBasicGroupChatCreate
}

func (*MessageBasicGroupChatCreate) MessageContentType() string {
	return TypeMessageBasicGroupChatCreate
}

// A newly created supergroup or channel
type MessageSupergroupChatCreate struct {
	meta
	// Title of the supergroup or channel
	Title string `json:"title"`
}

func (entity *MessageSupergroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSupergroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*MessageSupergroupChatCreate) GetClass() string {
	return ClassMessageContent
}

func (*MessageSupergroupChatCreate) GetType() string {
	return TypeMessageSupergroupChatCreate
}

func (*MessageSupergroupChatCreate) MessageContentType() string {
	return TypeMessageSupergroupChatCreate
}

// An updated chat title
type MessageChatChangeTitle struct {
	meta
	// New chat title
	Title string `json:"title"`
}

func (entity *MessageChatChangeTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatChangeTitle

	return json.Marshal((*stub)(entity))
}

func (*MessageChatChangeTitle) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatChangeTitle) GetType() string {
	return TypeMessageChatChangeTitle
}

func (*MessageChatChangeTitle) MessageContentType() string {
	return TypeMessageChatChangeTitle
}

// An updated chat photo
type MessageChatChangePhoto struct {
	meta
	// New chat photo
	Photo *ChatPhoto `json:"photo"`
}

func (entity *MessageChatChangePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatChangePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageChatChangePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatChangePhoto) GetType() string {
	return TypeMessageChatChangePhoto
}

func (*MessageChatChangePhoto) MessageContentType() string {
	return TypeMessageChatChangePhoto
}

// A deleted chat photo
type MessageChatDeletePhoto struct {
	meta
}

func (entity *MessageChatDeletePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatDeletePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageChatDeletePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatDeletePhoto) GetType() string {
	return TypeMessageChatDeletePhoto
}

func (*MessageChatDeletePhoto) MessageContentType() string {
	return TypeMessageChatDeletePhoto
}

// New chat members were added
type MessageChatAddMembers struct {
	meta
	// User identifiers of the new members
	MemberUserIds []int64 `json:"member_user_ids"`
}

func (entity *MessageChatAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatAddMembers

	return json.Marshal((*stub)(entity))
}

func (*MessageChatAddMembers) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatAddMembers) GetType() string {
	return TypeMessageChatAddMembers
}

func (*MessageChatAddMembers) MessageContentType() string {
	return TypeMessageChatAddMembers
}

// A new member joined the chat via an invite link
type MessageChatJoinByLink struct {
	meta
}

func (entity *MessageChatJoinByLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatJoinByLink

	return json.Marshal((*stub)(entity))
}

func (*MessageChatJoinByLink) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatJoinByLink) GetType() string {
	return TypeMessageChatJoinByLink
}

func (*MessageChatJoinByLink) MessageContentType() string {
	return TypeMessageChatJoinByLink
}

// A new member was accepted to the chat by an administrator
type MessageChatJoinByRequest struct {
	meta
}

func (entity *MessageChatJoinByRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatJoinByRequest

	return json.Marshal((*stub)(entity))
}

func (*MessageChatJoinByRequest) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatJoinByRequest) GetType() string {
	return TypeMessageChatJoinByRequest
}

func (*MessageChatJoinByRequest) MessageContentType() string {
	return TypeMessageChatJoinByRequest
}

// A chat member was deleted
type MessageChatDeleteMember struct {
	meta
	// User identifier of the deleted chat member
	UserId int64 `json:"user_id"`
}

func (entity *MessageChatDeleteMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatDeleteMember

	return json.Marshal((*stub)(entity))
}

func (*MessageChatDeleteMember) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatDeleteMember) GetType() string {
	return TypeMessageChatDeleteMember
}

func (*MessageChatDeleteMember) MessageContentType() string {
	return TypeMessageChatDeleteMember
}

// A basic group was upgraded to a supergroup and was deactivated as the result
type MessageChatUpgradeTo struct {
	meta
	// Identifier of the supergroup to which the basic group was upgraded
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *MessageChatUpgradeTo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatUpgradeTo

	return json.Marshal((*stub)(entity))
}

func (*MessageChatUpgradeTo) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatUpgradeTo) GetType() string {
	return TypeMessageChatUpgradeTo
}

func (*MessageChatUpgradeTo) MessageContentType() string {
	return TypeMessageChatUpgradeTo
}

// A supergroup has been created from a basic group
type MessageChatUpgradeFrom struct {
	meta
	// Title of the newly created supergroup
	Title string `json:"title"`
	// The identifier of the original basic group
	BasicGroupId int64 `json:"basic_group_id"`
}

func (entity *MessageChatUpgradeFrom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatUpgradeFrom

	return json.Marshal((*stub)(entity))
}

func (*MessageChatUpgradeFrom) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatUpgradeFrom) GetType() string {
	return TypeMessageChatUpgradeFrom
}

func (*MessageChatUpgradeFrom) MessageContentType() string {
	return TypeMessageChatUpgradeFrom
}

// A message has been pinned
type MessagePinMessage struct {
	meta
	// Identifier of the pinned message, can be an identifier of a deleted message or 0
	MessageId int64 `json:"message_id"`
}

func (entity *MessagePinMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePinMessage

	return json.Marshal((*stub)(entity))
}

func (*MessagePinMessage) GetClass() string {
	return ClassMessageContent
}

func (*MessagePinMessage) GetType() string {
	return TypeMessagePinMessage
}

func (*MessagePinMessage) MessageContentType() string {
	return TypeMessagePinMessage
}

// A screenshot of a message in the chat has been taken
type MessageScreenshotTaken struct {
	meta
}

func (entity *MessageScreenshotTaken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageScreenshotTaken

	return json.Marshal((*stub)(entity))
}

func (*MessageScreenshotTaken) GetClass() string {
	return ClassMessageContent
}

func (*MessageScreenshotTaken) GetType() string {
	return TypeMessageScreenshotTaken
}

func (*MessageScreenshotTaken) MessageContentType() string {
	return TypeMessageScreenshotTaken
}

// A theme in the chat has been changed
type MessageChatSetTheme struct {
	meta
	// If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
	ThemeName string `json:"theme_name"`
}

func (entity *MessageChatSetTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatSetTheme

	return json.Marshal((*stub)(entity))
}

func (*MessageChatSetTheme) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatSetTheme) GetType() string {
	return TypeMessageChatSetTheme
}

func (*MessageChatSetTheme) MessageContentType() string {
	return TypeMessageChatSetTheme
}

// The auto-delete or self-destruct timer for messages in the chat has been changed
type MessageChatSetMessageAutoDeleteTime struct {
	meta
	// New value auto-delete or self-destruct time, in seconds; 0 if disabled
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"`
	// If not 0, a user identifier, which default setting was automatically applied
	FromUserId int64 `json:"from_user_id"`
}

func (entity *MessageChatSetMessageAutoDeleteTime) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatSetMessageAutoDeleteTime

	return json.Marshal((*stub)(entity))
}

func (*MessageChatSetMessageAutoDeleteTime) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatSetMessageAutoDeleteTime) GetType() string {
	return TypeMessageChatSetMessageAutoDeleteTime
}

func (*MessageChatSetMessageAutoDeleteTime) MessageContentType() string {
	return TypeMessageChatSetMessageAutoDeleteTime
}

// A forum topic has been created
type MessageForumTopicCreated struct {
	meta
	// Name of the topic
	Name string `json:"name"`
	// Icon of the topic
	Icon *ForumTopicIcon `json:"icon"`
}

func (entity *MessageForumTopicCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicCreated

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicCreated) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicCreated) GetType() string {
	return TypeMessageForumTopicCreated
}

func (*MessageForumTopicCreated) MessageContentType() string {
	return TypeMessageForumTopicCreated
}

// A forum topic has been edited
type MessageForumTopicEdited struct {
	meta
	// If non-empty, the new name of the topic
	Name string `json:"name"`
	// True, if icon's custom_emoji_id is changed
	EditIconCustomEmojiId bool `json:"edit_icon_custom_emoji_id"`
	// New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
	IconCustomEmojiId JsonInt64 `json:"icon_custom_emoji_id"`
}

func (entity *MessageForumTopicEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicEdited

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicEdited) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicEdited) GetType() string {
	return TypeMessageForumTopicEdited
}

func (*MessageForumTopicEdited) MessageContentType() string {
	return TypeMessageForumTopicEdited
}

// A forum topic has been closed or opened
type MessageForumTopicIsClosedToggled struct {
	meta
	// True, if the topic was closed; otherwise, the topic was reopened
	IsClosed bool `json:"is_closed"`
}

func (entity *MessageForumTopicIsClosedToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicIsClosedToggled

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicIsClosedToggled) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicIsClosedToggled) GetType() string {
	return TypeMessageForumTopicIsClosedToggled
}

func (*MessageForumTopicIsClosedToggled) MessageContentType() string {
	return TypeMessageForumTopicIsClosedToggled
}

// A General forum topic has been hidden or unhidden
type MessageForumTopicIsHiddenToggled struct {
	meta
	// True, if the topic was hidden; otherwise, the topic was unhidden
	IsHidden bool `json:"is_hidden"`
}

func (entity *MessageForumTopicIsHiddenToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicIsHiddenToggled

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicIsHiddenToggled) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicIsHiddenToggled) GetType() string {
	return TypeMessageForumTopicIsHiddenToggled
}

func (*MessageForumTopicIsHiddenToggled) MessageContentType() string {
	return TypeMessageForumTopicIsHiddenToggled
}

// A profile photo was suggested to a user in a private chat
type MessageSuggestProfilePhoto struct {
	meta
	// The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
	Photo *ChatPhoto `json:"photo"`
}

func (entity *MessageSuggestProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSuggestProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageSuggestProfilePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageSuggestProfilePhoto) GetType() string {
	return TypeMessageSuggestProfilePhoto
}

func (*MessageSuggestProfilePhoto) MessageContentType() string {
	return TypeMessageSuggestProfilePhoto
}

// A non-standard action has happened in the chat
type MessageCustomServiceAction struct {
	meta
	// Message text to be shown in the chat
	Text string `json:"text"`
}

func (entity *MessageCustomServiceAction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCustomServiceAction

	return json.Marshal((*stub)(entity))
}

func (*MessageCustomServiceAction) GetClass() string {
	return ClassMessageContent
}

func (*MessageCustomServiceAction) GetType() string {
	return TypeMessageCustomServiceAction
}

func (*MessageCustomServiceAction) MessageContentType() string {
	return TypeMessageCustomServiceAction
}

// A new high score was achieved in a game
type MessageGameScore struct {
	meta
	// Identifier of the message with the game, can be an identifier of a deleted message
	GameMessageId int64 `json:"game_message_id"`
	// Identifier of the game; may be different from the games presented in the message with the game
	GameId JsonInt64 `json:"game_id"`
	// New score
	Score int32 `json:"score"`
}

func (entity *MessageGameScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGameScore

	return json.Marshal((*stub)(entity))
}

func (*MessageGameScore) GetClass() string {
	return ClassMessageContent
}

func (*MessageGameScore) GetType() string {
	return TypeMessageGameScore
}

func (*MessageGameScore) MessageContentType() string {
	return TypeMessageGameScore
}

// A payment has been completed
type MessagePaymentSuccessful struct {
	meta
	// Identifier of the chat, containing the corresponding invoice message
	InvoiceChatId int64 `json:"invoice_chat_id"`
	// Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
	InvoiceMessageId int64 `json:"invoice_message_id"`
	// Currency for the price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// True, if this is a recurring payment
	IsRecurring bool `json:"is_recurring"`
	// True, if this is the first recurring payment
	IsFirstRecurring bool `json:"is_first_recurring"`
	// Name of the invoice; may be empty if unknown
	InvoiceName string `json:"invoice_name"`
}

func (entity *MessagePaymentSuccessful) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentSuccessful

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentSuccessful) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentSuccessful) GetType() string {
	return TypeMessagePaymentSuccessful
}

func (*MessagePaymentSuccessful) MessageContentType() string {
	return TypeMessagePaymentSuccessful
}

// A payment has been completed; for bots only
type MessagePaymentSuccessfulBot struct {
	meta
	// Currency for price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// True, if this is a recurring payment
	IsRecurring bool `json:"is_recurring"`
	// True, if this is the first recurring payment
	IsFirstRecurring bool `json:"is_first_recurring"`
	// Invoice payload
	InvoicePayload []byte `json:"invoice_payload"`
	// Identifier of the shipping option chosen by the user; may be empty if not applicable
	ShippingOptionId string `json:"shipping_option_id"`
	// Information about the order; may be null
	OrderInfo *OrderInfo `json:"order_info"`
	// Telegram payment identifier
	TelegramPaymentChargeId string `json:"telegram_payment_charge_id"`
	// Provider payment identifier
	ProviderPaymentChargeId string `json:"provider_payment_charge_id"`
}

func (entity *MessagePaymentSuccessfulBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentSuccessfulBot

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentSuccessfulBot) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentSuccessfulBot) GetType() string {
	return TypeMessagePaymentSuccessfulBot
}

func (*MessagePaymentSuccessfulBot) MessageContentType() string {
	return TypeMessagePaymentSuccessfulBot
}

// Telegram Premium was gifted to the user
type MessageGiftedPremium struct {
	meta
	// Currency for the paid amount
	Currency string `json:"currency"`
	// The paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of month the Telegram Premium subscription will be active
	MonthCount int32 `json:"month_count"`
	// A sticker to be shown in the message; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageGiftedPremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiftedPremium

	return json.Marshal((*stub)(entity))
}

func (*MessageGiftedPremium) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiftedPremium) GetType() string {
	return TypeMessageGiftedPremium
}

func (*MessageGiftedPremium) MessageContentType() string {
	return TypeMessageGiftedPremium
}

// A contact has registered with Telegram
type MessageContactRegistered struct {
	meta
}

func (entity *MessageContactRegistered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageContactRegistered

	return json.Marshal((*stub)(entity))
}

func (*MessageContactRegistered) GetClass() string {
	return ClassMessageContent
}

func (*MessageContactRegistered) GetType() string {
	return TypeMessageContactRegistered
}

func (*MessageContactRegistered) MessageContentType() string {
	return TypeMessageContactRegistered
}

// The current user shared a user, which was requested by the bot
type MessageUserShared struct {
	meta
	// Identifier of the shared user
	UserId int64 `json:"user_id"`
	// Identifier of the keyboard button with the request
	ButtonId int32 `json:"button_id"`
}

func (entity *MessageUserShared) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageUserShared

	return json.Marshal((*stub)(entity))
}

func (*MessageUserShared) GetClass() string {
	return ClassMessageContent
}

func (*MessageUserShared) GetType() string {
	return TypeMessageUserShared
}

func (*MessageUserShared) MessageContentType() string {
	return TypeMessageUserShared
}

// The current user shared a chat, which was requested by the bot
type MessageChatShared struct {
	meta
	// Identifier of the shared chat
	ChatId int64 `json:"chat_id"`
	// Identifier of the keyboard button with the request
	ButtonId int32 `json:"button_id"`
}

func (entity *MessageChatShared) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatShared

	return json.Marshal((*stub)(entity))
}

func (*MessageChatShared) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatShared) GetType() string {
	return TypeMessageChatShared
}

func (*MessageChatShared) MessageContentType() string {
	return TypeMessageChatShared
}

// The current user has connected a website by logging in using Telegram Login Widget on it
type MessageWebsiteConnected struct {
	meta
	// Domain name of the connected website
	DomainName string `json:"domain_name"`
}

func (entity *MessageWebsiteConnected) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageWebsiteConnected

	return json.Marshal((*stub)(entity))
}

func (*MessageWebsiteConnected) GetClass() string {
	return ClassMessageContent
}

func (*MessageWebsiteConnected) GetType() string {
	return TypeMessageWebsiteConnected
}

func (*MessageWebsiteConnected) MessageContentType() string {
	return TypeMessageWebsiteConnected
}

// The user allowed the bot to send messages
type MessageBotWriteAccessAllowed struct {
	meta
	// Information about the Web App, which requested the access; may be null if none or the Web App was opened from the attachment menu
	WebApp *WebApp `json:"web_app"`
}

func (entity *MessageBotWriteAccessAllowed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageBotWriteAccessAllowed

	return json.Marshal((*stub)(entity))
}

func (*MessageBotWriteAccessAllowed) GetClass() string {
	return ClassMessageContent
}

func (*MessageBotWriteAccessAllowed) GetType() string {
	return TypeMessageBotWriteAccessAllowed
}

func (*MessageBotWriteAccessAllowed) MessageContentType() string {
	return TypeMessageBotWriteAccessAllowed
}

// Data from a Web App has been sent to a bot
type MessageWebAppDataSent struct {
	meta
	// Text of the keyboardButtonTypeWebApp button, which opened the Web App
	ButtonText string `json:"button_text"`
}

func (entity *MessageWebAppDataSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageWebAppDataSent

	return json.Marshal((*stub)(entity))
}

func (*MessageWebAppDataSent) GetClass() string {
	return ClassMessageContent
}

func (*MessageWebAppDataSent) GetType() string {
	return TypeMessageWebAppDataSent
}

func (*MessageWebAppDataSent) MessageContentType() string {
	return TypeMessageWebAppDataSent
}

// Data from a Web App has been received; for bots only
type MessageWebAppDataReceived struct {
	meta
	// Text of the keyboardButtonTypeWebApp button, which opened the Web App
	ButtonText string `json:"button_text"`
	// Received data
	Data string `json:"data"`
}

func (entity *MessageWebAppDataReceived) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageWebAppDataReceived

	return json.Marshal((*stub)(entity))
}

func (*MessageWebAppDataReceived) GetClass() string {
	return ClassMessageContent
}

func (*MessageWebAppDataReceived) GetType() string {
	return TypeMessageWebAppDataReceived
}

func (*MessageWebAppDataReceived) MessageContentType() string {
	return TypeMessageWebAppDataReceived
}

// Telegram Passport data has been sent to a bot
type MessagePassportDataSent struct {
	meta
	// List of Telegram Passport element types sent
	Types []PassportElementType `json:"types"`
}

func (entity *MessagePassportDataSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePassportDataSent

	return json.Marshal((*stub)(entity))
}

func (*MessagePassportDataSent) GetClass() string {
	return ClassMessageContent
}

func (*MessagePassportDataSent) GetType() string {
	return TypeMessagePassportDataSent
}

func (*MessagePassportDataSent) MessageContentType() string {
	return TypeMessagePassportDataSent
}

func (messagePassportDataSent *MessagePassportDataSent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Types []json.RawMessage `json:"types"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTypes, _ := UnmarshalListOfPassportElementType(tmp.Types)
	messagePassportDataSent.Types = fieldTypes

	return nil
}

// Telegram Passport data has been received; for bots only
type MessagePassportDataReceived struct {
	meta
	// List of received Telegram Passport elements
	Elements []*EncryptedPassportElement `json:"elements"`
	// Encrypted data credentials
	Credentials *EncryptedCredentials `json:"credentials"`
}

func (entity *MessagePassportDataReceived) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePassportDataReceived

	return json.Marshal((*stub)(entity))
}

func (*MessagePassportDataReceived) GetClass() string {
	return ClassMessageContent
}

func (*MessagePassportDataReceived) GetType() string {
	return TypeMessagePassportDataReceived
}

func (*MessagePassportDataReceived) MessageContentType() string {
	return TypeMessagePassportDataReceived
}

// A user in the chat came within proximity alert range
type MessageProximityAlertTriggered struct {
	meta
	// The identifier of a user or chat that triggered the proximity alert
	TravelerId MessageSender `json:"traveler_id"`
	// The identifier of a user or chat that subscribed for the proximity alert
	WatcherId MessageSender `json:"watcher_id"`
	// The distance between the users
	Distance int32 `json:"distance"`
}

func (entity *MessageProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageProximityAlertTriggered

	return json.Marshal((*stub)(entity))
}

func (*MessageProximityAlertTriggered) GetClass() string {
	return ClassMessageContent
}

func (*MessageProximityAlertTriggered) GetType() string {
	return TypeMessageProximityAlertTriggered
}

func (*MessageProximityAlertTriggered) MessageContentType() string {
	return TypeMessageProximityAlertTriggered
}

func (messageProximityAlertTriggered *MessageProximityAlertTriggered) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TravelerId json.RawMessage `json:"traveler_id"`
		WatcherId  json.RawMessage `json:"watcher_id"`
		Distance   int32           `json:"distance"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageProximityAlertTriggered.Distance = tmp.Distance

	fieldTravelerId, _ := UnmarshalMessageSender(tmp.TravelerId)
	messageProximityAlertTriggered.TravelerId = fieldTravelerId

	fieldWatcherId, _ := UnmarshalMessageSender(tmp.WatcherId)
	messageProximityAlertTriggered.WatcherId = fieldWatcherId

	return nil
}

// Message content that is not supported in the current TDLib version
type MessageUnsupported struct {
	meta
}

func (entity *MessageUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageUnsupported

	return json.Marshal((*stub)(entity))
}

func (*MessageUnsupported) GetClass() string {
	return ClassMessageContent
}

func (*MessageUnsupported) GetType() string {
	return TypeMessageUnsupported
}

func (*MessageUnsupported) MessageContentType() string {
	return TypeMessageUnsupported
}

// A mention of a user, a supergroup, or a channel by their username
type TextEntityTypeMention struct {
	meta
}

func (entity *TextEntityTypeMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMention

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMention) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMention) GetType() string {
	return TypeTextEntityTypeMention
}

func (*TextEntityTypeMention) TextEntityTypeType() string {
	return TypeTextEntityTypeMention
}

// A hashtag text, beginning with "#"
type TextEntityTypeHashtag struct {
	meta
}

func (entity *TextEntityTypeHashtag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeHashtag

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeHashtag) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeHashtag) GetType() string {
	return TypeTextEntityTypeHashtag
}

func (*TextEntityTypeHashtag) TextEntityTypeType() string {
	return TypeTextEntityTypeHashtag
}

// A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD")
type TextEntityTypeCashtag struct {
	meta
}

func (entity *TextEntityTypeCashtag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCashtag

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCashtag) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCashtag) GetType() string {
	return TypeTextEntityTypeCashtag
}

func (*TextEntityTypeCashtag) TextEntityTypeType() string {
	return TypeTextEntityTypeCashtag
}

// A bot command, beginning with "/"
type TextEntityTypeBotCommand struct {
	meta
}

func (entity *TextEntityTypeBotCommand) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBotCommand

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBotCommand) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBotCommand) GetType() string {
	return TypeTextEntityTypeBotCommand
}

func (*TextEntityTypeBotCommand) TextEntityTypeType() string {
	return TypeTextEntityTypeBotCommand
}

// An HTTP URL
type TextEntityTypeUrl struct {
	meta
}

func (entity *TextEntityTypeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeUrl

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeUrl) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeUrl) GetType() string {
	return TypeTextEntityTypeUrl
}

func (*TextEntityTypeUrl) TextEntityTypeType() string {
	return TypeTextEntityTypeUrl
}

// An email address
type TextEntityTypeEmailAddress struct {
	meta
}

func (entity *TextEntityTypeEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeEmailAddress) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeEmailAddress) GetType() string {
	return TypeTextEntityTypeEmailAddress
}

func (*TextEntityTypeEmailAddress) TextEntityTypeType() string {
	return TypeTextEntityTypeEmailAddress
}

// A phone number
type TextEntityTypePhoneNumber struct {
	meta
}

func (entity *TextEntityTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePhoneNumber) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePhoneNumber) GetType() string {
	return TypeTextEntityTypePhoneNumber
}

func (*TextEntityTypePhoneNumber) TextEntityTypeType() string {
	return TypeTextEntityTypePhoneNumber
}

// A bank card number. The getBankCardInfo method can be used to get information about the bank card
type TextEntityTypeBankCardNumber struct {
	meta
}

func (entity *TextEntityTypeBankCardNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBankCardNumber

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBankCardNumber) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBankCardNumber) GetType() string {
	return TypeTextEntityTypeBankCardNumber
}

func (*TextEntityTypeBankCardNumber) TextEntityTypeType() string {
	return TypeTextEntityTypeBankCardNumber
}

// A bold text
type TextEntityTypeBold struct {
	meta
}

func (entity *TextEntityTypeBold) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBold

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBold) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBold) GetType() string {
	return TypeTextEntityTypeBold
}

func (*TextEntityTypeBold) TextEntityTypeType() string {
	return TypeTextEntityTypeBold
}

// An italic text
type TextEntityTypeItalic struct {
	meta
}

func (entity *TextEntityTypeItalic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeItalic

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeItalic) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeItalic) GetType() string {
	return TypeTextEntityTypeItalic
}

func (*TextEntityTypeItalic) TextEntityTypeType() string {
	return TypeTextEntityTypeItalic
}

// An underlined text
type TextEntityTypeUnderline struct {
	meta
}

func (entity *TextEntityTypeUnderline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeUnderline

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeUnderline) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeUnderline) GetType() string {
	return TypeTextEntityTypeUnderline
}

func (*TextEntityTypeUnderline) TextEntityTypeType() string {
	return TypeTextEntityTypeUnderline
}

// A strikethrough text
type TextEntityTypeStrikethrough struct {
	meta
}

func (entity *TextEntityTypeStrikethrough) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeStrikethrough

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeStrikethrough) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeStrikethrough) GetType() string {
	return TypeTextEntityTypeStrikethrough
}

func (*TextEntityTypeStrikethrough) TextEntityTypeType() string {
	return TypeTextEntityTypeStrikethrough
}

// A spoiler text
type TextEntityTypeSpoiler struct {
	meta
}

func (entity *TextEntityTypeSpoiler) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeSpoiler

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeSpoiler) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeSpoiler) GetType() string {
	return TypeTextEntityTypeSpoiler
}

func (*TextEntityTypeSpoiler) TextEntityTypeType() string {
	return TypeTextEntityTypeSpoiler
}

// Text that must be formatted as if inside a code HTML tag
type TextEntityTypeCode struct {
	meta
}

func (entity *TextEntityTypeCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCode

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCode) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCode) GetType() string {
	return TypeTextEntityTypeCode
}

func (*TextEntityTypeCode) TextEntityTypeType() string {
	return TypeTextEntityTypeCode
}

// Text that must be formatted as if inside a pre HTML tag
type TextEntityTypePre struct {
	meta
}

func (entity *TextEntityTypePre) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePre

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePre) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePre) GetType() string {
	return TypeTextEntityTypePre
}

func (*TextEntityTypePre) TextEntityTypeType() string {
	return TypeTextEntityTypePre
}

// Text that must be formatted as if inside pre, and code HTML tags
type TextEntityTypePreCode struct {
	meta
	// Programming language of the code; as defined by the sender
	Language string `json:"language"`
}

func (entity *TextEntityTypePreCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePreCode

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePreCode) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePreCode) GetType() string {
	return TypeTextEntityTypePreCode
}

func (*TextEntityTypePreCode) TextEntityTypeType() string {
	return TypeTextEntityTypePreCode
}

// A text description shown instead of a raw URL
type TextEntityTypeTextUrl struct {
	meta
	// HTTP or tg:// URL to be opened when the link is clicked
	Url string `json:"url"`
}

func (entity *TextEntityTypeTextUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeTextUrl

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeTextUrl) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeTextUrl) GetType() string {
	return TypeTextEntityTypeTextUrl
}

func (*TextEntityTypeTextUrl) TextEntityTypeType() string {
	return TypeTextEntityTypeTextUrl
}

// A text shows instead of a raw mention of the user (e.g., when the user has no username)
type TextEntityTypeMentionName struct {
	meta
	// Identifier of the mentioned user
	UserId int64 `json:"user_id"`
}

func (entity *TextEntityTypeMentionName) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMentionName

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMentionName) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMentionName) GetType() string {
	return TypeTextEntityTypeMentionName
}

func (*TextEntityTypeMentionName) TextEntityTypeType() string {
	return TypeTextEntityTypeMentionName
}

// A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji
type TextEntityTypeCustomEmoji struct {
	meta
	// Unique identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *TextEntityTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCustomEmoji) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCustomEmoji) GetType() string {
	return TypeTextEntityTypeCustomEmoji
}

func (*TextEntityTypeCustomEmoji) TextEntityTypeType() string {
	return TypeTextEntityTypeCustomEmoji
}

// A media timestamp
type TextEntityTypeMediaTimestamp struct {
	meta
	// Timestamp from which a video/audio/video note/voice note playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message
	MediaTimestamp int32 `json:"media_timestamp"`
}

func (entity *TextEntityTypeMediaTimestamp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMediaTimestamp

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMediaTimestamp) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMediaTimestamp) GetType() string {
	return TypeTextEntityTypeMediaTimestamp
}

func (*TextEntityTypeMediaTimestamp) TextEntityTypeType() string {
	return TypeTextEntityTypeMediaTimestamp
}

// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
type InputThumbnail struct {
	meta
	// Thumbnail file to send. Sending thumbnails by file_id is currently not supported
	Thumbnail InputFile `json:"thumbnail"`
	// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
	Width int32 `json:"width"`
	// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
	Height int32 `json:"height"`
}

func (entity *InputThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputThumbnail

	return json.Marshal((*stub)(entity))
}

func (*InputThumbnail) GetClass() string {
	return ClassInputThumbnail
}

func (*InputThumbnail) GetType() string {
	return TypeInputThumbnail
}

func (inputThumbnail *InputThumbnail) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Thumbnail json.RawMessage `json:"thumbnail"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputThumbnail.Width = tmp.Width
	inputThumbnail.Height = tmp.Height

	fieldThumbnail, _ := UnmarshalInputFile(tmp.Thumbnail)
	inputThumbnail.Thumbnail = fieldThumbnail

	return nil
}

// The message will be sent at the specified date
type MessageSchedulingStateSendAtDate struct {
	meta
	// Date the message will be sent. The date must be within 367 days in the future
	SendDate int32 `json:"send_date"`
}

func (entity *MessageSchedulingStateSendAtDate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendAtDate

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendAtDate) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendAtDate) GetType() string {
	return TypeMessageSchedulingStateSendAtDate
}

func (*MessageSchedulingStateSendAtDate) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendAtDate
}

// The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known
type MessageSchedulingStateSendWhenOnline struct {
	meta
}

func (entity *MessageSchedulingStateSendWhenOnline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendWhenOnline

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendWhenOnline) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendWhenOnline) GetType() string {
	return TypeMessageSchedulingStateSendWhenOnline
}

func (*MessageSchedulingStateSendWhenOnline) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendWhenOnline
}

// Options to be used when a message is sent
type MessageSendOptions struct {
	meta
	// Pass true to disable notification for the message
	DisableNotification bool `json:"disable_notification"`
	// Pass true if the message is sent from the background
	FromBackground bool `json:"from_background"`
	// Pass true if the content of the message must be protected from forwarding and saving; for bots only
	ProtectContent bool `json:"protect_content"`
	// Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
	UpdateOrderOfInstalledStickerSets bool `json:"update_order_of_installed_sticker_sets"`
	// Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
	SchedulingState MessageSchedulingState `json:"scheduling_state"`
	// Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
	SendingId int32 `json:"sending_id"`
}

func (entity *MessageSendOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendOptions

	return json.Marshal((*stub)(entity))
}

func (*MessageSendOptions) GetClass() string {
	return ClassMessageSendOptions
}

func (*MessageSendOptions) GetType() string {
	return TypeMessageSendOptions
}

func (messageSendOptions *MessageSendOptions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		DisableNotification               bool            `json:"disable_notification"`
		FromBackground                    bool            `json:"from_background"`
		ProtectContent                    bool            `json:"protect_content"`
		UpdateOrderOfInstalledStickerSets bool            `json:"update_order_of_installed_sticker_sets"`
		SchedulingState                   json.RawMessage `json:"scheduling_state"`
		SendingId                         int32           `json:"sending_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageSendOptions.DisableNotification = tmp.DisableNotification
	messageSendOptions.FromBackground = tmp.FromBackground
	messageSendOptions.ProtectContent = tmp.ProtectContent
	messageSendOptions.UpdateOrderOfInstalledStickerSets = tmp.UpdateOrderOfInstalledStickerSets
	messageSendOptions.SendingId = tmp.SendingId

	fieldSchedulingState, _ := UnmarshalMessageSchedulingState(tmp.SchedulingState)
	messageSendOptions.SchedulingState = fieldSchedulingState

	return nil
}

// Options to be used when a message content is copied without reference to the original sender. Service messages and messageInvoice can't be copied
type MessageCopyOptions struct {
	meta
	// True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
	SendCopy bool `json:"send_copy"`
	// True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
	ReplaceCaption bool `json:"replace_caption"`
	// New message caption; pass null to copy message without caption. Ignored if replace_caption is false
	NewCaption *FormattedText `json:"new_caption"`
}

func (entity *MessageCopyOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCopyOptions

	return json.Marshal((*stub)(entity))
}

func (*MessageCopyOptions) GetClass() string {
	return ClassMessageCopyOptions
}

func (*MessageCopyOptions) GetType() string {
	return TypeMessageCopyOptions
}

// A text message
type InputMessageText struct {
	meta
	// Formatted text to be sent; 1-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
	Text *FormattedText `json:"text"`
	// True, if rich web page previews for URLs in the message text must be disabled
	DisableWebPagePreview bool `json:"disable_web_page_preview"`
	// True, if a chat message draft must be deleted
	ClearDraft bool `json:"clear_draft"`
}

func (entity *InputMessageText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageText

	return json.Marshal((*stub)(entity))
}

func (*InputMessageText) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageText) GetType() string {
	return TypeInputMessageText
}

func (*InputMessageText) InputMessageContentType() string {
	return TypeInputMessageText
}

// An animation message (GIF-style).
type InputMessageAnimation struct {
	meta
	// Animation file to be sent
	Animation InputFile `json:"animation"`
	// Animation thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the animation, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Duration of the animation, in seconds
	Duration int32 `json:"duration"`
	// Width of the animation; may be replaced by the server
	Width int32 `json:"width"`
	// Height of the animation; may be replaced by the server
	Height int32 `json:"height"`
	// Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
	HasSpoiler bool `json:"has_spoiler"`
}

func (entity *InputMessageAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputMessageAnimation) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageAnimation) GetType() string {
	return TypeInputMessageAnimation
}

func (*InputMessageAnimation) InputMessageContentType() string {
	return TypeInputMessageAnimation
}

func (inputMessageAnimation *InputMessageAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Animation           json.RawMessage `json:"animation"`
		Thumbnail           *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Duration            int32           `json:"duration"`
		Width               int32           `json:"width"`
		Height              int32           `json:"height"`
		Caption             *FormattedText  `json:"caption"`
		HasSpoiler          bool            `json:"has_spoiler"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageAnimation.Thumbnail = tmp.Thumbnail
	inputMessageAnimation.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessageAnimation.Duration = tmp.Duration
	inputMessageAnimation.Width = tmp.Width
	inputMessageAnimation.Height = tmp.Height
	inputMessageAnimation.Caption = tmp.Caption
	inputMessageAnimation.HasSpoiler = tmp.HasSpoiler

	fieldAnimation, _ := UnmarshalInputFile(tmp.Animation)
	inputMessageAnimation.Animation = fieldAnimation

	return nil
}

// An audio message
type InputMessageAudio struct {
	meta
	// Audio file to be sent
	Audio InputFile `json:"audio"`
	// Thumbnail of the cover for the album; pass null to skip thumbnail uploading
	AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"`
	// Duration of the audio, in seconds; may be replaced by the server
	Duration int32 `json:"duration"`
	// Title of the audio; 0-64 characters; may be replaced by the server
	Title string `json:"title"`
	// Performer of the audio; 0-64 characters, may be replaced by the server
	Performer string `json:"performer"`
	// Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageAudio

	return json.Marshal((*stub)(entity))
}

func (*InputMessageAudio) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageAudio) GetType() string {
	return TypeInputMessageAudio
}

func (*InputMessageAudio) InputMessageContentType() string {
	return TypeInputMessageAudio
}

func (inputMessageAudio *InputMessageAudio) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Audio               json.RawMessage `json:"audio"`
		AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"`
		Duration            int32           `json:"duration"`
		Title               string          `json:"title"`
		Performer           string          `json:"performer"`
		Caption             *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageAudio.AlbumCoverThumbnail = tmp.AlbumCoverThumbnail
	inputMessageAudio.Duration = tmp.Duration
	inputMessageAudio.Title = tmp.Title
	inputMessageAudio.Performer = tmp.Performer
	inputMessageAudio.Caption = tmp.Caption

	fieldAudio, _ := UnmarshalInputFile(tmp.Audio)
	inputMessageAudio.Audio = fieldAudio

	return nil
}

// A document message (general file)
type InputMessageDocument struct {
	meta
	// Document to be sent
	Document InputFile `json:"document"`
	// Document thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// If true, automatic file type detection will be disabled and the document will always be sent as file. Always true for files sent to secret chats
	DisableContentTypeDetection bool `json:"disable_content_type_detection"`
	// Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageDocument

	return json.Marshal((*stub)(entity))
}

func (*InputMessageDocument) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageDocument) GetType() string {
	return TypeInputMessageDocument
}

func (*InputMessageDocument) InputMessageContentType() string {
	return TypeInputMessageDocument
}

func (inputMessageDocument *InputMessageDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Document                    json.RawMessage `json:"document"`
		Thumbnail                   *InputThumbnail `json:"thumbnail"`
		DisableContentTypeDetection bool            `json:"disable_content_type_detection"`
		Caption                     *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageDocument.Thumbnail = tmp.Thumbnail
	inputMessageDocument.DisableContentTypeDetection = tmp.DisableContentTypeDetection
	inputMessageDocument.Caption = tmp.Caption

	fieldDocument, _ := UnmarshalInputFile(tmp.Document)
	inputMessageDocument.Document = fieldDocument

	return nil
}

// A photo message
type InputMessagePhoto struct {
	meta
	// Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
	Photo InputFile `json:"photo"`
	// Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the photo, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Photo width
	Width int32 `json:"width"`
	// Photo height
	Height int32 `json:"height"`
	// Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// Photo self-destruct time, in seconds (0-60). A non-zero self-destruct time can be specified only in private chats
	SelfDestructTime int32 `json:"self_destruct_time"`
	// True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
	HasSpoiler bool `json:"has_spoiler"`
}

func (entity *InputMessagePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePhoto

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePhoto) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePhoto) GetType() string {
	return TypeInputMessagePhoto
}

func (*InputMessagePhoto) InputMessageContentType() string {
	return TypeInputMessagePhoto
}

func (inputMessagePhoto *InputMessagePhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Photo               json.RawMessage `json:"photo"`
		Thumbnail           *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Width               int32           `json:"width"`
		Height              int32           `json:"height"`
		Caption             *FormattedText  `json:"caption"`
		SelfDestructTime    int32           `json:"self_destruct_time"`
		HasSpoiler          bool            `json:"has_spoiler"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessagePhoto.Thumbnail = tmp.Thumbnail
	inputMessagePhoto.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessagePhoto.Width = tmp.Width
	inputMessagePhoto.Height = tmp.Height
	inputMessagePhoto.Caption = tmp.Caption
	inputMessagePhoto.SelfDestructTime = tmp.SelfDestructTime
	inputMessagePhoto.HasSpoiler = tmp.HasSpoiler

	fieldPhoto, _ := UnmarshalInputFile(tmp.Photo)
	inputMessagePhoto.Photo = fieldPhoto

	return nil
}

// A sticker message
type InputMessageSticker struct {
	meta
	// Sticker to be sent
	Sticker InputFile `json:"sticker"`
	// Sticker thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Sticker width
	Width int32 `json:"width"`
	// Sticker height
	Height int32 `json:"height"`
	// Emoji used to choose the sticker
	Emoji string `json:"emoji"`
}

func (entity *InputMessageSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageSticker

	return json.Marshal((*stub)(entity))
}

func (*InputMessageSticker) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageSticker) GetType() string {
	return TypeInputMessageSticker
}

func (*InputMessageSticker) InputMessageContentType() string {
	return TypeInputMessageSticker
}

func (inputMessageSticker *InputMessageSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sticker   json.RawMessage `json:"sticker"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
		Emoji     string          `json:"emoji"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageSticker.Thumbnail = tmp.Thumbnail
	inputMessageSticker.Width = tmp.Width
	inputMessageSticker.Height = tmp.Height
	inputMessageSticker.Emoji = tmp.Emoji

	fieldSticker, _ := UnmarshalInputFile(tmp.Sticker)
	inputMessageSticker.Sticker = fieldSticker

	return nil
}

// A video message
type InputMessageVideo struct {
	meta
	// Video to be sent
	Video InputFile `json:"video"`
	// Video thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the video, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// Video width
	Width int32 `json:"width"`
	// Video height
	Height int32 `json:"height"`
	// True, if the video is supposed to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
	// Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// Video self-destruct time, in seconds (0-60). A non-zero self-destruct time can be specified only in private chats
	SelfDestructTime int32 `json:"self_destruct_time"`
	// True, if the video preview must be covered by a spoiler animation; not supported in secret chats
	HasSpoiler bool `json:"has_spoiler"`
}

func (entity *InputMessageVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVideo

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVideo) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVideo) GetType() string {
	return TypeInputMessageVideo
}

func (*InputMessageVideo) InputMessageContentType() string {
	return TypeInputMessageVideo
}

func (inputMessageVideo *InputMessageVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Video               json.RawMessage `json:"video"`
		Thumbnail           *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Duration            int32           `json:"duration"`
		Width               int32           `json:"width"`
		Height              int32           `json:"height"`
		SupportsStreaming   bool            `json:"supports_streaming"`
		Caption             *FormattedText  `json:"caption"`
		SelfDestructTime    int32           `json:"self_destruct_time"`
		HasSpoiler          bool            `json:"has_spoiler"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVideo.Thumbnail = tmp.Thumbnail
	inputMessageVideo.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessageVideo.Duration = tmp.Duration
	inputMessageVideo.Width = tmp.Width
	inputMessageVideo.Height = tmp.Height
	inputMessageVideo.SupportsStreaming = tmp.SupportsStreaming
	inputMessageVideo.Caption = tmp.Caption
	inputMessageVideo.SelfDestructTime = tmp.SelfDestructTime
	inputMessageVideo.HasSpoiler = tmp.HasSpoiler

	fieldVideo, _ := UnmarshalInputFile(tmp.Video)
	inputMessageVideo.Video = fieldVideo

	return nil
}

// A video note message
type InputMessageVideoNote struct {
	meta
	// Video note to be sent
	VideoNote InputFile `json:"video_note"`
	// Video thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// Video width and height; must be positive and not greater than 640
	Length int32 `json:"length"`
}

func (entity *InputMessageVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVideoNote

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVideoNote) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVideoNote) GetType() string {
	return TypeInputMessageVideoNote
}

func (*InputMessageVideoNote) InputMessageContentType() string {
	return TypeInputMessageVideoNote
}

func (inputMessageVideoNote *InputMessageVideoNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		VideoNote json.RawMessage `json:"video_note"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Duration  int32           `json:"duration"`
		Length    int32           `json:"length"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVideoNote.Thumbnail = tmp.Thumbnail
	inputMessageVideoNote.Duration = tmp.Duration
	inputMessageVideoNote.Length = tmp.Length

	fieldVideoNote, _ := UnmarshalInputFile(tmp.VideoNote)
	inputMessageVideoNote.VideoNote = fieldVideoNote

	return nil
}

// A voice note message
type InputMessageVoiceNote struct {
	meta
	// Voice note to be sent
	VoiceNote InputFile `json:"voice_note"`
	// Duration of the voice note, in seconds
	Duration int32 `json:"duration"`
	// Waveform representation of the voice note in 5-bit format
	Waveform []byte `json:"waveform"`
	// Voice note caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVoiceNote) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVoiceNote) GetType() string {
	return TypeInputMessageVoiceNote
}

func (*InputMessageVoiceNote) InputMessageContentType() string {
	return TypeInputMessageVoiceNote
}

func (inputMessageVoiceNote *InputMessageVoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		VoiceNote json.RawMessage `json:"voice_note"`
		Duration  int32           `json:"duration"`
		Waveform  []byte          `json:"waveform"`
		Caption   *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVoiceNote.Duration = tmp.Duration
	inputMessageVoiceNote.Waveform = tmp.Waveform
	inputMessageVoiceNote.Caption = tmp.Caption

	fieldVoiceNote, _ := UnmarshalInputFile(tmp.VoiceNote)
	inputMessageVoiceNote.VoiceNote = fieldVoiceNote

	return nil
}

// A message with a location
type InputMessageLocation struct {
	meta
	// Location to be sent
	Location *Location `json:"location"`
	// Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise
	LivePeriod int32 `json:"live_period"`
	// For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
	Heading int32 `json:"heading"`
	// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
	ProximityAlertRadius int32 `json:"proximity_alert_radius"`
}

func (entity *InputMessageLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageLocation

	return json.Marshal((*stub)(entity))
}

func (*InputMessageLocation) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageLocation) GetType() string {
	return TypeInputMessageLocation
}

func (*InputMessageLocation) InputMessageContentType() string {
	return TypeInputMessageLocation
}

// A message with information about a venue
type InputMessageVenue struct {
	meta
	// Venue to send
	Venue *Venue `json:"venue"`
}

func (entity *InputMessageVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVenue

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVenue) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVenue) GetType() string {
	return TypeInputMessageVenue
}

func (*InputMessageVenue) InputMessageContentType() string {
	return TypeInputMessageVenue
}

// A message containing a user contact
type InputMessageContact struct {
	meta
	// Contact to send
	Contact *Contact `json:"contact"`
}

func (entity *InputMessageContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageContact

	return json.Marshal((*stub)(entity))
}

func (*InputMessageContact) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageContact) GetType() string {
	return TypeInputMessageContact
}

func (*InputMessageContact) InputMessageContentType() string {
	return TypeInputMessageContact
}

// A dice message
type InputMessageDice struct {
	meta
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`
	// True, if the chat message draft must be deleted
	ClearDraft bool `json:"clear_draft"`
}

func (entity *InputMessageDice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageDice

	return json.Marshal((*stub)(entity))
}

func (*InputMessageDice) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageDice) GetType() string {
	return TypeInputMessageDice
}

func (*InputMessageDice) InputMessageContentType() string {
	return TypeInputMessageDice
}

// A message with a game; not supported for channels or secret chats
type InputMessageGame struct {
	meta
	// User identifier of the bot that owns the game
	BotUserId int64 `json:"bot_user_id"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
}

func (entity *InputMessageGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageGame

	return json.Marshal((*stub)(entity))
}

func (*InputMessageGame) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageGame) GetType() string {
	return TypeInputMessageGame
}

func (*InputMessageGame) InputMessageContentType() string {
	return TypeInputMessageGame
}

// A message with an invoice; can be used only by bots
type InputMessageInvoice struct {
	meta
	// Invoice
	Invoice *Invoice `json:"invoice"`
	// Product title; 1-32 characters
	Title string `json:"title"`
	// Product description; 0-255 characters
	Description string `json:"description"`
	// Product photo URL; optional
	PhotoUrl string `json:"photo_url"`
	// Product photo size
	PhotoSize int32 `json:"photo_size"`
	// Product photo width
	PhotoWidth int32 `json:"photo_width"`
	// Product photo height
	PhotoHeight int32 `json:"photo_height"`
	// The invoice payload
	Payload []byte `json:"payload"`
	// Payment provider token
	ProviderToken string `json:"provider_token"`
	// JSON-encoded data about the invoice, which will be shared with the payment provider
	ProviderData string `json:"provider_data"`
	// Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
	StartParameter string `json:"start_parameter"`
	// The content of extended media attached to the invoice. The content of the message to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
	ExtendedMediaContent InputMessageContent `json:"extended_media_content"`
}

func (entity *InputMessageInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageInvoice

	return json.Marshal((*stub)(entity))
}

func (*InputMessageInvoice) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageInvoice) GetType() string {
	return TypeInputMessageInvoice
}

func (*InputMessageInvoice) InputMessageContentType() string {
	return TypeInputMessageInvoice
}

func (inputMessageInvoice *InputMessageInvoice) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Invoice              *Invoice        `json:"invoice"`
		Title                string          `json:"title"`
		Description          string          `json:"description"`
		PhotoUrl             string          `json:"photo_url"`
		PhotoSize            int32           `json:"photo_size"`
		PhotoWidth           int32           `json:"photo_width"`
		PhotoHeight          int32           `json:"photo_height"`
		Payload              []byte          `json:"payload"`
		ProviderToken        string          `json:"provider_token"`
		ProviderData         string          `json:"provider_data"`
		StartParameter       string          `json:"start_parameter"`
		ExtendedMediaContent json.RawMessage `json:"extended_media_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageInvoice.Invoice = tmp.Invoice
	inputMessageInvoice.Title = tmp.Title
	inputMessageInvoice.Description = tmp.Description
	inputMessageInvoice.PhotoUrl = tmp.PhotoUrl
	inputMessageInvoice.PhotoSize = tmp.PhotoSize
	inputMessageInvoice.PhotoWidth = tmp.PhotoWidth
	inputMessageInvoice.PhotoHeight = tmp.PhotoHeight
	inputMessageInvoice.Payload = tmp.Payload
	inputMessageInvoice.ProviderToken = tmp.ProviderToken
	inputMessageInvoice.ProviderData = tmp.ProviderData
	inputMessageInvoice.StartParameter = tmp.StartParameter

	fieldExtendedMediaContent, _ := UnmarshalInputMessageContent(tmp.ExtendedMediaContent)
	inputMessageInvoice.ExtendedMediaContent = fieldExtendedMediaContent

	return nil
}

// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
type InputMessagePoll struct {
	meta
	// Poll question; 1-255 characters (up to 300 characters for bots)
	Question string `json:"question"`
	// List of poll answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`
	// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
	IsAnonymous bool `json:"is_anonymous"`
	// Type of the poll
	Type PollType `json:"type"`
	// Amount of time the poll will be active after creation, in seconds; for bots only
	OpenPeriod int32 `json:"open_period"`
	// Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
	CloseDate int32 `json:"close_date"`
	// True, if the poll needs to be sent already closed; for bots only
	IsClosed bool `json:"is_closed"`
}

func (entity *InputMessagePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePoll

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePoll) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePoll) GetType() string {
	return TypeInputMessagePoll
}

func (*InputMessagePoll) InputMessageContentType() string {
	return TypeInputMessagePoll
}

func (inputMessagePoll *InputMessagePoll) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Question    string          `json:"question"`
		Options     []string        `json:"options"`
		IsAnonymous bool            `json:"is_anonymous"`
		Type        json.RawMessage `json:"type"`
		OpenPeriod  int32           `json:"open_period"`
		CloseDate   int32           `json:"close_date"`
		IsClosed    bool            `json:"is_closed"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessagePoll.Question = tmp.Question
	inputMessagePoll.Options = tmp.Options
	inputMessagePoll.IsAnonymous = tmp.IsAnonymous
	inputMessagePoll.OpenPeriod = tmp.OpenPeriod
	inputMessagePoll.CloseDate = tmp.CloseDate
	inputMessagePoll.IsClosed = tmp.IsClosed

	fieldType, _ := UnmarshalPollType(tmp.Type)
	inputMessagePoll.Type = fieldType

	return nil
}

// A forwarded message
type InputMessageForwarded struct {
	meta
	// Identifier for the chat this forwarded message came from
	FromChatId int64 `json:"from_chat_id"`
	// Identifier of the message to forward
	MessageId int64 `json:"message_id"`
	// True, if a game message is being shared from a launched game; applies only to game messages
	InGameShare bool `json:"in_game_share"`
	// Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
	CopyOptions *MessageCopyOptions `json:"copy_options"`
}

func (entity *InputMessageForwarded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageForwarded

	return json.Marshal((*stub)(entity))
}

func (*InputMessageForwarded) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageForwarded) GetType() string {
	return TypeInputMessageForwarded
}

func (*InputMessageForwarded) InputMessageContentType() string {
	return TypeInputMessageForwarded
}

// Returns all found messages, no filter is applied
type SearchMessagesFilterEmpty struct {
	meta
}

func (entity *SearchMessagesFilterEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterEmpty

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterEmpty) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterEmpty) GetType() string {
	return TypeSearchMessagesFilterEmpty
}

func (*SearchMessagesFilterEmpty) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterEmpty
}

// Returns only animation messages
type SearchMessagesFilterAnimation struct {
	meta
}

func (entity *SearchMessagesFilterAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterAnimation

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterAnimation) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterAnimation) GetType() string {
	return TypeSearchMessagesFilterAnimation
}

func (*SearchMessagesFilterAnimation) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterAnimation
}

// Returns only audio messages
type SearchMessagesFilterAudio struct {
	meta
}

func (entity *SearchMessagesFilterAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterAudio

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterAudio) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterAudio) GetType() string {
	return TypeSearchMessagesFilterAudio
}

func (*SearchMessagesFilterAudio) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterAudio
}

// Returns only document messages
type SearchMessagesFilterDocument struct {
	meta
}

func (entity *SearchMessagesFilterDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterDocument

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterDocument) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterDocument) GetType() string {
	return TypeSearchMessagesFilterDocument
}

func (*SearchMessagesFilterDocument) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterDocument
}

// Returns only photo messages
type SearchMessagesFilterPhoto struct {
	meta
}

func (entity *SearchMessagesFilterPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPhoto

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPhoto) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPhoto) GetType() string {
	return TypeSearchMessagesFilterPhoto
}

func (*SearchMessagesFilterPhoto) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPhoto
}

// Returns only video messages
type SearchMessagesFilterVideo struct {
	meta
}

func (entity *SearchMessagesFilterVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVideo

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVideo) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVideo) GetType() string {
	return TypeSearchMessagesFilterVideo
}

func (*SearchMessagesFilterVideo) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVideo
}

// Returns only voice note messages
type SearchMessagesFilterVoiceNote struct {
	meta
}

func (entity *SearchMessagesFilterVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVoiceNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVoiceNote) GetType() string {
	return TypeSearchMessagesFilterVoiceNote
}

func (*SearchMessagesFilterVoiceNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVoiceNote
}

// Returns only photo and video messages
type SearchMessagesFilterPhotoAndVideo struct {
	meta
}

func (entity *SearchMessagesFilterPhotoAndVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPhotoAndVideo

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPhotoAndVideo) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPhotoAndVideo) GetType() string {
	return TypeSearchMessagesFilterPhotoAndVideo
}

func (*SearchMessagesFilterPhotoAndVideo) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPhotoAndVideo
}

// Returns only messages containing URLs
type SearchMessagesFilterUrl struct {
	meta
}

func (entity *SearchMessagesFilterUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUrl

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUrl) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUrl) GetType() string {
	return TypeSearchMessagesFilterUrl
}

func (*SearchMessagesFilterUrl) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUrl
}

// Returns only messages containing chat photos
type SearchMessagesFilterChatPhoto struct {
	meta
}

func (entity *SearchMessagesFilterChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterChatPhoto) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterChatPhoto) GetType() string {
	return TypeSearchMessagesFilterChatPhoto
}

func (*SearchMessagesFilterChatPhoto) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterChatPhoto
}

// Returns only video note messages
type SearchMessagesFilterVideoNote struct {
	meta
}

func (entity *SearchMessagesFilterVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVideoNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVideoNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVideoNote) GetType() string {
	return TypeSearchMessagesFilterVideoNote
}

func (*SearchMessagesFilterVideoNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVideoNote
}

// Returns only voice and video note messages
type SearchMessagesFilterVoiceAndVideoNote struct {
	meta
}

func (entity *SearchMessagesFilterVoiceAndVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVoiceAndVideoNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVoiceAndVideoNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVoiceAndVideoNote) GetType() string {
	return TypeSearchMessagesFilterVoiceAndVideoNote
}

func (*SearchMessagesFilterVoiceAndVideoNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVoiceAndVideoNote
}

// Returns only messages with mentions of the current user, or messages that are replies to their messages
type SearchMessagesFilterMention struct {
	meta
}

func (entity *SearchMessagesFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterMention

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterMention) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterMention) GetType() string {
	return TypeSearchMessagesFilterMention
}

func (*SearchMessagesFilterMention) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterMention
}

// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
type SearchMessagesFilterUnreadMention struct {
	meta
}

func (entity *SearchMessagesFilterUnreadMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUnreadMention

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUnreadMention) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUnreadMention) GetType() string {
	return TypeSearchMessagesFilterUnreadMention
}

func (*SearchMessagesFilterUnreadMention) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUnreadMention
}

// Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
type SearchMessagesFilterUnreadReaction struct {
	meta
}

func (entity *SearchMessagesFilterUnreadReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUnreadReaction

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUnreadReaction) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUnreadReaction) GetType() string {
	return TypeSearchMessagesFilterUnreadReaction
}

func (*SearchMessagesFilterUnreadReaction) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUnreadReaction
}

// Returns only failed to send messages. This filter can be used only if the message database is used
type SearchMessagesFilterFailedToSend struct {
	meta
}

func (entity *SearchMessagesFilterFailedToSend) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterFailedToSend

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterFailedToSend) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterFailedToSend) GetType() string {
	return TypeSearchMessagesFilterFailedToSend
}

func (*SearchMessagesFilterFailedToSend) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterFailedToSend
}

// Returns only pinned messages
type SearchMessagesFilterPinned struct {
	meta
}

func (entity *SearchMessagesFilterPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPinned

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPinned) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPinned) GetType() string {
	return TypeSearchMessagesFilterPinned
}

func (*SearchMessagesFilterPinned) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPinned
}

// The user is typing a message
type ChatActionTyping struct {
	meta
}

func (entity *ChatActionTyping) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionTyping

	return json.Marshal((*stub)(entity))
}

func (*ChatActionTyping) GetClass() string {
	return ClassChatAction
}

func (*ChatActionTyping) GetType() string {
	return TypeChatActionTyping
}

func (*ChatActionTyping) ChatActionType() string {
	return TypeChatActionTyping
}

// The user is recording a video
type ChatActionRecordingVideo struct {
	meta
}

func (entity *ChatActionRecordingVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVideo

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVideo) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVideo) GetType() string {
	return TypeChatActionRecordingVideo
}

func (*ChatActionRecordingVideo) ChatActionType() string {
	return TypeChatActionRecordingVideo
}

// The user is uploading a video
type ChatActionUploadingVideo struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVideo

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVideo) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVideo) GetType() string {
	return TypeChatActionUploadingVideo
}

func (*ChatActionUploadingVideo) ChatActionType() string {
	return TypeChatActionUploadingVideo
}

// The user is recording a voice note
type ChatActionRecordingVoiceNote struct {
	meta
}

func (entity *ChatActionRecordingVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVoiceNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVoiceNote) GetType() string {
	return TypeChatActionRecordingVoiceNote
}

func (*ChatActionRecordingVoiceNote) ChatActionType() string {
	return TypeChatActionRecordingVoiceNote
}

// The user is uploading a voice note
type ChatActionUploadingVoiceNote struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVoiceNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVoiceNote) GetType() string {
	return TypeChatActionUploadingVoiceNote
}

func (*ChatActionUploadingVoiceNote) ChatActionType() string {
	return TypeChatActionUploadingVoiceNote
}

// The user is uploading a photo
type ChatActionUploadingPhoto struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingPhoto

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingPhoto) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingPhoto) GetType() string {
	return TypeChatActionUploadingPhoto
}

func (*ChatActionUploadingPhoto) ChatActionType() string {
	return TypeChatActionUploadingPhoto
}

// The user is uploading a document
type ChatActionUploadingDocument struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingDocument

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingDocument) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingDocument) GetType() string {
	return TypeChatActionUploadingDocument
}

func (*ChatActionUploadingDocument) ChatActionType() string {
	return TypeChatActionUploadingDocument
}

// The user is picking a sticker to send
type ChatActionChoosingSticker struct {
	meta
}

func (entity *ChatActionChoosingSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingSticker

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingSticker) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingSticker) GetType() string {
	return TypeChatActionChoosingSticker
}

func (*ChatActionChoosingSticker) ChatActionType() string {
	return TypeChatActionChoosingSticker
}

// The user is picking a location or venue to send
type ChatActionChoosingLocation struct {
	meta
}

func (entity *ChatActionChoosingLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingLocation) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingLocation) GetType() string {
	return TypeChatActionChoosingLocation
}

func (*ChatActionChoosingLocation) ChatActionType() string {
	return TypeChatActionChoosingLocation
}

// The user is picking a contact to send
type ChatActionChoosingContact struct {
	meta
}

func (entity *ChatActionChoosingContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingContact

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingContact) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingContact) GetType() string {
	return TypeChatActionChoosingContact
}

func (*ChatActionChoosingContact) ChatActionType() string {
	return TypeChatActionChoosingContact
}

// The user has started to play a game
type ChatActionStartPlayingGame struct {
	meta
}

func (entity *ChatActionStartPlayingGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionStartPlayingGame

	return json.Marshal((*stub)(entity))
}

func (*ChatActionStartPlayingGame) GetClass() string {
	return ClassChatAction
}

func (*ChatActionStartPlayingGame) GetType() string {
	return TypeChatActionStartPlayingGame
}

func (*ChatActionStartPlayingGame) ChatActionType() string {
	return TypeChatActionStartPlayingGame
}

// The user is recording a video note
type ChatActionRecordingVideoNote struct {
	meta
}

func (entity *ChatActionRecordingVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVideoNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVideoNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVideoNote) GetType() string {
	return TypeChatActionRecordingVideoNote
}

func (*ChatActionRecordingVideoNote) ChatActionType() string {
	return TypeChatActionRecordingVideoNote
}

// The user is uploading a video note
type ChatActionUploadingVideoNote struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVideoNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVideoNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVideoNote) GetType() string {
	return TypeChatActionUploadingVideoNote
}

func (*ChatActionUploadingVideoNote) ChatActionType() string {
	return TypeChatActionUploadingVideoNote
}

// The user is watching animations sent by the other party by clicking on an animated emoji
type ChatActionWatchingAnimations struct {
	meta
	// The animated emoji
	Emoji string `json:"emoji"`
}

func (entity *ChatActionWatchingAnimations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionWatchingAnimations

	return json.Marshal((*stub)(entity))
}

func (*ChatActionWatchingAnimations) GetClass() string {
	return ClassChatAction
}

func (*ChatActionWatchingAnimations) GetType() string {
	return TypeChatActionWatchingAnimations
}

func (*ChatActionWatchingAnimations) ChatActionType() string {
	return TypeChatActionWatchingAnimations
}

// The user has canceled the previous action
type ChatActionCancel struct {
	meta
}

func (entity *ChatActionCancel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionCancel

	return json.Marshal((*stub)(entity))
}

func (*ChatActionCancel) GetClass() string {
	return ClassChatAction
}

func (*ChatActionCancel) GetType() string {
	return TypeChatActionCancel
}

func (*ChatActionCancel) ChatActionType() string {
	return TypeChatActionCancel
}

// The user status was never changed
type UserStatusEmpty struct {
	meta
}

func (entity *UserStatusEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusEmpty

	return json.Marshal((*stub)(entity))
}

func (*UserStatusEmpty) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusEmpty) GetType() string {
	return TypeUserStatusEmpty
}

func (*UserStatusEmpty) UserStatusType() string {
	return TypeUserStatusEmpty
}

// The user is online
type UserStatusOnline struct {
	meta
	// Point in time (Unix timestamp) when the user's online status will expire
	Expires int32 `json:"expires"`
}

func (entity *UserStatusOnline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusOnline

	return json.Marshal((*stub)(entity))
}

func (*UserStatusOnline) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusOnline) GetType() string {
	return TypeUserStatusOnline
}

func (*UserStatusOnline) UserStatusType() string {
	return TypeUserStatusOnline
}

// The user is offline
type UserStatusOffline struct {
	meta
	// Point in time (Unix timestamp) when the user was last online
	WasOnline int32 `json:"was_online"`
}

func (entity *UserStatusOffline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusOffline

	return json.Marshal((*stub)(entity))
}

func (*UserStatusOffline) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusOffline) GetType() string {
	return TypeUserStatusOffline
}

func (*UserStatusOffline) UserStatusType() string {
	return TypeUserStatusOffline
}

// The user was online recently
type UserStatusRecently struct {
	meta
}

func (entity *UserStatusRecently) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusRecently

	return json.Marshal((*stub)(entity))
}

func (*UserStatusRecently) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusRecently) GetType() string {
	return TypeUserStatusRecently
}

func (*UserStatusRecently) UserStatusType() string {
	return TypeUserStatusRecently
}

// The user is offline, but was online last week
type UserStatusLastWeek struct {
	meta
}

func (entity *UserStatusLastWeek) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusLastWeek

	return json.Marshal((*stub)(entity))
}

func (*UserStatusLastWeek) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusLastWeek) GetType() string {
	return TypeUserStatusLastWeek
}

func (*UserStatusLastWeek) UserStatusType() string {
	return TypeUserStatusLastWeek
}

// The user is offline, but was online last month
type UserStatusLastMonth struct {
	meta
}

func (entity *UserStatusLastMonth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusLastMonth

	return json.Marshal((*stub)(entity))
}

func (*UserStatusLastMonth) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusLastMonth) GetType() string {
	return TypeUserStatusLastMonth
}

func (*UserStatusLastMonth) UserStatusType() string {
	return TypeUserStatusLastMonth
}

// Represents a list of stickers
type Stickers struct {
	meta
	// List of stickers
	Stickers []*Sticker `json:"stickers"`
}

func (entity *Stickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Stickers

	return json.Marshal((*stub)(entity))
}

func (*Stickers) GetClass() string {
	return ClassStickers
}

func (*Stickers) GetType() string {
	return TypeStickers
}

// Represents a list of emoji
type Emojis struct {
	meta
	// List of emojis
	Emojis []string `json:"emojis"`
}

func (entity *Emojis) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Emojis

	return json.Marshal((*stub)(entity))
}

func (*Emojis) GetClass() string {
	return ClassEmojis
}

func (*Emojis) GetType() string {
	return TypeEmojis
}

// Represents a sticker set
type StickerSet struct {
	meta
	// Identifier of the sticker set
	Id JsonInt64 `json:"id"`
	// Title of the sticker set
	Title string `json:"title"`
	// Name of the sticker set
	Name string `json:"name"`
	// Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
	ThumbnailOutline []*ClosedVectorPath `json:"thumbnail_outline"`
	// True, if the sticker set has been installed by the current user
	IsInstalled bool `json:"is_installed"`
	// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsArchived bool `json:"is_archived"`
	// True, if the sticker set is official
	IsOfficial bool `json:"is_official"`
	// Format of the stickers in the set
	StickerFormat StickerFormat `json:"sticker_format"`
	// Type of the stickers in the set
	StickerType StickerType `json:"sticker_type"`
	// True for already viewed trending sticker sets
	IsViewed bool `json:"is_viewed"`
	// List of stickers in this set
	Stickers []*Sticker `json:"stickers"`
	// A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
	Emojis []*Emojis `json:"emojis"`
}

func (entity *StickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSet

	return json.Marshal((*stub)(entity))
}

func (*StickerSet) GetClass() string {
	return ClassStickerSet
}

func (*StickerSet) GetType() string {
	return TypeStickerSet
}

func (stickerSet *StickerSet) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id               JsonInt64           `json:"id"`
		Title            string              `json:"title"`
		Name             string              `json:"name"`
		Thumbnail        *Thumbnail          `json:"thumbnail"`
		ThumbnailOutline []*ClosedVectorPath `json:"thumbnail_outline"`
		IsInstalled      bool                `json:"is_installed"`
		IsArchived       bool                `json:"is_archived"`
		IsOfficial       bool                `json:"is_official"`
		StickerFormat    json.RawMessage     `json:"sticker_format"`
		StickerType      json.RawMessage     `json:"sticker_type"`
		IsViewed         bool                `json:"is_viewed"`
		Stickers         []*Sticker          `json:"stickers"`
		Emojis           []*Emojis           `json:"emojis"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	stickerSet.Id = tmp.Id
	stickerSet.Title = tmp.Title
	stickerSet.Name = tmp.Name
	stickerSet.Thumbnail = tmp.Thumbnail
	stickerSet.ThumbnailOutline = tmp.ThumbnailOutline
	stickerSet.IsInstalled = tmp.IsInstalled
	stickerSet.IsArchived = tmp.IsArchived
	stickerSet.IsOfficial = tmp.IsOfficial
	stickerSet.IsViewed = tmp.IsViewed
	stickerSet.Stickers = tmp.Stickers
	stickerSet.Emojis = tmp.Emojis

	fieldStickerFormat, _ := UnmarshalStickerFormat(tmp.StickerFormat)
	stickerSet.StickerFormat = fieldStickerFormat

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	stickerSet.StickerType = fieldStickerType

	return nil
}

// Represents short information about a sticker set
type StickerSetInfo struct {
	meta
	// Identifier of the sticker set
	Id JsonInt64 `json:"id"`
	// Title of the sticker set
	Title string `json:"title"`
	// Name of the sticker set
	Name string `json:"name"`
	// Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
	ThumbnailOutline []*ClosedVectorPath `json:"thumbnail_outline"`
	// True, if the sticker set has been installed by the current user
	IsInstalled bool `json:"is_installed"`
	// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsArchived bool `json:"is_archived"`
	// True, if the sticker set is official
	IsOfficial bool `json:"is_official"`
	// Format of the stickers in the set
	StickerFormat StickerFormat `json:"sticker_format"`
	// Type of the stickers in the set
	StickerType StickerType `json:"sticker_type"`
	// True for already viewed trending sticker sets
	IsViewed bool `json:"is_viewed"`
	// Total number of stickers in the set
	Size int32 `json:"size"`
	// Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
	Covers []*Sticker `json:"covers"`
}

func (entity *StickerSetInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSetInfo

	return json.Marshal((*stub)(entity))
}

func (*StickerSetInfo) GetClass() string {
	return ClassStickerSetInfo
}

func (*StickerSetInfo) GetType() string {
	return TypeStickerSetInfo
}

func (stickerSetInfo *StickerSetInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id               JsonInt64           `json:"id"`
		Title            string              `json:"title"`
		Name             string              `json:"name"`
		Thumbnail        *Thumbnail          `json:"thumbnail"`
		ThumbnailOutline []*ClosedVectorPath `json:"thumbnail_outline"`
		IsInstalled      bool                `json:"is_installed"`
		IsArchived       bool                `json:"is_archived"`
		IsOfficial       bool                `json:"is_official"`
		StickerFormat    json.RawMessage     `json:"sticker_format"`
		StickerType      json.RawMessage     `json:"sticker_type"`
		IsViewed         bool                `json:"is_viewed"`
		Size             int32               `json:"size"`
		Covers           []*Sticker          `json:"covers"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	stickerSetInfo.Id = tmp.Id
	stickerSetInfo.Title = tmp.Title
	stickerSetInfo.Name = tmp.Name
	stickerSetInfo.Thumbnail = tmp.Thumbnail
	stickerSetInfo.ThumbnailOutline = tmp.ThumbnailOutline
	stickerSetInfo.IsInstalled = tmp.IsInstalled
	stickerSetInfo.IsArchived = tmp.IsArchived
	stickerSetInfo.IsOfficial = tmp.IsOfficial
	stickerSetInfo.IsViewed = tmp.IsViewed
	stickerSetInfo.Size = tmp.Size
	stickerSetInfo.Covers = tmp.Covers

	fieldStickerFormat, _ := UnmarshalStickerFormat(tmp.StickerFormat)
	stickerSetInfo.StickerFormat = fieldStickerFormat

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	stickerSetInfo.StickerType = fieldStickerType

	return nil
}

// Represents a list of sticker sets
type StickerSets struct {
	meta
	// Approximate total number of sticker sets found
	TotalCount int32 `json:"total_count"`
	// List of sticker sets
	Sets []*StickerSetInfo `json:"sets"`
}

func (entity *StickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSets

	return json.Marshal((*stub)(entity))
}

func (*StickerSets) GetClass() string {
	return ClassStickerSets
}

func (*StickerSets) GetType() string {
	return TypeStickerSets
}

// Represents a list of trending sticker sets
type TrendingStickerSets struct {
	meta
	// Approximate total number of trending sticker sets
	TotalCount int32 `json:"total_count"`
	// List of trending sticker sets
	Sets []*StickerSetInfo `json:"sets"`
	// True, if the list contains sticker sets with premium stickers
	IsPremium bool `json:"is_premium"`
}

func (entity *TrendingStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TrendingStickerSets

	return json.Marshal((*stub)(entity))
}

func (*TrendingStickerSets) GetClass() string {
	return ClassTrendingStickerSets
}

func (*TrendingStickerSets) GetType() string {
	return TypeTrendingStickerSets
}

// Contains a list of similar emoji to search for in getStickers and searchStickers
type EmojiCategory struct {
	meta
	// Name of the category
	Name string `json:"name"`
	// Custom emoji sticker, which represents icon of the category
	Icon *Sticker `json:"icon"`
	// List of emojis in the category
	Emojis []string `json:"emojis"`
}

func (entity *EmojiCategory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategory

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategory) GetClass() string {
	return ClassEmojiCategory
}

func (*EmojiCategory) GetType() string {
	return TypeEmojiCategory
}

// Represents a list of emoji categories
type EmojiCategories struct {
	meta
	// List of categories
	Categories []*EmojiCategory `json:"categories"`
}

func (entity *EmojiCategories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategories

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategories) GetClass() string {
	return ClassEmojiCategories
}

func (*EmojiCategories) GetType() string {
	return TypeEmojiCategories
}

// The category must be used by default
type EmojiCategoryTypeDefault struct {
	meta
}

func (entity *EmojiCategoryTypeDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeDefault

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeDefault) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeDefault) GetType() string {
	return TypeEmojiCategoryTypeDefault
}

func (*EmojiCategoryTypeDefault) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeDefault
}

// The category must be used for emoji status selection
type EmojiCategoryTypeEmojiStatus struct {
	meta
}

func (entity *EmojiCategoryTypeEmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeEmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeEmojiStatus) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeEmojiStatus) GetType() string {
	return TypeEmojiCategoryTypeEmojiStatus
}

func (*EmojiCategoryTypeEmojiStatus) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeEmojiStatus
}

// The category must be used for chat photo emoji selection
type EmojiCategoryTypeChatPhoto struct {
	meta
}

func (entity *EmojiCategoryTypeChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeChatPhoto) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeChatPhoto) GetType() string {
	return TypeEmojiCategoryTypeChatPhoto
}

func (*EmojiCategoryTypeChatPhoto) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeChatPhoto
}

// The call wasn't discarded, or the reason is unknown
type CallDiscardReasonEmpty struct {
	meta
}

func (entity *CallDiscardReasonEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonEmpty

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonEmpty) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonEmpty) GetType() string {
	return TypeCallDiscardReasonEmpty
}

func (*CallDiscardReasonEmpty) CallDiscardReasonType() string {
	return TypeCallDiscardReasonEmpty
}

// The call was ended before the conversation started. It was canceled by the caller or missed by the other party
type CallDiscardReasonMissed struct {
	meta
}

func (entity *CallDiscardReasonMissed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonMissed

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonMissed) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonMissed) GetType() string {
	return TypeCallDiscardReasonMissed
}

func (*CallDiscardReasonMissed) CallDiscardReasonType() string {
	return TypeCallDiscardReasonMissed
}

// The call was ended before the conversation started. It was declined by the other party
type CallDiscardReasonDeclined struct {
	meta
}

func (entity *CallDiscardReasonDeclined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonDeclined

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonDeclined) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonDeclined) GetType() string {
	return TypeCallDiscardReasonDeclined
}

func (*CallDiscardReasonDeclined) CallDiscardReasonType() string {
	return TypeCallDiscardReasonDeclined
}

// The call was ended during the conversation because the users were disconnected
type CallDiscardReasonDisconnected struct {
	meta
}

func (entity *CallDiscardReasonDisconnected) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonDisconnected

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonDisconnected) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonDisconnected) GetType() string {
	return TypeCallDiscardReasonDisconnected
}

func (*CallDiscardReasonDisconnected) CallDiscardReasonType() string {
	return TypeCallDiscardReasonDisconnected
}

// The call was ended because one of the parties hung up
type CallDiscardReasonHungUp struct {
	meta
}

func (entity *CallDiscardReasonHungUp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonHungUp

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonHungUp) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonHungUp) GetType() string {
	return TypeCallDiscardReasonHungUp
}

func (*CallDiscardReasonHungUp) CallDiscardReasonType() string {
	return TypeCallDiscardReasonHungUp
}

// Specifies the supported call protocols
type CallProtocol struct {
	meta
	// True, if UDP peer-to-peer connections are supported
	UdpP2p bool `json:"udp_p2p"`
	// True, if connection through UDP reflectors is supported
	UdpReflector bool `json:"udp_reflector"`
	// The minimum supported API layer; use 65
	MinLayer int32 `json:"min_layer"`
	// The maximum supported API layer; use 65
	MaxLayer int32 `json:"max_layer"`
	// List of supported tgcalls versions
	LibraryVersions []string `json:"library_versions"`
}

func (entity *CallProtocol) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProtocol

	return json.Marshal((*stub)(entity))
}

func (*CallProtocol) GetClass() string {
	return ClassCallProtocol
}

func (*CallProtocol) GetType() string {
	return TypeCallProtocol
}

// A Telegram call reflector
type CallServerTypeTelegramReflector struct {
	meta
	// A peer tag to be used with the reflector
	PeerTag []byte `json:"peer_tag"`
	// True, if the server uses TCP instead of UDP
	IsTcp bool `json:"is_tcp"`
}

func (entity *CallServerTypeTelegramReflector) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallServerTypeTelegramReflector

	return json.Marshal((*stub)(entity))
}

func (*CallServerTypeTelegramReflector) GetClass() string {
	return ClassCallServerType
}

func (*CallServerTypeTelegramReflector) GetType() string {
	return TypeCallServerTypeTelegramReflector
}

func (*CallServerTypeTelegramReflector) CallServerTypeType() string {
	return TypeCallServerTypeTelegramReflector
}

// A WebRTC server
type CallServerTypeWebrtc struct {
	meta
	// Username to be used for authentication
	Username string `json:"username"`
	// Authentication password
	Password string `json:"password"`
	// True, if the server supports TURN
	SupportsTurn bool `json:"supports_turn"`
	// True, if the server supports STUN
	SupportsStun bool `json:"supports_stun"`
}

func (entity *CallServerTypeWebrtc) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallServerTypeWebrtc

	return json.Marshal((*stub)(entity))
}

func (*CallServerTypeWebrtc) GetClass() string {
	return ClassCallServerType
}

func (*CallServerTypeWebrtc) GetType() string {
	return TypeCallServerTypeWebrtc
}

func (*CallServerTypeWebrtc) CallServerTypeType() string {
	return TypeCallServerTypeWebrtc
}

// Describes a server for relaying call data
type CallServer struct {
	meta
	// Server identifier
	Id JsonInt64 `json:"id"`
	// Server IPv4 address
	IpAddress string `json:"ip_address"`
	// Server IPv6 address
	Ipv6Address string `json:"ipv6_address"`
	// Server port number
	Port int32 `json:"port"`
	// Server type
	Type CallServerType `json:"type"`
}

func (entity *CallServer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallServer

	return json.Marshal((*stub)(entity))
}

func (*CallServer) GetClass() string {
	return ClassCallServer
}

func (*CallServer) GetType() string {
	return TypeCallServer
}

func (callServer *CallServer) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id          JsonInt64       `json:"id"`
		IpAddress   string          `json:"ip_address"`
		Ipv6Address string          `json:"ipv6_address"`
		Port        int32           `json:"port"`
		Type        json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	callServer.Id = tmp.Id
	callServer.IpAddress = tmp.IpAddress
	callServer.Ipv6Address = tmp.Ipv6Address
	callServer.Port = tmp.Port

	fieldType, _ := UnmarshalCallServerType(tmp.Type)
	callServer.Type = fieldType

	return nil
}

// Contains the call identifier
type CallId struct {
	meta
	// Call identifier
	Id int32 `json:"id"`
}

func (entity *CallId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallId

	return json.Marshal((*stub)(entity))
}

func (*CallId) GetClass() string {
	return ClassCallId
}

func (*CallId) GetType() string {
	return TypeCallId
}

// Contains the group call identifier
type GroupCallId struct {
	meta
	// Group call identifier
	Id int32 `json:"id"`
}

func (entity *GroupCallId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallId

	return json.Marshal((*stub)(entity))
}

func (*GroupCallId) GetClass() string {
	return ClassGroupCallId
}

func (*GroupCallId) GetType() string {
	return TypeGroupCallId
}

// The call is pending, waiting to be accepted by a user
type CallStatePending struct {
	meta
	// True, if the call has already been created by the server
	IsCreated bool `json:"is_created"`
	// True, if the call has already been received by the other party
	IsReceived bool `json:"is_received"`
}

func (entity *CallStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStatePending

	return json.Marshal((*stub)(entity))
}

func (*CallStatePending) GetClass() string {
	return ClassCallState
}

func (*CallStatePending) GetType() string {
	return TypeCallStatePending
}

func (*CallStatePending) CallStateType() string {
	return TypeCallStatePending
}

// The call has been answered and encryption keys are being exchanged
type CallStateExchangingKeys struct {
	meta
}

func (entity *CallStateExchangingKeys) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateExchangingKeys

	return json.Marshal((*stub)(entity))
}

func (*CallStateExchangingKeys) GetClass() string {
	return ClassCallState
}

func (*CallStateExchangingKeys) GetType() string {
	return TypeCallStateExchangingKeys
}

func (*CallStateExchangingKeys) CallStateType() string {
	return TypeCallStateExchangingKeys
}

// The call is ready to use
type CallStateReady struct {
	meta
	// Call protocols supported by the peer
	Protocol *CallProtocol `json:"protocol"`
	// List of available call servers
	Servers []*CallServer `json:"servers"`
	// A JSON-encoded call config
	Config string `json:"config"`
	// Call encryption key
	EncryptionKey []byte `json:"encryption_key"`
	// Encryption key emojis fingerprint
	Emojis []string `json:"emojis"`
	// True, if peer-to-peer connection is allowed by users privacy settings
	AllowP2p bool `json:"allow_p2p"`
}

func (entity *CallStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateReady

	return json.Marshal((*stub)(entity))
}

func (*CallStateReady) GetClass() string {
	return ClassCallState
}

func (*CallStateReady) GetType() string {
	return TypeCallStateReady
}

func (*CallStateReady) CallStateType() string {
	return TypeCallStateReady
}

// The call is hanging up after discardCall has been called
type CallStateHangingUp struct {
	meta
}

func (entity *CallStateHangingUp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateHangingUp

	return json.Marshal((*stub)(entity))
}

func (*CallStateHangingUp) GetClass() string {
	return ClassCallState
}

func (*CallStateHangingUp) GetType() string {
	return TypeCallStateHangingUp
}

func (*CallStateHangingUp) CallStateType() string {
	return TypeCallStateHangingUp
}

// The call has ended successfully
type CallStateDiscarded struct {
	meta
	// The reason, why the call has ended
	Reason CallDiscardReason `json:"reason"`
	// True, if the call rating must be sent to the server
	NeedRating bool `json:"need_rating"`
	// True, if the call debug information must be sent to the server
	NeedDebugInformation bool `json:"need_debug_information"`
	// True, if the call log must be sent to the server
	NeedLog bool `json:"need_log"`
}

func (entity *CallStateDiscarded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateDiscarded

	return json.Marshal((*stub)(entity))
}

func (*CallStateDiscarded) GetClass() string {
	return ClassCallState
}

func (*CallStateDiscarded) GetType() string {
	return TypeCallStateDiscarded
}

func (*CallStateDiscarded) CallStateType() string {
	return TypeCallStateDiscarded
}

func (callStateDiscarded *CallStateDiscarded) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Reason               json.RawMessage `json:"reason"`
		NeedRating           bool            `json:"need_rating"`
		NeedDebugInformation bool            `json:"need_debug_information"`
		NeedLog              bool            `json:"need_log"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	callStateDiscarded.NeedRating = tmp.NeedRating
	callStateDiscarded.NeedDebugInformation = tmp.NeedDebugInformation
	callStateDiscarded.NeedLog = tmp.NeedLog

	fieldReason, _ := UnmarshalCallDiscardReason(tmp.Reason)
	callStateDiscarded.Reason = fieldReason

	return nil
}

// The call has ended with an error
type CallStateError struct {
	meta
	// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
	Error *Error `json:"error"`
}

func (entity *CallStateError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateError

	return json.Marshal((*stub)(entity))
}

func (*CallStateError) GetClass() string {
	return ClassCallState
}

func (*CallStateError) GetType() string {
	return TypeCallStateError
}

func (*CallStateError) CallStateType() string {
	return TypeCallStateError
}

// The worst available video quality
type GroupCallVideoQualityThumbnail struct {
	meta
}

func (entity *GroupCallVideoQualityThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoQualityThumbnail

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoQualityThumbnail) GetClass() string {
	return ClassGroupCallVideoQuality
}

func (*GroupCallVideoQualityThumbnail) GetType() string {
	return TypeGroupCallVideoQualityThumbnail
}

func (*GroupCallVideoQualityThumbnail) GroupCallVideoQualityType() string {
	return TypeGroupCallVideoQualityThumbnail
}

// The medium video quality
type GroupCallVideoQualityMedium struct {
	meta
}

func (entity *GroupCallVideoQualityMedium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoQualityMedium

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoQualityMedium) GetClass() string {
	return ClassGroupCallVideoQuality
}

func (*GroupCallVideoQualityMedium) GetType() string {
	return TypeGroupCallVideoQualityMedium
}

func (*GroupCallVideoQualityMedium) GroupCallVideoQualityType() string {
	return TypeGroupCallVideoQualityMedium
}

// The best available video quality
type GroupCallVideoQualityFull struct {
	meta
}

func (entity *GroupCallVideoQualityFull) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoQualityFull

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoQualityFull) GetClass() string {
	return ClassGroupCallVideoQuality
}

func (*GroupCallVideoQualityFull) GetType() string {
	return TypeGroupCallVideoQualityFull
}

func (*GroupCallVideoQualityFull) GroupCallVideoQualityType() string {
	return TypeGroupCallVideoQualityFull
}

// Describes an available stream in a group call
type GroupCallStream struct {
	meta
	// Identifier of an audio/video channel
	ChannelId int32 `json:"channel_id"`
	// Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
	Scale int32 `json:"scale"`
	// Point in time when the stream currently ends; Unix timestamp in milliseconds
	TimeOffset int64 `json:"time_offset"`
}

func (entity *GroupCallStream) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallStream

	return json.Marshal((*stub)(entity))
}

func (*GroupCallStream) GetClass() string {
	return ClassGroupCallStream
}

func (*GroupCallStream) GetType() string {
	return TypeGroupCallStream
}

// Represents a list of group call streams
type GroupCallStreams struct {
	meta
	// A list of group call streams
	Streams []*GroupCallStream `json:"streams"`
}

func (entity *GroupCallStreams) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallStreams

	return json.Marshal((*stub)(entity))
}

func (*GroupCallStreams) GetClass() string {
	return ClassGroupCallStreams
}

func (*GroupCallStreams) GetType() string {
	return TypeGroupCallStreams
}

// Represents an RTMP URL
type RtmpUrl struct {
	meta
	// The URL
	Url string `json:"url"`
	// Stream key
	StreamKey string `json:"stream_key"`
}

func (entity *RtmpUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RtmpUrl

	return json.Marshal((*stub)(entity))
}

func (*RtmpUrl) GetClass() string {
	return ClassRtmpUrl
}

func (*RtmpUrl) GetType() string {
	return TypeRtmpUrl
}

// Describes a recently speaking participant in a group call
type GroupCallRecentSpeaker struct {
	meta
	// Group call participant identifier
	ParticipantId MessageSender `json:"participant_id"`
	// True, is the user has spoken recently
	IsSpeaking bool `json:"is_speaking"`
}

func (entity *GroupCallRecentSpeaker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallRecentSpeaker

	return json.Marshal((*stub)(entity))
}

func (*GroupCallRecentSpeaker) GetClass() string {
	return ClassGroupCallRecentSpeaker
}

func (*GroupCallRecentSpeaker) GetType() string {
	return TypeGroupCallRecentSpeaker
}

func (groupCallRecentSpeaker *GroupCallRecentSpeaker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId json.RawMessage `json:"participant_id"`
		IsSpeaking    bool            `json:"is_speaking"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	groupCallRecentSpeaker.IsSpeaking = tmp.IsSpeaking

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	groupCallRecentSpeaker.ParticipantId = fieldParticipantId

	return nil
}

// Describes a group call
type GroupCall struct {
	meta
	// Group call identifier
	Id int32 `json:"id"`
	// Group call title
	Title string `json:"title"`
	// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
	ScheduledStartDate int32 `json:"scheduled_start_date"`
	// True, if the group call is scheduled and the current user will receive a notification when the group call will start
	EnabledStartNotification bool `json:"enabled_start_notification"`
	// True, if the call is active
	IsActive bool `json:"is_active"`
	// True, if the chat is an RTMP stream instead of an ordinary video chat
	IsRtmpStream bool `json:"is_rtmp_stream"`
	// True, if the call is joined
	IsJoined bool `json:"is_joined"`
	// True, if user was kicked from the call because of network loss and the call needs to be rejoined
	NeedRejoin bool `json:"need_rejoin"`
	// True, if the current user can manage the group call
	CanBeManaged bool `json:"can_be_managed"`
	// Number of participants in the group call
	ParticipantCount int32 `json:"participant_count"`
	// True, if group call participants, which are muted, aren't returned in participant list
	HasHiddenListeners bool `json:"has_hidden_listeners"`
	// True, if all group call participants are loaded
	LoadedAllParticipants bool `json:"loaded_all_participants"`
	// At most 3 recently speaking users in the group call
	RecentSpeakers []*GroupCallRecentSpeaker `json:"recent_speakers"`
	// True, if the current user's video is enabled
	IsMyVideoEnabled bool `json:"is_my_video_enabled"`
	// True, if the current user's video is paused
	IsMyVideoPaused bool `json:"is_my_video_paused"`
	// True, if the current user can broadcast video or share screen
	CanEnableVideo bool `json:"can_enable_video"`
	// True, if only group call administrators can unmute new participants
	MuteNewParticipants bool `json:"mute_new_participants"`
	// True, if the current user can enable or disable mute_new_participants setting
	CanToggleMuteNewParticipants bool `json:"can_toggle_mute_new_participants"`
	// Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
	RecordDuration int32 `json:"record_duration"`
	// True, if a video file is being recorded for the call
	IsVideoRecorded bool `json:"is_video_recorded"`
	// Call duration, in seconds; for ended calls only
	Duration int32 `json:"duration"`
}

func (entity *GroupCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCall

	return json.Marshal((*stub)(entity))
}

func (*GroupCall) GetClass() string {
	return ClassGroupCall
}

func (*GroupCall) GetType() string {
	return TypeGroupCall
}

// Describes a group of video synchronization source identifiers
type GroupCallVideoSourceGroup struct {
	meta
	// The semantics of sources, one of "SIM" or "FID"
	Semantics string `json:"semantics"`
	// The list of synchronization source identifiers
	SourceIds []int32 `json:"source_ids"`
}

func (entity *GroupCallVideoSourceGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoSourceGroup

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoSourceGroup) GetClass() string {
	return ClassGroupCallVideoSourceGroup
}

func (*GroupCallVideoSourceGroup) GetType() string {
	return TypeGroupCallVideoSourceGroup
}

// Contains information about a group call participant's video channel
type GroupCallParticipantVideoInfo struct {
	meta
	// List of synchronization source groups of the video
	SourceGroups []*GroupCallVideoSourceGroup `json:"source_groups"`
	// Video channel endpoint identifier
	EndpointId string `json:"endpoint_id"`
	// True, if the video is paused. This flag needs to be ignored, if new video frames are received
	IsPaused bool `json:"is_paused"`
}

func (entity *GroupCallParticipantVideoInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallParticipantVideoInfo

	return json.Marshal((*stub)(entity))
}

func (*GroupCallParticipantVideoInfo) GetClass() string {
	return ClassGroupCallParticipantVideoInfo
}

func (*GroupCallParticipantVideoInfo) GetType() string {
	return TypeGroupCallParticipantVideoInfo
}

// Represents a group call participant
type GroupCallParticipant struct {
	meta
	// Identifier of the group call participant
	ParticipantId MessageSender `json:"participant_id"`
	// User's audio channel synchronization source identifier
	AudioSourceId int32 `json:"audio_source_id"`
	// User's screen sharing audio channel synchronization source identifier
	ScreenSharingAudioSourceId int32 `json:"screen_sharing_audio_source_id"`
	// Information about user's video channel; may be null if there is no active video
	VideoInfo *GroupCallParticipantVideoInfo `json:"video_info"`
	// Information about user's screen sharing video channel; may be null if there is no active screen sharing video
	ScreenSharingVideoInfo *GroupCallParticipantVideoInfo `json:"screen_sharing_video_info"`
	// The participant user's bio or the participant chat's description
	Bio string `json:"bio"`
	// True, if the participant is the current user
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
	IsSpeaking bool `json:"is_speaking"`
	// True, if the participant hand is raised
	IsHandRaised bool `json:"is_hand_raised"`
	// True, if the current user can mute the participant for all other group call participants
	CanBeMutedForAllUsers bool `json:"can_be_muted_for_all_users"`
	// True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
	CanBeUnmutedForAllUsers bool `json:"can_be_unmuted_for_all_users"`
	// True, if the current user can mute the participant only for self
	CanBeMutedForCurrentUser bool `json:"can_be_muted_for_current_user"`
	// True, if the current user can unmute the participant for self
	CanBeUnmutedForCurrentUser bool `json:"can_be_unmuted_for_current_user"`
	// True, if the participant is muted for all users
	IsMutedForAllUsers bool `json:"is_muted_for_all_users"`
	// True, if the participant is muted for the current user
	IsMutedForCurrentUser bool `json:"is_muted_for_current_user"`
	// True, if the participant is muted for all users, but can unmute themselves
	CanUnmuteSelf bool `json:"can_unmute_self"`
	// Participant's volume level; 1-20000 in hundreds of percents
	VolumeLevel int32 `json:"volume_level"`
	// User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
	Order string `json:"order"`
}

func (entity *GroupCallParticipant) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallParticipant

	return json.Marshal((*stub)(entity))
}

func (*GroupCallParticipant) GetClass() string {
	return ClassGroupCallParticipant
}

func (*GroupCallParticipant) GetType() string {
	return TypeGroupCallParticipant
}

func (groupCallParticipant *GroupCallParticipant) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId              json.RawMessage                `json:"participant_id"`
		AudioSourceId              int32                          `json:"audio_source_id"`
		ScreenSharingAudioSourceId int32                          `json:"screen_sharing_audio_source_id"`
		VideoInfo                  *GroupCallParticipantVideoInfo `json:"video_info"`
		ScreenSharingVideoInfo     *GroupCallParticipantVideoInfo `json:"screen_sharing_video_info"`
		Bio                        string                         `json:"bio"`
		IsCurrentUser              bool                           `json:"is_current_user"`
		IsSpeaking                 bool                           `json:"is_speaking"`
		IsHandRaised               bool                           `json:"is_hand_raised"`
		CanBeMutedForAllUsers      bool                           `json:"can_be_muted_for_all_users"`
		CanBeUnmutedForAllUsers    bool                           `json:"can_be_unmuted_for_all_users"`
		CanBeMutedForCurrentUser   bool                           `json:"can_be_muted_for_current_user"`
		CanBeUnmutedForCurrentUser bool                           `json:"can_be_unmuted_for_current_user"`
		IsMutedForAllUsers         bool                           `json:"is_muted_for_all_users"`
		IsMutedForCurrentUser      bool                           `json:"is_muted_for_current_user"`
		CanUnmuteSelf              bool                           `json:"can_unmute_self"`
		VolumeLevel                int32                          `json:"volume_level"`
		Order                      string                         `json:"order"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	groupCallParticipant.AudioSourceId = tmp.AudioSourceId
	groupCallParticipant.ScreenSharingAudioSourceId = tmp.ScreenSharingAudioSourceId
	groupCallParticipant.VideoInfo = tmp.VideoInfo
	groupCallParticipant.ScreenSharingVideoInfo = tmp.ScreenSharingVideoInfo
	groupCallParticipant.Bio = tmp.Bio
	groupCallParticipant.IsCurrentUser = tmp.IsCurrentUser
	groupCallParticipant.IsSpeaking = tmp.IsSpeaking
	groupCallParticipant.IsHandRaised = tmp.IsHandRaised
	groupCallParticipant.CanBeMutedForAllUsers = tmp.CanBeMutedForAllUsers
	groupCallParticipant.CanBeUnmutedForAllUsers = tmp.CanBeUnmutedForAllUsers
	groupCallParticipant.CanBeMutedForCurrentUser = tmp.CanBeMutedForCurrentUser
	groupCallParticipant.CanBeUnmutedForCurrentUser = tmp.CanBeUnmutedForCurrentUser
	groupCallParticipant.IsMutedForAllUsers = tmp.IsMutedForAllUsers
	groupCallParticipant.IsMutedForCurrentUser = tmp.IsMutedForCurrentUser
	groupCallParticipant.CanUnmuteSelf = tmp.CanUnmuteSelf
	groupCallParticipant.VolumeLevel = tmp.VolumeLevel
	groupCallParticipant.Order = tmp.Order

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	groupCallParticipant.ParticipantId = fieldParticipantId

	return nil
}

// The user heard their own voice
type CallProblemEcho struct {
	meta
}

func (entity *CallProblemEcho) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemEcho

	return json.Marshal((*stub)(entity))
}

func (*CallProblemEcho) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemEcho) GetType() string {
	return TypeCallProblemEcho
}

func (*CallProblemEcho) CallProblemType() string {
	return TypeCallProblemEcho
}

// The user heard background noise
type CallProblemNoise struct {
	meta
}

func (entity *CallProblemNoise) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemNoise

	return json.Marshal((*stub)(entity))
}

func (*CallProblemNoise) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemNoise) GetType() string {
	return TypeCallProblemNoise
}

func (*CallProblemNoise) CallProblemType() string {
	return TypeCallProblemNoise
}

// The other side kept disappearing
type CallProblemInterruptions struct {
	meta
}

func (entity *CallProblemInterruptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemInterruptions

	return json.Marshal((*stub)(entity))
}

func (*CallProblemInterruptions) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemInterruptions) GetType() string {
	return TypeCallProblemInterruptions
}

func (*CallProblemInterruptions) CallProblemType() string {
	return TypeCallProblemInterruptions
}

// The speech was distorted
type CallProblemDistortedSpeech struct {
	meta
}

func (entity *CallProblemDistortedSpeech) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDistortedSpeech

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDistortedSpeech) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDistortedSpeech) GetType() string {
	return TypeCallProblemDistortedSpeech
}

func (*CallProblemDistortedSpeech) CallProblemType() string {
	return TypeCallProblemDistortedSpeech
}

// The user couldn't hear the other side
type CallProblemSilentLocal struct {
	meta
}

func (entity *CallProblemSilentLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemSilentLocal

	return json.Marshal((*stub)(entity))
}

func (*CallProblemSilentLocal) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemSilentLocal) GetType() string {
	return TypeCallProblemSilentLocal
}

func (*CallProblemSilentLocal) CallProblemType() string {
	return TypeCallProblemSilentLocal
}

// The other side couldn't hear the user
type CallProblemSilentRemote struct {
	meta
}

func (entity *CallProblemSilentRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemSilentRemote

	return json.Marshal((*stub)(entity))
}

func (*CallProblemSilentRemote) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemSilentRemote) GetType() string {
	return TypeCallProblemSilentRemote
}

func (*CallProblemSilentRemote) CallProblemType() string {
	return TypeCallProblemSilentRemote
}

// The call ended unexpectedly
type CallProblemDropped struct {
	meta
}

func (entity *CallProblemDropped) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDropped

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDropped) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDropped) GetType() string {
	return TypeCallProblemDropped
}

func (*CallProblemDropped) CallProblemType() string {
	return TypeCallProblemDropped
}

// The video was distorted
type CallProblemDistortedVideo struct {
	meta
}

func (entity *CallProblemDistortedVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDistortedVideo

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDistortedVideo) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDistortedVideo) GetType() string {
	return TypeCallProblemDistortedVideo
}

func (*CallProblemDistortedVideo) CallProblemType() string {
	return TypeCallProblemDistortedVideo
}

// The video was pixelated
type CallProblemPixelatedVideo struct {
	meta
}

func (entity *CallProblemPixelatedVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemPixelatedVideo

	return json.Marshal((*stub)(entity))
}

func (*CallProblemPixelatedVideo) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemPixelatedVideo) GetType() string {
	return TypeCallProblemPixelatedVideo
}

func (*CallProblemPixelatedVideo) CallProblemType() string {
	return TypeCallProblemPixelatedVideo
}

// Describes a call
type Call struct {
	meta
	// Call identifier, not persistent
	Id int32 `json:"id"`
	// Peer user identifier
	UserId int64 `json:"user_id"`
	// True, if the call is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the call is a video call
	IsVideo bool `json:"is_video"`
	// Call state
	State CallState `json:"state"`
}

func (entity *Call) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Call

	return json.Marshal((*stub)(entity))
}

func (*Call) GetClass() string {
	return ClassCall
}

func (*Call) GetType() string {
	return TypeCall
}

func (call *Call) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         int32           `json:"id"`
		UserId     int64           `json:"user_id"`
		IsOutgoing bool            `json:"is_outgoing"`
		IsVideo    bool            `json:"is_video"`
		State      json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	call.Id = tmp.Id
	call.UserId = tmp.UserId
	call.IsOutgoing = tmp.IsOutgoing
	call.IsVideo = tmp.IsVideo

	fieldState, _ := UnmarshalCallState(tmp.State)
	call.State = fieldState

	return nil
}

// Settings for Firebase Authentication in the official Android application
type FirebaseAuthenticationSettingsAndroid struct {
	meta
}

func (entity *FirebaseAuthenticationSettingsAndroid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FirebaseAuthenticationSettingsAndroid

	return json.Marshal((*stub)(entity))
}

func (*FirebaseAuthenticationSettingsAndroid) GetClass() string {
	return ClassFirebaseAuthenticationSettings
}

func (*FirebaseAuthenticationSettingsAndroid) GetType() string {
	return TypeFirebaseAuthenticationSettingsAndroid
}

func (*FirebaseAuthenticationSettingsAndroid) FirebaseAuthenticationSettingsType() string {
	return TypeFirebaseAuthenticationSettingsAndroid
}

// Settings for Firebase Authentication in the official iOS application
type FirebaseAuthenticationSettingsIos struct {
	meta
	// Device token from Apple Push Notification service
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
}

func (entity *FirebaseAuthenticationSettingsIos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FirebaseAuthenticationSettingsIos

	return json.Marshal((*stub)(entity))
}

func (*FirebaseAuthenticationSettingsIos) GetClass() string {
	return ClassFirebaseAuthenticationSettings
}

func (*FirebaseAuthenticationSettingsIos) GetType() string {
	return TypeFirebaseAuthenticationSettingsIos
}

func (*FirebaseAuthenticationSettingsIos) FirebaseAuthenticationSettingsType() string {
	return TypeFirebaseAuthenticationSettingsIos
}

// Contains settings for the authentication of the user's phone number
type PhoneNumberAuthenticationSettings struct {
	meta
	// Pass true if the authentication code may be sent via a flash call to the specified phone number
	AllowFlashCall bool `json:"allow_flash_call"`
	// Pass true if the authentication code may be sent via a missed call to the specified phone number
	AllowMissedCall bool `json:"allow_missed_call"`
	// Pass true if the authenticated phone number is used on the current device
	IsCurrentPhoneNumber bool `json:"is_current_phone_number"`
	// For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
	AllowSmsRetrieverApi bool `json:"allow_sms_retriever_api"`
	// For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication
	FirebaseAuthenticationSettings FirebaseAuthenticationSettings `json:"firebase_authentication_settings"`
	// List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
	AuthenticationTokens []string `json:"authentication_tokens"`
}

func (entity *PhoneNumberAuthenticationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberAuthenticationSettings

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberAuthenticationSettings) GetClass() string {
	return ClassPhoneNumberAuthenticationSettings
}

func (*PhoneNumberAuthenticationSettings) GetType() string {
	return TypePhoneNumberAuthenticationSettings
}

func (phoneNumberAuthenticationSettings *PhoneNumberAuthenticationSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AllowFlashCall                 bool            `json:"allow_flash_call"`
		AllowMissedCall                bool            `json:"allow_missed_call"`
		IsCurrentPhoneNumber           bool            `json:"is_current_phone_number"`
		AllowSmsRetrieverApi           bool            `json:"allow_sms_retriever_api"`
		FirebaseAuthenticationSettings json.RawMessage `json:"firebase_authentication_settings"`
		AuthenticationTokens           []string        `json:"authentication_tokens"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	phoneNumberAuthenticationSettings.AllowFlashCall = tmp.AllowFlashCall
	phoneNumberAuthenticationSettings.AllowMissedCall = tmp.AllowMissedCall
	phoneNumberAuthenticationSettings.IsCurrentPhoneNumber = tmp.IsCurrentPhoneNumber
	phoneNumberAuthenticationSettings.AllowSmsRetrieverApi = tmp.AllowSmsRetrieverApi
	phoneNumberAuthenticationSettings.AuthenticationTokens = tmp.AuthenticationTokens

	fieldFirebaseAuthenticationSettings, _ := UnmarshalFirebaseAuthenticationSettings(tmp.FirebaseAuthenticationSettings)
	phoneNumberAuthenticationSettings.FirebaseAuthenticationSettings = fieldFirebaseAuthenticationSettings

	return nil
}

// Represents a reaction applied to a message
type AddedReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// Identifier of the chat member, applied the reaction
	SenderId MessageSender `json:"sender_id"`
	// Point in time (Unix timestamp) when the reaction was added
	Date int32 `json:"date"`
}

func (entity *AddedReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AddedReaction

	return json.Marshal((*stub)(entity))
}

func (*AddedReaction) GetClass() string {
	return ClassAddedReaction
}

func (*AddedReaction) GetType() string {
	return TypeAddedReaction
}

func (addedReaction *AddedReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type     json.RawMessage `json:"type"`
		SenderId json.RawMessage `json:"sender_id"`
		Date     int32           `json:"date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	addedReaction.Date = tmp.Date

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	addedReaction.Type = fieldType

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	addedReaction.SenderId = fieldSenderId

	return nil
}

// Represents a list of reactions added to a message
type AddedReactions struct {
	meta
	// The total number of found reactions
	TotalCount int32 `json:"total_count"`
	// The list of added reactions
	Reactions []*AddedReaction `json:"reactions"`
	// The offset for the next request. If empty, there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *AddedReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AddedReactions

	return json.Marshal((*stub)(entity))
}

func (*AddedReactions) GetClass() string {
	return ClassAddedReactions
}

func (*AddedReactions) GetType() string {
	return TypeAddedReactions
}

// Represents an available reaction
type AvailableReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// True, if Telegram Premium is needed to send the reaction
	NeedsPremium bool `json:"needs_premium"`
}

func (entity *AvailableReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AvailableReaction

	return json.Marshal((*stub)(entity))
}

func (*AvailableReaction) GetClass() string {
	return ClassAvailableReaction
}

func (*AvailableReaction) GetType() string {
	return TypeAvailableReaction
}

func (availableReaction *AvailableReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type         json.RawMessage `json:"type"`
		NeedsPremium bool            `json:"needs_premium"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	availableReaction.NeedsPremium = tmp.NeedsPremium

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	availableReaction.Type = fieldType

	return nil
}

// Represents a list of reactions that can be added to a message
type AvailableReactions struct {
	meta
	// List of reactions to be shown at the top
	TopReactions []*AvailableReaction `json:"top_reactions"`
	// List of recently used reactions
	RecentReactions []*AvailableReaction `json:"recent_reactions"`
	// List of popular reactions
	PopularReactions []*AvailableReaction `json:"popular_reactions"`
	// True, if custom emoji reactions could be added by Telegram Premium subscribers
	AllowCustomEmoji bool `json:"allow_custom_emoji"`
}

func (entity *AvailableReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AvailableReactions

	return json.Marshal((*stub)(entity))
}

func (*AvailableReactions) GetClass() string {
	return ClassAvailableReactions
}

func (*AvailableReactions) GetType() string {
	return TypeAvailableReactions
}

// Contains information about a emoji reaction
type EmojiReaction struct {
	meta
	// Text representation of the reaction
	Emoji string `json:"emoji"`
	// Reaction title
	Title string `json:"title"`
	// True, if the reaction can be added to new messages and enabled in chats
	IsActive bool `json:"is_active"`
	// Static icon for the reaction
	StaticIcon *Sticker `json:"static_icon"`
	// Appear animation for the reaction
	AppearAnimation *Sticker `json:"appear_animation"`
	// Select animation for the reaction
	SelectAnimation *Sticker `json:"select_animation"`
	// Activate animation for the reaction
	ActivateAnimation *Sticker `json:"activate_animation"`
	// Effect animation for the reaction
	EffectAnimation *Sticker `json:"effect_animation"`
	// Around animation for the reaction; may be null
	AroundAnimation *Sticker `json:"around_animation"`
	// Center animation for the reaction; may be null
	CenterAnimation *Sticker `json:"center_animation"`
}

func (entity *EmojiReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiReaction

	return json.Marshal((*stub)(entity))
}

func (*EmojiReaction) GetClass() string {
	return ClassEmojiReaction
}

func (*EmojiReaction) GetType() string {
	return TypeEmojiReaction
}

// Represents a list of animations
type Animations struct {
	meta
	// List of animations
	Animations []*Animation `json:"animations"`
}

func (entity *Animations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Animations

	return json.Marshal((*stub)(entity))
}

func (*Animations) GetClass() string {
	return ClassAnimations
}

func (*Animations) GetType() string {
	return TypeAnimations
}

// A regular animated sticker
type DiceStickersRegular struct {
	meta
	// The animated sticker with the dice animation
	Sticker *Sticker `json:"sticker"`
}

func (entity *DiceStickersRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DiceStickersRegular

	return json.Marshal((*stub)(entity))
}

func (*DiceStickersRegular) GetClass() string {
	return ClassDiceStickers
}

func (*DiceStickersRegular) GetType() string {
	return TypeDiceStickersRegular
}

func (*DiceStickersRegular) DiceStickersType() string {
	return TypeDiceStickersRegular
}

// Animated stickers to be combined into a slot machine
type DiceStickersSlotMachine struct {
	meta
	// The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
	Background *Sticker `json:"background"`
	// The animated sticker with the lever animation. The lever animation must play once in the initial dice state
	Lever *Sticker `json:"lever"`
	// The animated sticker with the left reel
	LeftReel *Sticker `json:"left_reel"`
	// The animated sticker with the center reel
	CenterReel *Sticker `json:"center_reel"`
	// The animated sticker with the right reel
	RightReel *Sticker `json:"right_reel"`
}

func (entity *DiceStickersSlotMachine) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DiceStickersSlotMachine

	return json.Marshal((*stub)(entity))
}

func (*DiceStickersSlotMachine) GetClass() string {
	return ClassDiceStickers
}

func (*DiceStickersSlotMachine) GetType() string {
	return TypeDiceStickersSlotMachine
}

func (*DiceStickersSlotMachine) DiceStickersType() string {
	return TypeDiceStickersSlotMachine
}

// Represents the result of an importContacts request
type ImportedContacts struct {
	meta
	// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
	UserIds []int64 `json:"user_ids"`
	// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
	ImporterCount []int32 `json:"importer_count"`
}

func (entity *ImportedContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ImportedContacts

	return json.Marshal((*stub)(entity))
}

func (*ImportedContacts) GetClass() string {
	return ClassImportedContacts
}

func (*ImportedContacts) GetType() string {
	return TypeImportedContacts
}

// The speech recognition is ongoing
type SpeechRecognitionResultPending struct {
	meta
	// Partially recognized text
	PartialText string `json:"partial_text"`
}

func (entity *SpeechRecognitionResultPending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SpeechRecognitionResultPending

	return json.Marshal((*stub)(entity))
}

func (*SpeechRecognitionResultPending) GetClass() string {
	return ClassSpeechRecognitionResult
}

func (*SpeechRecognitionResultPending) GetType() string {
	return TypeSpeechRecognitionResultPending
}

func (*SpeechRecognitionResultPending) SpeechRecognitionResultType() string {
	return TypeSpeechRecognitionResultPending
}

// The speech recognition successfully finished
type SpeechRecognitionResultText struct {
	meta
	// Recognized text
	Text string `json:"text"`
}

func (entity *SpeechRecognitionResultText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SpeechRecognitionResultText

	return json.Marshal((*stub)(entity))
}

func (*SpeechRecognitionResultText) GetClass() string {
	return ClassSpeechRecognitionResult
}

func (*SpeechRecognitionResultText) GetType() string {
	return TypeSpeechRecognitionResultText
}

func (*SpeechRecognitionResultText) SpeechRecognitionResultType() string {
	return TypeSpeechRecognitionResultText
}

// The speech recognition failed
type SpeechRecognitionResultError struct {
	meta
	// Received error
	Error *Error `json:"error"`
}

func (entity *SpeechRecognitionResultError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SpeechRecognitionResultError

	return json.Marshal((*stub)(entity))
}

func (*SpeechRecognitionResultError) GetClass() string {
	return ClassSpeechRecognitionResult
}

func (*SpeechRecognitionResultError) GetType() string {
	return TypeSpeechRecognitionResultError
}

func (*SpeechRecognitionResultError) SpeechRecognitionResultType() string {
	return TypeSpeechRecognitionResultError
}

// Describes a color to highlight a bot added to attachment menu
type AttachmentMenuBotColor struct {
	meta
	// Color in the RGB24 format for light themes
	LightColor int32 `json:"light_color"`
	// Color in the RGB24 format for dark themes
	DarkColor int32 `json:"dark_color"`
}

func (entity *AttachmentMenuBotColor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AttachmentMenuBotColor

	return json.Marshal((*stub)(entity))
}

func (*AttachmentMenuBotColor) GetClass() string {
	return ClassAttachmentMenuBotColor
}

func (*AttachmentMenuBotColor) GetType() string {
	return TypeAttachmentMenuBotColor
}

// Represents a bot, which can be added to attachment menu
type AttachmentMenuBot struct {
	meta
	// User identifier of the bot added to attachment menu
	BotUserId int64 `json:"bot_user_id"`
	// True, if the bot supports opening from attachment menu in the chat with the bot
	SupportsSelfChat bool `json:"supports_self_chat"`
	// True, if the bot supports opening from attachment menu in private chats with ordinary users
	SupportsUserChats bool `json:"supports_user_chats"`
	// True, if the bot supports opening from attachment menu in private chats with other bots
	SupportsBotChats bool `json:"supports_bot_chats"`
	// True, if the bot supports opening from attachment menu in basic group and supergroup chats
	SupportsGroupChats bool `json:"supports_group_chats"`
	// True, if the bot supports opening from attachment menu in channel chats
	SupportsChannelChats bool `json:"supports_channel_chats"`
	// True, if the bot supports "settings_button_pressed" event
	SupportsSettings bool `json:"supports_settings"`
	// True, if the user must be asked for the permission to the bot to send them messages
	RequestWriteAccess bool `json:"request_write_access"`
	// Name for the bot in attachment menu
	Name string `json:"name"`
	// Color to highlight selected name of the bot if appropriate; may be null
	NameColor *AttachmentMenuBotColor `json:"name_color"`
	// Default attachment menu icon for the bot in SVG format; may be null
	DefaultIcon *File `json:"default_icon"`
	// Attachment menu icon for the bot in SVG format for the official iOS app; may be null
	IosStaticIcon *File `json:"ios_static_icon"`
	// Attachment menu icon for the bot in TGS format for the official iOS app; may be null
	IosAnimatedIcon *File `json:"ios_animated_icon"`
	// Attachment menu icon for the bot in TGS format for the official Android app; may be null
	AndroidIcon *File `json:"android_icon"`
	// Attachment menu icon for the bot in TGS format for the official native macOS app; may be null
	MacosIcon *File `json:"macos_icon"`
	// Color to highlight selected icon of the bot if appropriate; may be null
	IconColor *AttachmentMenuBotColor `json:"icon_color"`
	// Default placeholder for opened Web Apps in SVG format; may be null
	WebAppPlaceholder *File `json:"web_app_placeholder"`
}

func (entity *AttachmentMenuBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AttachmentMenuBot

	return json.Marshal((*stub)(entity))
}

func (*AttachmentMenuBot) GetClass() string {
	return ClassAttachmentMenuBot
}

func (*AttachmentMenuBot) GetType() string {
	return TypeAttachmentMenuBot
}

// Information about the message sent by answerWebAppQuery
type SentWebAppMessage struct {
	meta
	// Identifier of the sent inline message, if known
	InlineMessageId string `json:"inline_message_id"`
}

func (entity *SentWebAppMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SentWebAppMessage

	return json.Marshal((*stub)(entity))
}

func (*SentWebAppMessage) GetClass() string {
	return ClassSentWebAppMessage
}

func (*SentWebAppMessage) GetType() string {
	return TypeSentWebAppMessage
}

// Contains an HTTP URL
type HttpUrl struct {
	meta
	// The URL
	Url string `json:"url"`
}

func (entity *HttpUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub HttpUrl

	return json.Marshal((*stub)(entity))
}

func (*HttpUrl) GetClass() string {
	return ClassHttpUrl
}

func (*HttpUrl) GetType() string {
	return TypeHttpUrl
}

// Contains an HTTPS URL, which can be used to get information about a user
type UserLink struct {
	meta
	// The URL
	Url string `json:"url"`
	// Left time for which the link is valid, in seconds; 0 if the link is a public username link
	ExpiresIn int32 `json:"expires_in"`
}

func (entity *UserLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserLink

	return json.Marshal((*stub)(entity))
}

func (*UserLink) GetClass() string {
	return ClassUserLink
}

func (*UserLink) GetType() string {
	return TypeUserLink
}

// Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
type InputInlineQueryResultAnimation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the query result
	Title string `json:"title"`
	// URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
	ThumbnailMimeType string `json:"thumbnail_mime_type"`
	// The URL of the video file (file size must not exceed 1MB)
	VideoUrl string `json:"video_url"`
	// MIME type of the video file. Must be one of "image/gif" and "video/mp4"
	VideoMimeType string `json:"video_mime_type"`
	// Duration of the video, in seconds
	VideoDuration int32 `json:"video_duration"`
	// Width of the video
	VideoWidth int32 `json:"video_width"`
	// Height of the video
	VideoHeight int32 `json:"video_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAnimation) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAnimation) GetType() string {
	return TypeInputInlineQueryResultAnimation
}

func (*InputInlineQueryResultAnimation) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAnimation
}

func (inputInlineQueryResultAnimation *InputInlineQueryResultAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailMimeType   string          `json:"thumbnail_mime_type"`
		VideoUrl            string          `json:"video_url"`
		VideoMimeType       string          `json:"video_mime_type"`
		VideoDuration       int32           `json:"video_duration"`
		VideoWidth          int32           `json:"video_width"`
		VideoHeight         int32           `json:"video_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAnimation.Id = tmp.Id
	inputInlineQueryResultAnimation.Title = tmp.Title
	inputInlineQueryResultAnimation.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultAnimation.ThumbnailMimeType = tmp.ThumbnailMimeType
	inputInlineQueryResultAnimation.VideoUrl = tmp.VideoUrl
	inputInlineQueryResultAnimation.VideoMimeType = tmp.VideoMimeType
	inputInlineQueryResultAnimation.VideoDuration = tmp.VideoDuration
	inputInlineQueryResultAnimation.VideoWidth = tmp.VideoWidth
	inputInlineQueryResultAnimation.VideoHeight = tmp.VideoHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAnimation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAnimation.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an article or web page
type InputInlineQueryResultArticle struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the result, if it exists
	Url string `json:"url"`
	// True, if the URL must be not shown
	HideUrl bool `json:"hide_url"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result
	Description string `json:"description"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultArticle

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultArticle) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultArticle) GetType() string {
	return TypeInputInlineQueryResultArticle
}

func (*InputInlineQueryResultArticle) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultArticle
}

func (inputInlineQueryResultArticle *InputInlineQueryResultArticle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Url                 string          `json:"url"`
		HideUrl             bool            `json:"hide_url"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultArticle.Id = tmp.Id
	inputInlineQueryResultArticle.Url = tmp.Url
	inputInlineQueryResultArticle.HideUrl = tmp.HideUrl
	inputInlineQueryResultArticle.Title = tmp.Title
	inputInlineQueryResultArticle.Description = tmp.Description
	inputInlineQueryResultArticle.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultArticle.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultArticle.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultArticle.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultArticle.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an MP3 audio file
type InputInlineQueryResultAudio struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the audio file
	Title string `json:"title"`
	// Performer of the audio file
	Performer string `json:"performer"`
	// The URL of the audio file
	AudioUrl string `json:"audio_url"`
	// Audio file duration, in seconds
	AudioDuration int32 `json:"audio_duration"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAudio

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAudio) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAudio) GetType() string {
	return TypeInputInlineQueryResultAudio
}

func (*InputInlineQueryResultAudio) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAudio
}

func (inputInlineQueryResultAudio *InputInlineQueryResultAudio) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Performer           string          `json:"performer"`
		AudioUrl            string          `json:"audio_url"`
		AudioDuration       int32           `json:"audio_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAudio.Id = tmp.Id
	inputInlineQueryResultAudio.Title = tmp.Title
	inputInlineQueryResultAudio.Performer = tmp.Performer
	inputInlineQueryResultAudio.AudioUrl = tmp.AudioUrl
	inputInlineQueryResultAudio.AudioDuration = tmp.AudioDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAudio.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAudio.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a user contact
type InputInlineQueryResultContact struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// User contact
	Contact *Contact `json:"contact"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultContact

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultContact) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultContact) GetType() string {
	return TypeInputInlineQueryResultContact
}

func (*InputInlineQueryResultContact) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultContact
}

func (inputInlineQueryResultContact *InputInlineQueryResultContact) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Contact             *Contact        `json:"contact"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultContact.Id = tmp.Id
	inputInlineQueryResultContact.Contact = tmp.Contact
	inputInlineQueryResultContact.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultContact.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultContact.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultContact.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultContact.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a file
type InputInlineQueryResultDocument struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the resulting file
	Title string `json:"title"`
	// Short description of the result, if known
	Description string `json:"description"`
	// URL of the file
	DocumentUrl string `json:"document_url"`
	// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
	MimeType string `json:"mime_type"`
	// The URL of the file thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Width of the thumbnail
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Height of the thumbnail
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultDocument

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultDocument) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultDocument) GetType() string {
	return TypeInputInlineQueryResultDocument
}

func (*InputInlineQueryResultDocument) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultDocument
}

func (inputInlineQueryResultDocument *InputInlineQueryResultDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		DocumentUrl         string          `json:"document_url"`
		MimeType            string          `json:"mime_type"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultDocument.Id = tmp.Id
	inputInlineQueryResultDocument.Title = tmp.Title
	inputInlineQueryResultDocument.Description = tmp.Description
	inputInlineQueryResultDocument.DocumentUrl = tmp.DocumentUrl
	inputInlineQueryResultDocument.MimeType = tmp.MimeType
	inputInlineQueryResultDocument.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultDocument.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultDocument.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultDocument.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultDocument.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a game
type InputInlineQueryResultGame struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *InputInlineQueryResultGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultGame

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultGame) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultGame) GetType() string {
	return TypeInputInlineQueryResultGame
}

func (*InputInlineQueryResultGame) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultGame
}

func (inputInlineQueryResultGame *InputInlineQueryResultGame) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id            string          `json:"id"`
		GameShortName string          `json:"game_short_name"`
		ReplyMarkup   json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultGame.Id = tmp.Id
	inputInlineQueryResultGame.GameShortName = tmp.GameShortName

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultGame.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Represents a point on the map
type InputInlineQueryResultLocation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Location result
	Location *Location `json:"location"`
	// Amount of time relative to the message sent time until the location can be updated, in seconds
	LivePeriod int32 `json:"live_period"`
	// Title of the result
	Title string `json:"title"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultLocation

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultLocation) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultLocation) GetType() string {
	return TypeInputInlineQueryResultLocation
}

func (*InputInlineQueryResultLocation) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultLocation
}

func (inputInlineQueryResultLocation *InputInlineQueryResultLocation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Location            *Location       `json:"location"`
		LivePeriod          int32           `json:"live_period"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultLocation.Id = tmp.Id
	inputInlineQueryResultLocation.Location = tmp.Location
	inputInlineQueryResultLocation.LivePeriod = tmp.LivePeriod
	inputInlineQueryResultLocation.Title = tmp.Title
	inputInlineQueryResultLocation.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultLocation.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultLocation.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultLocation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultLocation.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents link to a JPEG image
type InputInlineQueryResultPhoto struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result, if known
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
	// URL of the photo thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the JPEG photo (photo size must not exceed 5MB)
	PhotoUrl string `json:"photo_url"`
	// Width of the photo
	PhotoWidth int32 `json:"photo_width"`
	// Height of the photo
	PhotoHeight int32 `json:"photo_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultPhoto

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultPhoto) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultPhoto) GetType() string {
	return TypeInputInlineQueryResultPhoto
}

func (*InputInlineQueryResultPhoto) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultPhoto
}

func (inputInlineQueryResultPhoto *InputInlineQueryResultPhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		PhotoUrl            string          `json:"photo_url"`
		PhotoWidth          int32           `json:"photo_width"`
		PhotoHeight         int32           `json:"photo_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultPhoto.Id = tmp.Id
	inputInlineQueryResultPhoto.Title = tmp.Title
	inputInlineQueryResultPhoto.Description = tmp.Description
	inputInlineQueryResultPhoto.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultPhoto.PhotoUrl = tmp.PhotoUrl
	inputInlineQueryResultPhoto.PhotoWidth = tmp.PhotoWidth
	inputInlineQueryResultPhoto.PhotoHeight = tmp.PhotoHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultPhoto.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultPhoto.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a WEBP, TGS, or WEBM sticker
type InputInlineQueryResultSticker struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the sticker thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
	StickerUrl string `json:"sticker_url"`
	// Width of the sticker
	StickerWidth int32 `json:"sticker_width"`
	// Height of the sticker
	StickerHeight int32 `json:"sticker_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultSticker

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultSticker) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultSticker) GetType() string {
	return TypeInputInlineQueryResultSticker
}

func (*InputInlineQueryResultSticker) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultSticker
}

func (inputInlineQueryResultSticker *InputInlineQueryResultSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		StickerUrl          string          `json:"sticker_url"`
		StickerWidth        int32           `json:"sticker_width"`
		StickerHeight       int32           `json:"sticker_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultSticker.Id = tmp.Id
	inputInlineQueryResultSticker.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultSticker.StickerUrl = tmp.StickerUrl
	inputInlineQueryResultSticker.StickerWidth = tmp.StickerWidth
	inputInlineQueryResultSticker.StickerHeight = tmp.StickerHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultSticker.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultSticker.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents information about a venue
type InputInlineQueryResultVenue struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Venue result
	Venue *Venue `json:"venue"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVenue

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVenue) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVenue) GetType() string {
	return TypeInputInlineQueryResultVenue
}

func (*InputInlineQueryResultVenue) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVenue
}

func (inputInlineQueryResultVenue *InputInlineQueryResultVenue) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Venue               *Venue          `json:"venue"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVenue.Id = tmp.Id
	inputInlineQueryResultVenue.Venue = tmp.Venue
	inputInlineQueryResultVenue.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultVenue.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultVenue.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVenue.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVenue.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a page containing an embedded video player or a video file
type InputInlineQueryResultVideo struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
	// The URL of the video thumbnail (JPEG), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// URL of the embedded video player or video file
	VideoUrl string `json:"video_url"`
	// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
	MimeType string `json:"mime_type"`
	// Width of the video
	VideoWidth int32 `json:"video_width"`
	// Height of the video
	VideoHeight int32 `json:"video_height"`
	// Video duration, in seconds
	VideoDuration int32 `json:"video_duration"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVideo

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVideo) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVideo) GetType() string {
	return TypeInputInlineQueryResultVideo
}

func (*InputInlineQueryResultVideo) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVideo
}

func (inputInlineQueryResultVideo *InputInlineQueryResultVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		VideoUrl            string          `json:"video_url"`
		MimeType            string          `json:"mime_type"`
		VideoWidth          int32           `json:"video_width"`
		VideoHeight         int32           `json:"video_height"`
		VideoDuration       int32           `json:"video_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVideo.Id = tmp.Id
	inputInlineQueryResultVideo.Title = tmp.Title
	inputInlineQueryResultVideo.Description = tmp.Description
	inputInlineQueryResultVideo.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultVideo.VideoUrl = tmp.VideoUrl
	inputInlineQueryResultVideo.MimeType = tmp.MimeType
	inputInlineQueryResultVideo.VideoWidth = tmp.VideoWidth
	inputInlineQueryResultVideo.VideoHeight = tmp.VideoHeight
	inputInlineQueryResultVideo.VideoDuration = tmp.VideoDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVideo.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVideo.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
type InputInlineQueryResultVoiceNote struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the voice note
	Title string `json:"title"`
	// The URL of the voice note file
	VoiceNoteUrl string `json:"voice_note_url"`
	// Duration of the voice note, in seconds
	VoiceNoteDuration int32 `json:"voice_note_duration"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVoiceNote) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVoiceNote) GetType() string {
	return TypeInputInlineQueryResultVoiceNote
}

func (*InputInlineQueryResultVoiceNote) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVoiceNote
}

func (inputInlineQueryResultVoiceNote *InputInlineQueryResultVoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		VoiceNoteUrl        string          `json:"voice_note_url"`
		VoiceNoteDuration   int32           `json:"voice_note_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVoiceNote.Id = tmp.Id
	inputInlineQueryResultVoiceNote.Title = tmp.Title
	inputInlineQueryResultVoiceNote.VoiceNoteUrl = tmp.VoiceNoteUrl
	inputInlineQueryResultVoiceNote.VoiceNoteDuration = tmp.VoiceNoteDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVoiceNote.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVoiceNote.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an article or web page
type InlineQueryResultArticle struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the result, if it exists
	Url string `json:"url"`
	// True, if the URL must be not shown
	HideUrl bool `json:"hide_url"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result
	Description string `json:"description"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultArticle

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultArticle) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultArticle) GetType() string {
	return TypeInlineQueryResultArticle
}

func (*InlineQueryResultArticle) InlineQueryResultType() string {
	return TypeInlineQueryResultArticle
}

// Represents a user contact
type InlineQueryResultContact struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// A user contact
	Contact *Contact `json:"contact"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultContact

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultContact) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultContact) GetType() string {
	return TypeInlineQueryResultContact
}

func (*InlineQueryResultContact) InlineQueryResultType() string {
	return TypeInlineQueryResultContact
}

// Represents a point on the map
type InlineQueryResultLocation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Location result
	Location *Location `json:"location"`
	// Title of the result
	Title string `json:"title"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultLocation

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultLocation) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultLocation) GetType() string {
	return TypeInlineQueryResultLocation
}

func (*InlineQueryResultLocation) InlineQueryResultType() string {
	return TypeInlineQueryResultLocation
}

// Represents information about a venue
type InlineQueryResultVenue struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Venue result
	Venue *Venue `json:"venue"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVenue

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVenue) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVenue) GetType() string {
	return TypeInlineQueryResultVenue
}

func (*InlineQueryResultVenue) InlineQueryResultType() string {
	return TypeInlineQueryResultVenue
}

// Represents information about a game
type InlineQueryResultGame struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Game result
	Game *Game `json:"game"`
}

func (entity *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultGame

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultGame) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultGame) GetType() string {
	return TypeInlineQueryResultGame
}

func (*InlineQueryResultGame) InlineQueryResultType() string {
	return TypeInlineQueryResultGame
}

// Represents an animation file
type InlineQueryResultAnimation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Animation file
	Animation *Animation `json:"animation"`
	// Animation title
	Title string `json:"title"`
}

func (entity *InlineQueryResultAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultAnimation

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultAnimation) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultAnimation) GetType() string {
	return TypeInlineQueryResultAnimation
}

func (*InlineQueryResultAnimation) InlineQueryResultType() string {
	return TypeInlineQueryResultAnimation
}

// Represents an audio file
type InlineQueryResultAudio struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Audio file
	Audio *Audio `json:"audio"`
}

func (entity *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultAudio

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultAudio) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultAudio) GetType() string {
	return TypeInlineQueryResultAudio
}

func (*InlineQueryResultAudio) InlineQueryResultType() string {
	return TypeInlineQueryResultAudio
}

// Represents a document
type InlineQueryResultDocument struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Document
	Document *Document `json:"document"`
	// Document title
	Title string `json:"title"`
	// Document description
	Description string `json:"description"`
}

func (entity *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultDocument

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultDocument) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultDocument) GetType() string {
	return TypeInlineQueryResultDocument
}

func (*InlineQueryResultDocument) InlineQueryResultType() string {
	return TypeInlineQueryResultDocument
}

// Represents a photo
type InlineQueryResultPhoto struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Photo
	Photo *Photo `json:"photo"`
	// Title of the result, if known
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
}

func (entity *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultPhoto

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultPhoto) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultPhoto) GetType() string {
	return TypeInlineQueryResultPhoto
}

func (*InlineQueryResultPhoto) InlineQueryResultType() string {
	return TypeInlineQueryResultPhoto
}

// Represents a sticker
type InlineQueryResultSticker struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Sticker
	Sticker *Sticker `json:"sticker"`
}

func (entity *InlineQueryResultSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultSticker

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultSticker) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultSticker) GetType() string {
	return TypeInlineQueryResultSticker
}

func (*InlineQueryResultSticker) InlineQueryResultType() string {
	return TypeInlineQueryResultSticker
}

// Represents a video
type InlineQueryResultVideo struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Video
	Video *Video `json:"video"`
	// Title of the video
	Title string `json:"title"`
	// Description of the video
	Description string `json:"description"`
}

func (entity *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVideo

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVideo) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVideo) GetType() string {
	return TypeInlineQueryResultVideo
}

func (*InlineQueryResultVideo) InlineQueryResultType() string {
	return TypeInlineQueryResultVideo
}

// Represents a voice note
type InlineQueryResultVoiceNote struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Voice note
	VoiceNote *VoiceNote `json:"voice_note"`
	// Title of the voice note
	Title string `json:"title"`
}

func (entity *InlineQueryResultVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVoiceNote) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVoiceNote) GetType() string {
	return TypeInlineQueryResultVoiceNote
}

func (*InlineQueryResultVoiceNote) InlineQueryResultType() string {
	return TypeInlineQueryResultVoiceNote
}

// Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter
type InlineQueryResultsButtonTypeStartBot struct {
	meta
	// The parameter for the bot start message
	Parameter string `json:"parameter"`
}

func (entity *InlineQueryResultsButtonTypeStartBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultsButtonTypeStartBot

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultsButtonTypeStartBot) GetClass() string {
	return ClassInlineQueryResultsButtonType
}

func (*InlineQueryResultsButtonTypeStartBot) GetType() string {
	return TypeInlineQueryResultsButtonTypeStartBot
}

func (*InlineQueryResultsButtonTypeStartBot) InlineQueryResultsButtonTypeType() string {
	return TypeInlineQueryResultsButtonTypeStartBot
}

// Describes the button that opens a Web App by calling getWebAppUrl
type InlineQueryResultsButtonTypeWebApp struct {
	meta
	// An HTTP URL to pass to getWebAppUrl
	Url string `json:"url"`
}

func (entity *InlineQueryResultsButtonTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultsButtonTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultsButtonTypeWebApp) GetClass() string {
	return ClassInlineQueryResultsButtonType
}

func (*InlineQueryResultsButtonTypeWebApp) GetType() string {
	return TypeInlineQueryResultsButtonTypeWebApp
}

func (*InlineQueryResultsButtonTypeWebApp) InlineQueryResultsButtonTypeType() string {
	return TypeInlineQueryResultsButtonTypeWebApp
}

// Represents a button to be shown above inline query results
type InlineQueryResultsButton struct {
	meta
	// The text of the button
	Text string `json:"text"`
	// Type of the button
	Type InlineQueryResultsButtonType `json:"type"`
}

func (entity *InlineQueryResultsButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultsButton

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultsButton) GetClass() string {
	return ClassInlineQueryResultsButton
}

func (*InlineQueryResultsButton) GetType() string {
	return TypeInlineQueryResultsButton
}

func (inlineQueryResultsButton *InlineQueryResultsButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineQueryResultsButton.Text = tmp.Text

	fieldType, _ := UnmarshalInlineQueryResultsButtonType(tmp.Type)
	inlineQueryResultsButton.Type = fieldType

	return nil
}

// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
type InlineQueryResults struct {
	meta
	// Unique identifier of the inline query
	InlineQueryId JsonInt64 `json:"inline_query_id"`
	// Button to be shown above inline query results; may be null
	Button *InlineQueryResultsButton `json:"button"`
	// Results of the query
	Results []InlineQueryResult `json:"results"`
	// The offset for the next request. If empty, there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *InlineQueryResults) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResults

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResults) GetClass() string {
	return ClassInlineQueryResults
}

func (*InlineQueryResults) GetType() string {
	return TypeInlineQueryResults
}

func (inlineQueryResults *InlineQueryResults) UnmarshalJSON(data []byte) error {
	var tmp struct {
		InlineQueryId JsonInt64                 `json:"inline_query_id"`
		Button        *InlineQueryResultsButton `json:"button"`
		Results       []json.RawMessage         `json:"results"`
		NextOffset    string                    `json:"next_offset"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineQueryResults.InlineQueryId = tmp.InlineQueryId
	inlineQueryResults.Button = tmp.Button
	inlineQueryResults.NextOffset = tmp.NextOffset

	fieldResults, _ := UnmarshalListOfInlineQueryResult(tmp.Results)
	inlineQueryResults.Results = fieldResults

	return nil
}

// The payload for a general callback button
type CallbackQueryPayloadData struct {
	meta
	// Data that was attached to the callback button
	Data []byte `json:"data"`
}

func (entity *CallbackQueryPayloadData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadData

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadData) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadData) GetType() string {
	return TypeCallbackQueryPayloadData
}

func (*CallbackQueryPayloadData) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadData
}

// The payload for a callback button requiring password
type CallbackQueryPayloadDataWithPassword struct {
	meta
	// The 2-step verification password for the current user
	Password string `json:"password"`
	// Data that was attached to the callback button
	Data []byte `json:"data"`
}

func (entity *CallbackQueryPayloadDataWithPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadDataWithPassword

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadDataWithPassword) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadDataWithPassword) GetType() string {
	return TypeCallbackQueryPayloadDataWithPassword
}

func (*CallbackQueryPayloadDataWithPassword) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadDataWithPassword
}

// The payload for a game callback button
type CallbackQueryPayloadGame struct {
	meta
	// A short name of the game that was attached to the callback button
	GameShortName string `json:"game_short_name"`
}

func (entity *CallbackQueryPayloadGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadGame

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadGame) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadGame) GetType() string {
	return TypeCallbackQueryPayloadGame
}

func (*CallbackQueryPayloadGame) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadGame
}

// Contains a bot's answer to a callback query
type CallbackQueryAnswer struct {
	meta
	// Text of the answer
	Text string `json:"text"`
	// True, if an alert must be shown to the user instead of a toast notification
	ShowAlert bool `json:"show_alert"`
	// URL to be opened
	Url string `json:"url"`
}

func (entity *CallbackQueryAnswer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryAnswer

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryAnswer) GetClass() string {
	return ClassCallbackQueryAnswer
}

func (*CallbackQueryAnswer) GetType() string {
	return TypeCallbackQueryAnswer
}

// Contains the result of a custom request
type CustomRequestResult struct {
	meta
	// A JSON-serialized result
	Result string `json:"result"`
}

func (entity *CustomRequestResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CustomRequestResult

	return json.Marshal((*stub)(entity))
}

func (*CustomRequestResult) GetClass() string {
	return ClassCustomRequestResult
}

func (*CustomRequestResult) GetType() string {
	return TypeCustomRequestResult
}

// Contains one row of the game high score table
type GameHighScore struct {
	meta
	// Position in the high score table
	Position int32 `json:"position"`
	// User identifier
	UserId int64 `json:"user_id"`
	// User score
	Score int32 `json:"score"`
}

func (entity *GameHighScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GameHighScore

	return json.Marshal((*stub)(entity))
}

func (*GameHighScore) GetClass() string {
	return ClassGameHighScore
}

func (*GameHighScore) GetType() string {
	return TypeGameHighScore
}

// Contains a list of game high scores
type GameHighScores struct {
	meta
	// A list of game high scores
	Scores []*GameHighScore `json:"scores"`
}

func (entity *GameHighScores) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GameHighScores

	return json.Marshal((*stub)(entity))
}

func (*GameHighScores) GetClass() string {
	return ClassGameHighScores
}

func (*GameHighScores) GetType() string {
	return TypeGameHighScores
}

// A message was edited
type ChatEventMessageEdited struct {
	meta
	// The original message before the edit
	OldMessage *Message `json:"old_message"`
	// The message after it was edited
	NewMessage *Message `json:"new_message"`
}

func (entity *ChatEventMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageEdited) GetType() string {
	return TypeChatEventMessageEdited
}

func (*ChatEventMessageEdited) ChatEventActionType() string {
	return TypeChatEventMessageEdited
}

// A message was deleted
type ChatEventMessageDeleted struct {
	meta
	// Deleted message
	Message *Message `json:"message"`
	// True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
	CanReportAntiSpamFalsePositive bool `json:"can_report_anti_spam_false_positive"`
}

func (entity *ChatEventMessageDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageDeleted) GetType() string {
	return TypeChatEventMessageDeleted
}

func (*ChatEventMessageDeleted) ChatEventActionType() string {
	return TypeChatEventMessageDeleted
}

// A message was pinned
type ChatEventMessagePinned struct {
	meta
	// Pinned message
	Message *Message `json:"message"`
}

func (entity *ChatEventMessagePinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessagePinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessagePinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessagePinned) GetType() string {
	return TypeChatEventMessagePinned
}

func (*ChatEventMessagePinned) ChatEventActionType() string {
	return TypeChatEventMessagePinned
}

// A message was unpinned
type ChatEventMessageUnpinned struct {
	meta
	// Unpinned message
	Message *Message `json:"message"`
}

func (entity *ChatEventMessageUnpinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageUnpinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageUnpinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageUnpinned) GetType() string {
	return TypeChatEventMessageUnpinned
}

func (*ChatEventMessageUnpinned) ChatEventActionType() string {
	return TypeChatEventMessageUnpinned
}

// A poll in a message was stopped
type ChatEventPollStopped struct {
	meta
	// The message with the poll
	Message *Message `json:"message"`
}

func (entity *ChatEventPollStopped) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPollStopped

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPollStopped) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPollStopped) GetType() string {
	return TypeChatEventPollStopped
}

func (*ChatEventPollStopped) ChatEventActionType() string {
	return TypeChatEventPollStopped
}

// A new member joined the chat
type ChatEventMemberJoined struct {
	meta
}

func (entity *ChatEventMemberJoined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoined

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoined) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoined) GetType() string {
	return TypeChatEventMemberJoined
}

func (*ChatEventMemberJoined) ChatEventActionType() string {
	return TypeChatEventMemberJoined
}

// A new member joined the chat via an invite link
type ChatEventMemberJoinedByInviteLink struct {
	meta
	// Invite link used to join the chat
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventMemberJoinedByInviteLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoinedByInviteLink

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoinedByInviteLink) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoinedByInviteLink) GetType() string {
	return TypeChatEventMemberJoinedByInviteLink
}

func (*ChatEventMemberJoinedByInviteLink) ChatEventActionType() string {
	return TypeChatEventMemberJoinedByInviteLink
}

// A new member was accepted to the chat by an administrator
type ChatEventMemberJoinedByRequest struct {
	meta
	// User identifier of the chat administrator, approved user join request
	ApproverUserId int64 `json:"approver_user_id"`
	// Invite link used to join the chat; may be null
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventMemberJoinedByRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoinedByRequest

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoinedByRequest) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoinedByRequest) GetType() string {
	return TypeChatEventMemberJoinedByRequest
}

func (*ChatEventMemberJoinedByRequest) ChatEventActionType() string {
	return TypeChatEventMemberJoinedByRequest
}

// A new chat member was invited
type ChatEventMemberInvited struct {
	meta
	// New member user identifier
	UserId int64 `json:"user_id"`
	// New member status
	Status ChatMemberStatus `json:"status"`
}

func (entity *ChatEventMemberInvited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberInvited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberInvited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberInvited) GetType() string {
	return TypeChatEventMemberInvited
}

func (*ChatEventMemberInvited) ChatEventActionType() string {
	return TypeChatEventMemberInvited
}

func (chatEventMemberInvited *ChatEventMemberInvited) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int64           `json:"user_id"`
		Status json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberInvited.UserId = tmp.UserId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	chatEventMemberInvited.Status = fieldStatus

	return nil
}

// A member left the chat
type ChatEventMemberLeft struct {
	meta
}

func (entity *ChatEventMemberLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberLeft

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberLeft) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberLeft) GetType() string {
	return TypeChatEventMemberLeft
}

func (*ChatEventMemberLeft) ChatEventActionType() string {
	return TypeChatEventMemberLeft
}

// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
type ChatEventMemberPromoted struct {
	meta
	// Affected chat member user identifier
	UserId int64 `json:"user_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberPromoted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberPromoted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberPromoted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberPromoted) GetType() string {
	return TypeChatEventMemberPromoted
}

func (*ChatEventMemberPromoted) ChatEventActionType() string {
	return TypeChatEventMemberPromoted
}

func (chatEventMemberPromoted *ChatEventMemberPromoted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId    int64           `json:"user_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberPromoted.UserId = tmp.UserId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberPromoted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberPromoted.NewStatus = fieldNewStatus

	return nil
}

// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
type ChatEventMemberRestricted struct {
	meta
	// Affected chat member identifier
	MemberId MessageSender `json:"member_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberRestricted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberRestricted) GetType() string {
	return TypeChatEventMemberRestricted
}

func (*ChatEventMemberRestricted) ChatEventActionType() string {
	return TypeChatEventMemberRestricted
}

func (chatEventMemberRestricted *ChatEventMemberRestricted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MemberId  json.RawMessage `json:"member_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldMemberId, _ := UnmarshalMessageSender(tmp.MemberId)
	chatEventMemberRestricted.MemberId = fieldMemberId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberRestricted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberRestricted.NewStatus = fieldNewStatus

	return nil
}

// The chat available reactions were changed
type ChatEventAvailableReactionsChanged struct {
	meta
	// Previous chat available reactions
	OldAvailableReactions ChatAvailableReactions `json:"old_available_reactions"`
	// New chat available reactions
	NewAvailableReactions ChatAvailableReactions `json:"new_available_reactions"`
}

func (entity *ChatEventAvailableReactionsChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventAvailableReactionsChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventAvailableReactionsChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventAvailableReactionsChanged) GetType() string {
	return TypeChatEventAvailableReactionsChanged
}

func (*ChatEventAvailableReactionsChanged) ChatEventActionType() string {
	return TypeChatEventAvailableReactionsChanged
}

func (chatEventAvailableReactionsChanged *ChatEventAvailableReactionsChanged) UnmarshalJSON(data []byte) error {
	var tmp struct {
		OldAvailableReactions json.RawMessage `json:"old_available_reactions"`
		NewAvailableReactions json.RawMessage `json:"new_available_reactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldOldAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.OldAvailableReactions)
	chatEventAvailableReactionsChanged.OldAvailableReactions = fieldOldAvailableReactions

	fieldNewAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.NewAvailableReactions)
	chatEventAvailableReactionsChanged.NewAvailableReactions = fieldNewAvailableReactions

	return nil
}

// The chat description was changed
type ChatEventDescriptionChanged struct {
	meta
	// Previous chat description
	OldDescription string `json:"old_description"`
	// New chat description
	NewDescription string `json:"new_description"`
}

func (entity *ChatEventDescriptionChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventDescriptionChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventDescriptionChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventDescriptionChanged) GetType() string {
	return TypeChatEventDescriptionChanged
}

func (*ChatEventDescriptionChanged) ChatEventActionType() string {
	return TypeChatEventDescriptionChanged
}

// The linked chat of a supergroup was changed
type ChatEventLinkedChatChanged struct {
	meta
	// Previous supergroup linked chat identifier
	OldLinkedChatId int64 `json:"old_linked_chat_id"`
	// New supergroup linked chat identifier
	NewLinkedChatId int64 `json:"new_linked_chat_id"`
}

func (entity *ChatEventLinkedChatChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLinkedChatChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLinkedChatChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventLinkedChatChanged) GetType() string {
	return TypeChatEventLinkedChatChanged
}

func (*ChatEventLinkedChatChanged) ChatEventActionType() string {
	return TypeChatEventLinkedChatChanged
}

// The supergroup location was changed
type ChatEventLocationChanged struct {
	meta
	// Previous location; may be null
	OldLocation *ChatLocation `json:"old_location"`
	// New location; may be null
	NewLocation *ChatLocation `json:"new_location"`
}

func (entity *ChatEventLocationChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLocationChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLocationChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventLocationChanged) GetType() string {
	return TypeChatEventLocationChanged
}

func (*ChatEventLocationChanged) ChatEventActionType() string {
	return TypeChatEventLocationChanged
}

// The message auto-delete timer was changed
type ChatEventMessageAutoDeleteTimeChanged struct {
	meta
	// Previous value of message_auto_delete_time
	OldMessageAutoDeleteTime int32 `json:"old_message_auto_delete_time"`
	// New value of message_auto_delete_time
	NewMessageAutoDeleteTime int32 `json:"new_message_auto_delete_time"`
}

func (entity *ChatEventMessageAutoDeleteTimeChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageAutoDeleteTimeChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageAutoDeleteTimeChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageAutoDeleteTimeChanged) GetType() string {
	return TypeChatEventMessageAutoDeleteTimeChanged
}

func (*ChatEventMessageAutoDeleteTimeChanged) ChatEventActionType() string {
	return TypeChatEventMessageAutoDeleteTimeChanged
}

// The chat permissions was changed
type ChatEventPermissionsChanged struct {
	meta
	// Previous chat permissions
	OldPermissions *ChatPermissions `json:"old_permissions"`
	// New chat permissions
	NewPermissions *ChatPermissions `json:"new_permissions"`
}

func (entity *ChatEventPermissionsChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPermissionsChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPermissionsChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPermissionsChanged) GetType() string {
	return TypeChatEventPermissionsChanged
}

func (*ChatEventPermissionsChanged) ChatEventActionType() string {
	return TypeChatEventPermissionsChanged
}

// The chat photo was changed
type ChatEventPhotoChanged struct {
	meta
	// Previous chat photo value; may be null
	OldPhoto *ChatPhoto `json:"old_photo"`
	// New chat photo value; may be null
	NewPhoto *ChatPhoto `json:"new_photo"`
}

func (entity *ChatEventPhotoChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPhotoChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPhotoChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPhotoChanged) GetType() string {
	return TypeChatEventPhotoChanged
}

func (*ChatEventPhotoChanged) ChatEventActionType() string {
	return TypeChatEventPhotoChanged
}

// The slow_mode_delay setting of a supergroup was changed
type ChatEventSlowModeDelayChanged struct {
	meta
	// Previous value of slow_mode_delay, in seconds
	OldSlowModeDelay int32 `json:"old_slow_mode_delay"`
	// New value of slow_mode_delay, in seconds
	NewSlowModeDelay int32 `json:"new_slow_mode_delay"`
}

func (entity *ChatEventSlowModeDelayChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventSlowModeDelayChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventSlowModeDelayChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventSlowModeDelayChanged) GetType() string {
	return TypeChatEventSlowModeDelayChanged
}

func (*ChatEventSlowModeDelayChanged) ChatEventActionType() string {
	return TypeChatEventSlowModeDelayChanged
}

// The supergroup sticker set was changed
type ChatEventStickerSetChanged struct {
	meta
	// Previous identifier of the chat sticker set; 0 if none
	OldStickerSetId JsonInt64 `json:"old_sticker_set_id"`
	// New identifier of the chat sticker set; 0 if none
	NewStickerSetId JsonInt64 `json:"new_sticker_set_id"`
}

func (entity *ChatEventStickerSetChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventStickerSetChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventStickerSetChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventStickerSetChanged) GetType() string {
	return TypeChatEventStickerSetChanged
}

func (*ChatEventStickerSetChanged) ChatEventActionType() string {
	return TypeChatEventStickerSetChanged
}

// The chat title was changed
type ChatEventTitleChanged struct {
	meta
	// Previous chat title
	OldTitle string `json:"old_title"`
	// New chat title
	NewTitle string `json:"new_title"`
}

func (entity *ChatEventTitleChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventTitleChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventTitleChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventTitleChanged) GetType() string {
	return TypeChatEventTitleChanged
}

func (*ChatEventTitleChanged) ChatEventActionType() string {
	return TypeChatEventTitleChanged
}

// The chat editable username was changed
type ChatEventUsernameChanged struct {
	meta
	// Previous chat username
	OldUsername string `json:"old_username"`
	// New chat username
	NewUsername string `json:"new_username"`
}

func (entity *ChatEventUsernameChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventUsernameChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventUsernameChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventUsernameChanged) GetType() string {
	return TypeChatEventUsernameChanged
}

func (*ChatEventUsernameChanged) ChatEventActionType() string {
	return TypeChatEventUsernameChanged
}

// The chat active usernames were changed
type ChatEventActiveUsernamesChanged struct {
	meta
	// Previous list of active usernames
	OldUsernames []string `json:"old_usernames"`
	// New list of active usernames
	NewUsernames []string `json:"new_usernames"`
}

func (entity *ChatEventActiveUsernamesChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventActiveUsernamesChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventActiveUsernamesChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventActiveUsernamesChanged) GetType() string {
	return TypeChatEventActiveUsernamesChanged
}

func (*ChatEventActiveUsernamesChanged) ChatEventActionType() string {
	return TypeChatEventActiveUsernamesChanged
}

// The has_protected_content setting of a channel was toggled
type ChatEventHasProtectedContentToggled struct {
	meta
	// New value of has_protected_content
	HasProtectedContent bool `json:"has_protected_content"`
}

func (entity *ChatEventHasProtectedContentToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventHasProtectedContentToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventHasProtectedContentToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventHasProtectedContentToggled) GetType() string {
	return TypeChatEventHasProtectedContentToggled
}

func (*ChatEventHasProtectedContentToggled) ChatEventActionType() string {
	return TypeChatEventHasProtectedContentToggled
}

// The can_invite_users permission of a supergroup chat was toggled
type ChatEventInvitesToggled struct {
	meta
	// New value of can_invite_users permission
	CanInviteUsers bool `json:"can_invite_users"`
}

func (entity *ChatEventInvitesToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInvitesToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInvitesToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInvitesToggled) GetType() string {
	return TypeChatEventInvitesToggled
}

func (*ChatEventInvitesToggled) ChatEventActionType() string {
	return TypeChatEventInvitesToggled
}

// The is_all_history_available setting of a supergroup was toggled
type ChatEventIsAllHistoryAvailableToggled struct {
	meta
	// New value of is_all_history_available
	IsAllHistoryAvailable bool `json:"is_all_history_available"`
}

func (entity *ChatEventIsAllHistoryAvailableToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventIsAllHistoryAvailableToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventIsAllHistoryAvailableToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventIsAllHistoryAvailableToggled) GetType() string {
	return TypeChatEventIsAllHistoryAvailableToggled
}

func (*ChatEventIsAllHistoryAvailableToggled) ChatEventActionType() string {
	return TypeChatEventIsAllHistoryAvailableToggled
}

// The has_aggressive_anti_spam_enabled setting of a supergroup was toggled
type ChatEventHasAggressiveAntiSpamEnabledToggled struct {
	meta
	// New value of has_aggressive_anti_spam_enabled
	HasAggressiveAntiSpamEnabled bool `json:"has_aggressive_anti_spam_enabled"`
}

func (entity *ChatEventHasAggressiveAntiSpamEnabledToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventHasAggressiveAntiSpamEnabledToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventHasAggressiveAntiSpamEnabledToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventHasAggressiveAntiSpamEnabledToggled) GetType() string {
	return TypeChatEventHasAggressiveAntiSpamEnabledToggled
}

func (*ChatEventHasAggressiveAntiSpamEnabledToggled) ChatEventActionType() string {
	return TypeChatEventHasAggressiveAntiSpamEnabledToggled
}

// The sign_messages setting of a channel was toggled
type ChatEventSignMessagesToggled struct {
	meta
	// New value of sign_messages
	SignMessages bool `json:"sign_messages"`
}

func (entity *ChatEventSignMessagesToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventSignMessagesToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventSignMessagesToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventSignMessagesToggled) GetType() string {
	return TypeChatEventSignMessagesToggled
}

func (*ChatEventSignMessagesToggled) ChatEventActionType() string {
	return TypeChatEventSignMessagesToggled
}

// A chat invite link was edited
type ChatEventInviteLinkEdited struct {
	meta
	// Previous information about the invite link
	OldInviteLink *ChatInviteLink `json:"old_invite_link"`
	// New information about the invite link
	NewInviteLink *ChatInviteLink `json:"new_invite_link"`
}

func (entity *ChatEventInviteLinkEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInviteLinkEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInviteLinkEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInviteLinkEdited) GetType() string {
	return TypeChatEventInviteLinkEdited
}

func (*ChatEventInviteLinkEdited) ChatEventActionType() string {
	return TypeChatEventInviteLinkEdited
}

// A chat invite link was revoked
type ChatEventInviteLinkRevoked struct {
	meta
	// The invite link
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventInviteLinkRevoked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInviteLinkRevoked

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInviteLinkRevoked) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInviteLinkRevoked) GetType() string {
	return TypeChatEventInviteLinkRevoked
}

func (*ChatEventInviteLinkRevoked) ChatEventActionType() string {
	return TypeChatEventInviteLinkRevoked
}

// A revoked chat invite link was deleted
type ChatEventInviteLinkDeleted struct {
	meta
	// The invite link
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventInviteLinkDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInviteLinkDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInviteLinkDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInviteLinkDeleted) GetType() string {
	return TypeChatEventInviteLinkDeleted
}

func (*ChatEventInviteLinkDeleted) ChatEventActionType() string {
	return TypeChatEventInviteLinkDeleted
}

// A video chat was created
type ChatEventVideoChatCreated struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
}

func (entity *ChatEventVideoChatCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatCreated

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatCreated) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatCreated) GetType() string {
	return TypeChatEventVideoChatCreated
}

func (*ChatEventVideoChatCreated) ChatEventActionType() string {
	return TypeChatEventVideoChatCreated
}

// A video chat was ended
type ChatEventVideoChatEnded struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
}

func (entity *ChatEventVideoChatEnded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatEnded

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatEnded) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatEnded) GetType() string {
	return TypeChatEventVideoChatEnded
}

func (*ChatEventVideoChatEnded) ChatEventActionType() string {
	return TypeChatEventVideoChatEnded
}

// The mute_new_participants setting of a video chat was toggled
type ChatEventVideoChatMuteNewParticipantsToggled struct {
	meta
	// New value of the mute_new_participants setting
	MuteNewParticipants bool `json:"mute_new_participants"`
}

func (entity *ChatEventVideoChatMuteNewParticipantsToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatMuteNewParticipantsToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatMuteNewParticipantsToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatMuteNewParticipantsToggled) GetType() string {
	return TypeChatEventVideoChatMuteNewParticipantsToggled
}

func (*ChatEventVideoChatMuteNewParticipantsToggled) ChatEventActionType() string {
	return TypeChatEventVideoChatMuteNewParticipantsToggled
}

// A video chat participant was muted or unmuted
type ChatEventVideoChatParticipantIsMutedToggled struct {
	meta
	// Identifier of the affected group call participant
	ParticipantId MessageSender `json:"participant_id"`
	// New value of is_muted
	IsMuted bool `json:"is_muted"`
}

func (entity *ChatEventVideoChatParticipantIsMutedToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatParticipantIsMutedToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatParticipantIsMutedToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatParticipantIsMutedToggled) GetType() string {
	return TypeChatEventVideoChatParticipantIsMutedToggled
}

func (*ChatEventVideoChatParticipantIsMutedToggled) ChatEventActionType() string {
	return TypeChatEventVideoChatParticipantIsMutedToggled
}

func (chatEventVideoChatParticipantIsMutedToggled *ChatEventVideoChatParticipantIsMutedToggled) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId json.RawMessage `json:"participant_id"`
		IsMuted       bool            `json:"is_muted"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventVideoChatParticipantIsMutedToggled.IsMuted = tmp.IsMuted

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	chatEventVideoChatParticipantIsMutedToggled.ParticipantId = fieldParticipantId

	return nil
}

// A video chat participant volume level was changed
type ChatEventVideoChatParticipantVolumeLevelChanged struct {
	meta
	// Identifier of the affected group call participant
	ParticipantId MessageSender `json:"participant_id"`
	// New value of volume_level; 1-20000 in hundreds of percents
	VolumeLevel int32 `json:"volume_level"`
}

func (entity *ChatEventVideoChatParticipantVolumeLevelChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatParticipantVolumeLevelChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatParticipantVolumeLevelChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatParticipantVolumeLevelChanged) GetType() string {
	return TypeChatEventVideoChatParticipantVolumeLevelChanged
}

func (*ChatEventVideoChatParticipantVolumeLevelChanged) ChatEventActionType() string {
	return TypeChatEventVideoChatParticipantVolumeLevelChanged
}

func (chatEventVideoChatParticipantVolumeLevelChanged *ChatEventVideoChatParticipantVolumeLevelChanged) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId json.RawMessage `json:"participant_id"`
		VolumeLevel   int32           `json:"volume_level"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventVideoChatParticipantVolumeLevelChanged.VolumeLevel = tmp.VolumeLevel

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	chatEventVideoChatParticipantVolumeLevelChanged.ParticipantId = fieldParticipantId

	return nil
}

// The is_forum setting of a channel was toggled
type ChatEventIsForumToggled struct {
	meta
	// New value of is_forum
	IsForum bool `json:"is_forum"`
}

func (entity *ChatEventIsForumToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventIsForumToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventIsForumToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventIsForumToggled) GetType() string {
	return TypeChatEventIsForumToggled
}

func (*ChatEventIsForumToggled) ChatEventActionType() string {
	return TypeChatEventIsForumToggled
}

// A new forum topic was created
type ChatEventForumTopicCreated struct {
	meta
	// Information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicCreated

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicCreated) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicCreated) GetType() string {
	return TypeChatEventForumTopicCreated
}

func (*ChatEventForumTopicCreated) ChatEventActionType() string {
	return TypeChatEventForumTopicCreated
}

// A forum topic was edited
type ChatEventForumTopicEdited struct {
	meta
	// Old information about the topic
	OldTopicInfo *ForumTopicInfo `json:"old_topic_info"`
	// New information about the topic
	NewTopicInfo *ForumTopicInfo `json:"new_topic_info"`
}

func (entity *ChatEventForumTopicEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicEdited) GetType() string {
	return TypeChatEventForumTopicEdited
}

func (*ChatEventForumTopicEdited) ChatEventActionType() string {
	return TypeChatEventForumTopicEdited
}

// A forum topic was closed or reopened
type ChatEventForumTopicToggleIsClosed struct {
	meta
	// New information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicToggleIsClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicToggleIsClosed

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicToggleIsClosed) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicToggleIsClosed) GetType() string {
	return TypeChatEventForumTopicToggleIsClosed
}

func (*ChatEventForumTopicToggleIsClosed) ChatEventActionType() string {
	return TypeChatEventForumTopicToggleIsClosed
}

// The General forum topic was hidden or unhidden
type ChatEventForumTopicToggleIsHidden struct {
	meta
	// New information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicToggleIsHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicToggleIsHidden

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicToggleIsHidden) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicToggleIsHidden) GetType() string {
	return TypeChatEventForumTopicToggleIsHidden
}

func (*ChatEventForumTopicToggleIsHidden) ChatEventActionType() string {
	return TypeChatEventForumTopicToggleIsHidden
}

// A forum topic was deleted
type ChatEventForumTopicDeleted struct {
	meta
	// Information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicDeleted) GetType() string {
	return TypeChatEventForumTopicDeleted
}

func (*ChatEventForumTopicDeleted) ChatEventActionType() string {
	return TypeChatEventForumTopicDeleted
}

// A pinned forum topic was changed
type ChatEventForumTopicPinned struct {
	meta
	// Information about the old pinned topic; may be null
	OldTopicInfo *ForumTopicInfo `json:"old_topic_info"`
	// Information about the new pinned topic; may be null
	NewTopicInfo *ForumTopicInfo `json:"new_topic_info"`
}

func (entity *ChatEventForumTopicPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicPinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicPinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicPinned) GetType() string {
	return TypeChatEventForumTopicPinned
}

func (*ChatEventForumTopicPinned) ChatEventActionType() string {
	return TypeChatEventForumTopicPinned
}

// Represents a chat event
type ChatEvent struct {
	meta
	// Chat event identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the event happened
	Date int32 `json:"date"`
	// Identifier of the user or chat who performed the action
	MemberId MessageSender `json:"member_id"`
	// The action
	Action ChatEventAction `json:"action"`
}

func (entity *ChatEvent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEvent

	return json.Marshal((*stub)(entity))
}

func (*ChatEvent) GetClass() string {
	return ClassChatEvent
}

func (*ChatEvent) GetType() string {
	return TypeChatEvent
}

func (chatEvent *ChatEvent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id       JsonInt64       `json:"id"`
		Date     int32           `json:"date"`
		MemberId json.RawMessage `json:"member_id"`
		Action   json.RawMessage `json:"action"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEvent.Id = tmp.Id
	chatEvent.Date = tmp.Date

	fieldMemberId, _ := UnmarshalMessageSender(tmp.MemberId)
	chatEvent.MemberId = fieldMemberId

	fieldAction, _ := UnmarshalChatEventAction(tmp.Action)
	chatEvent.Action = fieldAction

	return nil
}

// Contains a list of chat events
type ChatEvents struct {
	meta
	// List of events
	Events []*ChatEvent `json:"events"`
}

func (entity *ChatEvents) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEvents

	return json.Marshal((*stub)(entity))
}

func (*ChatEvents) GetClass() string {
	return ClassChatEvents
}

func (*ChatEvents) GetType() string {
	return TypeChatEvents
}

// Represents a set of filters used to obtain a chat event log
type ChatEventLogFilters struct {
	meta
	// True, if message edits need to be returned
	MessageEdits bool `json:"message_edits"`
	// True, if message deletions need to be returned
	MessageDeletions bool `json:"message_deletions"`
	// True, if pin/unpin events need to be returned
	MessagePins bool `json:"message_pins"`
	// True, if members joining events need to be returned
	MemberJoins bool `json:"member_joins"`
	// True, if members leaving events need to be returned
	MemberLeaves bool `json:"member_leaves"`
	// True, if invited member events need to be returned
	MemberInvites bool `json:"member_invites"`
	// True, if member promotion/demotion events need to be returned
	MemberPromotions bool `json:"member_promotions"`
	// True, if member restricted/unrestricted/banned/unbanned events need to be returned
	MemberRestrictions bool `json:"member_restrictions"`
	// True, if changes in chat information need to be returned
	InfoChanges bool `json:"info_changes"`
	// True, if changes in chat settings need to be returned
	SettingChanges bool `json:"setting_changes"`
	// True, if changes to invite links need to be returned
	InviteLinkChanges bool `json:"invite_link_changes"`
	// True, if video chat actions need to be returned
	VideoChatChanges bool `json:"video_chat_changes"`
	// True, if forum-related actions need to be returned
	ForumChanges bool `json:"forum_changes"`
}

func (entity *ChatEventLogFilters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLogFilters

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLogFilters) GetClass() string {
	return ClassChatEventLogFilters
}

func (*ChatEventLogFilters) GetType() string {
	return TypeChatEventLogFilters
}

// An ordinary language pack string
type LanguagePackStringValueOrdinary struct {
	meta
	// String value
	Value string `json:"value"`
}

func (entity *LanguagePackStringValueOrdinary) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValueOrdinary

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValueOrdinary) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValueOrdinary) GetType() string {
	return TypeLanguagePackStringValueOrdinary
}

func (*LanguagePackStringValueOrdinary) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValueOrdinary
}

// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
type LanguagePackStringValuePluralized struct {
	meta
	// Value for zero objects
	ZeroValue string `json:"zero_value"`
	// Value for one object
	OneValue string `json:"one_value"`
	// Value for two objects
	TwoValue string `json:"two_value"`
	// Value for few objects
	FewValue string `json:"few_value"`
	// Value for many objects
	ManyValue string `json:"many_value"`
	// Default value
	OtherValue string `json:"other_value"`
}

func (entity *LanguagePackStringValuePluralized) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValuePluralized

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValuePluralized) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValuePluralized) GetType() string {
	return TypeLanguagePackStringValuePluralized
}

func (*LanguagePackStringValuePluralized) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValuePluralized
}

// A deleted language pack string, the value must be taken from the built-in English language pack
type LanguagePackStringValueDeleted struct {
	meta
}

func (entity *LanguagePackStringValueDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValueDeleted

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValueDeleted) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValueDeleted) GetType() string {
	return TypeLanguagePackStringValueDeleted
}

func (*LanguagePackStringValueDeleted) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValueDeleted
}

// Represents one language pack string
type LanguagePackString struct {
	meta
	// String key
	Key string `json:"key"`
	// String value; pass null if the string needs to be taken from the built-in English language pack
	Value LanguagePackStringValue `json:"value"`
}

func (entity *LanguagePackString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackString

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackString) GetClass() string {
	return ClassLanguagePackString
}

func (*LanguagePackString) GetType() string {
	return TypeLanguagePackString
}

func (languagePackString *LanguagePackString) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Key   string          `json:"key"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	languagePackString.Key = tmp.Key

	fieldValue, _ := UnmarshalLanguagePackStringValue(tmp.Value)
	languagePackString.Value = fieldValue

	return nil
}

// Contains a list of language pack strings
type LanguagePackStrings struct {
	meta
	// A list of language pack strings
	Strings []*LanguagePackString `json:"strings"`
}

func (entity *LanguagePackStrings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStrings

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStrings) GetClass() string {
	return ClassLanguagePackStrings
}

func (*LanguagePackStrings) GetType() string {
	return TypeLanguagePackStrings
}

// Contains information about a language pack
type LanguagePackInfo struct {
	meta
	// Unique language pack identifier
	Id string `json:"id"`
	// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
	BaseLanguagePackId string `json:"base_language_pack_id"`
	// Language name
	Name string `json:"name"`
	// Name of the language in that language
	NativeName string `json:"native_name"`
	// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
	PluralCode string `json:"plural_code"`
	// True, if the language pack is official
	IsOfficial bool `json:"is_official"`
	// True, if the language pack strings are RTL
	IsRtl bool `json:"is_rtl"`
	// True, if the language pack is a beta language pack
	IsBeta bool `json:"is_beta"`
	// True, if the language pack is installed by the current user
	IsInstalled bool `json:"is_installed"`
	// Total number of non-deleted strings from the language pack
	TotalStringCount int32 `json:"total_string_count"`
	// Total number of translated strings from the language pack
	TranslatedStringCount int32 `json:"translated_string_count"`
	// Total number of non-deleted strings from the language pack available locally
	LocalStringCount int32 `json:"local_string_count"`
	// Link to language translation interface; empty for custom local language packs
	TranslationUrl string `json:"translation_url"`
}

func (entity *LanguagePackInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackInfo

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackInfo) GetClass() string {
	return ClassLanguagePackInfo
}

func (*LanguagePackInfo) GetType() string {
	return TypeLanguagePackInfo
}

// Contains information about the current localization target
type LocalizationTargetInfo struct {
	meta
	// List of available language packs for this application
	LanguagePacks []*LanguagePackInfo `json:"language_packs"`
}

func (entity *LocalizationTargetInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocalizationTargetInfo

	return json.Marshal((*stub)(entity))
}

func (*LocalizationTargetInfo) GetClass() string {
	return ClassLocalizationTargetInfo
}

func (*LocalizationTargetInfo) GetType() string {
	return TypeLocalizationTargetInfo
}

// The maximum number of joined supergroups and channels
type PremiumLimitTypeSupergroupCount struct {
	meta
}

func (entity *PremiumLimitTypeSupergroupCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeSupergroupCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeSupergroupCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeSupergroupCount) GetType() string {
	return TypePremiumLimitTypeSupergroupCount
}

func (*PremiumLimitTypeSupergroupCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeSupergroupCount
}

// The maximum number of pinned chats in the main chat list
type PremiumLimitTypePinnedChatCount struct {
	meta
}

func (entity *PremiumLimitTypePinnedChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypePinnedChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypePinnedChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypePinnedChatCount) GetType() string {
	return TypePremiumLimitTypePinnedChatCount
}

func (*PremiumLimitTypePinnedChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypePinnedChatCount
}

// The maximum number of created public chats
type PremiumLimitTypeCreatedPublicChatCount struct {
	meta
}

func (entity *PremiumLimitTypeCreatedPublicChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeCreatedPublicChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeCreatedPublicChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeCreatedPublicChatCount) GetType() string {
	return TypePremiumLimitTypeCreatedPublicChatCount
}

func (*PremiumLimitTypeCreatedPublicChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeCreatedPublicChatCount
}

// The maximum number of saved animations
type PremiumLimitTypeSavedAnimationCount struct {
	meta
}

func (entity *PremiumLimitTypeSavedAnimationCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeSavedAnimationCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeSavedAnimationCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeSavedAnimationCount) GetType() string {
	return TypePremiumLimitTypeSavedAnimationCount
}

func (*PremiumLimitTypeSavedAnimationCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeSavedAnimationCount
}

// The maximum number of favorite stickers
type PremiumLimitTypeFavoriteStickerCount struct {
	meta
}

func (entity *PremiumLimitTypeFavoriteStickerCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeFavoriteStickerCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeFavoriteStickerCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeFavoriteStickerCount) GetType() string {
	return TypePremiumLimitTypeFavoriteStickerCount
}

func (*PremiumLimitTypeFavoriteStickerCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeFavoriteStickerCount
}

// The maximum number of chat filters
type PremiumLimitTypeChatFilterCount struct {
	meta
}

func (entity *PremiumLimitTypeChatFilterCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeChatFilterCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeChatFilterCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeChatFilterCount) GetType() string {
	return TypePremiumLimitTypeChatFilterCount
}

func (*PremiumLimitTypeChatFilterCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeChatFilterCount
}

// The maximum number of pinned and always included, or always excluded chats in a chat filter
type PremiumLimitTypeChatFilterChosenChatCount struct {
	meta
}

func (entity *PremiumLimitTypeChatFilterChosenChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeChatFilterChosenChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeChatFilterChosenChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeChatFilterChosenChatCount) GetType() string {
	return TypePremiumLimitTypeChatFilterChosenChatCount
}

func (*PremiumLimitTypeChatFilterChosenChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeChatFilterChosenChatCount
}

// The maximum number of pinned chats in the archive chat list
type PremiumLimitTypePinnedArchivedChatCount struct {
	meta
}

func (entity *PremiumLimitTypePinnedArchivedChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypePinnedArchivedChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypePinnedArchivedChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypePinnedArchivedChatCount) GetType() string {
	return TypePremiumLimitTypePinnedArchivedChatCount
}

func (*PremiumLimitTypePinnedArchivedChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypePinnedArchivedChatCount
}

// The maximum length of sent media caption
type PremiumLimitTypeCaptionLength struct {
	meta
}

func (entity *PremiumLimitTypeCaptionLength) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeCaptionLength

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeCaptionLength) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeCaptionLength) GetType() string {
	return TypePremiumLimitTypeCaptionLength
}

func (*PremiumLimitTypeCaptionLength) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeCaptionLength
}

// The maximum length of the user's bio
type PremiumLimitTypeBioLength struct {
	meta
}

func (entity *PremiumLimitTypeBioLength) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeBioLength

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeBioLength) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeBioLength) GetType() string {
	return TypePremiumLimitTypeBioLength
}

func (*PremiumLimitTypeBioLength) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeBioLength
}

// Increased limits
type PremiumFeatureIncreasedLimits struct {
	meta
}

func (entity *PremiumFeatureIncreasedLimits) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureIncreasedLimits

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureIncreasedLimits) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureIncreasedLimits) GetType() string {
	return TypePremiumFeatureIncreasedLimits
}

func (*PremiumFeatureIncreasedLimits) PremiumFeatureType() string {
	return TypePremiumFeatureIncreasedLimits
}

// Increased maximum upload file size
type PremiumFeatureIncreasedUploadFileSize struct {
	meta
}

func (entity *PremiumFeatureIncreasedUploadFileSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureIncreasedUploadFileSize

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureIncreasedUploadFileSize) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureIncreasedUploadFileSize) GetType() string {
	return TypePremiumFeatureIncreasedUploadFileSize
}

func (*PremiumFeatureIncreasedUploadFileSize) PremiumFeatureType() string {
	return TypePremiumFeatureIncreasedUploadFileSize
}

// Improved download speed
type PremiumFeatureImprovedDownloadSpeed struct {
	meta
}

func (entity *PremiumFeatureImprovedDownloadSpeed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureImprovedDownloadSpeed

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureImprovedDownloadSpeed) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureImprovedDownloadSpeed) GetType() string {
	return TypePremiumFeatureImprovedDownloadSpeed
}

func (*PremiumFeatureImprovedDownloadSpeed) PremiumFeatureType() string {
	return TypePremiumFeatureImprovedDownloadSpeed
}

// The ability to convert voice notes to text
type PremiumFeatureVoiceRecognition struct {
	meta
}

func (entity *PremiumFeatureVoiceRecognition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureVoiceRecognition

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureVoiceRecognition) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureVoiceRecognition) GetType() string {
	return TypePremiumFeatureVoiceRecognition
}

func (*PremiumFeatureVoiceRecognition) PremiumFeatureType() string {
	return TypePremiumFeatureVoiceRecognition
}

// Disabled ads
type PremiumFeatureDisabledAds struct {
	meta
}

func (entity *PremiumFeatureDisabledAds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureDisabledAds

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureDisabledAds) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureDisabledAds) GetType() string {
	return TypePremiumFeatureDisabledAds
}

func (*PremiumFeatureDisabledAds) PremiumFeatureType() string {
	return TypePremiumFeatureDisabledAds
}

// Allowed to use more reactions
type PremiumFeatureUniqueReactions struct {
	meta
}

func (entity *PremiumFeatureUniqueReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureUniqueReactions

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureUniqueReactions) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureUniqueReactions) GetType() string {
	return TypePremiumFeatureUniqueReactions
}

func (*PremiumFeatureUniqueReactions) PremiumFeatureType() string {
	return TypePremiumFeatureUniqueReactions
}

// Allowed to use premium stickers with unique effects
type PremiumFeatureUniqueStickers struct {
	meta
}

func (entity *PremiumFeatureUniqueStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureUniqueStickers

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureUniqueStickers) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureUniqueStickers) GetType() string {
	return TypePremiumFeatureUniqueStickers
}

func (*PremiumFeatureUniqueStickers) PremiumFeatureType() string {
	return TypePremiumFeatureUniqueStickers
}

// Allowed to use custom emoji stickers in message texts and captions
type PremiumFeatureCustomEmoji struct {
	meta
}

func (entity *PremiumFeatureCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureCustomEmoji) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureCustomEmoji) GetType() string {
	return TypePremiumFeatureCustomEmoji
}

func (*PremiumFeatureCustomEmoji) PremiumFeatureType() string {
	return TypePremiumFeatureCustomEmoji
}

// Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
type PremiumFeatureAdvancedChatManagement struct {
	meta
}

func (entity *PremiumFeatureAdvancedChatManagement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAdvancedChatManagement

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAdvancedChatManagement) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAdvancedChatManagement) GetType() string {
	return TypePremiumFeatureAdvancedChatManagement
}

func (*PremiumFeatureAdvancedChatManagement) PremiumFeatureType() string {
	return TypePremiumFeatureAdvancedChatManagement
}

// A badge in the user's profile
type PremiumFeatureProfileBadge struct {
	meta
}

func (entity *PremiumFeatureProfileBadge) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureProfileBadge

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureProfileBadge) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureProfileBadge) GetType() string {
	return TypePremiumFeatureProfileBadge
}

func (*PremiumFeatureProfileBadge) PremiumFeatureType() string {
	return TypePremiumFeatureProfileBadge
}

// A emoji status shown along with the user's name
type PremiumFeatureEmojiStatus struct {
	meta
}

func (entity *PremiumFeatureEmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureEmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureEmojiStatus) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureEmojiStatus) GetType() string {
	return TypePremiumFeatureEmojiStatus
}

func (*PremiumFeatureEmojiStatus) PremiumFeatureType() string {
	return TypePremiumFeatureEmojiStatus
}

// Profile photo animation on message and chat screens
type PremiumFeatureAnimatedProfilePhoto struct {
	meta
}

func (entity *PremiumFeatureAnimatedProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAnimatedProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAnimatedProfilePhoto) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAnimatedProfilePhoto) GetType() string {
	return TypePremiumFeatureAnimatedProfilePhoto
}

func (*PremiumFeatureAnimatedProfilePhoto) PremiumFeatureType() string {
	return TypePremiumFeatureAnimatedProfilePhoto
}

// The ability to set a custom emoji as a forum topic icon
type PremiumFeatureForumTopicIcon struct {
	meta
}

func (entity *PremiumFeatureForumTopicIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureForumTopicIcon

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureForumTopicIcon) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureForumTopicIcon) GetType() string {
	return TypePremiumFeatureForumTopicIcon
}

func (*PremiumFeatureForumTopicIcon) PremiumFeatureType() string {
	return TypePremiumFeatureForumTopicIcon
}

// Allowed to set a premium application icons
type PremiumFeatureAppIcons struct {
	meta
}

func (entity *PremiumFeatureAppIcons) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAppIcons

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAppIcons) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAppIcons) GetType() string {
	return TypePremiumFeatureAppIcons
}

func (*PremiumFeatureAppIcons) PremiumFeatureType() string {
	return TypePremiumFeatureAppIcons
}

// Allowed to translate chat messages real-time
type PremiumFeatureRealTimeChatTranslation struct {
	meta
}

func (entity *PremiumFeatureRealTimeChatTranslation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureRealTimeChatTranslation

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureRealTimeChatTranslation) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureRealTimeChatTranslation) GetType() string {
	return TypePremiumFeatureRealTimeChatTranslation
}

func (*PremiumFeatureRealTimeChatTranslation) PremiumFeatureType() string {
	return TypePremiumFeatureRealTimeChatTranslation
}

// Contains information about a limit, increased for Premium users
type PremiumLimit struct {
	meta
	// The type of the limit
	Type PremiumLimitType `json:"type"`
	// Default value of the limit
	DefaultValue int32 `json:"default_value"`
	// Value of the limit for Premium users
	PremiumValue int32 `json:"premium_value"`
}

func (entity *PremiumLimit) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimit

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimit) GetClass() string {
	return ClassPremiumLimit
}

func (*PremiumLimit) GetType() string {
	return TypePremiumLimit
}

func (premiumLimit *PremiumLimit) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type         json.RawMessage `json:"type"`
		DefaultValue int32           `json:"default_value"`
		PremiumValue int32           `json:"premium_value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumLimit.DefaultValue = tmp.DefaultValue
	premiumLimit.PremiumValue = tmp.PremiumValue

	fieldType, _ := UnmarshalPremiumLimitType(tmp.Type)
	premiumLimit.Type = fieldType

	return nil
}

// Contains information about features, available to Premium users
type PremiumFeatures struct {
	meta
	// The list of available features
	Features []PremiumFeature `json:"features"`
	// The list of limits, increased for Premium users
	Limits []*PremiumLimit `json:"limits"`
	// An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
	PaymentLink InternalLinkType `json:"payment_link"`
}

func (entity *PremiumFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatures

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatures) GetClass() string {
	return ClassPremiumFeatures
}

func (*PremiumFeatures) GetType() string {
	return TypePremiumFeatures
}

func (premiumFeatures *PremiumFeatures) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Features    []json.RawMessage `json:"features"`
		Limits      []*PremiumLimit   `json:"limits"`
		PaymentLink json.RawMessage   `json:"payment_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumFeatures.Limits = tmp.Limits

	fieldFeatures, _ := UnmarshalListOfPremiumFeature(tmp.Features)
	premiumFeatures.Features = fieldFeatures

	fieldPaymentLink, _ := UnmarshalInternalLinkType(tmp.PaymentLink)
	premiumFeatures.PaymentLink = fieldPaymentLink

	return nil
}

// A limit was exceeded
type PremiumSourceLimitExceeded struct {
	meta
	// Type of the exceeded limit
	LimitType PremiumLimitType `json:"limit_type"`
}

func (entity *PremiumSourceLimitExceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceLimitExceeded

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceLimitExceeded) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceLimitExceeded) GetType() string {
	return TypePremiumSourceLimitExceeded
}

func (*PremiumSourceLimitExceeded) PremiumSourceType() string {
	return TypePremiumSourceLimitExceeded
}

func (premiumSourceLimitExceeded *PremiumSourceLimitExceeded) UnmarshalJSON(data []byte) error {
	var tmp struct {
		LimitType json.RawMessage `json:"limit_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldLimitType, _ := UnmarshalPremiumLimitType(tmp.LimitType)
	premiumSourceLimitExceeded.LimitType = fieldLimitType

	return nil
}

// A user tried to use a Premium feature
type PremiumSourceFeature struct {
	meta
	// The used feature
	Feature PremiumFeature `json:"feature"`
}

func (entity *PremiumSourceFeature) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceFeature

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceFeature) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceFeature) GetType() string {
	return TypePremiumSourceFeature
}

func (*PremiumSourceFeature) PremiumSourceType() string {
	return TypePremiumSourceFeature
}

func (premiumSourceFeature *PremiumSourceFeature) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature json.RawMessage `json:"feature"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFeature, _ := UnmarshalPremiumFeature(tmp.Feature)
	premiumSourceFeature.Feature = fieldFeature

	return nil
}

// A user opened an internal link of the type internalLinkTypePremiumFeatures
type PremiumSourceLink struct {
	meta
	// The referrer from the link
	Referrer string `json:"referrer"`
}

func (entity *PremiumSourceLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceLink

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceLink) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceLink) GetType() string {
	return TypePremiumSourceLink
}

func (*PremiumSourceLink) PremiumSourceType() string {
	return TypePremiumSourceLink
}

// A user opened the Premium features screen from settings
type PremiumSourceSettings struct {
	meta
}

func (entity *PremiumSourceSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceSettings

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceSettings) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceSettings) GetType() string {
	return TypePremiumSourceSettings
}

func (*PremiumSourceSettings) PremiumSourceType() string {
	return TypePremiumSourceSettings
}

// Describes a promotion animation for a Premium feature
type PremiumFeaturePromotionAnimation struct {
	meta
	// Premium feature
	Feature PremiumFeature `json:"feature"`
	// Promotion animation for the feature
	Animation *Animation `json:"animation"`
}

func (entity *PremiumFeaturePromotionAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeaturePromotionAnimation

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeaturePromotionAnimation) GetClass() string {
	return ClassPremiumFeaturePromotionAnimation
}

func (*PremiumFeaturePromotionAnimation) GetType() string {
	return TypePremiumFeaturePromotionAnimation
}

func (premiumFeaturePromotionAnimation *PremiumFeaturePromotionAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature   json.RawMessage `json:"feature"`
		Animation *Animation      `json:"animation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumFeaturePromotionAnimation.Animation = tmp.Animation

	fieldFeature, _ := UnmarshalPremiumFeature(tmp.Feature)
	premiumFeaturePromotionAnimation.Feature = fieldFeature

	return nil
}

// Contains state of Telegram Premium subscription and promotion videos for Premium features
type PremiumState struct {
	meta
	// Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
	State *FormattedText `json:"state"`
	// The list of available options for buying Telegram Premium
	PaymentOptions []*PremiumStatePaymentOption `json:"payment_options"`
	// The list of available promotion animations for Premium features
	Animations []*PremiumFeaturePromotionAnimation `json:"animations"`
}

func (entity *PremiumState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumState

	return json.Marshal((*stub)(entity))
}

func (*PremiumState) GetClass() string {
	return ClassPremiumState
}

func (*PremiumState) GetType() string {
	return TypePremiumState
}

// The user subscribed to Telegram Premium
type StorePaymentPurposePremiumSubscription struct {
	meta
	// Pass true if this is a restore of a Telegram Premium purchase; only for App Store
	IsRestore bool `json:"is_restore"`
	// Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
	IsUpgrade bool `json:"is_upgrade"`
}

func (entity *StorePaymentPurposePremiumSubscription) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposePremiumSubscription

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposePremiumSubscription) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposePremiumSubscription) GetType() string {
	return TypeStorePaymentPurposePremiumSubscription
}

func (*StorePaymentPurposePremiumSubscription) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposePremiumSubscription
}

// The user gifted Telegram Premium to another user
type StorePaymentPurposeGiftedPremium struct {
	meta
	// Identifier of the user for which Premium was gifted
	UserId int64 `json:"user_id"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
}

func (entity *StorePaymentPurposeGiftedPremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposeGiftedPremium

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposeGiftedPremium) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposeGiftedPremium) GetType() string {
	return TypeStorePaymentPurposeGiftedPremium
}

func (*StorePaymentPurposeGiftedPremium) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposeGiftedPremium
}

// A token for Firebase Cloud Messaging
type DeviceTokenFirebaseCloudMessaging struct {
	meta
	// Device registration token; may be empty to deregister a device
	Token string `json:"token"`
	// True, if push notifications must be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenFirebaseCloudMessaging) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenFirebaseCloudMessaging

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenFirebaseCloudMessaging) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenFirebaseCloudMessaging) GetType() string {
	return TypeDeviceTokenFirebaseCloudMessaging
}

func (*DeviceTokenFirebaseCloudMessaging) DeviceTokenType() string {
	return TypeDeviceTokenFirebaseCloudMessaging
}

// A token for Apple Push Notification service
type DeviceTokenApplePush struct {
	meta
	// Device token; may be empty to deregister a device
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
}

func (entity *DeviceTokenApplePush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenApplePush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenApplePush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenApplePush) GetType() string {
	return TypeDeviceTokenApplePush
}

func (*DeviceTokenApplePush) DeviceTokenType() string {
	return TypeDeviceTokenApplePush
}

// A token for Apple Push Notification service VoIP notifications
type DeviceTokenApplePushVoIP struct {
	meta
	// Device token; may be empty to deregister a device
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
	// True, if push notifications must be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenApplePushVoIP) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenApplePushVoIP

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenApplePushVoIP) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenApplePushVoIP) GetType() string {
	return TypeDeviceTokenApplePushVoIP
}

func (*DeviceTokenApplePushVoIP) DeviceTokenType() string {
	return TypeDeviceTokenApplePushVoIP
}

// A token for Windows Push Notification Services
type DeviceTokenWindowsPush struct {
	meta
	// The access token that will be used to send notifications; may be empty to deregister a device
	AccessToken string `json:"access_token"`
}

func (entity *DeviceTokenWindowsPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenWindowsPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenWindowsPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenWindowsPush) GetType() string {
	return TypeDeviceTokenWindowsPush
}

func (*DeviceTokenWindowsPush) DeviceTokenType() string {
	return TypeDeviceTokenWindowsPush
}

// A token for Microsoft Push Notification Service
type DeviceTokenMicrosoftPush struct {
	meta
	// Push notification channel URI; may be empty to deregister a device
	ChannelUri string `json:"channel_uri"`
}

func (entity *DeviceTokenMicrosoftPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenMicrosoftPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenMicrosoftPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenMicrosoftPush) GetType() string {
	return TypeDeviceTokenMicrosoftPush
}

func (*DeviceTokenMicrosoftPush) DeviceTokenType() string {
	return TypeDeviceTokenMicrosoftPush
}

// A token for Microsoft Push Notification Service VoIP channel
type DeviceTokenMicrosoftPushVoIP struct {
	meta
	// Push notification channel URI; may be empty to deregister a device
	ChannelUri string `json:"channel_uri"`
}

func (entity *DeviceTokenMicrosoftPushVoIP) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenMicrosoftPushVoIP

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenMicrosoftPushVoIP) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenMicrosoftPushVoIP) GetType() string {
	return TypeDeviceTokenMicrosoftPushVoIP
}

func (*DeviceTokenMicrosoftPushVoIP) DeviceTokenType() string {
	return TypeDeviceTokenMicrosoftPushVoIP
}

// A token for web Push API
type DeviceTokenWebPush struct {
	meta
	// Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
	Endpoint string `json:"endpoint"`
	// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
	P256dhBase64url string `json:"p256dh_base64url"`
	// Base64url-encoded authentication secret
	AuthBase64url string `json:"auth_base64url"`
}

func (entity *DeviceTokenWebPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenWebPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenWebPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenWebPush) GetType() string {
	return TypeDeviceTokenWebPush
}

func (*DeviceTokenWebPush) DeviceTokenType() string {
	return TypeDeviceTokenWebPush
}

// A token for Simple Push API for Firefox OS
type DeviceTokenSimplePush struct {
	meta
	// Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
	Endpoint string `json:"endpoint"`
}

func (entity *DeviceTokenSimplePush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenSimplePush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenSimplePush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenSimplePush) GetType() string {
	return TypeDeviceTokenSimplePush
}

func (*DeviceTokenSimplePush) DeviceTokenType() string {
	return TypeDeviceTokenSimplePush
}

// A token for Ubuntu Push Client service
type DeviceTokenUbuntuPush struct {
	meta
	// Token; may be empty to deregister a device
	Token string `json:"token"`
}

func (entity *DeviceTokenUbuntuPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenUbuntuPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenUbuntuPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenUbuntuPush) GetType() string {
	return TypeDeviceTokenUbuntuPush
}

func (*DeviceTokenUbuntuPush) DeviceTokenType() string {
	return TypeDeviceTokenUbuntuPush
}

// A token for BlackBerry Push Service
type DeviceTokenBlackBerryPush struct {
	meta
	// Token; may be empty to deregister a device
	Token string `json:"token"`
}

func (entity *DeviceTokenBlackBerryPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenBlackBerryPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenBlackBerryPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenBlackBerryPush) GetType() string {
	return TypeDeviceTokenBlackBerryPush
}

func (*DeviceTokenBlackBerryPush) DeviceTokenType() string {
	return TypeDeviceTokenBlackBerryPush
}

// A token for Tizen Push Service
type DeviceTokenTizenPush struct {
	meta
	// Push service registration identifier; may be empty to deregister a device
	RegId string `json:"reg_id"`
}

func (entity *DeviceTokenTizenPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenTizenPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenTizenPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenTizenPush) GetType() string {
	return TypeDeviceTokenTizenPush
}

func (*DeviceTokenTizenPush) DeviceTokenType() string {
	return TypeDeviceTokenTizenPush
}

// A token for HUAWEI Push Service
type DeviceTokenHuaweiPush struct {
	meta
	// Device registration token; may be empty to deregister a device
	Token string `json:"token"`
	// True, if push notifications must be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenHuaweiPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenHuaweiPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenHuaweiPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenHuaweiPush) GetType() string {
	return TypeDeviceTokenHuaweiPush
}

func (*DeviceTokenHuaweiPush) DeviceTokenType() string {
	return TypeDeviceTokenHuaweiPush
}

// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
type PushReceiverId struct {
	meta
	// The globally unique identifier of push notification subscription
	Id JsonInt64 `json:"id"`
}

func (entity *PushReceiverId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushReceiverId

	return json.Marshal((*stub)(entity))
}

func (*PushReceiverId) GetClass() string {
	return ClassPushReceiverId
}

func (*PushReceiverId) GetType() string {
	return TypePushReceiverId
}

// Describes a solid fill of a background
type BackgroundFillSolid struct {
	meta
	// A color of the background in the RGB24 format
	Color int32 `json:"color"`
}

func (entity *BackgroundFillSolid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillSolid

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillSolid) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillSolid) GetType() string {
	return TypeBackgroundFillSolid
}

func (*BackgroundFillSolid) BackgroundFillType() string {
	return TypeBackgroundFillSolid
}

// Describes a gradient fill of a background
type BackgroundFillGradient struct {
	meta
	// A top color of the background in the RGB24 format
	TopColor int32 `json:"top_color"`
	// A bottom color of the background in the RGB24 format
	BottomColor int32 `json:"bottom_color"`
	// Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
	RotationAngle int32 `json:"rotation_angle"`
}

func (entity *BackgroundFillGradient) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillGradient

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillGradient) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillGradient) GetType() string {
	return TypeBackgroundFillGradient
}

func (*BackgroundFillGradient) BackgroundFillType() string {
	return TypeBackgroundFillGradient
}

// Describes a freeform gradient fill of a background
type BackgroundFillFreeformGradient struct {
	meta
	// A list of 3 or 4 colors of the freeform gradients in the RGB24 format
	Colors []int32 `json:"colors"`
}

func (entity *BackgroundFillFreeformGradient) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillFreeformGradient

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillFreeformGradient) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillFreeformGradient) GetType() string {
	return TypeBackgroundFillFreeformGradient
}

func (*BackgroundFillFreeformGradient) BackgroundFillType() string {
	return TypeBackgroundFillFreeformGradient
}

// A wallpaper in JPEG format
type BackgroundTypeWallpaper struct {
	meta
	// True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
	IsBlurred bool `json:"is_blurred"`
	// True, if the background needs to be slightly moved when device is tilted
	IsMoving bool `json:"is_moving"`
}

func (entity *BackgroundTypeWallpaper) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeWallpaper

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeWallpaper) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeWallpaper) GetType() string {
	return TypeBackgroundTypeWallpaper
}

func (*BackgroundTypeWallpaper) BackgroundTypeType() string {
	return TypeBackgroundTypeWallpaper
}

// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
type BackgroundTypePattern struct {
	meta
	// Fill of the background
	Fill BackgroundFill `json:"fill"`
	// Intensity of the pattern when it is shown above the filled background; 0-100.
	Intensity int32 `json:"intensity"`
	// True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
	IsInverted bool `json:"is_inverted"`
	// True, if the background needs to be slightly moved when device is tilted
	IsMoving bool `json:"is_moving"`
}

func (entity *BackgroundTypePattern) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypePattern

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypePattern) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypePattern) GetType() string {
	return TypeBackgroundTypePattern
}

func (*BackgroundTypePattern) BackgroundTypeType() string {
	return TypeBackgroundTypePattern
}

func (backgroundTypePattern *BackgroundTypePattern) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Fill       json.RawMessage `json:"fill"`
		Intensity  int32           `json:"intensity"`
		IsInverted bool            `json:"is_inverted"`
		IsMoving   bool            `json:"is_moving"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	backgroundTypePattern.Intensity = tmp.Intensity
	backgroundTypePattern.IsInverted = tmp.IsInverted
	backgroundTypePattern.IsMoving = tmp.IsMoving

	fieldFill, _ := UnmarshalBackgroundFill(tmp.Fill)
	backgroundTypePattern.Fill = fieldFill

	return nil
}

// A filled background
type BackgroundTypeFill struct {
	meta
	// The background fill
	Fill BackgroundFill `json:"fill"`
}

func (entity *BackgroundTypeFill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeFill

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeFill) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeFill) GetType() string {
	return TypeBackgroundTypeFill
}

func (*BackgroundTypeFill) BackgroundTypeType() string {
	return TypeBackgroundTypeFill
}

func (backgroundTypeFill *BackgroundTypeFill) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Fill json.RawMessage `json:"fill"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFill, _ := UnmarshalBackgroundFill(tmp.Fill)
	backgroundTypeFill.Fill = fieldFill

	return nil
}

// Describes a chat background
type Background struct {
	meta
	// Unique background identifier
	Id JsonInt64 `json:"id"`
	// True, if this is one of default backgrounds
	IsDefault bool `json:"is_default"`
	// True, if the background is dark and is recommended to be used with dark theme
	IsDark bool `json:"is_dark"`
	// Unique background name
	Name string `json:"name"`
	// Document with the background; may be null. Null only for filled backgrounds
	Document *Document `json:"document"`
	// Type of the background
	Type BackgroundType `json:"type"`
}

func (entity *Background) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Background

	return json.Marshal((*stub)(entity))
}

func (*Background) GetClass() string {
	return ClassBackground
}

func (*Background) GetType() string {
	return TypeBackground
}

func (background *Background) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id        JsonInt64       `json:"id"`
		IsDefault bool            `json:"is_default"`
		IsDark    bool            `json:"is_dark"`
		Name      string          `json:"name"`
		Document  *Document       `json:"document"`
		Type      json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	background.Id = tmp.Id
	background.IsDefault = tmp.IsDefault
	background.IsDark = tmp.IsDark
	background.Name = tmp.Name
	background.Document = tmp.Document

	fieldType, _ := UnmarshalBackgroundType(tmp.Type)
	background.Type = fieldType

	return nil
}

// Contains a list of backgrounds
type Backgrounds struct {
	meta
	// A list of backgrounds
	Backgrounds []*Background `json:"backgrounds"`
}

func (entity *Backgrounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Backgrounds

	return json.Marshal((*stub)(entity))
}

func (*Backgrounds) GetClass() string {
	return ClassBackgrounds
}

func (*Backgrounds) GetType() string {
	return TypeBackgrounds
}

// A background from a local file
type InputBackgroundLocal struct {
	meta
	// Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
	Background InputFile `json:"background"`
}

func (entity *InputBackgroundLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundLocal

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundLocal) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundLocal) GetType() string {
	return TypeInputBackgroundLocal
}

func (*InputBackgroundLocal) InputBackgroundType() string {
	return TypeInputBackgroundLocal
}

func (inputBackgroundLocal *InputBackgroundLocal) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Background json.RawMessage `json:"background"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldBackground, _ := UnmarshalInputFile(tmp.Background)
	inputBackgroundLocal.Background = fieldBackground

	return nil
}

// A background from the server
type InputBackgroundRemote struct {
	meta
	// The background identifier
	BackgroundId JsonInt64 `json:"background_id"`
}

func (entity *InputBackgroundRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundRemote

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundRemote) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundRemote) GetType() string {
	return TypeInputBackgroundRemote
}

func (*InputBackgroundRemote) InputBackgroundType() string {
	return TypeInputBackgroundRemote
}

// Describes theme settings
type ThemeSettings struct {
	meta
	// Theme accent color in ARGB format
	AccentColor int32 `json:"accent_color"`
	// The background to be used in chats; may be null
	Background *Background `json:"background"`
	// The fill to be used as a background for outgoing messages
	OutgoingMessageFill BackgroundFill `json:"outgoing_message_fill"`
	// If true, the freeform gradient fill needs to be animated on every sent message
	AnimateOutgoingMessageFill bool `json:"animate_outgoing_message_fill"`
	// Accent color of outgoing messages in ARGB format
	OutgoingMessageAccentColor int32 `json:"outgoing_message_accent_color"`
}

func (entity *ThemeSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThemeSettings

	return json.Marshal((*stub)(entity))
}

func (*ThemeSettings) GetClass() string {
	return ClassThemeSettings
}

func (*ThemeSettings) GetType() string {
	return TypeThemeSettings
}

func (themeSettings *ThemeSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AccentColor                int32           `json:"accent_color"`
		Background                 *Background     `json:"background"`
		OutgoingMessageFill        json.RawMessage `json:"outgoing_message_fill"`
		AnimateOutgoingMessageFill bool            `json:"animate_outgoing_message_fill"`
		OutgoingMessageAccentColor int32           `json:"outgoing_message_accent_color"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	themeSettings.AccentColor = tmp.AccentColor
	themeSettings.Background = tmp.Background
	themeSettings.AnimateOutgoingMessageFill = tmp.AnimateOutgoingMessageFill
	themeSettings.OutgoingMessageAccentColor = tmp.OutgoingMessageAccentColor

	fieldOutgoingMessageFill, _ := UnmarshalBackgroundFill(tmp.OutgoingMessageFill)
	themeSettings.OutgoingMessageFill = fieldOutgoingMessageFill

	return nil
}

// Describes a chat theme
type ChatTheme struct {
	meta
	// Theme name
	Name string `json:"name"`
	// Theme settings for a light chat theme
	LightSettings *ThemeSettings `json:"light_settings"`
	// Theme settings for a dark chat theme
	DarkSettings *ThemeSettings `json:"dark_settings"`
}

func (entity *ChatTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTheme

	return json.Marshal((*stub)(entity))
}

func (*ChatTheme) GetClass() string {
	return ClassChatTheme
}

func (*ChatTheme) GetType() string {
	return TypeChatTheme
}

// Contains a list of hashtags
type Hashtags struct {
	meta
	// A list of hashtags
	Hashtags []string `json:"hashtags"`
}

func (entity *Hashtags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Hashtags

	return json.Marshal((*stub)(entity))
}

func (*Hashtags) GetClass() string {
	return ClassHashtags
}

func (*Hashtags) GetType() string {
	return TypeHashtags
}

// The session can be used
type CanTransferOwnershipResultOk struct {
	meta
}

func (entity *CanTransferOwnershipResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultOk

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultOk) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultOk) GetType() string {
	return TypeCanTransferOwnershipResultOk
}

func (*CanTransferOwnershipResultOk) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultOk
}

// The 2-step verification needs to be enabled first
type CanTransferOwnershipResultPasswordNeeded struct {
	meta
}

func (entity *CanTransferOwnershipResultPasswordNeeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultPasswordNeeded

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultPasswordNeeded) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultPasswordNeeded) GetType() string {
	return TypeCanTransferOwnershipResultPasswordNeeded
}

func (*CanTransferOwnershipResultPasswordNeeded) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultPasswordNeeded
}

// The 2-step verification was enabled recently, user needs to wait
type CanTransferOwnershipResultPasswordTooFresh struct {
	meta
	// Time left before the session can be used to transfer ownership of a chat, in seconds
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanTransferOwnershipResultPasswordTooFresh) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultPasswordTooFresh

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultPasswordTooFresh) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultPasswordTooFresh) GetType() string {
	return TypeCanTransferOwnershipResultPasswordTooFresh
}

func (*CanTransferOwnershipResultPasswordTooFresh) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultPasswordTooFresh
}

// The session was created recently, user needs to wait
type CanTransferOwnershipResultSessionTooFresh struct {
	meta
	// Time left before the session can be used to transfer ownership of a chat, in seconds
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanTransferOwnershipResultSessionTooFresh) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultSessionTooFresh

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultSessionTooFresh) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultSessionTooFresh) GetType() string {
	return TypeCanTransferOwnershipResultSessionTooFresh
}

func (*CanTransferOwnershipResultSessionTooFresh) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultSessionTooFresh
}

// The username can be set
type CheckChatUsernameResultOk struct {
	meta
}

func (entity *CheckChatUsernameResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultOk

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultOk) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultOk) GetType() string {
	return TypeCheckChatUsernameResultOk
}

func (*CheckChatUsernameResultOk) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultOk
}

// The username is invalid
type CheckChatUsernameResultUsernameInvalid struct {
	meta
}

func (entity *CheckChatUsernameResultUsernameInvalid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernameInvalid

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernameInvalid) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernameInvalid) GetType() string {
	return TypeCheckChatUsernameResultUsernameInvalid
}

func (*CheckChatUsernameResultUsernameInvalid) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernameInvalid
}

// The username is occupied
type CheckChatUsernameResultUsernameOccupied struct {
	meta
}

func (entity *CheckChatUsernameResultUsernameOccupied) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernameOccupied

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernameOccupied) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernameOccupied) GetType() string {
	return TypeCheckChatUsernameResultUsernameOccupied
}

func (*CheckChatUsernameResultUsernameOccupied) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernameOccupied
}

// The username can be purchased at fragment.com
type CheckChatUsernameResultUsernamePurchasable struct {
	meta
}

func (entity *CheckChatUsernameResultUsernamePurchasable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernamePurchasable

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernamePurchasable) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernamePurchasable) GetType() string {
	return TypeCheckChatUsernameResultUsernamePurchasable
}

func (*CheckChatUsernameResultUsernamePurchasable) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernamePurchasable
}

// The user has too many chats with username, one of them must be made private first
type CheckChatUsernameResultPublicChatsTooMany struct {
	meta
}

func (entity *CheckChatUsernameResultPublicChatsTooMany) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultPublicChatsTooMany

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultPublicChatsTooMany) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultPublicChatsTooMany) GetType() string {
	return TypeCheckChatUsernameResultPublicChatsTooMany
}

func (*CheckChatUsernameResultPublicChatsTooMany) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultPublicChatsTooMany
}

// The user can't be a member of a public supergroup
type CheckChatUsernameResultPublicGroupsUnavailable struct {
	meta
}

func (entity *CheckChatUsernameResultPublicGroupsUnavailable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultPublicGroupsUnavailable

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) GetType() string {
	return TypeCheckChatUsernameResultPublicGroupsUnavailable
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultPublicGroupsUnavailable
}

// The name can be set
type CheckStickerSetNameResultOk struct {
	meta
}

func (entity *CheckStickerSetNameResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckStickerSetNameResultOk

	return json.Marshal((*stub)(entity))
}

func (*CheckStickerSetNameResultOk) GetClass() string {
	return ClassCheckStickerSetNameResult
}

func (*CheckStickerSetNameResultOk) GetType() string {
	return TypeCheckStickerSetNameResultOk
}

func (*CheckStickerSetNameResultOk) CheckStickerSetNameResultType() string {
	return TypeCheckStickerSetNameResultOk
}

// The name is invalid
type CheckStickerSetNameResultNameInvalid struct {
	meta
}

func (entity *CheckStickerSetNameResultNameInvalid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckStickerSetNameResultNameInvalid

	return json.Marshal((*stub)(entity))
}

func (*CheckStickerSetNameResultNameInvalid) GetClass() string {
	return ClassCheckStickerSetNameResult
}

func (*CheckStickerSetNameResultNameInvalid) GetType() string {
	return TypeCheckStickerSetNameResultNameInvalid
}

func (*CheckStickerSetNameResultNameInvalid) CheckStickerSetNameResultType() string {
	return TypeCheckStickerSetNameResultNameInvalid
}

// The name is occupied
type CheckStickerSetNameResultNameOccupied struct {
	meta
}

func (entity *CheckStickerSetNameResultNameOccupied) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckStickerSetNameResultNameOccupied

	return json.Marshal((*stub)(entity))
}

func (*CheckStickerSetNameResultNameOccupied) GetClass() string {
	return ClassCheckStickerSetNameResult
}

func (*CheckStickerSetNameResultNameOccupied) GetType() string {
	return TypeCheckStickerSetNameResultNameOccupied
}

func (*CheckStickerSetNameResultNameOccupied) CheckStickerSetNameResultType() string {
	return TypeCheckStickerSetNameResultNameOccupied
}

// The password was reset
type ResetPasswordResultOk struct {
	meta
}

func (entity *ResetPasswordResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResetPasswordResultOk

	return json.Marshal((*stub)(entity))
}

func (*ResetPasswordResultOk) GetClass() string {
	return ClassResetPasswordResult
}

func (*ResetPasswordResultOk) GetType() string {
	return TypeResetPasswordResultOk
}

func (*ResetPasswordResultOk) ResetPasswordResultType() string {
	return TypeResetPasswordResultOk
}

// The password reset request is pending
type ResetPasswordResultPending struct {
	meta
	// Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
	PendingResetDate int32 `json:"pending_reset_date"`
}

func (entity *ResetPasswordResultPending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResetPasswordResultPending

	return json.Marshal((*stub)(entity))
}

func (*ResetPasswordResultPending) GetClass() string {
	return ClassResetPasswordResult
}

func (*ResetPasswordResultPending) GetType() string {
	return TypeResetPasswordResultPending
}

func (*ResetPasswordResultPending) ResetPasswordResultType() string {
	return TypeResetPasswordResultPending
}

// The password reset request was declined
type ResetPasswordResultDeclined struct {
	meta
	// Point in time (Unix timestamp) when the password reset can be retried
	RetryDate int32 `json:"retry_date"`
}

func (entity *ResetPasswordResultDeclined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResetPasswordResultDeclined

	return json.Marshal((*stub)(entity))
}

func (*ResetPasswordResultDeclined) GetClass() string {
	return ClassResetPasswordResult
}

func (*ResetPasswordResultDeclined) GetType() string {
	return TypeResetPasswordResultDeclined
}

func (*ResetPasswordResultDeclined) ResetPasswordResultType() string {
	return TypeResetPasswordResultDeclined
}

// The messages was exported from a private chat
type MessageFileTypePrivate struct {
	meta
	// Name of the other party; may be empty if unrecognized
	Name string `json:"name"`
}

func (entity *MessageFileTypePrivate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageFileTypePrivate

	return json.Marshal((*stub)(entity))
}

func (*MessageFileTypePrivate) GetClass() string {
	return ClassMessageFileType
}

func (*MessageFileTypePrivate) GetType() string {
	return TypeMessageFileTypePrivate
}

func (*MessageFileTypePrivate) MessageFileTypeType() string {
	return TypeMessageFileTypePrivate
}

// The messages was exported from a group chat
type MessageFileTypeGroup struct {
	meta
	// Title of the group chat; may be empty if unrecognized
	Title string `json:"title"`
}

func (entity *MessageFileTypeGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageFileTypeGroup

	return json.Marshal((*stub)(entity))
}

func (*MessageFileTypeGroup) GetClass() string {
	return ClassMessageFileType
}

func (*MessageFileTypeGroup) GetType() string {
	return TypeMessageFileTypeGroup
}

func (*MessageFileTypeGroup) MessageFileTypeType() string {
	return TypeMessageFileTypeGroup
}

// The messages was exported from a chat of unknown type
type MessageFileTypeUnknown struct {
	meta
}

func (entity *MessageFileTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageFileTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*MessageFileTypeUnknown) GetClass() string {
	return ClassMessageFileType
}

func (*MessageFileTypeUnknown) GetType() string {
	return TypeMessageFileTypeUnknown
}

func (*MessageFileTypeUnknown) MessageFileTypeType() string {
	return TypeMessageFileTypeUnknown
}

// A general message with hidden content
type PushMessageContentHidden struct {
	meta
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentHidden

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentHidden) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentHidden) GetType() string {
	return TypePushMessageContentHidden
}

func (*PushMessageContentHidden) PushMessageContentType() string {
	return TypePushMessageContentHidden
}

// An animation message (GIF-style).
type PushMessageContentAnimation struct {
	meta
	// Message content; may be null
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption string `json:"caption"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentAnimation

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentAnimation) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentAnimation) GetType() string {
	return TypePushMessageContentAnimation
}

func (*PushMessageContentAnimation) PushMessageContentType() string {
	return TypePushMessageContentAnimation
}

// An audio message
type PushMessageContentAudio struct {
	meta
	// Message content; may be null
	Audio *Audio `json:"audio"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentAudio

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentAudio) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentAudio) GetType() string {
	return TypePushMessageContentAudio
}

func (*PushMessageContentAudio) PushMessageContentType() string {
	return TypePushMessageContentAudio
}

// A message with a user contact
type PushMessageContentContact struct {
	meta
	// Contact's name
	Name string `json:"name"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentContact

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentContact) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentContact) GetType() string {
	return TypePushMessageContentContact
}

func (*PushMessageContentContact) PushMessageContentType() string {
	return TypePushMessageContentContact
}

// A contact has registered with Telegram
type PushMessageContentContactRegistered struct {
	meta
}

func (entity *PushMessageContentContactRegistered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentContactRegistered

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentContactRegistered) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentContactRegistered) GetType() string {
	return TypePushMessageContentContactRegistered
}

func (*PushMessageContentContactRegistered) PushMessageContentType() string {
	return TypePushMessageContentContactRegistered
}

// A document message (a general file)
type PushMessageContentDocument struct {
	meta
	// Message content; may be null
	Document *Document `json:"document"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentDocument

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentDocument) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentDocument) GetType() string {
	return TypePushMessageContentDocument
}

func (*PushMessageContentDocument) PushMessageContentType() string {
	return TypePushMessageContentDocument
}

// A message with a game
type PushMessageContentGame struct {
	meta
	// Game title, empty for pinned game message
	Title string `json:"title"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGame

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGame) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGame) GetType() string {
	return TypePushMessageContentGame
}

func (*PushMessageContentGame) PushMessageContentType() string {
	return TypePushMessageContentGame
}

// A new high score was achieved in a game
type PushMessageContentGameScore struct {
	meta
	// Game title, empty for pinned message
	Title string `json:"title"`
	// New score, 0 for pinned message
	Score int32 `json:"score"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGameScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGameScore

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGameScore) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGameScore) GetType() string {
	return TypePushMessageContentGameScore
}

func (*PushMessageContentGameScore) PushMessageContentType() string {
	return TypePushMessageContentGameScore
}

// A message with an invoice from a bot
type PushMessageContentInvoice struct {
	meta
	// Product price
	Price string `json:"price"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentInvoice

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentInvoice) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentInvoice) GetType() string {
	return TypePushMessageContentInvoice
}

func (*PushMessageContentInvoice) PushMessageContentType() string {
	return TypePushMessageContentInvoice
}

// A message with a location
type PushMessageContentLocation struct {
	meta
	// True, if the location is live
	IsLive bool `json:"is_live"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentLocation

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentLocation) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentLocation) GetType() string {
	return TypePushMessageContentLocation
}

func (*PushMessageContentLocation) PushMessageContentType() string {
	return TypePushMessageContentLocation
}

// A photo message
type PushMessageContentPhoto struct {
	meta
	// Message content; may be null
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption string `json:"caption"`
	// True, if the photo is secret
	IsSecret bool `json:"is_secret"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPhoto) GetType() string {
	return TypePushMessageContentPhoto
}

func (*PushMessageContentPhoto) PushMessageContentType() string {
	return TypePushMessageContentPhoto
}

// A message with a poll
type PushMessageContentPoll struct {
	meta
	// Poll question
	Question string `json:"question"`
	// True, if the poll is regular and not in quiz mode
	IsRegular bool `json:"is_regular"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPoll

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPoll) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPoll) GetType() string {
	return TypePushMessageContentPoll
}

func (*PushMessageContentPoll) PushMessageContentType() string {
	return TypePushMessageContentPoll
}

// A screenshot of a message in the chat has been taken
type PushMessageContentScreenshotTaken struct {
	meta
}

func (entity *PushMessageContentScreenshotTaken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentScreenshotTaken

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentScreenshotTaken) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentScreenshotTaken) GetType() string {
	return TypePushMessageContentScreenshotTaken
}

func (*PushMessageContentScreenshotTaken) PushMessageContentType() string {
	return TypePushMessageContentScreenshotTaken
}

// A message with a sticker
type PushMessageContentSticker struct {
	meta
	// Message content; may be null
	Sticker *Sticker `json:"sticker"`
	// Emoji corresponding to the sticker; may be empty
	Emoji string `json:"emoji"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentSticker

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentSticker) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentSticker) GetType() string {
	return TypePushMessageContentSticker
}

func (*PushMessageContentSticker) PushMessageContentType() string {
	return TypePushMessageContentSticker
}

// A text message
type PushMessageContentText struct {
	meta
	// Message text
	Text string `json:"text"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentText

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentText) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentText) GetType() string {
	return TypePushMessageContentText
}

func (*PushMessageContentText) PushMessageContentType() string {
	return TypePushMessageContentText
}

// A video message
type PushMessageContentVideo struct {
	meta
	// Message content; may be null
	Video *Video `json:"video"`
	// Video caption
	Caption string `json:"caption"`
	// True, if the video is secret
	IsSecret bool `json:"is_secret"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVideo

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVideo) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVideo) GetType() string {
	return TypePushMessageContentVideo
}

func (*PushMessageContentVideo) PushMessageContentType() string {
	return TypePushMessageContentVideo
}

// A video note message
type PushMessageContentVideoNote struct {
	meta
	// Message content; may be null
	VideoNote *VideoNote `json:"video_note"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVideoNote

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVideoNote) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVideoNote) GetType() string {
	return TypePushMessageContentVideoNote
}

func (*PushMessageContentVideoNote) PushMessageContentType() string {
	return TypePushMessageContentVideoNote
}

// A voice note message
type PushMessageContentVoiceNote struct {
	meta
	// Message content; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVoiceNote) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVoiceNote) GetType() string {
	return TypePushMessageContentVoiceNote
}

func (*PushMessageContentVoiceNote) PushMessageContentType() string {
	return TypePushMessageContentVoiceNote
}

// A newly created basic group
type PushMessageContentBasicGroupChatCreate struct {
	meta
}

func (entity *PushMessageContentBasicGroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentBasicGroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentBasicGroupChatCreate) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentBasicGroupChatCreate) GetType() string {
	return TypePushMessageContentBasicGroupChatCreate
}

func (*PushMessageContentBasicGroupChatCreate) PushMessageContentType() string {
	return TypePushMessageContentBasicGroupChatCreate
}

// New chat members were invited to a group
type PushMessageContentChatAddMembers struct {
	meta
	// Name of the added member
	MemberName string `json:"member_name"`
	// True, if the current user was added to the group
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the user has returned to the group themselves
	IsReturned bool `json:"is_returned"`
}

func (entity *PushMessageContentChatAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatAddMembers

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatAddMembers) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatAddMembers) GetType() string {
	return TypePushMessageContentChatAddMembers
}

func (*PushMessageContentChatAddMembers) PushMessageContentType() string {
	return TypePushMessageContentChatAddMembers
}

// A chat photo was edited
type PushMessageContentChatChangePhoto struct {
	meta
}

func (entity *PushMessageContentChatChangePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatChangePhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatChangePhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatChangePhoto) GetType() string {
	return TypePushMessageContentChatChangePhoto
}

func (*PushMessageContentChatChangePhoto) PushMessageContentType() string {
	return TypePushMessageContentChatChangePhoto
}

// A chat title was edited
type PushMessageContentChatChangeTitle struct {
	meta
	// New chat title
	Title string `json:"title"`
}

func (entity *PushMessageContentChatChangeTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatChangeTitle

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatChangeTitle) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatChangeTitle) GetType() string {
	return TypePushMessageContentChatChangeTitle
}

func (*PushMessageContentChatChangeTitle) PushMessageContentType() string {
	return TypePushMessageContentChatChangeTitle
}

// A chat theme was edited
type PushMessageContentChatSetTheme struct {
	meta
	// If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
	ThemeName string `json:"theme_name"`
}

func (entity *PushMessageContentChatSetTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatSetTheme

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatSetTheme) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatSetTheme) GetType() string {
	return TypePushMessageContentChatSetTheme
}

func (*PushMessageContentChatSetTheme) PushMessageContentType() string {
	return TypePushMessageContentChatSetTheme
}

// A chat member was deleted
type PushMessageContentChatDeleteMember struct {
	meta
	// Name of the deleted member
	MemberName string `json:"member_name"`
	// True, if the current user was deleted from the group
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the user has left the group themselves
	IsLeft bool `json:"is_left"`
}

func (entity *PushMessageContentChatDeleteMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatDeleteMember

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatDeleteMember) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatDeleteMember) GetType() string {
	return TypePushMessageContentChatDeleteMember
}

func (*PushMessageContentChatDeleteMember) PushMessageContentType() string {
	return TypePushMessageContentChatDeleteMember
}

// A new member joined the chat via an invite link
type PushMessageContentChatJoinByLink struct {
	meta
}

func (entity *PushMessageContentChatJoinByLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatJoinByLink

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatJoinByLink) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatJoinByLink) GetType() string {
	return TypePushMessageContentChatJoinByLink
}

func (*PushMessageContentChatJoinByLink) PushMessageContentType() string {
	return TypePushMessageContentChatJoinByLink
}

// A new member was accepted to the chat by an administrator
type PushMessageContentChatJoinByRequest struct {
	meta
}

func (entity *PushMessageContentChatJoinByRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatJoinByRequest

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatJoinByRequest) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatJoinByRequest) GetType() string {
	return TypePushMessageContentChatJoinByRequest
}

func (*PushMessageContentChatJoinByRequest) PushMessageContentType() string {
	return TypePushMessageContentChatJoinByRequest
}

// A new recurrent payment was made by the current user
type PushMessageContentRecurringPayment struct {
	meta
	// The paid amount
	Amount string `json:"amount"`
}

func (entity *PushMessageContentRecurringPayment) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentRecurringPayment

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentRecurringPayment) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentRecurringPayment) GetType() string {
	return TypePushMessageContentRecurringPayment
}

func (*PushMessageContentRecurringPayment) PushMessageContentType() string {
	return TypePushMessageContentRecurringPayment
}

// A profile photo was suggested to the user
type PushMessageContentSuggestProfilePhoto struct {
	meta
}

func (entity *PushMessageContentSuggestProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentSuggestProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentSuggestProfilePhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentSuggestProfilePhoto) GetType() string {
	return TypePushMessageContentSuggestProfilePhoto
}

func (*PushMessageContentSuggestProfilePhoto) PushMessageContentType() string {
	return TypePushMessageContentSuggestProfilePhoto
}

// A forwarded messages
type PushMessageContentMessageForwards struct {
	meta
	// Number of forwarded messages
	TotalCount int32 `json:"total_count"`
}

func (entity *PushMessageContentMessageForwards) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentMessageForwards

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentMessageForwards) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentMessageForwards) GetType() string {
	return TypePushMessageContentMessageForwards
}

func (*PushMessageContentMessageForwards) PushMessageContentType() string {
	return TypePushMessageContentMessageForwards
}

// A media album
type PushMessageContentMediaAlbum struct {
	meta
	// Number of messages in the album
	TotalCount int32 `json:"total_count"`
	// True, if the album has at least one photo
	HasPhotos bool `json:"has_photos"`
	// True, if the album has at least one video file
	HasVideos bool `json:"has_videos"`
	// True, if the album has at least one audio file
	HasAudios bool `json:"has_audios"`
	// True, if the album has at least one document
	HasDocuments bool `json:"has_documents"`
}

func (entity *PushMessageContentMediaAlbum) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentMediaAlbum

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentMediaAlbum) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentMediaAlbum) GetType() string {
	return TypePushMessageContentMediaAlbum
}

func (*PushMessageContentMediaAlbum) PushMessageContentType() string {
	return TypePushMessageContentMediaAlbum
}

// New message was received
type NotificationTypeNewMessage struct {
	meta
	// The message
	Message *Message `json:"message"`
	// True, if message content must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
}

func (entity *NotificationTypeNewMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewMessage

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewMessage) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewMessage) GetType() string {
	return TypeNotificationTypeNewMessage
}

func (*NotificationTypeNewMessage) NotificationTypeType() string {
	return TypeNotificationTypeNewMessage
}

// New secret chat was created
type NotificationTypeNewSecretChat struct {
	meta
}

func (entity *NotificationTypeNewSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewSecretChat

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewSecretChat) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewSecretChat) GetType() string {
	return TypeNotificationTypeNewSecretChat
}

func (*NotificationTypeNewSecretChat) NotificationTypeType() string {
	return TypeNotificationTypeNewSecretChat
}

// New call was received
type NotificationTypeNewCall struct {
	meta
	// Call identifier
	CallId int32 `json:"call_id"`
}

func (entity *NotificationTypeNewCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewCall

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewCall) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewCall) GetType() string {
	return TypeNotificationTypeNewCall
}

func (*NotificationTypeNewCall) NotificationTypeType() string {
	return TypeNotificationTypeNewCall
}

// New message was received through a push notification
type NotificationTypeNewPushMessage struct {
	meta
	// The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages, or as reply_to_message_id
	MessageId int64 `json:"message_id"`
	// Identifier of the sender of the message. Corresponding user or chat may be inaccessible
	SenderId MessageSender `json:"sender_id"`
	// Name of the sender
	SenderName string `json:"sender_name"`
	// True, if the message is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// Push message content
	Content PushMessageContent `json:"content"`
}

func (entity *NotificationTypeNewPushMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewPushMessage

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewPushMessage) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewPushMessage) GetType() string {
	return TypeNotificationTypeNewPushMessage
}

func (*NotificationTypeNewPushMessage) NotificationTypeType() string {
	return TypeNotificationTypeNewPushMessage
}

func (notificationTypeNewPushMessage *NotificationTypeNewPushMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageId  int64           `json:"message_id"`
		SenderId   json.RawMessage `json:"sender_id"`
		SenderName string          `json:"sender_name"`
		IsOutgoing bool            `json:"is_outgoing"`
		Content    json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notificationTypeNewPushMessage.MessageId = tmp.MessageId
	notificationTypeNewPushMessage.SenderName = tmp.SenderName
	notificationTypeNewPushMessage.IsOutgoing = tmp.IsOutgoing

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	notificationTypeNewPushMessage.SenderId = fieldSenderId

	fieldContent, _ := UnmarshalPushMessageContent(tmp.Content)
	notificationTypeNewPushMessage.Content = fieldContent

	return nil
}

// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
type NotificationGroupTypeMessages struct {
	meta
}

func (entity *NotificationGroupTypeMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeMessages

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeMessages) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeMessages) GetType() string {
	return TypeNotificationGroupTypeMessages
}

func (*NotificationGroupTypeMessages) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeMessages
}

// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
type NotificationGroupTypeMentions struct {
	meta
}

func (entity *NotificationGroupTypeMentions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeMentions

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeMentions) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeMentions) GetType() string {
	return TypeNotificationGroupTypeMentions
}

func (*NotificationGroupTypeMentions) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeMentions
}

// A group containing a notification of type notificationTypeNewSecretChat
type NotificationGroupTypeSecretChat struct {
	meta
}

func (entity *NotificationGroupTypeSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeSecretChat

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeSecretChat) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeSecretChat) GetType() string {
	return TypeNotificationGroupTypeSecretChat
}

func (*NotificationGroupTypeSecretChat) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeSecretChat
}

// A group containing notifications of type notificationTypeNewCall
type NotificationGroupTypeCalls struct {
	meta
}

func (entity *NotificationGroupTypeCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeCalls

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeCalls) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeCalls) GetType() string {
	return TypeNotificationGroupTypeCalls
}

func (*NotificationGroupTypeCalls) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeCalls
}

// Describes a notification sound in MP3 format
type NotificationSound struct {
	meta
	// Unique identifier of the notification sound
	Id JsonInt64 `json:"id"`
	// Duration of the sound, in seconds
	Duration int32 `json:"duration"`
	// Point in time (Unix timestamp) when the sound was created
	Date int32 `json:"date"`
	// Title of the notification sound
	Title string `json:"title"`
	// Arbitrary data, defined while the sound was uploaded
	Data string `json:"data"`
	// File containing the sound
	Sound *File `json:"sound"`
}

func (entity *NotificationSound) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSound

	return json.Marshal((*stub)(entity))
}

func (*NotificationSound) GetClass() string {
	return ClassNotificationSound
}

func (*NotificationSound) GetType() string {
	return TypeNotificationSound
}

// Contains a list of notification sounds
type NotificationSounds struct {
	meta
	// A list of notification sounds
	NotificationSounds []*NotificationSound `json:"notification_sounds"`
}

func (entity *NotificationSounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSounds

	return json.Marshal((*stub)(entity))
}

func (*NotificationSounds) GetClass() string {
	return ClassNotificationSounds
}

func (*NotificationSounds) GetType() string {
	return TypeNotificationSounds
}

// Contains information about a notification
type Notification struct {
	meta
	// Unique persistent identifier of this notification
	Id int32 `json:"id"`
	// Notification date
	Date int32 `json:"date"`
	// True, if the notification was explicitly sent without sound
	IsSilent bool `json:"is_silent"`
	// Notification type
	Type NotificationType `json:"type"`
}

func (entity *Notification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Notification

	return json.Marshal((*stub)(entity))
}

func (*Notification) GetClass() string {
	return ClassNotification
}

func (*Notification) GetType() string {
	return TypeNotification
}

func (notification *Notification) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id       int32           `json:"id"`
		Date     int32           `json:"date"`
		IsSilent bool            `json:"is_silent"`
		Type     json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notification.Id = tmp.Id
	notification.Date = tmp.Date
	notification.IsSilent = tmp.IsSilent

	fieldType, _ := UnmarshalNotificationType(tmp.Type)
	notification.Type = fieldType

	return nil
}

// Describes a group of notifications
type NotificationGroup struct {
	meta
	// Unique persistent auto-incremented from 1 identifier of the notification group
	Id int32 `json:"id"`
	// Type of the group
	Type NotificationGroupType `json:"type"`
	// Identifier of a chat to which all notifications in the group belong
	ChatId int64 `json:"chat_id"`
	// Total number of active notifications in the group
	TotalCount int32 `json:"total_count"`
	// The list of active notifications
	Notifications []*Notification `json:"notifications"`
}

func (entity *NotificationGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroup

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroup) GetClass() string {
	return ClassNotificationGroup
}

func (*NotificationGroup) GetType() string {
	return TypeNotificationGroup
}

func (notificationGroup *NotificationGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id            int32           `json:"id"`
		Type          json.RawMessage `json:"type"`
		ChatId        int64           `json:"chat_id"`
		TotalCount    int32           `json:"total_count"`
		Notifications []*Notification `json:"notifications"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notificationGroup.Id = tmp.Id
	notificationGroup.ChatId = tmp.ChatId
	notificationGroup.TotalCount = tmp.TotalCount
	notificationGroup.Notifications = tmp.Notifications

	fieldType, _ := UnmarshalNotificationGroupType(tmp.Type)
	notificationGroup.Type = fieldType

	return nil
}

// Represents a boolean option
type OptionValueBoolean struct {
	meta
	// The value of the option
	Value bool `json:"value"`
}

func (entity *OptionValueBoolean) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueBoolean

	return json.Marshal((*stub)(entity))
}

func (*OptionValueBoolean) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueBoolean) GetType() string {
	return TypeOptionValueBoolean
}

func (*OptionValueBoolean) OptionValueType() string {
	return TypeOptionValueBoolean
}

// Represents an unknown option or an option which has a default value
type OptionValueEmpty struct {
	meta
}

func (entity *OptionValueEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueEmpty

	return json.Marshal((*stub)(entity))
}

func (*OptionValueEmpty) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueEmpty) GetType() string {
	return TypeOptionValueEmpty
}

func (*OptionValueEmpty) OptionValueType() string {
	return TypeOptionValueEmpty
}

// Represents an integer option
type OptionValueInteger struct {
	meta
	// The value of the option
	Value JsonInt64 `json:"value"`
}

func (entity *OptionValueInteger) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueInteger

	return json.Marshal((*stub)(entity))
}

func (*OptionValueInteger) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueInteger) GetType() string {
	return TypeOptionValueInteger
}

func (*OptionValueInteger) OptionValueType() string {
	return TypeOptionValueInteger
}

// Represents a string option
type OptionValueString struct {
	meta
	// The value of the option
	Value string `json:"value"`
}

func (entity *OptionValueString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueString

	return json.Marshal((*stub)(entity))
}

func (*OptionValueString) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueString) GetType() string {
	return TypeOptionValueString
}

func (*OptionValueString) OptionValueType() string {
	return TypeOptionValueString
}

// Represents one member of a JSON object
type JsonObjectMember struct {
	meta
	// Member's key
	Key string `json:"key"`
	// Member's value
	Value JsonValue `json:"value"`
}

func (entity *JsonObjectMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonObjectMember

	return json.Marshal((*stub)(entity))
}

func (*JsonObjectMember) GetClass() string {
	return ClassJsonObjectMember
}

func (*JsonObjectMember) GetType() string {
	return TypeJsonObjectMember
}

func (jsonObjectMember *JsonObjectMember) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Key   string          `json:"key"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	jsonObjectMember.Key = tmp.Key

	fieldValue, _ := UnmarshalJsonValue(tmp.Value)
	jsonObjectMember.Value = fieldValue

	return nil
}

// Represents a null JSON value
type JsonValueNull struct {
	meta
}

func (entity *JsonValueNull) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueNull

	return json.Marshal((*stub)(entity))
}

func (*JsonValueNull) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueNull) GetType() string {
	return TypeJsonValueNull
}

func (*JsonValueNull) JsonValueType() string {
	return TypeJsonValueNull
}

// Represents a boolean JSON value
type JsonValueBoolean struct {
	meta
	// The value
	Value bool `json:"value"`
}

func (entity *JsonValueBoolean) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueBoolean

	return json.Marshal((*stub)(entity))
}

func (*JsonValueBoolean) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueBoolean) GetType() string {
	return TypeJsonValueBoolean
}

func (*JsonValueBoolean) JsonValueType() string {
	return TypeJsonValueBoolean
}

// Represents a numeric JSON value
type JsonValueNumber struct {
	meta
	// The value
	Value float64 `json:"value"`
}

func (entity *JsonValueNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueNumber

	return json.Marshal((*stub)(entity))
}

func (*JsonValueNumber) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueNumber) GetType() string {
	return TypeJsonValueNumber
}

func (*JsonValueNumber) JsonValueType() string {
	return TypeJsonValueNumber
}

// Represents a string JSON value
type JsonValueString struct {
	meta
	// The value
	Value string `json:"value"`
}

func (entity *JsonValueString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueString

	return json.Marshal((*stub)(entity))
}

func (*JsonValueString) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueString) GetType() string {
	return TypeJsonValueString
}

func (*JsonValueString) JsonValueType() string {
	return TypeJsonValueString
}

// Represents a JSON array
type JsonValueArray struct {
	meta
	// The list of array elements
	Values []JsonValue `json:"values"`
}

func (entity *JsonValueArray) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueArray

	return json.Marshal((*stub)(entity))
}

func (*JsonValueArray) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueArray) GetType() string {
	return TypeJsonValueArray
}

func (*JsonValueArray) JsonValueType() string {
	return TypeJsonValueArray
}

func (jsonValueArray *JsonValueArray) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Values []json.RawMessage `json:"values"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldValues, _ := UnmarshalListOfJsonValue(tmp.Values)
	jsonValueArray.Values = fieldValues

	return nil
}

// Represents a JSON object
type JsonValueObject struct {
	meta
	// The list of object members
	Members []*JsonObjectMember `json:"members"`
}

func (entity *JsonValueObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueObject

	return json.Marshal((*stub)(entity))
}

func (*JsonValueObject) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueObject) GetType() string {
	return TypeJsonValueObject
}

func (*JsonValueObject) JsonValueType() string {
	return TypeJsonValueObject
}

// A rule to allow all users to do something
type UserPrivacySettingRuleAllowAll struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowAll

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowAll) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowAll) GetType() string {
	return TypeUserPrivacySettingRuleAllowAll
}

func (*UserPrivacySettingRuleAllowAll) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowAll
}

// A rule to allow all of a user's contacts to do something
type UserPrivacySettingRuleAllowContacts struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowContacts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowContacts) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowContacts) GetType() string {
	return TypeUserPrivacySettingRuleAllowContacts
}

func (*UserPrivacySettingRuleAllowContacts) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowContacts
}

// A rule to allow certain specified users to do something
type UserPrivacySettingRuleAllowUsers struct {
	meta
	// The user identifiers, total number of users in all rules must not exceed 1000
	UserIds []int64 `json:"user_ids"`
}

func (entity *UserPrivacySettingRuleAllowUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowUsers) GetType() string {
	return TypeUserPrivacySettingRuleAllowUsers
}

func (*UserPrivacySettingRuleAllowUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowUsers
}

// A rule to allow all members of certain specified basic groups and supergroups to doing something
type UserPrivacySettingRuleAllowChatMembers struct {
	meta
	// The chat identifiers, total number of chats in all rules must not exceed 20
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *UserPrivacySettingRuleAllowChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowChatMembers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowChatMembers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowChatMembers) GetType() string {
	return TypeUserPrivacySettingRuleAllowChatMembers
}

func (*UserPrivacySettingRuleAllowChatMembers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowChatMembers
}

// A rule to restrict all users from doing something
type UserPrivacySettingRuleRestrictAll struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictAll

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictAll) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictAll) GetType() string {
	return TypeUserPrivacySettingRuleRestrictAll
}

func (*UserPrivacySettingRuleRestrictAll) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictAll
}

// A rule to restrict all contacts of a user from doing something
type UserPrivacySettingRuleRestrictContacts struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictContacts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictContacts) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictContacts) GetType() string {
	return TypeUserPrivacySettingRuleRestrictContacts
}

func (*UserPrivacySettingRuleRestrictContacts) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictContacts
}

// A rule to restrict all specified users from doing something
type UserPrivacySettingRuleRestrictUsers struct {
	meta
	// The user identifiers, total number of users in all rules must not exceed 1000
	UserIds []int64 `json:"user_ids"`
}

func (entity *UserPrivacySettingRuleRestrictUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictUsers) GetType() string {
	return TypeUserPrivacySettingRuleRestrictUsers
}

func (*UserPrivacySettingRuleRestrictUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictUsers
}

// A rule to restrict all members of specified basic groups and supergroups from doing something
type UserPrivacySettingRuleRestrictChatMembers struct {
	meta
	// The chat identifiers, total number of chats in all rules must not exceed 20
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *UserPrivacySettingRuleRestrictChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictChatMembers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictChatMembers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictChatMembers) GetType() string {
	return TypeUserPrivacySettingRuleRestrictChatMembers
}

func (*UserPrivacySettingRuleRestrictChatMembers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictChatMembers
}

// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
type UserPrivacySettingRules struct {
	meta
	// A list of rules
	Rules []UserPrivacySettingRule `json:"rules"`
}

func (entity *UserPrivacySettingRules) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRules

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRules) GetClass() string {
	return ClassUserPrivacySettingRules
}

func (*UserPrivacySettingRules) GetType() string {
	return TypeUserPrivacySettingRules
}

func (userPrivacySettingRules *UserPrivacySettingRules) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Rules []json.RawMessage `json:"rules"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldRules, _ := UnmarshalListOfUserPrivacySettingRule(tmp.Rules)
	userPrivacySettingRules.Rules = fieldRules

	return nil
}

// A privacy setting for managing whether the user's online status is visible
type UserPrivacySettingShowStatus struct {
	meta
}

func (entity *UserPrivacySettingShowStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowStatus

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowStatus) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowStatus) GetType() string {
	return TypeUserPrivacySettingShowStatus
}

func (*UserPrivacySettingShowStatus) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowStatus
}

// A privacy setting for managing whether the user's profile photo is visible
type UserPrivacySettingShowProfilePhoto struct {
	meta
}

func (entity *UserPrivacySettingShowProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowProfilePhoto) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowProfilePhoto) GetType() string {
	return TypeUserPrivacySettingShowProfilePhoto
}

func (*UserPrivacySettingShowProfilePhoto) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowProfilePhoto
}

// A privacy setting for managing whether a link to the user's account is included in forwarded messages
type UserPrivacySettingShowLinkInForwardedMessages struct {
	meta
}

func (entity *UserPrivacySettingShowLinkInForwardedMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowLinkInForwardedMessages

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowLinkInForwardedMessages) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowLinkInForwardedMessages) GetType() string {
	return TypeUserPrivacySettingShowLinkInForwardedMessages
}

func (*UserPrivacySettingShowLinkInForwardedMessages) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowLinkInForwardedMessages
}

// A privacy setting for managing whether the user's phone number is visible
type UserPrivacySettingShowPhoneNumber struct {
	meta
}

func (entity *UserPrivacySettingShowPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowPhoneNumber) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowPhoneNumber) GetType() string {
	return TypeUserPrivacySettingShowPhoneNumber
}

func (*UserPrivacySettingShowPhoneNumber) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowPhoneNumber
}

// A privacy setting for managing whether the user can be invited to chats
type UserPrivacySettingAllowChatInvites struct {
	meta
}

func (entity *UserPrivacySettingAllowChatInvites) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowChatInvites

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowChatInvites) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowChatInvites) GetType() string {
	return TypeUserPrivacySettingAllowChatInvites
}

func (*UserPrivacySettingAllowChatInvites) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowChatInvites
}

// A privacy setting for managing whether the user can be called
type UserPrivacySettingAllowCalls struct {
	meta
}

func (entity *UserPrivacySettingAllowCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowCalls

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowCalls) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowCalls) GetType() string {
	return TypeUserPrivacySettingAllowCalls
}

func (*UserPrivacySettingAllowCalls) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowCalls
}

// A privacy setting for managing whether peer-to-peer connections can be used for calls
type UserPrivacySettingAllowPeerToPeerCalls struct {
	meta
}

func (entity *UserPrivacySettingAllowPeerToPeerCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowPeerToPeerCalls

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowPeerToPeerCalls) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowPeerToPeerCalls) GetType() string {
	return TypeUserPrivacySettingAllowPeerToPeerCalls
}

func (*UserPrivacySettingAllowPeerToPeerCalls) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowPeerToPeerCalls
}

// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
type UserPrivacySettingAllowFindingByPhoneNumber struct {
	meta
}

func (entity *UserPrivacySettingAllowFindingByPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowFindingByPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) GetType() string {
	return TypeUserPrivacySettingAllowFindingByPhoneNumber
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowFindingByPhoneNumber
}

// A privacy setting for managing whether the user can receive voice and video messages in private chats
type UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages struct {
	meta
}

func (entity *UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) GetType() string {
	return TypeUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
}

func (*UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
}

// Contains information about the period of inactivity after which the current user's account will automatically be deleted
type AccountTtl struct {
	meta
	// Number of days of inactivity before the account will be flagged for deletion; 30-366 days
	Days int32 `json:"days"`
}

func (entity *AccountTtl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AccountTtl

	return json.Marshal((*stub)(entity))
}

func (*AccountTtl) GetClass() string {
	return ClassAccountTtl
}

func (*AccountTtl) GetType() string {
	return TypeAccountTtl
}

// Contains default auto-delete timer setting for new chats
type MessageAutoDeleteTime struct {
	meta
	// Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
	Time int32 `json:"time"`
}

func (entity *MessageAutoDeleteTime) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAutoDeleteTime

	return json.Marshal((*stub)(entity))
}

func (*MessageAutoDeleteTime) GetClass() string {
	return ClassMessageAutoDeleteTime
}

func (*MessageAutoDeleteTime) GetType() string {
	return TypeMessageAutoDeleteTime
}

// The session is running on an Android device
type SessionTypeAndroid struct {
	meta
}

func (entity *SessionTypeAndroid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeAndroid

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeAndroid) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeAndroid) GetType() string {
	return TypeSessionTypeAndroid
}

func (*SessionTypeAndroid) SessionTypeType() string {
	return TypeSessionTypeAndroid
}

// The session is running on a generic Apple device
type SessionTypeApple struct {
	meta
}

func (entity *SessionTypeApple) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeApple

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeApple) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeApple) GetType() string {
	return TypeSessionTypeApple
}

func (*SessionTypeApple) SessionTypeType() string {
	return TypeSessionTypeApple
}

// The session is running on the Brave browser
type SessionTypeBrave struct {
	meta
}

func (entity *SessionTypeBrave) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeBrave

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeBrave) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeBrave) GetType() string {
	return TypeSessionTypeBrave
}

func (*SessionTypeBrave) SessionTypeType() string {
	return TypeSessionTypeBrave
}

// The session is running on the Chrome browser
type SessionTypeChrome struct {
	meta
}

func (entity *SessionTypeChrome) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeChrome

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeChrome) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeChrome) GetType() string {
	return TypeSessionTypeChrome
}

func (*SessionTypeChrome) SessionTypeType() string {
	return TypeSessionTypeChrome
}

// The session is running on the Edge browser
type SessionTypeEdge struct {
	meta
}

func (entity *SessionTypeEdge) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeEdge

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeEdge) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeEdge) GetType() string {
	return TypeSessionTypeEdge
}

func (*SessionTypeEdge) SessionTypeType() string {
	return TypeSessionTypeEdge
}

// The session is running on the Firefox browser
type SessionTypeFirefox struct {
	meta
}

func (entity *SessionTypeFirefox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeFirefox

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeFirefox) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeFirefox) GetType() string {
	return TypeSessionTypeFirefox
}

func (*SessionTypeFirefox) SessionTypeType() string {
	return TypeSessionTypeFirefox
}

// The session is running on an iPad device
type SessionTypeIpad struct {
	meta
}

func (entity *SessionTypeIpad) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeIpad

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeIpad) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeIpad) GetType() string {
	return TypeSessionTypeIpad
}

func (*SessionTypeIpad) SessionTypeType() string {
	return TypeSessionTypeIpad
}

// The session is running on an iPhone device
type SessionTypeIphone struct {
	meta
}

func (entity *SessionTypeIphone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeIphone

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeIphone) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeIphone) GetType() string {
	return TypeSessionTypeIphone
}

func (*SessionTypeIphone) SessionTypeType() string {
	return TypeSessionTypeIphone
}

// The session is running on a Linux device
type SessionTypeLinux struct {
	meta
}

func (entity *SessionTypeLinux) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeLinux

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeLinux) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeLinux) GetType() string {
	return TypeSessionTypeLinux
}

func (*SessionTypeLinux) SessionTypeType() string {
	return TypeSessionTypeLinux
}

// The session is running on a Mac device
type SessionTypeMac struct {
	meta
}

func (entity *SessionTypeMac) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeMac

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeMac) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeMac) GetType() string {
	return TypeSessionTypeMac
}

func (*SessionTypeMac) SessionTypeType() string {
	return TypeSessionTypeMac
}

// The session is running on the Opera browser
type SessionTypeOpera struct {
	meta
}

func (entity *SessionTypeOpera) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeOpera

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeOpera) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeOpera) GetType() string {
	return TypeSessionTypeOpera
}

func (*SessionTypeOpera) SessionTypeType() string {
	return TypeSessionTypeOpera
}

// The session is running on the Safari browser
type SessionTypeSafari struct {
	meta
}

func (entity *SessionTypeSafari) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeSafari

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeSafari) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeSafari) GetType() string {
	return TypeSessionTypeSafari
}

func (*SessionTypeSafari) SessionTypeType() string {
	return TypeSessionTypeSafari
}

// The session is running on an Ubuntu device
type SessionTypeUbuntu struct {
	meta
}

func (entity *SessionTypeUbuntu) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeUbuntu

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeUbuntu) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeUbuntu) GetType() string {
	return TypeSessionTypeUbuntu
}

func (*SessionTypeUbuntu) SessionTypeType() string {
	return TypeSessionTypeUbuntu
}

// The session is running on an unknown type of device
type SessionTypeUnknown struct {
	meta
}

func (entity *SessionTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeUnknown) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeUnknown) GetType() string {
	return TypeSessionTypeUnknown
}

func (*SessionTypeUnknown) SessionTypeType() string {
	return TypeSessionTypeUnknown
}

// The session is running on the Vivaldi browser
type SessionTypeVivaldi struct {
	meta
}

func (entity *SessionTypeVivaldi) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeVivaldi

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeVivaldi) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeVivaldi) GetType() string {
	return TypeSessionTypeVivaldi
}

func (*SessionTypeVivaldi) SessionTypeType() string {
	return TypeSessionTypeVivaldi
}

// The session is running on a Windows device
type SessionTypeWindows struct {
	meta
}

func (entity *SessionTypeWindows) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeWindows

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeWindows) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeWindows) GetType() string {
	return TypeSessionTypeWindows
}

func (*SessionTypeWindows) SessionTypeType() string {
	return TypeSessionTypeWindows
}

// The session is running on an Xbox console
type SessionTypeXbox struct {
	meta
}

func (entity *SessionTypeXbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeXbox

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeXbox) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeXbox) GetType() string {
	return TypeSessionTypeXbox
}

func (*SessionTypeXbox) SessionTypeType() string {
	return TypeSessionTypeXbox
}

// Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
type Session struct {
	meta
	// Session identifier
	Id JsonInt64 `json:"id"`
	// True, if this session is the current session
	IsCurrent bool `json:"is_current"`
	// True, if a 2-step verification password is needed to complete authorization of the session
	IsPasswordPending bool `json:"is_password_pending"`
	// True, if incoming secret chats can be accepted by the session
	CanAcceptSecretChats bool `json:"can_accept_secret_chats"`
	// True, if incoming calls can be accepted by the session
	CanAcceptCalls bool `json:"can_accept_calls"`
	// Session type based on the system and application version, which can be used to display a corresponding icon
	Type SessionType `json:"type"`
	// Telegram API identifier, as provided by the application
	ApiId int32 `json:"api_id"`
	// Name of the application, as provided by the application
	ApplicationName string `json:"application_name"`
	// The version of the application, as provided by the application
	ApplicationVersion string `json:"application_version"`
	// True, if the application is an official application or uses the api_id of an official application
	IsOfficialApplication bool `json:"is_official_application"`
	// Model of the device the application has been run or is running on, as provided by the application
	DeviceModel string `json:"device_model"`
	// Operating system the application has been run or is running on, as provided by the application
	Platform string `json:"platform"`
	// Version of the operating system the application has been run or is running on, as provided by the application
	SystemVersion string `json:"system_version"`
	// Point in time (Unix timestamp) when the user has logged in
	LogInDate int32 `json:"log_in_date"`
	// Point in time (Unix timestamp) when the session was last used
	LastActiveDate int32 `json:"last_active_date"`
	// IP address from which the session was created, in human-readable format
	Ip string `json:"ip"`
	// A two-letter country code for the country from which the session was created, based on the IP address
	Country string `json:"country"`
	// Region code from which the session was created, based on the IP address
	Region string `json:"region"`
}

func (entity *Session) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Session

	return json.Marshal((*stub)(entity))
}

func (*Session) GetClass() string {
	return ClassSession
}

func (*Session) GetType() string {
	return TypeSession
}

func (session *Session) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                    JsonInt64       `json:"id"`
		IsCurrent             bool            `json:"is_current"`
		IsPasswordPending     bool            `json:"is_password_pending"`
		CanAcceptSecretChats  bool            `json:"can_accept_secret_chats"`
		CanAcceptCalls        bool            `json:"can_accept_calls"`
		Type                  json.RawMessage `json:"type"`
		ApiId                 int32           `json:"api_id"`
		ApplicationName       string          `json:"application_name"`
		ApplicationVersion    string          `json:"application_version"`
		IsOfficialApplication bool            `json:"is_official_application"`
		DeviceModel           string          `json:"device_model"`
		Platform              string          `json:"platform"`
		SystemVersion         string          `json:"system_version"`
		LogInDate             int32           `json:"log_in_date"`
		LastActiveDate        int32           `json:"last_active_date"`
		Ip                    string          `json:"ip"`
		Country               string          `json:"country"`
		Region                string          `json:"region"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	session.Id = tmp.Id
	session.IsCurrent = tmp.IsCurrent
	session.IsPasswordPending = tmp.IsPasswordPending
	session.CanAcceptSecretChats = tmp.CanAcceptSecretChats
	session.CanAcceptCalls = tmp.CanAcceptCalls
	session.ApiId = tmp.ApiId
	session.ApplicationName = tmp.ApplicationName
	session.ApplicationVersion = tmp.ApplicationVersion
	session.IsOfficialApplication = tmp.IsOfficialApplication
	session.DeviceModel = tmp.DeviceModel
	session.Platform = tmp.Platform
	session.SystemVersion = tmp.SystemVersion
	session.LogInDate = tmp.LogInDate
	session.LastActiveDate = tmp.LastActiveDate
	session.Ip = tmp.Ip
	session.Country = tmp.Country
	session.Region = tmp.Region

	fieldType, _ := UnmarshalSessionType(tmp.Type)
	session.Type = fieldType

	return nil
}

// Contains a list of sessions
type Sessions struct {
	meta
	// List of sessions
	Sessions []*Session `json:"sessions"`
	// Number of days of inactivity before sessions will automatically be terminated; 1-366 days
	InactiveSessionTtlDays int32 `json:"inactive_session_ttl_days"`
}

func (entity *Sessions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Sessions

	return json.Marshal((*stub)(entity))
}

func (*Sessions) GetClass() string {
	return ClassSessions
}

func (*Sessions) GetType() string {
	return TypeSessions
}

// Contains information about one website the current user is logged in with Telegram
type ConnectedWebsite struct {
	meta
	// Website identifier
	Id JsonInt64 `json:"id"`
	// The domain name of the website
	DomainName string `json:"domain_name"`
	// User identifier of a bot linked with the website
	BotUserId int64 `json:"bot_user_id"`
	// The version of a browser used to log in
	Browser string `json:"browser"`
	// Operating system the browser is running on
	Platform string `json:"platform"`
	// Point in time (Unix timestamp) when the user was logged in
	LogInDate int32 `json:"log_in_date"`
	// Point in time (Unix timestamp) when obtained authorization was last used
	LastActiveDate int32 `json:"last_active_date"`
	// IP address from which the user was logged in, in human-readable format
	Ip string `json:"ip"`
	// Human-readable description of a country and a region from which the user was logged in, based on the IP address
	Location string `json:"location"`
}

func (entity *ConnectedWebsite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectedWebsite

	return json.Marshal((*stub)(entity))
}

func (*ConnectedWebsite) GetClass() string {
	return ClassConnectedWebsite
}

func (*ConnectedWebsite) GetType() string {
	return TypeConnectedWebsite
}

// Contains a list of websites the current user is logged in with Telegram
type ConnectedWebsites struct {
	meta
	// List of connected websites
	Websites []*ConnectedWebsite `json:"websites"`
}

func (entity *ConnectedWebsites) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectedWebsites

	return json.Marshal((*stub)(entity))
}

func (*ConnectedWebsites) GetClass() string {
	return ClassConnectedWebsites
}

func (*ConnectedWebsites) GetType() string {
	return TypeConnectedWebsites
}

// The chat contains spam messages
type ChatReportReasonSpam struct {
	meta
}

func (entity *ChatReportReasonSpam) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonSpam

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonSpam) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonSpam) GetType() string {
	return TypeChatReportReasonSpam
}

func (*ChatReportReasonSpam) ChatReportReasonType() string {
	return TypeChatReportReasonSpam
}

// The chat promotes violence
type ChatReportReasonViolence struct {
	meta
}

func (entity *ChatReportReasonViolence) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonViolence

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonViolence) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonViolence) GetType() string {
	return TypeChatReportReasonViolence
}

func (*ChatReportReasonViolence) ChatReportReasonType() string {
	return TypeChatReportReasonViolence
}

// The chat contains pornographic messages
type ChatReportReasonPornography struct {
	meta
}

func (entity *ChatReportReasonPornography) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonPornography

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonPornography) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonPornography) GetType() string {
	return TypeChatReportReasonPornography
}

func (*ChatReportReasonPornography) ChatReportReasonType() string {
	return TypeChatReportReasonPornography
}

// The chat has child abuse related content
type ChatReportReasonChildAbuse struct {
	meta
}

func (entity *ChatReportReasonChildAbuse) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonChildAbuse

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonChildAbuse) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonChildAbuse) GetType() string {
	return TypeChatReportReasonChildAbuse
}

func (*ChatReportReasonChildAbuse) ChatReportReasonType() string {
	return TypeChatReportReasonChildAbuse
}

// The chat contains copyrighted content
type ChatReportReasonCopyright struct {
	meta
}

func (entity *ChatReportReasonCopyright) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonCopyright

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonCopyright) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonCopyright) GetType() string {
	return TypeChatReportReasonCopyright
}

func (*ChatReportReasonCopyright) ChatReportReasonType() string {
	return TypeChatReportReasonCopyright
}

// The location-based chat is unrelated to its stated location
type ChatReportReasonUnrelatedLocation struct {
	meta
}

func (entity *ChatReportReasonUnrelatedLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonUnrelatedLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonUnrelatedLocation) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonUnrelatedLocation) GetType() string {
	return TypeChatReportReasonUnrelatedLocation
}

func (*ChatReportReasonUnrelatedLocation) ChatReportReasonType() string {
	return TypeChatReportReasonUnrelatedLocation
}

// The chat represents a fake account
type ChatReportReasonFake struct {
	meta
}

func (entity *ChatReportReasonFake) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonFake

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonFake) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonFake) GetType() string {
	return TypeChatReportReasonFake
}

func (*ChatReportReasonFake) ChatReportReasonType() string {
	return TypeChatReportReasonFake
}

// The chat has illegal drugs related content
type ChatReportReasonIllegalDrugs struct {
	meta
}

func (entity *ChatReportReasonIllegalDrugs) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonIllegalDrugs

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonIllegalDrugs) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonIllegalDrugs) GetType() string {
	return TypeChatReportReasonIllegalDrugs
}

func (*ChatReportReasonIllegalDrugs) ChatReportReasonType() string {
	return TypeChatReportReasonIllegalDrugs
}

// The chat contains messages with personal details
type ChatReportReasonPersonalDetails struct {
	meta
}

func (entity *ChatReportReasonPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonPersonalDetails) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonPersonalDetails) GetType() string {
	return TypeChatReportReasonPersonalDetails
}

func (*ChatReportReasonPersonalDetails) ChatReportReasonType() string {
	return TypeChatReportReasonPersonalDetails
}

// A custom reason provided by the user
type ChatReportReasonCustom struct {
	meta
}

func (entity *ChatReportReasonCustom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonCustom

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonCustom) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonCustom) GetType() string {
	return TypeChatReportReasonCustom
}

func (*ChatReportReasonCustom) ChatReportReasonType() string {
	return TypeChatReportReasonCustom
}

// The currently opened chat needs to be kept
type TargetChatCurrent struct {
	meta
}

func (entity *TargetChatCurrent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatCurrent

	return json.Marshal((*stub)(entity))
}

func (*TargetChatCurrent) GetClass() string {
	return ClassTargetChat
}

func (*TargetChatCurrent) GetType() string {
	return TypeTargetChatCurrent
}

func (*TargetChatCurrent) TargetChatType() string {
	return TypeTargetChatCurrent
}

// The chat needs to be chosen by the user among chats of the specified types
type TargetChatChosen struct {
	meta
	// True, if private chats with ordinary users are allowed
	AllowUserChats bool `json:"allow_user_chats"`
	// True, if private chats with other bots are allowed
	AllowBotChats bool `json:"allow_bot_chats"`
	// True, if basic group and supergroup chats are allowed
	AllowGroupChats bool `json:"allow_group_chats"`
	// True, if channel chats are allowed
	AllowChannelChats bool `json:"allow_channel_chats"`
}

func (entity *TargetChatChosen) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatChosen

	return json.Marshal((*stub)(entity))
}

func (*TargetChatChosen) GetClass() string {
	return ClassTargetChat
}

func (*TargetChatChosen) GetType() string {
	return TypeTargetChatChosen
}

func (*TargetChatChosen) TargetChatType() string {
	return TypeTargetChatChosen
}

// The chat needs to be open with the provided internal link
type TargetChatInternalLink struct {
	meta
	// An internal link pointing to the chat
	Link InternalLinkType `json:"link"`
}

func (entity *TargetChatInternalLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatInternalLink

	return json.Marshal((*stub)(entity))
}

func (*TargetChatInternalLink) GetClass() string {
	return ClassTargetChat
}

func (*TargetChatInternalLink) GetType() string {
	return TypeTargetChatInternalLink
}

func (*TargetChatInternalLink) TargetChatType() string {
	return TypeTargetChatInternalLink
}

func (targetChatInternalLink *TargetChatInternalLink) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Link json.RawMessage `json:"link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldLink, _ := UnmarshalInternalLinkType(tmp.Link)
	targetChatInternalLink.Link = fieldLink

	return nil
}

// The link is a link to the active sessions section of the application. Use getActiveSessions to handle the link
type InternalLinkTypeActiveSessions struct {
	meta
}

func (entity *InternalLinkTypeActiveSessions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeActiveSessions

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeActiveSessions) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeActiveSessions) GetType() string {
	return TypeInternalLinkTypeActiveSessions
}

func (*InternalLinkTypeActiveSessions) InternalLinkTypeType() string {
	return TypeInternalLinkTypeActiveSessions
}

// The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then, use getAttachmentMenuBot to receive information about the bot. If the bot isn't added to attachment menu, then user needs to confirm adding the bot to attachment menu. If user confirms adding, then use toggleBotIsAddedToAttachmentMenu to add it. If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL
type InternalLinkTypeAttachmentMenuBot struct {
	meta
	// Target chat to be opened
	TargetChat TargetChat `json:"target_chat"`
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// URL to be passed to openWebApp
	Url string `json:"url"`
}

func (entity *InternalLinkTypeAttachmentMenuBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeAttachmentMenuBot

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeAttachmentMenuBot) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeAttachmentMenuBot) GetType() string {
	return TypeInternalLinkTypeAttachmentMenuBot
}

func (*InternalLinkTypeAttachmentMenuBot) InternalLinkTypeType() string {
	return TypeInternalLinkTypeAttachmentMenuBot
}

func (internalLinkTypeAttachmentMenuBot *InternalLinkTypeAttachmentMenuBot) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TargetChat  json.RawMessage `json:"target_chat"`
		BotUsername string          `json:"bot_username"`
		Url         string          `json:"url"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	internalLinkTypeAttachmentMenuBot.BotUsername = tmp.BotUsername
	internalLinkTypeAttachmentMenuBot.Url = tmp.Url

	fieldTargetChat, _ := UnmarshalTargetChat(tmp.TargetChat)
	internalLinkTypeAttachmentMenuBot.TargetChat = fieldTargetChat

	return nil
}

// The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
type InternalLinkTypeAuthenticationCode struct {
	meta
	// The authentication code
	Code string `json:"code"`
}

func (entity *InternalLinkTypeAuthenticationCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeAuthenticationCode

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeAuthenticationCode) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeAuthenticationCode) GetType() string {
	return TypeInternalLinkTypeAuthenticationCode
}

func (*InternalLinkTypeAuthenticationCode) InternalLinkTypeType() string {
	return TypeInternalLinkTypeAuthenticationCode
}

// The link is a link to a background. Call searchBackground with the given background name to process the link
type InternalLinkTypeBackground struct {
	meta
	// Name of the background
	BackgroundName string `json:"background_name"`
}

func (entity *InternalLinkTypeBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBackground

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBackground) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBackground) GetType() string {
	return TypeInternalLinkTypeBackground
}

func (*InternalLinkTypeBackground) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBackground
}

// The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot, ask the current user to select a channel chat to add the bot to as an administrator. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights
type InternalLinkTypeBotAddToChannel struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// Expected administrator rights for the bot
	AdministratorRights *ChatAdministratorRights `json:"administrator_rights"`
}

func (entity *InternalLinkTypeBotAddToChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBotAddToChannel

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBotAddToChannel) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBotAddToChannel) GetType() string {
	return TypeInternalLinkTypeBotAddToChannel
}

func (*InternalLinkTypeBotAddToChannel) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBotAddToChannel
}

// The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot, and then call sendBotStartMessage with the given start parameter after the button is pressed
type InternalLinkTypeBotStart struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// The parameter to be passed to sendBotStartMessage
	StartParameter string `json:"start_parameter"`
	// True, if sendBotStartMessage must be called automatically without showing the START button
	Autostart bool `json:"autostart"`
}

func (entity *InternalLinkTypeBotStart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBotStart

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBotStart) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBotStart) GetType() string {
	return TypeInternalLinkTypeBotStart
}

func (*InternalLinkTypeBotStart) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBotStart
}

// The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups, ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup. If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat. Then, if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat.
type InternalLinkTypeBotStartInGroup struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// The parameter to be passed to sendBotStartMessage
	StartParameter string `json:"start_parameter"`
	// Expected administrator rights for the bot; may be null
	AdministratorRights *ChatAdministratorRights `json:"administrator_rights"`
}

func (entity *InternalLinkTypeBotStartInGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBotStartInGroup

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBotStartInGroup) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBotStartInGroup) GetType() string {
	return TypeInternalLinkTypeBotStartInGroup
}

func (*InternalLinkTypeBotStartInGroup) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBotStartInGroup
}

// The link is a link to the change phone number section of the app
type InternalLinkTypeChangePhoneNumber struct {
	meta
}

func (entity *InternalLinkTypeChangePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChangePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChangePhoneNumber) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChangePhoneNumber) GetType() string {
	return TypeInternalLinkTypeChangePhoneNumber
}

func (*InternalLinkTypeChangePhoneNumber) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChangePhoneNumber
}

// The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link
type InternalLinkTypeChatInvite struct {
	meta
	// Internal representation of the invite link
	InviteLink string `json:"invite_link"`
}

func (entity *InternalLinkTypeChatInvite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChatInvite

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChatInvite) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChatInvite) GetType() string {
	return TypeInternalLinkTypeChatInvite
}

func (*InternalLinkTypeChatInvite) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChatInvite
}

// The link is a link to the default message auto-delete timer settings section of the app settings
type InternalLinkTypeDefaultMessageAutoDeleteTimerSettings struct {
	meta
}

func (entity *InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeDefaultMessageAutoDeleteTimerSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) GetType() string {
	return TypeInternalLinkTypeDefaultMessageAutoDeleteTimerSettings
}

func (*InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeDefaultMessageAutoDeleteTimerSettings
}

// The link is a link to the edit profile section of the app settings
type InternalLinkTypeEditProfileSettings struct {
	meta
}

func (entity *InternalLinkTypeEditProfileSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeEditProfileSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeEditProfileSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeEditProfileSettings) GetType() string {
	return TypeInternalLinkTypeEditProfileSettings
}

func (*InternalLinkTypeEditProfileSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeEditProfileSettings
}

// The link is a link to the filter section of the app settings
type InternalLinkTypeFilterSettings struct {
	meta
}

func (entity *InternalLinkTypeFilterSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeFilterSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeFilterSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeFilterSettings) GetType() string {
	return TypeInternalLinkTypeFilterSettings
}

func (*InternalLinkTypeFilterSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeFilterSettings
}

// The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
type InternalLinkTypeGame struct {
	meta
	// Username of the bot that owns the game
	BotUsername string `json:"bot_username"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
}

func (entity *InternalLinkTypeGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeGame

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeGame) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeGame) GetType() string {
	return TypeInternalLinkTypeGame
}

func (*InternalLinkTypeGame) InternalLinkTypeType() string {
	return TypeInternalLinkTypeGame
}

// The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link
type InternalLinkTypeInstantView struct {
	meta
	// URL to be passed to getWebPageInstantView
	Url string `json:"url"`
	// An URL to open if getWebPageInstantView fails
	FallbackUrl string `json:"fallback_url"`
}

func (entity *InternalLinkTypeInstantView) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeInstantView

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeInstantView) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeInstantView) GetType() string {
	return TypeInternalLinkTypeInstantView
}

func (*InternalLinkTypeInstantView) InternalLinkTypeType() string {
	return TypeInternalLinkTypeInstantView
}

// The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link
type InternalLinkTypeInvoice struct {
	meta
	// Name of the invoice
	InvoiceName string `json:"invoice_name"`
}

func (entity *InternalLinkTypeInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeInvoice

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeInvoice) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeInvoice) GetType() string {
	return TypeInternalLinkTypeInvoice
}

func (*InternalLinkTypeInvoice) InternalLinkTypeType() string {
	return TypeInternalLinkTypeInvoice
}

// The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link
type InternalLinkTypeLanguagePack struct {
	meta
	// Language pack identifier
	LanguagePackId string `json:"language_pack_id"`
}

func (entity *InternalLinkTypeLanguagePack) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeLanguagePack

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeLanguagePack) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeLanguagePack) GetType() string {
	return TypeInternalLinkTypeLanguagePack
}

func (*InternalLinkTypeLanguagePack) InternalLinkTypeType() string {
	return TypeInternalLinkTypeLanguagePack
}

// The link is a link to the language section of the app settings
type InternalLinkTypeLanguageSettings struct {
	meta
}

func (entity *InternalLinkTypeLanguageSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeLanguageSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeLanguageSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeLanguageSettings) GetType() string {
	return TypeInternalLinkTypeLanguageSettings
}

func (*InternalLinkTypeLanguageSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeLanguageSettings
}

// The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link
type InternalLinkTypeMessage struct {
	meta
	// URL to be passed to getMessageLinkInfo
	Url string `json:"url"`
}

func (entity *InternalLinkTypeMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeMessage

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeMessage) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeMessage) GetType() string {
	return TypeInternalLinkTypeMessage
}

func (*InternalLinkTypeMessage) InternalLinkTypeType() string {
	return TypeInternalLinkTypeMessage
}

// The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
type InternalLinkTypeMessageDraft struct {
	meta
	// Message draft text
	Text *FormattedText `json:"text"`
	// True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
	ContainsLink bool `json:"contains_link"`
}

func (entity *InternalLinkTypeMessageDraft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeMessageDraft

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeMessageDraft) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeMessageDraft) GetType() string {
	return TypeInternalLinkTypeMessageDraft
}

func (*InternalLinkTypeMessageDraft) InternalLinkTypeType() string {
	return TypeInternalLinkTypeMessageDraft
}

// The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it
type InternalLinkTypePassportDataRequest struct {
	meta
	// User identifier of the service's bot
	BotUserId int64 `json:"bot_user_id"`
	// Telegram Passport element types requested by the service
	Scope string `json:"scope"`
	// Service's public key
	PublicKey string `json:"public_key"`
	// Unique request identifier provided by the service
	Nonce string `json:"nonce"`
	// An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
	CallbackUrl string `json:"callback_url"`
}

func (entity *InternalLinkTypePassportDataRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePassportDataRequest

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePassportDataRequest) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePassportDataRequest) GetType() string {
	return TypeInternalLinkTypePassportDataRequest
}

func (*InternalLinkTypePassportDataRequest) InternalLinkTypeType() string {
	return TypeInternalLinkTypePassportDataRequest
}

// The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link
type InternalLinkTypePhoneNumberConfirmation struct {
	meta
	// Hash value from the link
	Hash string `json:"hash"`
	// Phone number value from the link
	PhoneNumber string `json:"phone_number"`
}

func (entity *InternalLinkTypePhoneNumberConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePhoneNumberConfirmation

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePhoneNumberConfirmation) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePhoneNumberConfirmation) GetType() string {
	return TypeInternalLinkTypePhoneNumberConfirmation
}

func (*InternalLinkTypePhoneNumberConfirmation) InternalLinkTypeType() string {
	return TypeInternalLinkTypePhoneNumberConfirmation
}

// The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link
type InternalLinkTypePremiumFeatures struct {
	meta
	// Referrer specified in the link
	Referrer string `json:"referrer"`
}

func (entity *InternalLinkTypePremiumFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePremiumFeatures

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePremiumFeatures) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePremiumFeatures) GetType() string {
	return TypeInternalLinkTypePremiumFeatures
}

func (*InternalLinkTypePremiumFeatures) InternalLinkTypeType() string {
	return TypeInternalLinkTypePremiumFeatures
}

// The link is a link to the privacy and security section of the app settings
type InternalLinkTypePrivacyAndSecuritySettings struct {
	meta
}

func (entity *InternalLinkTypePrivacyAndSecuritySettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePrivacyAndSecuritySettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePrivacyAndSecuritySettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePrivacyAndSecuritySettings) GetType() string {
	return TypeInternalLinkTypePrivacyAndSecuritySettings
}

func (*InternalLinkTypePrivacyAndSecuritySettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypePrivacyAndSecuritySettings
}

// The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
type InternalLinkTypeProxy struct {
	meta
	// Proxy server IP address
	Server string `json:"server"`
	// Proxy server port
	Port int32 `json:"port"`
	// Type of the proxy
	Type ProxyType `json:"type"`
}

func (entity *InternalLinkTypeProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeProxy

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeProxy) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeProxy) GetType() string {
	return TypeInternalLinkTypeProxy
}

func (*InternalLinkTypeProxy) InternalLinkTypeType() string {
	return TypeInternalLinkTypeProxy
}

func (internalLinkTypeProxy *InternalLinkTypeProxy) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Server string          `json:"server"`
		Port   int32           `json:"port"`
		Type   json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	internalLinkTypeProxy.Server = tmp.Server
	internalLinkTypeProxy.Port = tmp.Port

	fieldType, _ := UnmarshalProxyType(tmp.Type)
	internalLinkTypeProxy.Type = fieldType

	return nil
}

// The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link
type InternalLinkTypePublicChat struct {
	meta
	// Username of the chat
	ChatUsername string `json:"chat_username"`
}

func (entity *InternalLinkTypePublicChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePublicChat

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePublicChat) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePublicChat) GetType() string {
	return TypeInternalLinkTypePublicChat
}

func (*InternalLinkTypePublicChat) InternalLinkTypeType() string {
	return TypeInternalLinkTypePublicChat
}

// The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to "This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown
type InternalLinkTypeQrCodeAuthentication struct {
	meta
}

func (entity *InternalLinkTypeQrCodeAuthentication) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeQrCodeAuthentication

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeQrCodeAuthentication) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeQrCodeAuthentication) GetType() string {
	return TypeInternalLinkTypeQrCodeAuthentication
}

func (*InternalLinkTypeQrCodeAuthentication) InternalLinkTypeType() string {
	return TypeInternalLinkTypeQrCodeAuthentication
}

// The link forces restore of App Store purchases when opened. For official iOS application only
type InternalLinkTypeRestorePurchases struct {
	meta
}

func (entity *InternalLinkTypeRestorePurchases) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeRestorePurchases

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeRestorePurchases) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeRestorePurchases) GetType() string {
	return TypeInternalLinkTypeRestorePurchases
}

func (*InternalLinkTypeRestorePurchases) InternalLinkTypeType() string {
	return TypeInternalLinkTypeRestorePurchases
}

// The link is a link to application settings
type InternalLinkTypeSettings struct {
	meta
}

func (entity *InternalLinkTypeSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeSettings) GetType() string {
	return TypeInternalLinkTypeSettings
}

func (*InternalLinkTypeSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeSettings
}

// The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set
type InternalLinkTypeStickerSet struct {
	meta
	// Name of the sticker set
	StickerSetName string `json:"sticker_set_name"`
	// True, if the sticker set is expected to contain custom emoji
	ExpectCustomEmoji bool `json:"expect_custom_emoji"`
}

func (entity *InternalLinkTypeStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeStickerSet

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeStickerSet) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeStickerSet) GetType() string {
	return TypeInternalLinkTypeStickerSet
}

func (*InternalLinkTypeStickerSet) InternalLinkTypeType() string {
	return TypeInternalLinkTypeStickerSet
}

// The link is a link to a theme. TDLib has no theme support yet
type InternalLinkTypeTheme struct {
	meta
	// Name of the theme
	ThemeName string `json:"theme_name"`
}

func (entity *InternalLinkTypeTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeTheme

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeTheme) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeTheme) GetType() string {
	return TypeInternalLinkTypeTheme
}

func (*InternalLinkTypeTheme) InternalLinkTypeType() string {
	return TypeInternalLinkTypeTheme
}

// The link is a link to the theme section of the app settings
type InternalLinkTypeThemeSettings struct {
	meta
}

func (entity *InternalLinkTypeThemeSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeThemeSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeThemeSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeThemeSettings) GetType() string {
	return TypeInternalLinkTypeThemeSettings
}

func (*InternalLinkTypeThemeSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeThemeSettings
}

// The link is an unknown tg: link. Call getDeepLinkInfo to process the link
type InternalLinkTypeUnknownDeepLink struct {
	meta
	// Link to be passed to getDeepLinkInfo
	Link string `json:"link"`
}

func (entity *InternalLinkTypeUnknownDeepLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUnknownDeepLink

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUnknownDeepLink) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUnknownDeepLink) GetType() string {
	return TypeInternalLinkTypeUnknownDeepLink
}

func (*InternalLinkTypeUnknownDeepLink) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUnknownDeepLink
}

// The link is a link to an unsupported proxy. An alert can be shown to the user
type InternalLinkTypeUnsupportedProxy struct {
	meta
}

func (entity *InternalLinkTypeUnsupportedProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUnsupportedProxy

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUnsupportedProxy) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUnsupportedProxy) GetType() string {
	return TypeInternalLinkTypeUnsupportedProxy
}

func (*InternalLinkTypeUnsupportedProxy) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUnsupportedProxy
}

// The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link
type InternalLinkTypeUserPhoneNumber struct {
	meta
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
}

func (entity *InternalLinkTypeUserPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUserPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUserPhoneNumber) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUserPhoneNumber) GetType() string {
	return TypeInternalLinkTypeUserPhoneNumber
}

func (*InternalLinkTypeUserPhoneNumber) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUserPhoneNumber
}

// The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link
type InternalLinkTypeUserToken struct {
	meta
	// The token
	Token string `json:"token"`
}

func (entity *InternalLinkTypeUserToken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUserToken

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUserToken) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUserToken) GetType() string {
	return TypeInternalLinkTypeUserToken
}

func (*InternalLinkTypeUserToken) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUserToken
}

// The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link
type InternalLinkTypeVideoChat struct {
	meta
	// Username of the chat with the video chat
	ChatUsername string `json:"chat_username"`
	// If non-empty, invite hash to be used to join the video chat without being muted by administrators
	InviteHash string `json:"invite_hash"`
	// True, if the video chat is expected to be a live stream in a channel or a broadcast group
	IsLiveStream bool `json:"is_live_stream"`
}

func (entity *InternalLinkTypeVideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeVideoChat

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeVideoChat) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeVideoChat) GetType() string {
	return TypeInternalLinkTypeVideoChat
}

func (*InternalLinkTypeVideoChat) InternalLinkTypeType() string {
	return TypeInternalLinkTypeVideoChat
}

// The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name. Process received foundWebApp by showing a confirmation dialog if needed, then calling getWebAppLinkUrl and opening the returned URL
type InternalLinkTypeWebApp struct {
	meta
	// Username of the bot that owns the Web App
	BotUsername string `json:"bot_username"`
	// Short name of the Web App
	WebAppShortName string `json:"web_app_short_name"`
	// Start parameter to be passed to getWebAppLinkUrl
	StartParameter string `json:"start_parameter"`
}

func (entity *InternalLinkTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeWebApp) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeWebApp) GetType() string {
	return TypeInternalLinkTypeWebApp
}

func (*InternalLinkTypeWebApp) InternalLinkTypeType() string {
	return TypeInternalLinkTypeWebApp
}

// Contains an HTTPS link to a message in a supergroup or channel, or a forum topic
type MessageLink struct {
	meta
	// The link
	Link string `json:"link"`
	// True, if the link will work for non-members of the chat
	IsPublic bool `json:"is_public"`
}

func (entity *MessageLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLink

	return json.Marshal((*stub)(entity))
}

func (*MessageLink) GetClass() string {
	return ClassMessageLink
}

func (*MessageLink) GetType() string {
	return TypeMessageLink
}

// Contains information about a link to a message or a forum topic in a chat
type MessageLinkInfo struct {
	meta
	// True, if the link is a public link for a message or a forum topic in a chat
	IsPublic bool `json:"is_public"`
	// If found, identifier of the chat to which the link points, 0 otherwise
	ChatId int64 `json:"chat_id"`
	// If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
	MessageThreadId int64 `json:"message_thread_id"`
	// If found, the linked message; may be null
	Message *Message `json:"message"`
	// Timestamp from which the video/audio/video note/voice note playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview
	MediaTimestamp int32 `json:"media_timestamp"`
	// True, if the whole media album to which the message belongs is linked
	ForAlbum bool `json:"for_album"`
}

func (entity *MessageLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageLinkInfo) GetClass() string {
	return ClassMessageLinkInfo
}

func (*MessageLinkInfo) GetType() string {
	return TypeMessageLinkInfo
}

// Contains a part of a file
type FilePart struct {
	meta
	// File bytes
	Data []byte `json:"data"`
}

func (entity *FilePart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FilePart

	return json.Marshal((*stub)(entity))
}

func (*FilePart) GetClass() string {
	return ClassFilePart
}

func (*FilePart) GetType() string {
	return TypeFilePart
}

// The data is not a file
type FileTypeNone struct {
	meta
}

func (entity *FileTypeNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeNone

	return json.Marshal((*stub)(entity))
}

func (*FileTypeNone) GetClass() string {
	return ClassFileType
}

func (*FileTypeNone) GetType() string {
	return TypeFileTypeNone
}

func (*FileTypeNone) FileTypeType() string {
	return TypeFileTypeNone
}

// The file is an animation
type FileTypeAnimation struct {
	meta
}

func (entity *FileTypeAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeAnimation

	return json.Marshal((*stub)(entity))
}

func (*FileTypeAnimation) GetClass() string {
	return ClassFileType
}

func (*FileTypeAnimation) GetType() string {
	return TypeFileTypeAnimation
}

func (*FileTypeAnimation) FileTypeType() string {
	return TypeFileTypeAnimation
}

// The file is an audio file
type FileTypeAudio struct {
	meta
}

func (entity *FileTypeAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeAudio

	return json.Marshal((*stub)(entity))
}

func (*FileTypeAudio) GetClass() string {
	return ClassFileType
}

func (*FileTypeAudio) GetType() string {
	return TypeFileTypeAudio
}

func (*FileTypeAudio) FileTypeType() string {
	return TypeFileTypeAudio
}

// The file is a document
type FileTypeDocument struct {
	meta
}

func (entity *FileTypeDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeDocument

	return json.Marshal((*stub)(entity))
}

func (*FileTypeDocument) GetClass() string {
	return ClassFileType
}

func (*FileTypeDocument) GetType() string {
	return TypeFileTypeDocument
}

func (*FileTypeDocument) FileTypeType() string {
	return TypeFileTypeDocument
}

// The file is a notification sound
type FileTypeNotificationSound struct {
	meta
}

func (entity *FileTypeNotificationSound) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeNotificationSound

	return json.Marshal((*stub)(entity))
}

func (*FileTypeNotificationSound) GetClass() string {
	return ClassFileType
}

func (*FileTypeNotificationSound) GetType() string {
	return TypeFileTypeNotificationSound
}

func (*FileTypeNotificationSound) FileTypeType() string {
	return TypeFileTypeNotificationSound
}

// The file is a photo
type FileTypePhoto struct {
	meta
}

func (entity *FileTypePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypePhoto

	return json.Marshal((*stub)(entity))
}

func (*FileTypePhoto) GetClass() string {
	return ClassFileType
}

func (*FileTypePhoto) GetType() string {
	return TypeFileTypePhoto
}

func (*FileTypePhoto) FileTypeType() string {
	return TypeFileTypePhoto
}

// The file is a profile photo
type FileTypeProfilePhoto struct {
	meta
}

func (entity *FileTypeProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*FileTypeProfilePhoto) GetClass() string {
	return ClassFileType
}

func (*FileTypeProfilePhoto) GetType() string {
	return TypeFileTypeProfilePhoto
}

func (*FileTypeProfilePhoto) FileTypeType() string {
	return TypeFileTypeProfilePhoto
}

// The file was sent to a secret chat (the file type is not known to the server)
type FileTypeSecret struct {
	meta
}

func (entity *FileTypeSecret) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecret

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecret) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecret) GetType() string {
	return TypeFileTypeSecret
}

func (*FileTypeSecret) FileTypeType() string {
	return TypeFileTypeSecret
}

// The file is a thumbnail of a file from a secret chat
type FileTypeSecretThumbnail struct {
	meta
}

func (entity *FileTypeSecretThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecretThumbnail

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecretThumbnail) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecretThumbnail) GetType() string {
	return TypeFileTypeSecretThumbnail
}

func (*FileTypeSecretThumbnail) FileTypeType() string {
	return TypeFileTypeSecretThumbnail
}

// The file is a file from Secure storage used for storing Telegram Passport files
type FileTypeSecure struct {
	meta
}

func (entity *FileTypeSecure) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecure

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecure) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecure) GetType() string {
	return TypeFileTypeSecure
}

func (*FileTypeSecure) FileTypeType() string {
	return TypeFileTypeSecure
}

// The file is a sticker
type FileTypeSticker struct {
	meta
}

func (entity *FileTypeSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSticker

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSticker) GetClass() string {
	return ClassFileType
}

func (*FileTypeSticker) GetType() string {
	return TypeFileTypeSticker
}

func (*FileTypeSticker) FileTypeType() string {
	return TypeFileTypeSticker
}

// The file is a thumbnail of another file
type FileTypeThumbnail struct {
	meta
}

func (entity *FileTypeThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeThumbnail

	return json.Marshal((*stub)(entity))
}

func (*FileTypeThumbnail) GetClass() string {
	return ClassFileType
}

func (*FileTypeThumbnail) GetType() string {
	return TypeFileTypeThumbnail
}

func (*FileTypeThumbnail) FileTypeType() string {
	return TypeFileTypeThumbnail
}

// The file type is not yet known
type FileTypeUnknown struct {
	meta
}

func (entity *FileTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*FileTypeUnknown) GetClass() string {
	return ClassFileType
}

func (*FileTypeUnknown) GetType() string {
	return TypeFileTypeUnknown
}

func (*FileTypeUnknown) FileTypeType() string {
	return TypeFileTypeUnknown
}

// The file is a video
type FileTypeVideo struct {
	meta
}

func (entity *FileTypeVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideo

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideo) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideo) GetType() string {
	return TypeFileTypeVideo
}

func (*FileTypeVideo) FileTypeType() string {
	return TypeFileTypeVideo
}

// The file is a video note
type FileTypeVideoNote struct {
	meta
}

func (entity *FileTypeVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideoNote

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideoNote) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideoNote) GetType() string {
	return TypeFileTypeVideoNote
}

func (*FileTypeVideoNote) FileTypeType() string {
	return TypeFileTypeVideoNote
}

// The file is a voice note
type FileTypeVoiceNote struct {
	meta
}

func (entity *FileTypeVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVoiceNote) GetClass() string {
	return ClassFileType
}

func (*FileTypeVoiceNote) GetType() string {
	return TypeFileTypeVoiceNote
}

func (*FileTypeVoiceNote) FileTypeType() string {
	return TypeFileTypeVoiceNote
}

// The file is a wallpaper or a background pattern
type FileTypeWallpaper struct {
	meta
}

func (entity *FileTypeWallpaper) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeWallpaper

	return json.Marshal((*stub)(entity))
}

func (*FileTypeWallpaper) GetClass() string {
	return ClassFileType
}

func (*FileTypeWallpaper) GetType() string {
	return TypeFileTypeWallpaper
}

func (*FileTypeWallpaper) FileTypeType() string {
	return TypeFileTypeWallpaper
}

// Contains the storage usage statistics for a specific file type
type StorageStatisticsByFileType struct {
	meta
	// File type
	FileType FileType `json:"file_type"`
	// Total size of the files, in bytes
	Size int64 `json:"size"`
	// Total number of files
	Count int32 `json:"count"`
}

func (entity *StorageStatisticsByFileType) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsByFileType

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsByFileType) GetClass() string {
	return ClassStorageStatisticsByFileType
}

func (*StorageStatisticsByFileType) GetType() string {
	return TypeStorageStatisticsByFileType
}

func (storageStatisticsByFileType *StorageStatisticsByFileType) UnmarshalJSON(data []byte) error {
	var tmp struct {
		FileType json.RawMessage `json:"file_type"`
		Size     int64           `json:"size"`
		Count    int32           `json:"count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storageStatisticsByFileType.Size = tmp.Size
	storageStatisticsByFileType.Count = tmp.Count

	fieldFileType, _ := UnmarshalFileType(tmp.FileType)
	storageStatisticsByFileType.FileType = fieldFileType

	return nil
}

// Contains the storage usage statistics for a specific chat
type StorageStatisticsByChat struct {
	meta
	// Chat identifier; 0 if none
	ChatId int64 `json:"chat_id"`
	// Total size of the files in the chat, in bytes
	Size int64 `json:"size"`
	// Total number of files in the chat
	Count int32 `json:"count"`
	// Statistics split by file types
	ByFileType []*StorageStatisticsByFileType `json:"by_file_type"`
}

func (entity *StorageStatisticsByChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsByChat

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsByChat) GetClass() string {
	return ClassStorageStatisticsByChat
}

func (*StorageStatisticsByChat) GetType() string {
	return TypeStorageStatisticsByChat
}

// Contains the exact storage usage statistics split by chats and file type
type StorageStatistics struct {
	meta
	// Total size of files, in bytes
	Size int64 `json:"size"`
	// Total number of files
	Count int32 `json:"count"`
	// Statistics split by chats
	ByChat []*StorageStatisticsByChat `json:"by_chat"`
}

func (entity *StorageStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatistics

	return json.Marshal((*stub)(entity))
}

func (*StorageStatistics) GetClass() string {
	return ClassStorageStatistics
}

func (*StorageStatistics) GetType() string {
	return TypeStorageStatistics
}

// Contains approximate storage usage statistics, excluding files of unknown file type
type StorageStatisticsFast struct {
	meta
	// Approximate total size of files, in bytes
	FilesSize int64 `json:"files_size"`
	// Approximate number of files
	FileCount int32 `json:"file_count"`
	// Size of the database
	DatabaseSize int64 `json:"database_size"`
	// Size of the language pack database
	LanguagePackDatabaseSize int64 `json:"language_pack_database_size"`
	// Size of the TDLib internal log
	LogSize int64 `json:"log_size"`
}

func (entity *StorageStatisticsFast) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsFast

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsFast) GetClass() string {
	return ClassStorageStatisticsFast
}

func (*StorageStatisticsFast) GetType() string {
	return TypeStorageStatisticsFast
}

// Contains database statistics
type DatabaseStatistics struct {
	meta
	// Database statistics in an unspecified human-readable format
	Statistics string `json:"statistics"`
}

func (entity *DatabaseStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DatabaseStatistics

	return json.Marshal((*stub)(entity))
}

func (*DatabaseStatistics) GetClass() string {
	return ClassDatabaseStatistics
}

func (*DatabaseStatistics) GetType() string {
	return TypeDatabaseStatistics
}

// The network is not available
type NetworkTypeNone struct {
	meta
}

func (entity *NetworkTypeNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeNone

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeNone) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeNone) GetType() string {
	return TypeNetworkTypeNone
}

func (*NetworkTypeNone) NetworkTypeType() string {
	return TypeNetworkTypeNone
}

// A mobile network
type NetworkTypeMobile struct {
	meta
}

func (entity *NetworkTypeMobile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeMobile

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeMobile) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeMobile) GetType() string {
	return TypeNetworkTypeMobile
}

func (*NetworkTypeMobile) NetworkTypeType() string {
	return TypeNetworkTypeMobile
}

// A mobile roaming network
type NetworkTypeMobileRoaming struct {
	meta
}

func (entity *NetworkTypeMobileRoaming) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeMobileRoaming

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeMobileRoaming) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeMobileRoaming) GetType() string {
	return TypeNetworkTypeMobileRoaming
}

func (*NetworkTypeMobileRoaming) NetworkTypeType() string {
	return TypeNetworkTypeMobileRoaming
}

// A Wi-Fi network
type NetworkTypeWiFi struct {
	meta
}

func (entity *NetworkTypeWiFi) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeWiFi

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeWiFi) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeWiFi) GetType() string {
	return TypeNetworkTypeWiFi
}

func (*NetworkTypeWiFi) NetworkTypeType() string {
	return TypeNetworkTypeWiFi
}

// A different network type (e.g., Ethernet network)
type NetworkTypeOther struct {
	meta
}

func (entity *NetworkTypeOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeOther

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeOther) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeOther) GetType() string {
	return TypeNetworkTypeOther
}

func (*NetworkTypeOther) NetworkTypeType() string {
	return TypeNetworkTypeOther
}

// Contains information about the total amount of data that was used to send and receive files
type NetworkStatisticsEntryFile struct {
	meta
	// Type of the file the data is part of; pass null if the data isn't related to files
	FileType FileType `json:"file_type"`
	// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	NetworkType NetworkType `json:"network_type"`
	// Total number of bytes sent
	SentBytes int64 `json:"sent_bytes"`
	// Total number of bytes received
	ReceivedBytes int64 `json:"received_bytes"`
}

func (entity *NetworkStatisticsEntryFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatisticsEntryFile

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatisticsEntryFile) GetClass() string {
	return ClassNetworkStatisticsEntry
}

func (*NetworkStatisticsEntryFile) GetType() string {
	return TypeNetworkStatisticsEntryFile
}

func (*NetworkStatisticsEntryFile) NetworkStatisticsEntryType() string {
	return TypeNetworkStatisticsEntryFile
}

func (networkStatisticsEntryFile *NetworkStatisticsEntryFile) UnmarshalJSON(data []byte) error {
	var tmp struct {
		FileType      json.RawMessage `json:"file_type"`
		NetworkType   json.RawMessage `json:"network_type"`
		SentBytes     int64           `json:"sent_bytes"`
		ReceivedBytes int64           `json:"received_bytes"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatisticsEntryFile.SentBytes = tmp.SentBytes
	networkStatisticsEntryFile.ReceivedBytes = tmp.ReceivedBytes

	fieldFileType, _ := UnmarshalFileType(tmp.FileType)
	networkStatisticsEntryFile.FileType = fieldFileType

	fieldNetworkType, _ := UnmarshalNetworkType(tmp.NetworkType)
	networkStatisticsEntryFile.NetworkType = fieldNetworkType

	return nil
}

// Contains information about the total amount of data that was used for calls
type NetworkStatisticsEntryCall struct {
	meta
	// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	NetworkType NetworkType `json:"network_type"`
	// Total number of bytes sent
	SentBytes int64 `json:"sent_bytes"`
	// Total number of bytes received
	ReceivedBytes int64 `json:"received_bytes"`
	// Total call duration, in seconds
	Duration float64 `json:"duration"`
}

func (entity *NetworkStatisticsEntryCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatisticsEntryCall

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatisticsEntryCall) GetClass() string {
	return ClassNetworkStatisticsEntry
}

func (*NetworkStatisticsEntryCall) GetType() string {
	return TypeNetworkStatisticsEntryCall
}

func (*NetworkStatisticsEntryCall) NetworkStatisticsEntryType() string {
	return TypeNetworkStatisticsEntryCall
}

func (networkStatisticsEntryCall *NetworkStatisticsEntryCall) UnmarshalJSON(data []byte) error {
	var tmp struct {
		NetworkType   json.RawMessage `json:"network_type"`
		SentBytes     int64           `json:"sent_bytes"`
		ReceivedBytes int64           `json:"received_bytes"`
		Duration      float64         `json:"duration"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatisticsEntryCall.SentBytes = tmp.SentBytes
	networkStatisticsEntryCall.ReceivedBytes = tmp.ReceivedBytes
	networkStatisticsEntryCall.Duration = tmp.Duration

	fieldNetworkType, _ := UnmarshalNetworkType(tmp.NetworkType)
	networkStatisticsEntryCall.NetworkType = fieldNetworkType

	return nil
}

// A full list of available network statistic entries
type NetworkStatistics struct {
	meta
	// Point in time (Unix timestamp) from which the statistics are collected
	SinceDate int32 `json:"since_date"`
	// Network statistics entries
	Entries []NetworkStatisticsEntry `json:"entries"`
}

func (entity *NetworkStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatistics

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatistics) GetClass() string {
	return ClassNetworkStatistics
}

func (*NetworkStatistics) GetType() string {
	return TypeNetworkStatistics
}

func (networkStatistics *NetworkStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		SinceDate int32             `json:"since_date"`
		Entries   []json.RawMessage `json:"entries"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatistics.SinceDate = tmp.SinceDate

	fieldEntries, _ := UnmarshalListOfNetworkStatisticsEntry(tmp.Entries)
	networkStatistics.Entries = fieldEntries

	return nil
}

// Contains auto-download settings
type AutoDownloadSettings struct {
	meta
	// True, if the auto-download is enabled
	IsAutoDownloadEnabled bool `json:"is_auto_download_enabled"`
	// The maximum size of a photo file to be auto-downloaded, in bytes
	MaxPhotoFileSize int32 `json:"max_photo_file_size"`
	// The maximum size of a video file to be auto-downloaded, in bytes
	MaxVideoFileSize int64 `json:"max_video_file_size"`
	// The maximum size of other file types to be auto-downloaded, in bytes
	MaxOtherFileSize int64 `json:"max_other_file_size"`
	// The maximum suggested bitrate for uploaded videos, in kbit/s
	VideoUploadBitrate int32 `json:"video_upload_bitrate"`
	// True, if the beginning of video files needs to be preloaded for instant playback
	PreloadLargeVideos bool `json:"preload_large_videos"`
	// True, if the next audio track needs to be preloaded while the user is listening to an audio file
	PreloadNextAudio bool `json:"preload_next_audio"`
	// True, if "use less data for calls" option needs to be enabled
	UseLessDataForCalls bool `json:"use_less_data_for_calls"`
}

func (entity *AutoDownloadSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutoDownloadSettings

	return json.Marshal((*stub)(entity))
}

func (*AutoDownloadSettings) GetClass() string {
	return ClassAutoDownloadSettings
}

func (*AutoDownloadSettings) GetType() string {
	return TypeAutoDownloadSettings
}

// Contains auto-download settings presets for the current user
type AutoDownloadSettingsPresets struct {
	meta
	// Preset with lowest settings; supposed to be used by default when roaming
	Low *AutoDownloadSettings `json:"low"`
	// Preset with medium settings; supposed to be used by default when using mobile data
	Medium *AutoDownloadSettings `json:"medium"`
	// Preset with highest settings; supposed to be used by default when connected on Wi-Fi
	High *AutoDownloadSettings `json:"high"`
}

func (entity *AutoDownloadSettingsPresets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutoDownloadSettingsPresets

	return json.Marshal((*stub)(entity))
}

func (*AutoDownloadSettingsPresets) GetClass() string {
	return ClassAutoDownloadSettingsPresets
}

func (*AutoDownloadSettingsPresets) GetType() string {
	return TypeAutoDownloadSettingsPresets
}

// Autosave settings applied to all private chats without chat-specific settings
type AutosaveSettingsScopePrivateChats struct {
	meta
}

func (entity *AutosaveSettingsScopePrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopePrivateChats

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopePrivateChats) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopePrivateChats) GetType() string {
	return TypeAutosaveSettingsScopePrivateChats
}

func (*AutosaveSettingsScopePrivateChats) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopePrivateChats
}

// Autosave settings applied to all basic group and supergroup chats without chat-specific settings
type AutosaveSettingsScopeGroupChats struct {
	meta
}

func (entity *AutosaveSettingsScopeGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopeGroupChats

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopeGroupChats) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopeGroupChats) GetType() string {
	return TypeAutosaveSettingsScopeGroupChats
}

func (*AutosaveSettingsScopeGroupChats) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopeGroupChats
}

// Autosave settings applied to all channel chats without chat-specific settings
type AutosaveSettingsScopeChannelChats struct {
	meta
}

func (entity *AutosaveSettingsScopeChannelChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopeChannelChats

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopeChannelChats) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopeChannelChats) GetType() string {
	return TypeAutosaveSettingsScopeChannelChats
}

func (*AutosaveSettingsScopeChannelChats) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopeChannelChats
}

// Autosave settings applied to a chat
type AutosaveSettingsScopeChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
}

func (entity *AutosaveSettingsScopeChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopeChat

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopeChat) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopeChat) GetType() string {
	return TypeAutosaveSettingsScopeChat
}

func (*AutosaveSettingsScopeChat) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopeChat
}

// Contains autosave settings for an autosave settings scope
type ScopeAutosaveSettings struct {
	meta
	// True, if photo autosave is enabled
	AutosavePhotos bool `json:"autosave_photos"`
	// True, if video autosave is enabled
	AutosaveVideos bool `json:"autosave_videos"`
	// The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
	MaxVideoFileSize int64 `json:"max_video_file_size"`
}

func (entity *ScopeAutosaveSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ScopeAutosaveSettings

	return json.Marshal((*stub)(entity))
}

func (*ScopeAutosaveSettings) GetClass() string {
	return ClassScopeAutosaveSettings
}

func (*ScopeAutosaveSettings) GetType() string {
	return TypeScopeAutosaveSettings
}

// Contains autosave settings for a chat, which overrides default settings for the corresponding scope
type AutosaveSettingsException struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Autosave settings for the chat
	Settings *ScopeAutosaveSettings `json:"settings"`
}

func (entity *AutosaveSettingsException) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsException

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsException) GetClass() string {
	return ClassAutosaveSettingsException
}

func (*AutosaveSettingsException) GetType() string {
	return TypeAutosaveSettingsException
}

// Describes autosave settings
type AutosaveSettings struct {
	meta
	// Default autosave settings for private chats
	PrivateChatSettings *ScopeAutosaveSettings `json:"private_chat_settings"`
	// Default autosave settings for basic group and supergroup chats
	GroupSettings *ScopeAutosaveSettings `json:"group_settings"`
	// Default autosave settings for channel chats
	ChannelSettings *ScopeAutosaveSettings `json:"channel_settings"`
	// Autosave settings for specific chats
	Exceptions []*AutosaveSettingsException `json:"exceptions"`
}

func (entity *AutosaveSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettings

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettings) GetClass() string {
	return ClassAutosaveSettings
}

func (*AutosaveSettings) GetType() string {
	return TypeAutosaveSettings
}

// Currently waiting for the network to become available. Use setNetworkType to change the available network type
type ConnectionStateWaitingForNetwork struct {
	meta
}

func (entity *ConnectionStateWaitingForNetwork) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateWaitingForNetwork

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateWaitingForNetwork) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateWaitingForNetwork) GetType() string {
	return TypeConnectionStateWaitingForNetwork
}

func (*ConnectionStateWaitingForNetwork) ConnectionStateType() string {
	return TypeConnectionStateWaitingForNetwork
}

// Currently establishing a connection with a proxy server
type ConnectionStateConnectingToProxy struct {
	meta
}

func (entity *ConnectionStateConnectingToProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateConnectingToProxy

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateConnectingToProxy) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateConnectingToProxy) GetType() string {
	return TypeConnectionStateConnectingToProxy
}

func (*ConnectionStateConnectingToProxy) ConnectionStateType() string {
	return TypeConnectionStateConnectingToProxy
}

// Currently establishing a connection to the Telegram servers
type ConnectionStateConnecting struct {
	meta
}

func (entity *ConnectionStateConnecting) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateConnecting

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateConnecting) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateConnecting) GetType() string {
	return TypeConnectionStateConnecting
}

func (*ConnectionStateConnecting) ConnectionStateType() string {
	return TypeConnectionStateConnecting
}

// Downloading data received while the application was offline
type ConnectionStateUpdating struct {
	meta
}

func (entity *ConnectionStateUpdating) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateUpdating

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateUpdating) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateUpdating) GetType() string {
	return TypeConnectionStateUpdating
}

func (*ConnectionStateUpdating) ConnectionStateType() string {
	return TypeConnectionStateUpdating
}

// There is a working connection to the Telegram servers
type ConnectionStateReady struct {
	meta
}

func (entity *ConnectionStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateReady

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateReady) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateReady) GetType() string {
	return TypeConnectionStateReady
}

func (*ConnectionStateReady) ConnectionStateType() string {
	return TypeConnectionStateReady
}

// A category containing frequently used private chats with non-bot users
type TopChatCategoryUsers struct {
	meta
}

func (entity *TopChatCategoryUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryUsers

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryUsers) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryUsers) GetType() string {
	return TypeTopChatCategoryUsers
}

func (*TopChatCategoryUsers) TopChatCategoryType() string {
	return TypeTopChatCategoryUsers
}

// A category containing frequently used private chats with bot users
type TopChatCategoryBots struct {
	meta
}

func (entity *TopChatCategoryBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryBots) GetType() string {
	return TypeTopChatCategoryBots
}

func (*TopChatCategoryBots) TopChatCategoryType() string {
	return TypeTopChatCategoryBots
}

// A category containing frequently used basic groups and supergroups
type TopChatCategoryGroups struct {
	meta
}

func (entity *TopChatCategoryGroups) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryGroups

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryGroups) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryGroups) GetType() string {
	return TypeTopChatCategoryGroups
}

func (*TopChatCategoryGroups) TopChatCategoryType() string {
	return TypeTopChatCategoryGroups
}

// A category containing frequently used channels
type TopChatCategoryChannels struct {
	meta
}

func (entity *TopChatCategoryChannels) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryChannels

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryChannels) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryChannels) GetType() string {
	return TypeTopChatCategoryChannels
}

func (*TopChatCategoryChannels) TopChatCategoryType() string {
	return TypeTopChatCategoryChannels
}

// A category containing frequently used chats with inline bots sorted by their usage in inline mode
type TopChatCategoryInlineBots struct {
	meta
}

func (entity *TopChatCategoryInlineBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryInlineBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryInlineBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryInlineBots) GetType() string {
	return TypeTopChatCategoryInlineBots
}

func (*TopChatCategoryInlineBots) TopChatCategoryType() string {
	return TypeTopChatCategoryInlineBots
}

// A category containing frequently used chats used for calls
type TopChatCategoryCalls struct {
	meta
}

func (entity *TopChatCategoryCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryCalls

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryCalls) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryCalls) GetType() string {
	return TypeTopChatCategoryCalls
}

func (*TopChatCategoryCalls) TopChatCategoryType() string {
	return TypeTopChatCategoryCalls
}

// A category containing frequently used chats used to forward messages
type TopChatCategoryForwardChats struct {
	meta
}

func (entity *TopChatCategoryForwardChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryForwardChats

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryForwardChats) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryForwardChats) GetType() string {
	return TypeTopChatCategoryForwardChats
}

func (*TopChatCategoryForwardChats) TopChatCategoryType() string {
	return TypeTopChatCategoryForwardChats
}

// A URL linking to a user
type TMeUrlTypeUser struct {
	meta
	// Identifier of the user
	UserId int64 `json:"user_id"`
}

func (entity *TMeUrlTypeUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeUser

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeUser) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeUser) GetType() string {
	return TypeTMeUrlTypeUser
}

func (*TMeUrlTypeUser) TMeUrlTypeType() string {
	return TypeTMeUrlTypeUser
}

// A URL linking to a public supergroup or channel
type TMeUrlTypeSupergroup struct {
	meta
	// Identifier of the supergroup or channel
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *TMeUrlTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeSupergroup) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeSupergroup) GetType() string {
	return TypeTMeUrlTypeSupergroup
}

func (*TMeUrlTypeSupergroup) TMeUrlTypeType() string {
	return TypeTMeUrlTypeSupergroup
}

// A chat invite link
type TMeUrlTypeChatInvite struct {
	meta
	// Information about the chat invite link
	Info *ChatInviteLinkInfo `json:"info"`
}

func (entity *TMeUrlTypeChatInvite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeChatInvite

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeChatInvite) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeChatInvite) GetType() string {
	return TypeTMeUrlTypeChatInvite
}

func (*TMeUrlTypeChatInvite) TMeUrlTypeType() string {
	return TypeTMeUrlTypeChatInvite
}

// A URL linking to a sticker set
type TMeUrlTypeStickerSet struct {
	meta
	// Identifier of the sticker set
	StickerSetId JsonInt64 `json:"sticker_set_id"`
}

func (entity *TMeUrlTypeStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeStickerSet

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeStickerSet) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeStickerSet) GetType() string {
	return TypeTMeUrlTypeStickerSet
}

func (*TMeUrlTypeStickerSet) TMeUrlTypeType() string {
	return TypeTMeUrlTypeStickerSet
}

// Represents a URL linking to an internal Telegram entity
type TMeUrl struct {
	meta
	// URL
	Url string `json:"url"`
	// Type of the URL
	Type TMeUrlType `json:"type"`
}

func (entity *TMeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrl

	return json.Marshal((*stub)(entity))
}

func (*TMeUrl) GetClass() string {
	return ClassTMeUrl
}

func (*TMeUrl) GetType() string {
	return TypeTMeUrl
}

func (tMeUrl *TMeUrl) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url  string          `json:"url"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	tMeUrl.Url = tmp.Url

	fieldType, _ := UnmarshalTMeUrlType(tmp.Type)
	tMeUrl.Type = fieldType

	return nil
}

// Contains a list of t.me URLs
type TMeUrls struct {
	meta
	// List of URLs
	Urls []*TMeUrl `json:"urls"`
}

func (entity *TMeUrls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrls

	return json.Marshal((*stub)(entity))
}

func (*TMeUrls) GetClass() string {
	return ClassTMeUrls
}

func (*TMeUrls) GetType() string {
	return TypeTMeUrls
}

// Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users" option
type SuggestedActionEnableArchiveAndMuteNewChats struct {
	meta
}

func (entity *SuggestedActionEnableArchiveAndMuteNewChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionEnableArchiveAndMuteNewChats

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionEnableArchiveAndMuteNewChats) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionEnableArchiveAndMuteNewChats) GetType() string {
	return TypeSuggestedActionEnableArchiveAndMuteNewChats
}

func (*SuggestedActionEnableArchiveAndMuteNewChats) SuggestedActionType() string {
	return TypeSuggestedActionEnableArchiveAndMuteNewChats
}

// Suggests the user to check whether they still remember their 2-step verification password
type SuggestedActionCheckPassword struct {
	meta
}

func (entity *SuggestedActionCheckPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionCheckPassword

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionCheckPassword) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionCheckPassword) GetType() string {
	return TypeSuggestedActionCheckPassword
}

func (*SuggestedActionCheckPassword) SuggestedActionType() string {
	return TypeSuggestedActionCheckPassword
}

// Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
type SuggestedActionCheckPhoneNumber struct {
	meta
}

func (entity *SuggestedActionCheckPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionCheckPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionCheckPhoneNumber) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionCheckPhoneNumber) GetType() string {
	return TypeSuggestedActionCheckPhoneNumber
}

func (*SuggestedActionCheckPhoneNumber) SuggestedActionType() string {
	return TypeSuggestedActionCheckPhoneNumber
}

// Suggests the user to view a hint about the meaning of one and two check marks on sent messages
type SuggestedActionViewChecksHint struct {
	meta
}

func (entity *SuggestedActionViewChecksHint) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionViewChecksHint

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionViewChecksHint) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionViewChecksHint) GetType() string {
	return TypeSuggestedActionViewChecksHint
}

func (*SuggestedActionViewChecksHint) SuggestedActionType() string {
	return TypeSuggestedActionViewChecksHint
}

// Suggests the user to convert specified supergroup to a broadcast group
type SuggestedActionConvertToBroadcastGroup struct {
	meta
	// Supergroup identifier
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *SuggestedActionConvertToBroadcastGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionConvertToBroadcastGroup

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionConvertToBroadcastGroup) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionConvertToBroadcastGroup) GetType() string {
	return TypeSuggestedActionConvertToBroadcastGroup
}

func (*SuggestedActionConvertToBroadcastGroup) SuggestedActionType() string {
	return TypeSuggestedActionConvertToBroadcastGroup
}

// Suggests the user to set a 2-step verification password to be able to log in again
type SuggestedActionSetPassword struct {
	meta
	// The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
	AuthorizationDelay int32 `json:"authorization_delay"`
}

func (entity *SuggestedActionSetPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionSetPassword

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionSetPassword) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionSetPassword) GetType() string {
	return TypeSuggestedActionSetPassword
}

func (*SuggestedActionSetPassword) SuggestedActionType() string {
	return TypeSuggestedActionSetPassword
}

// Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
type SuggestedActionUpgradePremium struct {
	meta
}

func (entity *SuggestedActionUpgradePremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionUpgradePremium

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionUpgradePremium) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionUpgradePremium) GetType() string {
	return TypeSuggestedActionUpgradePremium
}

func (*SuggestedActionUpgradePremium) SuggestedActionType() string {
	return TypeSuggestedActionUpgradePremium
}

// Suggests the user to subscribe to the Premium subscription with annual payments
type SuggestedActionSubscribeToAnnualPremium struct {
	meta
}

func (entity *SuggestedActionSubscribeToAnnualPremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionSubscribeToAnnualPremium

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionSubscribeToAnnualPremium) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionSubscribeToAnnualPremium) GetType() string {
	return TypeSuggestedActionSubscribeToAnnualPremium
}

func (*SuggestedActionSubscribeToAnnualPremium) SuggestedActionType() string {
	return TypeSuggestedActionSubscribeToAnnualPremium
}

// Contains a counter
type Count struct {
	meta
	// Count
	Count int32 `json:"count"`
}

func (entity *Count) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Count

	return json.Marshal((*stub)(entity))
}

func (*Count) GetClass() string {
	return ClassCount
}

func (*Count) GetType() string {
	return TypeCount
}

// Contains some text
type Text struct {
	meta
	// Text
	Text string `json:"text"`
}

func (entity *Text) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Text

	return json.Marshal((*stub)(entity))
}

func (*Text) GetClass() string {
	return ClassText
}

func (*Text) GetType() string {
	return TypeText
}

// Contains a value representing a number of seconds
type Seconds struct {
	meta
	// Number of seconds
	Seconds float64 `json:"seconds"`
}

func (entity *Seconds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Seconds

	return json.Marshal((*stub)(entity))
}

func (*Seconds) GetClass() string {
	return ClassSeconds
}

func (*Seconds) GetType() string {
	return TypeSeconds
}

// Contains size of downloaded prefix of a file
type FileDownloadedPrefixSize struct {
	meta
	// The prefix size, in bytes
	Size int64 `json:"size"`
}

func (entity *FileDownloadedPrefixSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileDownloadedPrefixSize

	return json.Marshal((*stub)(entity))
}

func (*FileDownloadedPrefixSize) GetClass() string {
	return ClassFileDownloadedPrefixSize
}

func (*FileDownloadedPrefixSize) GetType() string {
	return TypeFileDownloadedPrefixSize
}

// Contains information about a tg: deep link
type DeepLinkInfo struct {
	meta
	// Text to be shown to the user
	Text *FormattedText `json:"text"`
	// True, if the user must be asked to update the application
	NeedUpdateApplication bool `json:"need_update_application"`
}

func (entity *DeepLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeepLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*DeepLinkInfo) GetClass() string {
	return ClassDeepLinkInfo
}

func (*DeepLinkInfo) GetType() string {
	return TypeDeepLinkInfo
}

// The text uses Markdown-style formatting
type TextParseModeMarkdown struct {
	meta
	// Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
	Version int32 `json:"version"`
}

func (entity *TextParseModeMarkdown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextParseModeMarkdown

	return json.Marshal((*stub)(entity))
}

func (*TextParseModeMarkdown) GetClass() string {
	return ClassTextParseMode
}

func (*TextParseModeMarkdown) GetType() string {
	return TypeTextParseModeMarkdown
}

func (*TextParseModeMarkdown) TextParseModeType() string {
	return TypeTextParseModeMarkdown
}

// The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
type TextParseModeHTML struct {
	meta
}

func (entity *TextParseModeHTML) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextParseModeHTML

	return json.Marshal((*stub)(entity))
}

func (*TextParseModeHTML) GetClass() string {
	return ClassTextParseMode
}

func (*TextParseModeHTML) GetType() string {
	return TypeTextParseModeHTML
}

func (*TextParseModeHTML) TextParseModeType() string {
	return TypeTextParseModeHTML
}

// A SOCKS5 proxy server
type ProxyTypeSocks5 struct {
	meta
	// Username for logging in; may be empty
	Username string `json:"username"`
	// Password for logging in; may be empty
	Password string `json:"password"`
}

func (entity *ProxyTypeSocks5) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeSocks5

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeSocks5) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeSocks5) GetType() string {
	return TypeProxyTypeSocks5
}

func (*ProxyTypeSocks5) ProxyTypeType() string {
	return TypeProxyTypeSocks5
}

// A HTTP transparent proxy server
type ProxyTypeHttp struct {
	meta
	// Username for logging in; may be empty
	Username string `json:"username"`
	// Password for logging in; may be empty
	Password string `json:"password"`
	// Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
	HttpOnly bool `json:"http_only"`
}

func (entity *ProxyTypeHttp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeHttp

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeHttp) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeHttp) GetType() string {
	return TypeProxyTypeHttp
}

func (*ProxyTypeHttp) ProxyTypeType() string {
	return TypeProxyTypeHttp
}

// An MTProto proxy server
type ProxyTypeMtproto struct {
	meta
	// The proxy's secret in hexadecimal encoding
	Secret string `json:"secret"`
}

func (entity *ProxyTypeMtproto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeMtproto

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeMtproto) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeMtproto) GetType() string {
	return TypeProxyTypeMtproto
}

func (*ProxyTypeMtproto) ProxyTypeType() string {
	return TypeProxyTypeMtproto
}

// Contains information about a proxy server
type Proxy struct {
	meta
	// Unique identifier of the proxy
	Id int32 `json:"id"`
	// Proxy server IP address
	Server string `json:"server"`
	// Proxy server port
	Port int32 `json:"port"`
	// Point in time (Unix timestamp) when the proxy was last used; 0 if never
	LastUsedDate int32 `json:"last_used_date"`
	// True, if the proxy is enabled now
	IsEnabled bool `json:"is_enabled"`
	// Type of the proxy
	Type ProxyType `json:"type"`
}

func (entity *Proxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Proxy

	return json.Marshal((*stub)(entity))
}

func (*Proxy) GetClass() string {
	return ClassProxy
}

func (*Proxy) GetType() string {
	return TypeProxy
}

func (proxy *Proxy) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           int32           `json:"id"`
		Server       string          `json:"server"`
		Port         int32           `json:"port"`
		LastUsedDate int32           `json:"last_used_date"`
		IsEnabled    bool            `json:"is_enabled"`
		Type         json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	proxy.Id = tmp.Id
	proxy.Server = tmp.Server
	proxy.Port = tmp.Port
	proxy.LastUsedDate = tmp.LastUsedDate
	proxy.IsEnabled = tmp.IsEnabled

	fieldType, _ := UnmarshalProxyType(tmp.Type)
	proxy.Type = fieldType

	return nil
}

// Represents a list of proxy servers
type Proxies struct {
	meta
	// List of proxy servers
	Proxies []*Proxy `json:"proxies"`
}

func (entity *Proxies) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Proxies

	return json.Marshal((*stub)(entity))
}

func (*Proxies) GetClass() string {
	return ClassProxies
}

func (*Proxies) GetType() string {
	return TypeProxies
}

// A sticker to be added to a sticker set
type InputSticker struct {
	meta
	// File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
	Sticker InputFile `json:"sticker"`
	// String with 1-20 emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// Position where the mask is placed; pass null if not specified
	MaskPosition *MaskPosition `json:"mask_position"`
	// List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
	Keywords []string `json:"keywords"`
}

func (entity *InputSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputSticker

	return json.Marshal((*stub)(entity))
}

func (*InputSticker) GetClass() string {
	return ClassInputSticker
}

func (*InputSticker) GetType() string {
	return TypeInputSticker
}

func (inputSticker *InputSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sticker      json.RawMessage `json:"sticker"`
		Emojis       string          `json:"emojis"`
		MaskPosition *MaskPosition   `json:"mask_position"`
		Keywords     []string        `json:"keywords"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputSticker.Emojis = tmp.Emojis
	inputSticker.MaskPosition = tmp.MaskPosition
	inputSticker.Keywords = tmp.Keywords

	fieldSticker, _ := UnmarshalInputFile(tmp.Sticker)
	inputSticker.Sticker = fieldSticker

	return nil
}

// Represents a date range
type DateRange struct {
	meta
	// Point in time (Unix timestamp) at which the date range begins
	StartDate int32 `json:"start_date"`
	// Point in time (Unix timestamp) at which the date range ends
	EndDate int32 `json:"end_date"`
}

func (entity *DateRange) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DateRange

	return json.Marshal((*stub)(entity))
}

func (*DateRange) GetClass() string {
	return ClassDateRange
}

func (*DateRange) GetType() string {
	return TypeDateRange
}

// A value with information about its recent changes
type StatisticalValue struct {
	meta
	// The current value
	Value float64 `json:"value"`
	// The value for the previous day
	PreviousValue float64 `json:"previous_value"`
	// The growth rate of the value, as a percentage
	GrowthRatePercentage float64 `json:"growth_rate_percentage"`
}

func (entity *StatisticalValue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalValue

	return json.Marshal((*stub)(entity))
}

func (*StatisticalValue) GetClass() string {
	return ClassStatisticalValue
}

func (*StatisticalValue) GetType() string {
	return TypeStatisticalValue
}

// A graph data
type StatisticalGraphData struct {
	meta
	// Graph data in JSON format
	JsonData string `json:"json_data"`
	// If non-empty, a token which can be used to receive a zoomed in graph
	ZoomToken string `json:"zoom_token"`
}

func (entity *StatisticalGraphData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalGraphData

	return json.Marshal((*stub)(entity))
}

func (*StatisticalGraphData) GetClass() string {
	return ClassStatisticalGraph
}

func (*StatisticalGraphData) GetType() string {
	return TypeStatisticalGraphData
}

func (*StatisticalGraphData) StatisticalGraphType() string {
	return TypeStatisticalGraphData
}

// The graph data to be asynchronously loaded through getStatisticalGraph
type StatisticalGraphAsync struct {
	meta
	// The token to use for data loading
	Token string `json:"token"`
}

func (entity *StatisticalGraphAsync) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalGraphAsync

	return json.Marshal((*stub)(entity))
}

func (*StatisticalGraphAsync) GetClass() string {
	return ClassStatisticalGraph
}

func (*StatisticalGraphAsync) GetType() string {
	return TypeStatisticalGraphAsync
}

func (*StatisticalGraphAsync) StatisticalGraphType() string {
	return TypeStatisticalGraphAsync
}

// An error message to be shown to the user instead of the graph
type StatisticalGraphError struct {
	meta
	// The error message
	ErrorMessage string `json:"error_message"`
}

func (entity *StatisticalGraphError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalGraphError

	return json.Marshal((*stub)(entity))
}

func (*StatisticalGraphError) GetClass() string {
	return ClassStatisticalGraph
}

func (*StatisticalGraphError) GetType() string {
	return TypeStatisticalGraphError
}

func (*StatisticalGraphError) StatisticalGraphType() string {
	return TypeStatisticalGraphError
}

// Contains statistics about interactions with a message
type ChatStatisticsMessageInteractionInfo struct {
	meta
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Number of times the message was viewed
	ViewCount int32 `json:"view_count"`
	// Number of times the message was forwarded
	ForwardCount int32 `json:"forward_count"`
}

func (entity *ChatStatisticsMessageInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsMessageInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsMessageInteractionInfo) GetClass() string {
	return ClassChatStatisticsMessageInteractionInfo
}

func (*ChatStatisticsMessageInteractionInfo) GetType() string {
	return TypeChatStatisticsMessageInteractionInfo
}

// Contains statistics about messages sent by a user
type ChatStatisticsMessageSenderInfo struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Number of sent messages
	SentMessageCount int32 `json:"sent_message_count"`
	// Average number of characters in sent messages; 0 if unknown
	AverageCharacterCount int32 `json:"average_character_count"`
}

func (entity *ChatStatisticsMessageSenderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsMessageSenderInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsMessageSenderInfo) GetClass() string {
	return ClassChatStatisticsMessageSenderInfo
}

func (*ChatStatisticsMessageSenderInfo) GetType() string {
	return TypeChatStatisticsMessageSenderInfo
}

// Contains statistics about administrator actions done by a user
type ChatStatisticsAdministratorActionsInfo struct {
	meta
	// Administrator user identifier
	UserId int64 `json:"user_id"`
	// Number of messages deleted by the administrator
	DeletedMessageCount int32 `json:"deleted_message_count"`
	// Number of users banned by the administrator
	BannedUserCount int32 `json:"banned_user_count"`
	// Number of users restricted by the administrator
	RestrictedUserCount int32 `json:"restricted_user_count"`
}

func (entity *ChatStatisticsAdministratorActionsInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsAdministratorActionsInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsAdministratorActionsInfo) GetClass() string {
	return ClassChatStatisticsAdministratorActionsInfo
}

func (*ChatStatisticsAdministratorActionsInfo) GetType() string {
	return TypeChatStatisticsAdministratorActionsInfo
}

// Contains statistics about number of new members invited by a user
type ChatStatisticsInviterInfo struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Number of new members invited by the user
	AddedMemberCount int32 `json:"added_member_count"`
}

func (entity *ChatStatisticsInviterInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsInviterInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsInviterInfo) GetClass() string {
	return ClassChatStatisticsInviterInfo
}

func (*ChatStatisticsInviterInfo) GetType() string {
	return TypeChatStatisticsInviterInfo
}

// A detailed statistics about a supergroup chat
type ChatStatisticsSupergroup struct {
	meta
	// A period to which the statistics applies
	Period *DateRange `json:"period"`
	// Number of members in the chat
	MemberCount *StatisticalValue `json:"member_count"`
	// Number of messages sent to the chat
	MessageCount *StatisticalValue `json:"message_count"`
	// Number of users who viewed messages in the chat
	ViewerCount *StatisticalValue `json:"viewer_count"`
	// Number of users who sent messages to the chat
	SenderCount *StatisticalValue `json:"sender_count"`
	// A graph containing number of members in the chat
	MemberCountGraph StatisticalGraph `json:"member_count_graph"`
	// A graph containing number of members joined and left the chat
	JoinGraph StatisticalGraph `json:"join_graph"`
	// A graph containing number of new member joins per source
	JoinBySourceGraph StatisticalGraph `json:"join_by_source_graph"`
	// A graph containing distribution of active users per language
	LanguageGraph StatisticalGraph `json:"language_graph"`
	// A graph containing distribution of sent messages by content type
	MessageContentGraph StatisticalGraph `json:"message_content_graph"`
	// A graph containing number of different actions in the chat
	ActionGraph StatisticalGraph `json:"action_graph"`
	// A graph containing distribution of message views per hour
	DayGraph StatisticalGraph `json:"day_graph"`
	// A graph containing distribution of message views per day of week
	WeekGraph StatisticalGraph `json:"week_graph"`
	// List of users sent most messages in the last week
	TopSenders []*ChatStatisticsMessageSenderInfo `json:"top_senders"`
	// List of most active administrators in the last week
	TopAdministrators []*ChatStatisticsAdministratorActionsInfo `json:"top_administrators"`
	// List of most active inviters of new members in the last week
	TopInviters []*ChatStatisticsInviterInfo `json:"top_inviters"`
}

func (entity *ChatStatisticsSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsSupergroup

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsSupergroup) GetClass() string {
	return ClassChatStatistics
}

func (*ChatStatisticsSupergroup) GetType() string {
	return TypeChatStatisticsSupergroup
}

func (*ChatStatisticsSupergroup) ChatStatisticsType() string {
	return TypeChatStatisticsSupergroup
}

func (chatStatisticsSupergroup *ChatStatisticsSupergroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Period              *DateRange                                `json:"period"`
		MemberCount         *StatisticalValue                         `json:"member_count"`
		MessageCount        *StatisticalValue                         `json:"message_count"`
		ViewerCount         *StatisticalValue                         `json:"viewer_count"`
		SenderCount         *StatisticalValue                         `json:"sender_count"`
		MemberCountGraph    json.RawMessage                           `json:"member_count_graph"`
		JoinGraph           json.RawMessage                           `json:"join_graph"`
		JoinBySourceGraph   json.RawMessage                           `json:"join_by_source_graph"`
		LanguageGraph       json.RawMessage                           `json:"language_graph"`
		MessageContentGraph json.RawMessage                           `json:"message_content_graph"`
		ActionGraph         json.RawMessage                           `json:"action_graph"`
		DayGraph            json.RawMessage                           `json:"day_graph"`
		WeekGraph           json.RawMessage                           `json:"week_graph"`
		TopSenders          []*ChatStatisticsMessageSenderInfo        `json:"top_senders"`
		TopAdministrators   []*ChatStatisticsAdministratorActionsInfo `json:"top_administrators"`
		TopInviters         []*ChatStatisticsInviterInfo              `json:"top_inviters"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatStatisticsSupergroup.Period = tmp.Period
	chatStatisticsSupergroup.MemberCount = tmp.MemberCount
	chatStatisticsSupergroup.MessageCount = tmp.MessageCount
	chatStatisticsSupergroup.ViewerCount = tmp.ViewerCount
	chatStatisticsSupergroup.SenderCount = tmp.SenderCount
	chatStatisticsSupergroup.TopSenders = tmp.TopSenders
	chatStatisticsSupergroup.TopAdministrators = tmp.TopAdministrators
	chatStatisticsSupergroup.TopInviters = tmp.TopInviters

	fieldMemberCountGraph, _ := UnmarshalStatisticalGraph(tmp.MemberCountGraph)
	chatStatisticsSupergroup.MemberCountGraph = fieldMemberCountGraph

	fieldJoinGraph, _ := UnmarshalStatisticalGraph(tmp.JoinGraph)
	chatStatisticsSupergroup.JoinGraph = fieldJoinGraph

	fieldJoinBySourceGraph, _ := UnmarshalStatisticalGraph(tmp.JoinBySourceGraph)
	chatStatisticsSupergroup.JoinBySourceGraph = fieldJoinBySourceGraph

	fieldLanguageGraph, _ := UnmarshalStatisticalGraph(tmp.LanguageGraph)
	chatStatisticsSupergroup.LanguageGraph = fieldLanguageGraph

	fieldMessageContentGraph, _ := UnmarshalStatisticalGraph(tmp.MessageContentGraph)
	chatStatisticsSupergroup.MessageContentGraph = fieldMessageContentGraph

	fieldActionGraph, _ := UnmarshalStatisticalGraph(tmp.ActionGraph)
	chatStatisticsSupergroup.ActionGraph = fieldActionGraph

	fieldDayGraph, _ := UnmarshalStatisticalGraph(tmp.DayGraph)
	chatStatisticsSupergroup.DayGraph = fieldDayGraph

	fieldWeekGraph, _ := UnmarshalStatisticalGraph(tmp.WeekGraph)
	chatStatisticsSupergroup.WeekGraph = fieldWeekGraph

	return nil
}

// A detailed statistics about a channel chat
type ChatStatisticsChannel struct {
	meta
	// A period to which the statistics applies
	Period *DateRange `json:"period"`
	// Number of members in the chat
	MemberCount *StatisticalValue `json:"member_count"`
	// Mean number of times the recently sent messages was viewed
	MeanViewCount *StatisticalValue `json:"mean_view_count"`
	// Mean number of times the recently sent messages was shared
	MeanShareCount *StatisticalValue `json:"mean_share_count"`
	// A percentage of users with enabled notifications for the chat
	EnabledNotificationsPercentage float64 `json:"enabled_notifications_percentage"`
	// A graph containing number of members in the chat
	MemberCountGraph StatisticalGraph `json:"member_count_graph"`
	// A graph containing number of members joined and left the chat
	JoinGraph StatisticalGraph `json:"join_graph"`
	// A graph containing number of members muted and unmuted the chat
	MuteGraph StatisticalGraph `json:"mute_graph"`
	// A graph containing number of message views in a given hour in the last two weeks
	ViewCountByHourGraph StatisticalGraph `json:"view_count_by_hour_graph"`
	// A graph containing number of message views per source
	ViewCountBySourceGraph StatisticalGraph `json:"view_count_by_source_graph"`
	// A graph containing number of new member joins per source
	JoinBySourceGraph StatisticalGraph `json:"join_by_source_graph"`
	// A graph containing number of users viewed chat messages per language
	LanguageGraph StatisticalGraph `json:"language_graph"`
	// A graph containing number of chat message views and shares
	MessageInteractionGraph StatisticalGraph `json:"message_interaction_graph"`
	// A graph containing number of views of associated with the chat instant views
	InstantViewInteractionGraph StatisticalGraph `json:"instant_view_interaction_graph"`
	// Detailed statistics about number of views and shares of recently sent messages
	RecentMessageInteractions []*ChatStatisticsMessageInteractionInfo `json:"recent_message_interactions"`
}

func (entity *ChatStatisticsChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsChannel

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsChannel) GetClass() string {
	return ClassChatStatistics
}

func (*ChatStatisticsChannel) GetType() string {
	return TypeChatStatisticsChannel
}

func (*ChatStatisticsChannel) ChatStatisticsType() string {
	return TypeChatStatisticsChannel
}

func (chatStatisticsChannel *ChatStatisticsChannel) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Period                         *DateRange                              `json:"period"`
		MemberCount                    *StatisticalValue                       `json:"member_count"`
		MeanViewCount                  *StatisticalValue                       `json:"mean_view_count"`
		MeanShareCount                 *StatisticalValue                       `json:"mean_share_count"`
		EnabledNotificationsPercentage float64                                 `json:"enabled_notifications_percentage"`
		MemberCountGraph               json.RawMessage                         `json:"member_count_graph"`
		JoinGraph                      json.RawMessage                         `json:"join_graph"`
		MuteGraph                      json.RawMessage                         `json:"mute_graph"`
		ViewCountByHourGraph           json.RawMessage                         `json:"view_count_by_hour_graph"`
		ViewCountBySourceGraph         json.RawMessage                         `json:"view_count_by_source_graph"`
		JoinBySourceGraph              json.RawMessage                         `json:"join_by_source_graph"`
		LanguageGraph                  json.RawMessage                         `json:"language_graph"`
		MessageInteractionGraph        json.RawMessage                         `json:"message_interaction_graph"`
		InstantViewInteractionGraph    json.RawMessage                         `json:"instant_view_interaction_graph"`
		RecentMessageInteractions      []*ChatStatisticsMessageInteractionInfo `json:"recent_message_interactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatStatisticsChannel.Period = tmp.Period
	chatStatisticsChannel.MemberCount = tmp.MemberCount
	chatStatisticsChannel.MeanViewCount = tmp.MeanViewCount
	chatStatisticsChannel.MeanShareCount = tmp.MeanShareCount
	chatStatisticsChannel.EnabledNotificationsPercentage = tmp.EnabledNotificationsPercentage
	chatStatisticsChannel.RecentMessageInteractions = tmp.RecentMessageInteractions

	fieldMemberCountGraph, _ := UnmarshalStatisticalGraph(tmp.MemberCountGraph)
	chatStatisticsChannel.MemberCountGraph = fieldMemberCountGraph

	fieldJoinGraph, _ := UnmarshalStatisticalGraph(tmp.JoinGraph)
	chatStatisticsChannel.JoinGraph = fieldJoinGraph

	fieldMuteGraph, _ := UnmarshalStatisticalGraph(tmp.MuteGraph)
	chatStatisticsChannel.MuteGraph = fieldMuteGraph

	fieldViewCountByHourGraph, _ := UnmarshalStatisticalGraph(tmp.ViewCountByHourGraph)
	chatStatisticsChannel.ViewCountByHourGraph = fieldViewCountByHourGraph

	fieldViewCountBySourceGraph, _ := UnmarshalStatisticalGraph(tmp.ViewCountBySourceGraph)
	chatStatisticsChannel.ViewCountBySourceGraph = fieldViewCountBySourceGraph

	fieldJoinBySourceGraph, _ := UnmarshalStatisticalGraph(tmp.JoinBySourceGraph)
	chatStatisticsChannel.JoinBySourceGraph = fieldJoinBySourceGraph

	fieldLanguageGraph, _ := UnmarshalStatisticalGraph(tmp.LanguageGraph)
	chatStatisticsChannel.LanguageGraph = fieldLanguageGraph

	fieldMessageInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.MessageInteractionGraph)
	chatStatisticsChannel.MessageInteractionGraph = fieldMessageInteractionGraph

	fieldInstantViewInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.InstantViewInteractionGraph)
	chatStatisticsChannel.InstantViewInteractionGraph = fieldInstantViewInteractionGraph

	return nil
}

// A detailed statistics about a message
type MessageStatistics struct {
	meta
	// A graph containing number of message views and shares
	MessageInteractionGraph StatisticalGraph `json:"message_interaction_graph"`
}

func (entity *MessageStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageStatistics

	return json.Marshal((*stub)(entity))
}

func (*MessageStatistics) GetClass() string {
	return ClassMessageStatistics
}

func (*MessageStatistics) GetType() string {
	return TypeMessageStatistics
}

func (messageStatistics *MessageStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageInteractionGraph json.RawMessage `json:"message_interaction_graph"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldMessageInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.MessageInteractionGraph)
	messageStatistics.MessageInteractionGraph = fieldMessageInteractionGraph

	return nil
}

// A point on a Cartesian plane
type Point struct {
	meta
	// The point's first coordinate
	X float64 `json:"x"`
	// The point's second coordinate
	Y float64 `json:"y"`
}

func (entity *Point) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Point

	return json.Marshal((*stub)(entity))
}

func (*Point) GetClass() string {
	return ClassPoint
}

func (*Point) GetType() string {
	return TypePoint
}

// A straight line to a given point
type VectorPathCommandLine struct {
	meta
	// The end point of the straight line
	EndPoint *Point `json:"end_point"`
}

func (entity *VectorPathCommandLine) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VectorPathCommandLine

	return json.Marshal((*stub)(entity))
}

func (*VectorPathCommandLine) GetClass() string {
	return ClassVectorPathCommand
}

func (*VectorPathCommandLine) GetType() string {
	return TypeVectorPathCommandLine
}

func (*VectorPathCommandLine) VectorPathCommandType() string {
	return TypeVectorPathCommandLine
}

// A cubic Bézier curve to a given point
type VectorPathCommandCubicBezierCurve struct {
	meta
	// The start control point of the curve
	StartControlPoint *Point `json:"start_control_point"`
	// The end control point of the curve
	EndControlPoint *Point `json:"end_control_point"`
	// The end point of the curve
	EndPoint *Point `json:"end_point"`
}

func (entity *VectorPathCommandCubicBezierCurve) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VectorPathCommandCubicBezierCurve

	return json.Marshal((*stub)(entity))
}

func (*VectorPathCommandCubicBezierCurve) GetClass() string {
	return ClassVectorPathCommand
}

func (*VectorPathCommandCubicBezierCurve) GetType() string {
	return TypeVectorPathCommandCubicBezierCurve
}

func (*VectorPathCommandCubicBezierCurve) VectorPathCommandType() string {
	return TypeVectorPathCommandCubicBezierCurve
}

// A scope covering all users
type BotCommandScopeDefault struct {
	meta
}

func (entity *BotCommandScopeDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeDefault

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeDefault) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeDefault) GetType() string {
	return TypeBotCommandScopeDefault
}

func (*BotCommandScopeDefault) BotCommandScopeType() string {
	return TypeBotCommandScopeDefault
}

// A scope covering all private chats
type BotCommandScopeAllPrivateChats struct {
	meta
}

func (entity *BotCommandScopeAllPrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeAllPrivateChats

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeAllPrivateChats) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeAllPrivateChats) GetType() string {
	return TypeBotCommandScopeAllPrivateChats
}

func (*BotCommandScopeAllPrivateChats) BotCommandScopeType() string {
	return TypeBotCommandScopeAllPrivateChats
}

// A scope covering all group and supergroup chats
type BotCommandScopeAllGroupChats struct {
	meta
}

func (entity *BotCommandScopeAllGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeAllGroupChats

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeAllGroupChats) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeAllGroupChats) GetType() string {
	return TypeBotCommandScopeAllGroupChats
}

func (*BotCommandScopeAllGroupChats) BotCommandScopeType() string {
	return TypeBotCommandScopeAllGroupChats
}

// A scope covering all group and supergroup chat administrators
type BotCommandScopeAllChatAdministrators struct {
	meta
}

func (entity *BotCommandScopeAllChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeAllChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeAllChatAdministrators) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeAllChatAdministrators) GetType() string {
	return TypeBotCommandScopeAllChatAdministrators
}

func (*BotCommandScopeAllChatAdministrators) BotCommandScopeType() string {
	return TypeBotCommandScopeAllChatAdministrators
}

// A scope covering all members of a chat
type BotCommandScopeChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
}

func (entity *BotCommandScopeChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeChat

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeChat) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeChat) GetType() string {
	return TypeBotCommandScopeChat
}

func (*BotCommandScopeChat) BotCommandScopeType() string {
	return TypeBotCommandScopeChat
}

// A scope covering all administrators of a chat
type BotCommandScopeChatAdministrators struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
}

func (entity *BotCommandScopeChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeChatAdministrators) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeChatAdministrators) GetType() string {
	return TypeBotCommandScopeChatAdministrators
}

func (*BotCommandScopeChatAdministrators) BotCommandScopeType() string {
	return TypeBotCommandScopeChatAdministrators
}

// A scope covering a member of a chat
type BotCommandScopeChatMember struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// User identifier
	UserId int64 `json:"user_id"`
}

func (entity *BotCommandScopeChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeChatMember

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeChatMember) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeChatMember) GetType() string {
	return TypeBotCommandScopeChatMember
}

func (*BotCommandScopeChatMember) BotCommandScopeType() string {
	return TypeBotCommandScopeChatMember
}

// The user authorization state has changed
type UpdateAuthorizationState struct {
	meta
	// New authorization state
	AuthorizationState AuthorizationState `json:"authorization_state"`
}

func (entity *UpdateAuthorizationState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAuthorizationState

	return json.Marshal((*stub)(entity))
}

func (*UpdateAuthorizationState) GetClass() string {
	return ClassUpdate
}

func (*UpdateAuthorizationState) GetType() string {
	return TypeUpdateAuthorizationState
}

func (*UpdateAuthorizationState) UpdateType() string {
	return TypeUpdateAuthorizationState
}

func (updateAuthorizationState *UpdateAuthorizationState) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AuthorizationState json.RawMessage `json:"authorization_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldAuthorizationState, _ := UnmarshalAuthorizationState(tmp.AuthorizationState)
	updateAuthorizationState.AuthorizationState = fieldAuthorizationState

	return nil
}

// A new message was received; can also be an outgoing message
type UpdateNewMessage struct {
	meta
	// The new message
	Message *Message `json:"message"`
}

func (entity *UpdateNewMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewMessage) GetType() string {
	return TypeUpdateNewMessage
}

func (*UpdateNewMessage) UpdateType() string {
	return TypeUpdateNewMessage
}

// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
type UpdateMessageSendAcknowledged struct {
	meta
	// The chat identifier of the sent message
	ChatId int64 `json:"chat_id"`
	// A temporary message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageSendAcknowledged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendAcknowledged

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendAcknowledged) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendAcknowledged) GetType() string {
	return TypeUpdateMessageSendAcknowledged
}

func (*UpdateMessageSendAcknowledged) UpdateType() string {
	return TypeUpdateMessageSendAcknowledged
}

// A message has been successfully sent
type UpdateMessageSendSucceeded struct {
	meta
	// The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
	Message *Message `json:"message"`
	// The previous temporary message identifier
	OldMessageId int64 `json:"old_message_id"`
}

func (entity *UpdateMessageSendSucceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendSucceeded

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendSucceeded) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendSucceeded) GetType() string {
	return TypeUpdateMessageSendSucceeded
}

func (*UpdateMessageSendSucceeded) UpdateType() string {
	return TypeUpdateMessageSendSucceeded
}

// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
type UpdateMessageSendFailed struct {
	meta
	// The failed to send message
	Message *Message `json:"message"`
	// The previous temporary message identifier
	OldMessageId int64 `json:"old_message_id"`
	// An error code
	ErrorCode int32 `json:"error_code"`
	// Error message
	ErrorMessage string `json:"error_message"`
}

func (entity *UpdateMessageSendFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendFailed

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendFailed) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendFailed) GetType() string {
	return TypeUpdateMessageSendFailed
}

func (*UpdateMessageSendFailed) UpdateType() string {
	return TypeUpdateMessageSendFailed
}

// The message content has changed
type UpdateMessageContent struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// New message content
	NewContent MessageContent `json:"new_content"`
}

func (entity *UpdateMessageContent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageContent

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageContent) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageContent) GetType() string {
	return TypeUpdateMessageContent
}

func (*UpdateMessageContent) UpdateType() string {
	return TypeUpdateMessageContent
}

func (updateMessageContent *UpdateMessageContent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId     int64           `json:"chat_id"`
		MessageId  int64           `json:"message_id"`
		NewContent json.RawMessage `json:"new_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageContent.ChatId = tmp.ChatId
	updateMessageContent.MessageId = tmp.MessageId

	fieldNewContent, _ := UnmarshalMessageContent(tmp.NewContent)
	updateMessageContent.NewContent = fieldNewContent

	return nil
}

// A message was edited. Changes in the message content will come in a separate updateMessageContent
type UpdateMessageEdited struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Point in time (Unix timestamp) when the message was edited
	EditDate int32 `json:"edit_date"`
	// New message reply markup; may be null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *UpdateMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageEdited) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageEdited) GetType() string {
	return TypeUpdateMessageEdited
}

func (*UpdateMessageEdited) UpdateType() string {
	return TypeUpdateMessageEdited
}

func (updateMessageEdited *UpdateMessageEdited) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId      int64           `json:"chat_id"`
		MessageId   int64           `json:"message_id"`
		EditDate    int32           `json:"edit_date"`
		ReplyMarkup json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageEdited.ChatId = tmp.ChatId
	updateMessageEdited.MessageId = tmp.MessageId
	updateMessageEdited.EditDate = tmp.EditDate

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	updateMessageEdited.ReplyMarkup = fieldReplyMarkup

	return nil
}

// The message pinned state was changed
type UpdateMessageIsPinned struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The message identifier
	MessageId int64 `json:"message_id"`
	// True, if the message is pinned
	IsPinned bool `json:"is_pinned"`
}

func (entity *UpdateMessageIsPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageIsPinned

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageIsPinned) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageIsPinned) GetType() string {
	return TypeUpdateMessageIsPinned
}

func (*UpdateMessageIsPinned) UpdateType() string {
	return TypeUpdateMessageIsPinned
}

// The information about interactions with a message has changed
type UpdateMessageInteractionInfo struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// New information about interactions with the message; may be null
	InteractionInfo *MessageInteractionInfo `json:"interaction_info"`
}

func (entity *UpdateMessageInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageInteractionInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageInteractionInfo) GetType() string {
	return TypeUpdateMessageInteractionInfo
}

func (*UpdateMessageInteractionInfo) UpdateType() string {
	return TypeUpdateMessageInteractionInfo
}

// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer
type UpdateMessageContentOpened struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageContentOpened) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageContentOpened

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageContentOpened) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageContentOpened) GetType() string {
	return TypeUpdateMessageContentOpened
}

func (*UpdateMessageContentOpened) UpdateType() string {
	return TypeUpdateMessageContentOpened
}

// A message with an unread mention was read
type UpdateMessageMentionRead struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The new number of unread mention messages left in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
}

func (entity *UpdateMessageMentionRead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageMentionRead

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageMentionRead) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageMentionRead) GetType() string {
	return TypeUpdateMessageMentionRead
}

func (*UpdateMessageMentionRead) UpdateType() string {
	return TypeUpdateMessageMentionRead
}

// The list of unread reactions added to a message was changed
type UpdateMessageUnreadReactions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The new list of unread reactions
	UnreadReactions []*UnreadReaction `json:"unread_reactions"`
	// The new number of messages with unread reactions left in the chat
	UnreadReactionCount int32 `json:"unread_reaction_count"`
}

func (entity *UpdateMessageUnreadReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageUnreadReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageUnreadReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageUnreadReactions) GetType() string {
	return TypeUpdateMessageUnreadReactions
}

func (*UpdateMessageUnreadReactions) UpdateType() string {
	return TypeUpdateMessageUnreadReactions
}

// A message with a live location was viewed. When the update is received, the application is supposed to update the live location
type UpdateMessageLiveLocationViewed struct {
	meta
	// Identifier of the chat with the live location message
	ChatId int64 `json:"chat_id"`
	// Identifier of the message with live location
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageLiveLocationViewed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageLiveLocationViewed

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageLiveLocationViewed) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageLiveLocationViewed) GetType() string {
	return TypeUpdateMessageLiveLocationViewed
}

func (*UpdateMessageLiveLocationViewed) UpdateType() string {
	return TypeUpdateMessageLiveLocationViewed
}

// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
type UpdateNewChat struct {
	meta
	// The chat
	Chat *Chat `json:"chat"`
}

func (entity *UpdateNewChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChat) GetType() string {
	return TypeUpdateNewChat
}

func (*UpdateNewChat) UpdateType() string {
	return TypeUpdateNewChat
}

// The title of a chat was changed
type UpdateChatTitle struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat title
	Title string `json:"title"`
}

func (entity *UpdateChatTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatTitle

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatTitle) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatTitle) GetType() string {
	return TypeUpdateChatTitle
}

func (*UpdateChatTitle) UpdateType() string {
	return TypeUpdateChatTitle
}

// A chat photo was changed
type UpdateChatPhoto struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
}

func (entity *UpdateChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPhoto) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPhoto) GetType() string {
	return TypeUpdateChatPhoto
}

func (*UpdateChatPhoto) UpdateType() string {
	return TypeUpdateChatPhoto
}

// Chat permissions was changed
type UpdateChatPermissions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat permissions
	Permissions *ChatPermissions `json:"permissions"`
}

func (entity *UpdateChatPermissions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPermissions

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPermissions) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPermissions) GetType() string {
	return TypeUpdateChatPermissions
}

func (*UpdateChatPermissions) UpdateType() string {
	return TypeUpdateChatPermissions
}

// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case
type UpdateChatLastMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new last message in the chat; may be null
	LastMessage *Message `json:"last_message"`
	// The new chat positions in the chat lists
	Positions []*ChatPosition `json:"positions"`
}

func (entity *UpdateChatLastMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatLastMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatLastMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatLastMessage) GetType() string {
	return TypeUpdateChatLastMessage
}

func (*UpdateChatLastMessage) UpdateType() string {
	return TypeUpdateChatLastMessage
}

// The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update
type UpdateChatPosition struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New chat position. If new order is 0, then the chat needs to be removed from the list
	Position *ChatPosition `json:"position"`
}

func (entity *UpdateChatPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPosition

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPosition) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPosition) GetType() string {
	return TypeUpdateChatPosition
}

func (*UpdateChatPosition) UpdateType() string {
	return TypeUpdateChatPosition
}

// Incoming messages were read or the number of unread messages has been changed
type UpdateChatReadInbox struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// The number of unread messages left in the chat
	UnreadCount int32 `json:"unread_count"`
}

func (entity *UpdateChatReadInbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReadInbox

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReadInbox) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReadInbox) GetType() string {
	return TypeUpdateChatReadInbox
}

func (*UpdateChatReadInbox) UpdateType() string {
	return TypeUpdateChatReadInbox
}

// Outgoing messages were read
type UpdateChatReadOutbox struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
}

func (entity *UpdateChatReadOutbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReadOutbox

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReadOutbox) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReadOutbox) GetType() string {
	return TypeUpdateChatReadOutbox
}

func (*UpdateChatReadOutbox) UpdateType() string {
	return TypeUpdateChatReadOutbox
}

// The chat action bar was changed
type UpdateChatActionBar struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new value of the action bar; may be null
	ActionBar ChatActionBar `json:"action_bar"`
}

func (entity *UpdateChatActionBar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatActionBar

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatActionBar) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatActionBar) GetType() string {
	return TypeUpdateChatActionBar
}

func (*UpdateChatActionBar) UpdateType() string {
	return TypeUpdateChatActionBar
}

func (updateChatActionBar *UpdateChatActionBar) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId    int64           `json:"chat_id"`
		ActionBar json.RawMessage `json:"action_bar"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatActionBar.ChatId = tmp.ChatId

	fieldActionBar, _ := UnmarshalChatActionBar(tmp.ActionBar)
	updateChatActionBar.ActionBar = fieldActionBar

	return nil
}

// The chat available reactions were changed
type UpdateChatAvailableReactions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new reactions, available in the chat
	AvailableReactions ChatAvailableReactions `json:"available_reactions"`
}

func (entity *UpdateChatAvailableReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatAvailableReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatAvailableReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatAvailableReactions) GetType() string {
	return TypeUpdateChatAvailableReactions
}

func (*UpdateChatAvailableReactions) UpdateType() string {
	return TypeUpdateChatAvailableReactions
}

func (updateChatAvailableReactions *UpdateChatAvailableReactions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId             int64           `json:"chat_id"`
		AvailableReactions json.RawMessage `json:"available_reactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatAvailableReactions.ChatId = tmp.ChatId

	fieldAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.AvailableReactions)
	updateChatAvailableReactions.AvailableReactions = fieldAvailableReactions

	return nil
}

// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
type UpdateChatDraftMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new draft message; may be null
	DraftMessage *DraftMessage `json:"draft_message"`
	// The new chat positions in the chat lists
	Positions []*ChatPosition `json:"positions"`
}

func (entity *UpdateChatDraftMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatDraftMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatDraftMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatDraftMessage) GetType() string {
	return TypeUpdateChatDraftMessage
}

func (*UpdateChatDraftMessage) UpdateType() string {
	return TypeUpdateChatDraftMessage
}

// The message sender that is selected to send messages in a chat has changed
type UpdateChatMessageSender struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of message_sender_id; may be null if the user can't change message sender
	MessageSenderId MessageSender `json:"message_sender_id"`
}

func (entity *UpdateChatMessageSender) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatMessageSender

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatMessageSender) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatMessageSender) GetType() string {
	return TypeUpdateChatMessageSender
}

func (*UpdateChatMessageSender) UpdateType() string {
	return TypeUpdateChatMessageSender
}

func (updateChatMessageSender *UpdateChatMessageSender) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId          int64           `json:"chat_id"`
		MessageSenderId json.RawMessage `json:"message_sender_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatMessageSender.ChatId = tmp.ChatId

	fieldMessageSenderId, _ := UnmarshalMessageSender(tmp.MessageSenderId)
	updateChatMessageSender.MessageSenderId = fieldMessageSenderId

	return nil
}

// The message auto-delete or self-destruct timer setting for a chat was changed
type UpdateChatMessageAutoDeleteTime struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of message_auto_delete_time
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"`
}

func (entity *UpdateChatMessageAutoDeleteTime) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatMessageAutoDeleteTime

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatMessageAutoDeleteTime) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatMessageAutoDeleteTime) GetType() string {
	return TypeUpdateChatMessageAutoDeleteTime
}

func (*UpdateChatMessageAutoDeleteTime) UpdateType() string {
	return TypeUpdateChatMessageAutoDeleteTime
}

// Notification settings for a chat were changed
type UpdateChatNotificationSettings struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new notification settings
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateChatNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatNotificationSettings) GetType() string {
	return TypeUpdateChatNotificationSettings
}

func (*UpdateChatNotificationSettings) UpdateType() string {
	return TypeUpdateChatNotificationSettings
}

// The chat pending join requests were changed
type UpdateChatPendingJoinRequests struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new data about pending join requests; may be null
	PendingJoinRequests *ChatJoinRequestsInfo `json:"pending_join_requests"`
}

func (entity *UpdateChatPendingJoinRequests) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPendingJoinRequests

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPendingJoinRequests) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPendingJoinRequests) GetType() string {
	return TypeUpdateChatPendingJoinRequests
}

func (*UpdateChatPendingJoinRequests) UpdateType() string {
	return TypeUpdateChatPendingJoinRequests
}

// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
type UpdateChatReplyMarkup struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	ReplyMarkupMessageId int64 `json:"reply_markup_message_id"`
}

func (entity *UpdateChatReplyMarkup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReplyMarkup

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReplyMarkup) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReplyMarkup) GetType() string {
	return TypeUpdateChatReplyMarkup
}

func (*UpdateChatReplyMarkup) UpdateType() string {
	return TypeUpdateChatReplyMarkup
}

// The chat theme was changed
type UpdateChatTheme struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new name of the chat theme; may be empty if theme was reset to default
	ThemeName string `json:"theme_name"`
}

func (entity *UpdateChatTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatTheme

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatTheme) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatTheme) GetType() string {
	return TypeUpdateChatTheme
}

func (*UpdateChatTheme) UpdateType() string {
	return TypeUpdateChatTheme
}

// The chat unread_mention_count has changed
type UpdateChatUnreadMentionCount struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The number of unread mention messages left in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
}

func (entity *UpdateChatUnreadMentionCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatUnreadMentionCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatUnreadMentionCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatUnreadMentionCount) GetType() string {
	return TypeUpdateChatUnreadMentionCount
}

func (*UpdateChatUnreadMentionCount) UpdateType() string {
	return TypeUpdateChatUnreadMentionCount
}

// The chat unread_reaction_count has changed
type UpdateChatUnreadReactionCount struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The number of messages with unread reactions left in the chat
	UnreadReactionCount int32 `json:"unread_reaction_count"`
}

func (entity *UpdateChatUnreadReactionCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatUnreadReactionCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatUnreadReactionCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatUnreadReactionCount) GetType() string {
	return TypeUpdateChatUnreadReactionCount
}

func (*UpdateChatUnreadReactionCount) UpdateType() string {
	return TypeUpdateChatUnreadReactionCount
}

// A chat video chat state has changed
type UpdateChatVideoChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of video_chat
	VideoChat *VideoChat `json:"video_chat"`
}

func (entity *UpdateChatVideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatVideoChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatVideoChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatVideoChat) GetType() string {
	return TypeUpdateChatVideoChat
}

func (*UpdateChatVideoChat) UpdateType() string {
	return TypeUpdateChatVideoChat
}

// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
type UpdateChatDefaultDisableNotification struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new default_disable_notification value
	DefaultDisableNotification bool `json:"default_disable_notification"`
}

func (entity *UpdateChatDefaultDisableNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatDefaultDisableNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatDefaultDisableNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatDefaultDisableNotification) GetType() string {
	return TypeUpdateChatDefaultDisableNotification
}

func (*UpdateChatDefaultDisableNotification) UpdateType() string {
	return TypeUpdateChatDefaultDisableNotification
}

// A chat content was allowed or restricted for saving
type UpdateChatHasProtectedContent struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of has_protected_content
	HasProtectedContent bool `json:"has_protected_content"`
}

func (entity *UpdateChatHasProtectedContent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatHasProtectedContent

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatHasProtectedContent) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatHasProtectedContent) GetType() string {
	return TypeUpdateChatHasProtectedContent
}

func (*UpdateChatHasProtectedContent) UpdateType() string {
	return TypeUpdateChatHasProtectedContent
}

// Translation of chat messages was enabled or disabled
type UpdateChatIsTranslatable struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_translatable
	IsTranslatable bool `json:"is_translatable"`
}

func (entity *UpdateChatIsTranslatable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsTranslatable

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsTranslatable) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsTranslatable) GetType() string {
	return TypeUpdateChatIsTranslatable
}

func (*UpdateChatIsTranslatable) UpdateType() string {
	return TypeUpdateChatIsTranslatable
}

// A chat was marked as unread or was read
type UpdateChatIsMarkedAsUnread struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_marked_as_unread
	IsMarkedAsUnread bool `json:"is_marked_as_unread"`
}

func (entity *UpdateChatIsMarkedAsUnread) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsMarkedAsUnread

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsMarkedAsUnread) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsMarkedAsUnread) GetType() string {
	return TypeUpdateChatIsMarkedAsUnread
}

func (*UpdateChatIsMarkedAsUnread) UpdateType() string {
	return TypeUpdateChatIsMarkedAsUnread
}

// A chat was blocked or unblocked
type UpdateChatIsBlocked struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_blocked
	IsBlocked bool `json:"is_blocked"`
}

func (entity *UpdateChatIsBlocked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsBlocked

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsBlocked) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsBlocked) GetType() string {
	return TypeUpdateChatIsBlocked
}

func (*UpdateChatIsBlocked) UpdateType() string {
	return TypeUpdateChatIsBlocked
}

// A chat's has_scheduled_messages field has changed
type UpdateChatHasScheduledMessages struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of has_scheduled_messages
	HasScheduledMessages bool `json:"has_scheduled_messages"`
}

func (entity *UpdateChatHasScheduledMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatHasScheduledMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatHasScheduledMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatHasScheduledMessages) GetType() string {
	return TypeUpdateChatHasScheduledMessages
}

func (*UpdateChatHasScheduledMessages) UpdateType() string {
	return TypeUpdateChatHasScheduledMessages
}

// The list of chat filters or a chat filter has changed
type UpdateChatFilters struct {
	meta
	// The new list of chat filters
	ChatFilters []*ChatFilterInfo `json:"chat_filters"`
	// Position of the main chat list among chat filters, 0-based
	MainChatListPosition int32 `json:"main_chat_list_position"`
}

func (entity *UpdateChatFilters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatFilters

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatFilters) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatFilters) GetType() string {
	return TypeUpdateChatFilters
}

func (*UpdateChatFilters) UpdateType() string {
	return TypeUpdateChatFilters
}

// The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats. There is no guarantee that it will be sent just after the number of online users has changed
type UpdateChatOnlineMemberCount struct {
	meta
	// Identifier of the chat
	ChatId int64 `json:"chat_id"`
	// New number of online members in the chat, or 0 if unknown
	OnlineMemberCount int32 `json:"online_member_count"`
}

func (entity *UpdateChatOnlineMemberCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatOnlineMemberCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatOnlineMemberCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatOnlineMemberCount) GetType() string {
	return TypeUpdateChatOnlineMemberCount
}

func (*UpdateChatOnlineMemberCount) UpdateType() string {
	return TypeUpdateChatOnlineMemberCount
}

// Basic information about a topic in a forum chat was changed
type UpdateForumTopicInfo struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New information about the topic
	Info *ForumTopicInfo `json:"info"`
}

func (entity *UpdateForumTopicInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateForumTopicInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateForumTopicInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateForumTopicInfo) GetType() string {
	return TypeUpdateForumTopicInfo
}

func (*UpdateForumTopicInfo) UpdateType() string {
	return TypeUpdateForumTopicInfo
}

// Notification settings for some type of chats were updated
type UpdateScopeNotificationSettings struct {
	meta
	// Types of chats for which notification settings were updated
	Scope NotificationSettingsScope `json:"scope"`
	// The new notification settings
	NotificationSettings *ScopeNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateScopeNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateScopeNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateScopeNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateScopeNotificationSettings) GetType() string {
	return TypeUpdateScopeNotificationSettings
}

func (*UpdateScopeNotificationSettings) UpdateType() string {
	return TypeUpdateScopeNotificationSettings
}

func (updateScopeNotificationSettings *UpdateScopeNotificationSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Scope                json.RawMessage            `json:"scope"`
		NotificationSettings *ScopeNotificationSettings `json:"notification_settings"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateScopeNotificationSettings.NotificationSettings = tmp.NotificationSettings

	fieldScope, _ := UnmarshalNotificationSettingsScope(tmp.Scope)
	updateScopeNotificationSettings.Scope = fieldScope

	return nil
}

// A notification was changed
type UpdateNotification struct {
	meta
	// Unique notification group identifier
	NotificationGroupId int32 `json:"notification_group_id"`
	// Changed notification
	Notification *Notification `json:"notification"`
}

func (entity *UpdateNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateNotification) GetType() string {
	return TypeUpdateNotification
}

func (*UpdateNotification) UpdateType() string {
	return TypeUpdateNotification
}

// A list of active notifications in a notification group has changed
type UpdateNotificationGroup struct {
	meta
	// Unique notification group identifier
	NotificationGroupId int32 `json:"notification_group_id"`
	// New type of the notification group
	Type NotificationGroupType `json:"type"`
	// Identifier of a chat to which all notifications in the group belong
	ChatId int64 `json:"chat_id"`
	// Chat identifier, which notification settings must be applied to the added notifications
	NotificationSettingsChatId int64 `json:"notification_settings_chat_id"`
	// Identifier of the notification sound to be played; 0 if sound is disabled
	NotificationSoundId JsonInt64 `json:"notification_sound_id"`
	// Total number of unread notifications in the group, can be bigger than number of active notifications
	TotalCount int32 `json:"total_count"`
	// List of added group notifications, sorted by notification ID
	AddedNotifications []*Notification `json:"added_notifications"`
	// Identifiers of removed group notifications, sorted by notification ID
	RemovedNotificationIds []int32 `json:"removed_notification_ids"`
}

func (entity *UpdateNotificationGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNotificationGroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateNotificationGroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateNotificationGroup) GetType() string {
	return TypeUpdateNotificationGroup
}

func (*UpdateNotificationGroup) UpdateType() string {
	return TypeUpdateNotificationGroup
}

func (updateNotificationGroup *UpdateNotificationGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		NotificationGroupId        int32           `json:"notification_group_id"`
		Type                       json.RawMessage `json:"type"`
		ChatId                     int64           `json:"chat_id"`
		NotificationSettingsChatId int64           `json:"notification_settings_chat_id"`
		NotificationSoundId        JsonInt64       `json:"notification_sound_id"`
		TotalCount                 int32           `json:"total_count"`
		AddedNotifications         []*Notification `json:"added_notifications"`
		RemovedNotificationIds     []int32         `json:"removed_notification_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNotificationGroup.NotificationGroupId = tmp.NotificationGroupId
	updateNotificationGroup.ChatId = tmp.ChatId
	updateNotificationGroup.NotificationSettingsChatId = tmp.NotificationSettingsChatId
	updateNotificationGroup.NotificationSoundId = tmp.NotificationSoundId
	updateNotificationGroup.TotalCount = tmp.TotalCount
	updateNotificationGroup.AddedNotifications = tmp.AddedNotifications
	updateNotificationGroup.RemovedNotificationIds = tmp.RemovedNotificationIds

	fieldType, _ := UnmarshalNotificationGroupType(tmp.Type)
	updateNotificationGroup.Type = fieldType

	return nil
}

// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
type UpdateActiveNotifications struct {
	meta
	// Lists of active notification groups
	Groups []*NotificationGroup `json:"groups"`
}

func (entity *UpdateActiveNotifications) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateActiveNotifications

	return json.Marshal((*stub)(entity))
}

func (*UpdateActiveNotifications) GetClass() string {
	return ClassUpdate
}

func (*UpdateActiveNotifications) GetType() string {
	return TypeUpdateActiveNotifications
}

func (*UpdateActiveNotifications) UpdateType() string {
	return TypeUpdateActiveNotifications
}

// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
type UpdateHavePendingNotifications struct {
	meta
	// True, if there are some delayed notification updates, which will be sent soon
	HaveDelayedNotifications bool `json:"have_delayed_notifications"`
	// True, if there can be some yet unreceived notifications, which are being fetched from the server
	HaveUnreceivedNotifications bool `json:"have_unreceived_notifications"`
}

func (entity *UpdateHavePendingNotifications) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateHavePendingNotifications

	return json.Marshal((*stub)(entity))
}

func (*UpdateHavePendingNotifications) GetClass() string {
	return ClassUpdate
}

func (*UpdateHavePendingNotifications) GetType() string {
	return TypeUpdateHavePendingNotifications
}

func (*UpdateHavePendingNotifications) UpdateType() string {
	return TypeUpdateHavePendingNotifications
}

// Some messages were deleted
type UpdateDeleteMessages struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifiers of the deleted messages
	MessageIds []int64 `json:"message_ids"`
	// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
	IsPermanent bool `json:"is_permanent"`
	// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
	FromCache bool `json:"from_cache"`
}

func (entity *UpdateDeleteMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDeleteMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateDeleteMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateDeleteMessages) GetType() string {
	return TypeUpdateDeleteMessages
}

func (*UpdateDeleteMessages) UpdateType() string {
	return TypeUpdateDeleteMessages
}

// A message sender activity in the chat has changed
type UpdateChatAction struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// If not 0, a message thread identifier in which the action was performed
	MessageThreadId int64 `json:"message_thread_id"`
	// Identifier of a message sender performing the action
	SenderId MessageSender `json:"sender_id"`
	// The action
	Action ChatAction `json:"action"`
}

func (entity *UpdateChatAction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatAction

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatAction) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatAction) GetType() string {
	return TypeUpdateChatAction
}

func (*UpdateChatAction) UpdateType() string {
	return TypeUpdateChatAction
}

func (updateChatAction *UpdateChatAction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId          int64           `json:"chat_id"`
		MessageThreadId int64           `json:"message_thread_id"`
		SenderId        json.RawMessage `json:"sender_id"`
		Action          json.RawMessage `json:"action"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatAction.ChatId = tmp.ChatId
	updateChatAction.MessageThreadId = tmp.MessageThreadId

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	updateChatAction.SenderId = fieldSenderId

	fieldAction, _ := UnmarshalChatAction(tmp.Action)
	updateChatAction.Action = fieldAction

	return nil
}

// The user went online or offline
type UpdateUserStatus struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// New status of the user
	Status UserStatus `json:"status"`
}

func (entity *UpdateUserStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserStatus

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserStatus) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserStatus) GetType() string {
	return TypeUpdateUserStatus
}

func (*UpdateUserStatus) UpdateType() string {
	return TypeUpdateUserStatus
}

func (updateUserStatus *UpdateUserStatus) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int64           `json:"user_id"`
		Status json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserStatus.UserId = tmp.UserId

	fieldStatus, _ := UnmarshalUserStatus(tmp.Status)
	updateUserStatus.Status = fieldStatus

	return nil
}

// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
type UpdateUser struct {
	meta
	// New data about the user
	User *User `json:"user"`
}

func (entity *UpdateUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUser

	return json.Marshal((*stub)(entity))
}

func (*UpdateUser) GetClass() string {
	return ClassUpdate
}

func (*UpdateUser) GetType() string {
	return TypeUpdateUser
}

func (*UpdateUser) UpdateType() string {
	return TypeUpdateUser
}

// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
type UpdateBasicGroup struct {
	meta
	// New data about the group
	BasicGroup *BasicGroup `json:"basic_group"`
}

func (entity *UpdateBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateBasicGroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateBasicGroup) GetType() string {
	return TypeUpdateBasicGroup
}

func (*UpdateBasicGroup) UpdateType() string {
	return TypeUpdateBasicGroup
}

// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
type UpdateSupergroup struct {
	meta
	// New data about the supergroup
	Supergroup *Supergroup `json:"supergroup"`
}

func (entity *UpdateSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSupergroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateSupergroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateSupergroup) GetType() string {
	return TypeUpdateSupergroup
}

func (*UpdateSupergroup) UpdateType() string {
	return TypeUpdateSupergroup
}

// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
type UpdateSecretChat struct {
	meta
	// New data about the secret chat
	SecretChat *SecretChat `json:"secret_chat"`
}

func (entity *UpdateSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSecretChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateSecretChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateSecretChat) GetType() string {
	return TypeUpdateSecretChat
}

func (*UpdateSecretChat) UpdateType() string {
	return TypeUpdateSecretChat
}

// Some data in userFullInfo has been changed
type UpdateUserFullInfo struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// New full information about the user
	UserFullInfo *UserFullInfo `json:"user_full_info"`
}

func (entity *UpdateUserFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserFullInfo) GetType() string {
	return TypeUpdateUserFullInfo
}

func (*UpdateUserFullInfo) UpdateType() string {
	return TypeUpdateUserFullInfo
}

// Some data in basicGroupFullInfo has been changed
type UpdateBasicGroupFullInfo struct {
	meta
	// Identifier of a basic group
	BasicGroupId int64 `json:"basic_group_id"`
	// New full information about the group
	BasicGroupFullInfo *BasicGroupFullInfo `json:"basic_group_full_info"`
}

func (entity *UpdateBasicGroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBasicGroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateBasicGroupFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateBasicGroupFullInfo) GetType() string {
	return TypeUpdateBasicGroupFullInfo
}

func (*UpdateBasicGroupFullInfo) UpdateType() string {
	return TypeUpdateBasicGroupFullInfo
}

// Some data in supergroupFullInfo has been changed
type UpdateSupergroupFullInfo struct {
	meta
	// Identifier of the supergroup or channel
	SupergroupId int64 `json:"supergroup_id"`
	// New full information about the supergroup
	SupergroupFullInfo *SupergroupFullInfo `json:"supergroup_full_info"`
}

func (entity *UpdateSupergroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSupergroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateSupergroupFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateSupergroupFullInfo) GetType() string {
	return TypeUpdateSupergroupFullInfo
}

func (*UpdateSupergroupFullInfo) UpdateType() string {
	return TypeUpdateSupergroupFullInfo
}

// A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification
type UpdateServiceNotification struct {
	meta
	// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
	Type string `json:"type"`
	// Notification content
	Content MessageContent `json:"content"`
}

func (entity *UpdateServiceNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateServiceNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateServiceNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateServiceNotification) GetType() string {
	return TypeUpdateServiceNotification
}

func (*UpdateServiceNotification) UpdateType() string {
	return TypeUpdateServiceNotification
}

func (updateServiceNotification *UpdateServiceNotification) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    string          `json:"type"`
		Content json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateServiceNotification.Type = tmp.Type

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	updateServiceNotification.Content = fieldContent

	return nil
}

// Information about a file was updated
type UpdateFile struct {
	meta
	// New data about the file
	File *File `json:"file"`
}

func (entity *UpdateFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFile

	return json.Marshal((*stub)(entity))
}

func (*UpdateFile) GetClass() string {
	return ClassUpdate
}

func (*UpdateFile) GetType() string {
	return TypeUpdateFile
}

func (*UpdateFile) UpdateType() string {
	return TypeUpdateFile
}

// The file generation process needs to be started by the application
type UpdateFileGenerationStart struct {
	meta
	// Unique identifier for the generation process
	GenerationId JsonInt64 `json:"generation_id"`
	// The path to a file from which a new file is generated; may be empty
	OriginalPath string `json:"original_path"`
	// The path to a file that must be created and where the new file is generated
	DestinationPath string `json:"destination_path"`
	// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
	Conversion string `json:"conversion"`
}

func (entity *UpdateFileGenerationStart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileGenerationStart

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileGenerationStart) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileGenerationStart) GetType() string {
	return TypeUpdateFileGenerationStart
}

func (*UpdateFileGenerationStart) UpdateType() string {
	return TypeUpdateFileGenerationStart
}

// File generation is no longer needed
type UpdateFileGenerationStop struct {
	meta
	// Unique identifier for the generation process
	GenerationId JsonInt64 `json:"generation_id"`
}

func (entity *UpdateFileGenerationStop) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileGenerationStop

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileGenerationStop) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileGenerationStop) GetType() string {
	return TypeUpdateFileGenerationStop
}

func (*UpdateFileGenerationStop) UpdateType() string {
	return TypeUpdateFileGenerationStop
}

// The state of the file download list has changed
type UpdateFileDownloads struct {
	meta
	// Total size of files in the file download list, in bytes
	TotalSize int64 `json:"total_size"`
	// Total number of files in the file download list
	TotalCount int32 `json:"total_count"`
	// Total downloaded size of files in the file download list, in bytes
	DownloadedSize int64 `json:"downloaded_size"`
}

func (entity *UpdateFileDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileDownloads

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileDownloads) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileDownloads) GetType() string {
	return TypeUpdateFileDownloads
}

func (*UpdateFileDownloads) UpdateType() string {
	return TypeUpdateFileDownloads
}

// A file was added to the file download list. This update is sent only after file download list is loaded for the first time
type UpdateFileAddedToDownloads struct {
	meta
	// The added file download
	FileDownload *FileDownload `json:"file_download"`
	// New number of being downloaded and recently downloaded files found
	Counts *DownloadedFileCounts `json:"counts"`
}

func (entity *UpdateFileAddedToDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileAddedToDownloads

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileAddedToDownloads) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileAddedToDownloads) GetType() string {
	return TypeUpdateFileAddedToDownloads
}

func (*UpdateFileAddedToDownloads) UpdateType() string {
	return TypeUpdateFileAddedToDownloads
}

// A file download was changed. This update is sent only after file download list is loaded for the first time
type UpdateFileDownload struct {
	meta
	// File identifier
	FileId int32 `json:"file_id"`
	// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
	CompleteDate int32 `json:"complete_date"`
	// True, if downloading of the file is paused
	IsPaused bool `json:"is_paused"`
	// New number of being downloaded and recently downloaded files found
	Counts *DownloadedFileCounts `json:"counts"`
}

func (entity *UpdateFileDownload) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileDownload

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileDownload) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileDownload) GetType() string {
	return TypeUpdateFileDownload
}

func (*UpdateFileDownload) UpdateType() string {
	return TypeUpdateFileDownload
}

// A file was removed from the file download list. This update is sent only after file download list is loaded for the first time
type UpdateFileRemovedFromDownloads struct {
	meta
	// File identifier
	FileId int32 `json:"file_id"`
	// New number of being downloaded and recently downloaded files found
	Counts *DownloadedFileCounts `json:"counts"`
}

func (entity *UpdateFileRemovedFromDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileRemovedFromDownloads

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileRemovedFromDownloads) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileRemovedFromDownloads) GetType() string {
	return TypeUpdateFileRemovedFromDownloads
}

func (*UpdateFileRemovedFromDownloads) UpdateType() string {
	return TypeUpdateFileRemovedFromDownloads
}

// New call was created or information about a call was updated
type UpdateCall struct {
	meta
	// New data about a call
	Call *Call `json:"call"`
}

func (entity *UpdateCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateCall

	return json.Marshal((*stub)(entity))
}

func (*UpdateCall) GetClass() string {
	return ClassUpdate
}

func (*UpdateCall) GetType() string {
	return TypeUpdateCall
}

func (*UpdateCall) UpdateType() string {
	return TypeUpdateCall
}

// Information about a group call was updated
type UpdateGroupCall struct {
	meta
	// New data about a group call
	GroupCall *GroupCall `json:"group_call"`
}

func (entity *UpdateGroupCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateGroupCall

	return json.Marshal((*stub)(entity))
}

func (*UpdateGroupCall) GetClass() string {
	return ClassUpdate
}

func (*UpdateGroupCall) GetType() string {
	return TypeUpdateGroupCall
}

func (*UpdateGroupCall) UpdateType() string {
	return TypeUpdateGroupCall
}

// Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
type UpdateGroupCallParticipant struct {
	meta
	// Identifier of group call
	GroupCallId int32 `json:"group_call_id"`
	// New data about a participant
	Participant *GroupCallParticipant `json:"participant"`
}

func (entity *UpdateGroupCallParticipant) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateGroupCallParticipant

	return json.Marshal((*stub)(entity))
}

func (*UpdateGroupCallParticipant) GetClass() string {
	return ClassUpdate
}

func (*UpdateGroupCallParticipant) GetType() string {
	return TypeUpdateGroupCallParticipant
}

func (*UpdateGroupCallParticipant) UpdateType() string {
	return TypeUpdateGroupCallParticipant
}

// New call signaling data arrived
type UpdateNewCallSignalingData struct {
	meta
	// The call identifier
	CallId int32 `json:"call_id"`
	// The data
	Data []byte `json:"data"`
}

func (entity *UpdateNewCallSignalingData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCallSignalingData

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCallSignalingData) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCallSignalingData) GetType() string {
	return TypeUpdateNewCallSignalingData
}

func (*UpdateNewCallSignalingData) UpdateType() string {
	return TypeUpdateNewCallSignalingData
}

// Some privacy setting rules have been changed
type UpdateUserPrivacySettingRules struct {
	meta
	// The privacy setting
	Setting UserPrivacySetting `json:"setting"`
	// New privacy rules
	Rules *UserPrivacySettingRules `json:"rules"`
}

func (entity *UpdateUserPrivacySettingRules) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserPrivacySettingRules

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserPrivacySettingRules) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserPrivacySettingRules) GetType() string {
	return TypeUpdateUserPrivacySettingRules
}

func (*UpdateUserPrivacySettingRules) UpdateType() string {
	return TypeUpdateUserPrivacySettingRules
}

func (updateUserPrivacySettingRules *UpdateUserPrivacySettingRules) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Setting json.RawMessage          `json:"setting"`
		Rules   *UserPrivacySettingRules `json:"rules"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserPrivacySettingRules.Rules = tmp.Rules

	fieldSetting, _ := UnmarshalUserPrivacySetting(tmp.Setting)
	updateUserPrivacySettingRules.Setting = fieldSetting

	return nil
}

// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
type UpdateUnreadMessageCount struct {
	meta
	// The chat list with changed number of unread messages
	ChatList ChatList `json:"chat_list"`
	// Total number of unread messages
	UnreadCount int32 `json:"unread_count"`
	// Total number of unread messages in unmuted chats
	UnreadUnmutedCount int32 `json:"unread_unmuted_count"`
}

func (entity *UpdateUnreadMessageCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnreadMessageCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnreadMessageCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnreadMessageCount) GetType() string {
	return TypeUpdateUnreadMessageCount
}

func (*UpdateUnreadMessageCount) UpdateType() string {
	return TypeUpdateUnreadMessageCount
}

func (updateUnreadMessageCount *UpdateUnreadMessageCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatList           json.RawMessage `json:"chat_list"`
		UnreadCount        int32           `json:"unread_count"`
		UnreadUnmutedCount int32           `json:"unread_unmuted_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUnreadMessageCount.UnreadCount = tmp.UnreadCount
	updateUnreadMessageCount.UnreadUnmutedCount = tmp.UnreadUnmutedCount

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateUnreadMessageCount.ChatList = fieldChatList

	return nil
}

// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
type UpdateUnreadChatCount struct {
	meta
	// The chat list with changed number of unread messages
	ChatList ChatList `json:"chat_list"`
	// Approximate total number of chats in the chat list
	TotalCount int32 `json:"total_count"`
	// Total number of unread chats
	UnreadCount int32 `json:"unread_count"`
	// Total number of unread unmuted chats
	UnreadUnmutedCount int32 `json:"unread_unmuted_count"`
	// Total number of chats marked as unread
	MarkedAsUnreadCount int32 `json:"marked_as_unread_count"`
	// Total number of unmuted chats marked as unread
	MarkedAsUnreadUnmutedCount int32 `json:"marked_as_unread_unmuted_count"`
}

func (entity *UpdateUnreadChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnreadChatCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnreadChatCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnreadChatCount) GetType() string {
	return TypeUpdateUnreadChatCount
}

func (*UpdateUnreadChatCount) UpdateType() string {
	return TypeUpdateUnreadChatCount
}

func (updateUnreadChatCount *UpdateUnreadChatCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatList                   json.RawMessage `json:"chat_list"`
		TotalCount                 int32           `json:"total_count"`
		UnreadCount                int32           `json:"unread_count"`
		UnreadUnmutedCount         int32           `json:"unread_unmuted_count"`
		MarkedAsUnreadCount        int32           `json:"marked_as_unread_count"`
		MarkedAsUnreadUnmutedCount int32           `json:"marked_as_unread_unmuted_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUnreadChatCount.TotalCount = tmp.TotalCount
	updateUnreadChatCount.UnreadCount = tmp.UnreadCount
	updateUnreadChatCount.UnreadUnmutedCount = tmp.UnreadUnmutedCount
	updateUnreadChatCount.MarkedAsUnreadCount = tmp.MarkedAsUnreadCount
	updateUnreadChatCount.MarkedAsUnreadUnmutedCount = tmp.MarkedAsUnreadUnmutedCount

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateUnreadChatCount.ChatList = fieldChatList

	return nil
}

// An option changed its value
type UpdateOption struct {
	meta
	// The option name
	Name string `json:"name"`
	// The new option value
	Value OptionValue `json:"value"`
}

func (entity *UpdateOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateOption

	return json.Marshal((*stub)(entity))
}

func (*UpdateOption) GetClass() string {
	return ClassUpdate
}

func (*UpdateOption) GetType() string {
	return TypeUpdateOption
}

func (*UpdateOption) UpdateType() string {
	return TypeUpdateOption
}

func (updateOption *UpdateOption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Name  string          `json:"name"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateOption.Name = tmp.Name

	fieldValue, _ := UnmarshalOptionValue(tmp.Value)
	updateOption.Value = fieldValue

	return nil
}

// A sticker set has changed
type UpdateStickerSet struct {
	meta
	// The sticker set
	StickerSet *StickerSet `json:"sticker_set"`
}

func (entity *UpdateStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStickerSet

	return json.Marshal((*stub)(entity))
}

func (*UpdateStickerSet) GetClass() string {
	return ClassUpdate
}

func (*UpdateStickerSet) GetType() string {
	return TypeUpdateStickerSet
}

func (*UpdateStickerSet) UpdateType() string {
	return TypeUpdateStickerSet
}

// The list of installed sticker sets was updated
type UpdateInstalledStickerSets struct {
	meta
	// Type of the affected stickers
	StickerType StickerType `json:"sticker_type"`
	// The new list of installed ordinary sticker sets
	StickerSetIds []JsonInt64 `json:"sticker_set_ids"`
}

func (entity *UpdateInstalledStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateInstalledStickerSets

	return json.Marshal((*stub)(entity))
}

func (*UpdateInstalledStickerSets) GetClass() string {
	return ClassUpdate
}

func (*UpdateInstalledStickerSets) GetType() string {
	return TypeUpdateInstalledStickerSets
}

func (*UpdateInstalledStickerSets) UpdateType() string {
	return TypeUpdateInstalledStickerSets
}

func (updateInstalledStickerSets *UpdateInstalledStickerSets) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StickerType   json.RawMessage `json:"sticker_type"`
		StickerSetIds []JsonInt64     `json:"sticker_set_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateInstalledStickerSets.StickerSetIds = tmp.StickerSetIds

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	updateInstalledStickerSets.StickerType = fieldStickerType

	return nil
}

// The list of trending sticker sets was updated or some of them were viewed
type UpdateTrendingStickerSets struct {
	meta
	// Type of the affected stickers
	StickerType StickerType `json:"sticker_type"`
	// The prefix of the list of trending sticker sets with the newest trending sticker sets
	StickerSets *TrendingStickerSets `json:"sticker_sets"`
}

func (entity *UpdateTrendingStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateTrendingStickerSets

	return json.Marshal((*stub)(entity))
}

func (*UpdateTrendingStickerSets) GetClass() string {
	return ClassUpdate
}

func (*UpdateTrendingStickerSets) GetType() string {
	return TypeUpdateTrendingStickerSets
}

func (*UpdateTrendingStickerSets) UpdateType() string {
	return TypeUpdateTrendingStickerSets
}

func (updateTrendingStickerSets *UpdateTrendingStickerSets) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StickerType json.RawMessage      `json:"sticker_type"`
		StickerSets *TrendingStickerSets `json:"sticker_sets"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateTrendingStickerSets.StickerSets = tmp.StickerSets

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	updateTrendingStickerSets.StickerType = fieldStickerType

	return nil
}

// The list of recently used stickers was updated
type UpdateRecentStickers struct {
	meta
	// True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
	IsAttached bool `json:"is_attached"`
	// The new list of file identifiers of recently used stickers
	StickerIds []int32 `json:"sticker_ids"`
}

func (entity *UpdateRecentStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateRecentStickers

	return json.Marshal((*stub)(entity))
}

func (*UpdateRecentStickers) GetClass() string {
	return ClassUpdate
}

func (*UpdateRecentStickers) GetType() string {
	return TypeUpdateRecentStickers
}

func (*UpdateRecentStickers) UpdateType() string {
	return TypeUpdateRecentStickers
}

// The list of favorite stickers was updated
type UpdateFavoriteStickers struct {
	meta
	// The new list of file identifiers of favorite stickers
	StickerIds []int32 `json:"sticker_ids"`
}

func (entity *UpdateFavoriteStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFavoriteStickers

	return json.Marshal((*stub)(entity))
}

func (*UpdateFavoriteStickers) GetClass() string {
	return ClassUpdate
}

func (*UpdateFavoriteStickers) GetType() string {
	return TypeUpdateFavoriteStickers
}

func (*UpdateFavoriteStickers) UpdateType() string {
	return TypeUpdateFavoriteStickers
}

// The list of saved animations was updated
type UpdateSavedAnimations struct {
	meta
	// The new list of file identifiers of saved animations
	AnimationIds []int32 `json:"animation_ids"`
}

func (entity *UpdateSavedAnimations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedAnimations

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedAnimations) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedAnimations) GetType() string {
	return TypeUpdateSavedAnimations
}

func (*UpdateSavedAnimations) UpdateType() string {
	return TypeUpdateSavedAnimations
}

// The list of saved notifications sounds was updated. This update may not be sent until information about a notification sound was requested for the first time
type UpdateSavedNotificationSounds struct {
	meta
	// The new list of identifiers of saved notification sounds
	NotificationSoundIds []JsonInt64 `json:"notification_sound_ids"`
}

func (entity *UpdateSavedNotificationSounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedNotificationSounds

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedNotificationSounds) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedNotificationSounds) GetType() string {
	return TypeUpdateSavedNotificationSounds
}

func (*UpdateSavedNotificationSounds) UpdateType() string {
	return TypeUpdateSavedNotificationSounds
}

// The selected background has changed
type UpdateSelectedBackground struct {
	meta
	// True, if background for dark theme has changed
	ForDarkTheme bool `json:"for_dark_theme"`
	// The new selected background; may be null
	Background *Background `json:"background"`
}

func (entity *UpdateSelectedBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSelectedBackground

	return json.Marshal((*stub)(entity))
}

func (*UpdateSelectedBackground) GetClass() string {
	return ClassUpdate
}

func (*UpdateSelectedBackground) GetType() string {
	return TypeUpdateSelectedBackground
}

func (*UpdateSelectedBackground) UpdateType() string {
	return TypeUpdateSelectedBackground
}

// The list of available chat themes has changed
type UpdateChatThemes struct {
	meta
	// The new list of chat themes
	ChatThemes []*ChatTheme `json:"chat_themes"`
}

func (entity *UpdateChatThemes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatThemes

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatThemes) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatThemes) GetType() string {
	return TypeUpdateChatThemes
}

func (*UpdateChatThemes) UpdateType() string {
	return TypeUpdateChatThemes
}

// Some language pack strings have been updated
type UpdateLanguagePackStrings struct {
	meta
	// Localization target to which the language pack belongs
	LocalizationTarget string `json:"localization_target"`
	// Identifier of the updated language pack
	LanguagePackId string `json:"language_pack_id"`
	// List of changed language pack strings; empty if all strings have changed
	Strings []*LanguagePackString `json:"strings"`
}

func (entity *UpdateLanguagePackStrings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateLanguagePackStrings

	return json.Marshal((*stub)(entity))
}

func (*UpdateLanguagePackStrings) GetClass() string {
	return ClassUpdate
}

func (*UpdateLanguagePackStrings) GetType() string {
	return TypeUpdateLanguagePackStrings
}

func (*UpdateLanguagePackStrings) UpdateType() string {
	return TypeUpdateLanguagePackStrings
}

// The connection state has changed. This update must be used only to show a human-readable description of the connection state
type UpdateConnectionState struct {
	meta
	// The new connection state
	State ConnectionState `json:"state"`
}

func (entity *UpdateConnectionState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateConnectionState

	return json.Marshal((*stub)(entity))
}

func (*UpdateConnectionState) GetClass() string {
	return ClassUpdate
}

func (*UpdateConnectionState) GetType() string {
	return TypeUpdateConnectionState
}

func (*UpdateConnectionState) UpdateType() string {
	return TypeUpdateConnectionState
}

func (updateConnectionState *UpdateConnectionState) UnmarshalJSON(data []byte) error {
	var tmp struct {
		State json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldState, _ := UnmarshalConnectionState(tmp.State)
	updateConnectionState.State = fieldState

	return nil
}

// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
type UpdateTermsOfService struct {
	meta
	// Identifier of the terms of service
	TermsOfServiceId string `json:"terms_of_service_id"`
	// The new terms of service
	TermsOfService *TermsOfService `json:"terms_of_service"`
}

func (entity *UpdateTermsOfService) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateTermsOfService

	return json.Marshal((*stub)(entity))
}

func (*UpdateTermsOfService) GetClass() string {
	return ClassUpdate
}

func (*UpdateTermsOfService) GetType() string {
	return TypeUpdateTermsOfService
}

func (*UpdateTermsOfService) UpdateType() string {
	return TypeUpdateTermsOfService
}

// The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
type UpdateUsersNearby struct {
	meta
	// The new list of users nearby
	UsersNearby []*ChatNearby `json:"users_nearby"`
}

func (entity *UpdateUsersNearby) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUsersNearby

	return json.Marshal((*stub)(entity))
}

func (*UpdateUsersNearby) GetClass() string {
	return ClassUpdate
}

func (*UpdateUsersNearby) GetType() string {
	return TypeUpdateUsersNearby
}

func (*UpdateUsersNearby) UpdateType() string {
	return TypeUpdateUsersNearby
}

// The list of bots added to attachment menu has changed
type UpdateAttachmentMenuBots struct {
	meta
	// The new list of bots added to attachment menu. The bots must not be shown on scheduled messages screen
	Bots []*AttachmentMenuBot `json:"bots"`
}

func (entity *UpdateAttachmentMenuBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAttachmentMenuBots

	return json.Marshal((*stub)(entity))
}

func (*UpdateAttachmentMenuBots) GetClass() string {
	return ClassUpdate
}

func (*UpdateAttachmentMenuBots) GetType() string {
	return TypeUpdateAttachmentMenuBots
}

func (*UpdateAttachmentMenuBots) UpdateType() string {
	return TypeUpdateAttachmentMenuBots
}

// A message was sent by an opened Web App, so the Web App needs to be closed
type UpdateWebAppMessageSent struct {
	meta
	// Identifier of Web App launch
	WebAppLaunchId JsonInt64 `json:"web_app_launch_id"`
}

func (entity *UpdateWebAppMessageSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateWebAppMessageSent

	return json.Marshal((*stub)(entity))
}

func (*UpdateWebAppMessageSent) GetClass() string {
	return ClassUpdate
}

func (*UpdateWebAppMessageSent) GetType() string {
	return TypeUpdateWebAppMessageSent
}

func (*UpdateWebAppMessageSent) UpdateType() string {
	return TypeUpdateWebAppMessageSent
}

// The list of active emoji reactions has changed
type UpdateActiveEmojiReactions struct {
	meta
	// The new list of active emoji reactions
	Emojis []string `json:"emojis"`
}

func (entity *UpdateActiveEmojiReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateActiveEmojiReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateActiveEmojiReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateActiveEmojiReactions) GetType() string {
	return TypeUpdateActiveEmojiReactions
}

func (*UpdateActiveEmojiReactions) UpdateType() string {
	return TypeUpdateActiveEmojiReactions
}

// The type of default reaction has changed
type UpdateDefaultReactionType struct {
	meta
	// The new type of the default reaction
	ReactionType ReactionType `json:"reaction_type"`
}

func (entity *UpdateDefaultReactionType) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDefaultReactionType

	return json.Marshal((*stub)(entity))
}

func (*UpdateDefaultReactionType) GetClass() string {
	return ClassUpdate
}

func (*UpdateDefaultReactionType) GetType() string {
	return TypeUpdateDefaultReactionType
}

func (*UpdateDefaultReactionType) UpdateType() string {
	return TypeUpdateDefaultReactionType
}

func (updateDefaultReactionType *UpdateDefaultReactionType) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReactionType json.RawMessage `json:"reaction_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldReactionType, _ := UnmarshalReactionType(tmp.ReactionType)
	updateDefaultReactionType.ReactionType = fieldReactionType

	return nil
}

// The list of supported dice emojis has changed
type UpdateDiceEmojis struct {
	meta
	// The new list of supported dice emojis
	Emojis []string `json:"emojis"`
}

func (entity *UpdateDiceEmojis) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDiceEmojis

	return json.Marshal((*stub)(entity))
}

func (*UpdateDiceEmojis) GetClass() string {
	return ClassUpdate
}

func (*UpdateDiceEmojis) GetType() string {
	return TypeUpdateDiceEmojis
}

func (*UpdateDiceEmojis) UpdateType() string {
	return TypeUpdateDiceEmojis
}

// Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
type UpdateAnimatedEmojiMessageClicked struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The animated sticker to be played
	Sticker *Sticker `json:"sticker"`
}

func (entity *UpdateAnimatedEmojiMessageClicked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAnimatedEmojiMessageClicked

	return json.Marshal((*stub)(entity))
}

func (*UpdateAnimatedEmojiMessageClicked) GetClass() string {
	return ClassUpdate
}

func (*UpdateAnimatedEmojiMessageClicked) GetType() string {
	return TypeUpdateAnimatedEmojiMessageClicked
}

func (*UpdateAnimatedEmojiMessageClicked) UpdateType() string {
	return TypeUpdateAnimatedEmojiMessageClicked
}

// The parameters of animation search through getOption("animation_search_bot_username") bot has changed
type UpdateAnimationSearchParameters struct {
	meta
	// Name of the animation search provider
	Provider string `json:"provider"`
	// The new list of emojis suggested for searching
	Emojis []string `json:"emojis"`
}

func (entity *UpdateAnimationSearchParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAnimationSearchParameters

	return json.Marshal((*stub)(entity))
}

func (*UpdateAnimationSearchParameters) GetClass() string {
	return ClassUpdate
}

func (*UpdateAnimationSearchParameters) GetType() string {
	return TypeUpdateAnimationSearchParameters
}

func (*UpdateAnimationSearchParameters) UpdateType() string {
	return TypeUpdateAnimationSearchParameters
}

// The list of suggested to the user actions has changed
type UpdateSuggestedActions struct {
	meta
	// Added suggested actions
	AddedActions []SuggestedAction `json:"added_actions"`
	// Removed suggested actions
	RemovedActions []SuggestedAction `json:"removed_actions"`
}

func (entity *UpdateSuggestedActions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSuggestedActions

	return json.Marshal((*stub)(entity))
}

func (*UpdateSuggestedActions) GetClass() string {
	return ClassUpdate
}

func (*UpdateSuggestedActions) GetType() string {
	return TypeUpdateSuggestedActions
}

func (*UpdateSuggestedActions) UpdateType() string {
	return TypeUpdateSuggestedActions
}

func (updateSuggestedActions *UpdateSuggestedActions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AddedActions   []json.RawMessage `json:"added_actions"`
		RemovedActions []json.RawMessage `json:"removed_actions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldAddedActions, _ := UnmarshalListOfSuggestedAction(tmp.AddedActions)
	updateSuggestedActions.AddedActions = fieldAddedActions

	fieldRemovedActions, _ := UnmarshalListOfSuggestedAction(tmp.RemovedActions)
	updateSuggestedActions.RemovedActions = fieldRemovedActions

	return nil
}

// Adding users to a chat has failed because of their privacy settings. An invite link can be shared with the users if appropriate
type UpdateAddChatMembersPrivacyForbidden struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifiers of users, which weren't added because of their privacy settings
	UserIds []int64 `json:"user_ids"`
}

func (entity *UpdateAddChatMembersPrivacyForbidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAddChatMembersPrivacyForbidden

	return json.Marshal((*stub)(entity))
}

func (*UpdateAddChatMembersPrivacyForbidden) GetClass() string {
	return ClassUpdate
}

func (*UpdateAddChatMembersPrivacyForbidden) GetType() string {
	return TypeUpdateAddChatMembersPrivacyForbidden
}

func (*UpdateAddChatMembersPrivacyForbidden) UpdateType() string {
	return TypeUpdateAddChatMembersPrivacyForbidden
}

// Autosave settings for some type of chats were updated
type UpdateAutosaveSettings struct {
	meta
	// Type of chats for which autosave settings were updated
	Scope AutosaveSettingsScope `json:"scope"`
	// The new autosave settings; may be null if the settings are reset to default
	Settings *ScopeAutosaveSettings `json:"settings"`
}

func (entity *UpdateAutosaveSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAutosaveSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateAutosaveSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateAutosaveSettings) GetType() string {
	return TypeUpdateAutosaveSettings
}

func (*UpdateAutosaveSettings) UpdateType() string {
	return TypeUpdateAutosaveSettings
}

func (updateAutosaveSettings *UpdateAutosaveSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Scope    json.RawMessage        `json:"scope"`
		Settings *ScopeAutosaveSettings `json:"settings"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateAutosaveSettings.Settings = tmp.Settings

	fieldScope, _ := UnmarshalAutosaveSettingsScope(tmp.Scope)
	updateAutosaveSettings.Scope = fieldScope

	return nil
}

// A new incoming inline query; for bots only
type UpdateNewInlineQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// User location; may be null
	UserLocation *Location `json:"user_location"`
	// The type of the chat from which the query originated; may be null if unknown
	ChatType ChatType `json:"chat_type"`
	// Text of the query
	Query string `json:"query"`
	// Offset of the first entry to return
	Offset string `json:"offset"`
}

func (entity *UpdateNewInlineQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewInlineQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewInlineQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewInlineQuery) GetType() string {
	return TypeUpdateNewInlineQuery
}

func (*UpdateNewInlineQuery) UpdateType() string {
	return TypeUpdateNewInlineQuery
}

func (updateNewInlineQuery *UpdateNewInlineQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           JsonInt64       `json:"id"`
		SenderUserId int64           `json:"sender_user_id"`
		UserLocation *Location       `json:"user_location"`
		ChatType     json.RawMessage `json:"chat_type"`
		Query        string          `json:"query"`
		Offset       string          `json:"offset"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewInlineQuery.Id = tmp.Id
	updateNewInlineQuery.SenderUserId = tmp.SenderUserId
	updateNewInlineQuery.UserLocation = tmp.UserLocation
	updateNewInlineQuery.Query = tmp.Query
	updateNewInlineQuery.Offset = tmp.Offset

	fieldChatType, _ := UnmarshalChatType(tmp.ChatType)
	updateNewInlineQuery.ChatType = fieldChatType

	return nil
}

// The user has chosen a result of an inline query; for bots only
type UpdateNewChosenInlineResult struct {
	meta
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// User location; may be null
	UserLocation *Location `json:"user_location"`
	// Text of the query
	Query string `json:"query"`
	// Identifier of the chosen result
	ResultId string `json:"result_id"`
	// Identifier of the sent inline message, if known
	InlineMessageId string `json:"inline_message_id"`
}

func (entity *UpdateNewChosenInlineResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChosenInlineResult

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChosenInlineResult) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChosenInlineResult) GetType() string {
	return TypeUpdateNewChosenInlineResult
}

func (*UpdateNewChosenInlineResult) UpdateType() string {
	return TypeUpdateNewChosenInlineResult
}

// A new incoming callback query; for bots only
type UpdateNewCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Identifier of the chat where the query was sent
	ChatId int64 `json:"chat_id"`
	// Identifier of the message from which the query originated
	MessageId int64 `json:"message_id"`
	// Identifier that uniquely corresponds to the chat to which the message was sent
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCallbackQuery) GetType() string {
	return TypeUpdateNewCallbackQuery
}

func (*UpdateNewCallbackQuery) UpdateType() string {
	return TypeUpdateNewCallbackQuery
}

func (updateNewCallbackQuery *UpdateNewCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           JsonInt64       `json:"id"`
		SenderUserId int64           `json:"sender_user_id"`
		ChatId       int64           `json:"chat_id"`
		MessageId    int64           `json:"message_id"`
		ChatInstance JsonInt64       `json:"chat_instance"`
		Payload      json.RawMessage `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewCallbackQuery.Id = tmp.Id
	updateNewCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewCallbackQuery.ChatId = tmp.ChatId
	updateNewCallbackQuery.MessageId = tmp.MessageId
	updateNewCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming callback query from a message sent via a bot; for bots only
type UpdateNewInlineCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Identifier of the inline message from which the query originated
	InlineMessageId string `json:"inline_message_id"`
	// An identifier uniquely corresponding to the chat a message was sent to
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewInlineCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewInlineCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewInlineCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewInlineCallbackQuery) GetType() string {
	return TypeUpdateNewInlineCallbackQuery
}

func (*UpdateNewInlineCallbackQuery) UpdateType() string {
	return TypeUpdateNewInlineCallbackQuery
}

func (updateNewInlineCallbackQuery *UpdateNewInlineCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id              JsonInt64       `json:"id"`
		SenderUserId    int64           `json:"sender_user_id"`
		InlineMessageId string          `json:"inline_message_id"`
		ChatInstance    JsonInt64       `json:"chat_instance"`
		Payload         json.RawMessage `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewInlineCallbackQuery.Id = tmp.Id
	updateNewInlineCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewInlineCallbackQuery.InlineMessageId = tmp.InlineMessageId
	updateNewInlineCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewInlineCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming shipping query; for bots only. Only for invoices with flexible price
type UpdateNewShippingQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// User shipping address
	ShippingAddress *Address `json:"shipping_address"`
}

func (entity *UpdateNewShippingQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewShippingQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewShippingQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewShippingQuery) GetType() string {
	return TypeUpdateNewShippingQuery
}

func (*UpdateNewShippingQuery) UpdateType() string {
	return TypeUpdateNewShippingQuery
}

// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
type UpdateNewPreCheckoutQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Currency for the product price
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Invoice payload
	InvoicePayload []byte `json:"invoice_payload"`
	// Identifier of a shipping option chosen by the user; may be empty if not applicable
	ShippingOptionId string `json:"shipping_option_id"`
	// Information about the order; may be null
	OrderInfo *OrderInfo `json:"order_info"`
}

func (entity *UpdateNewPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewPreCheckoutQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewPreCheckoutQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewPreCheckoutQuery) GetType() string {
	return TypeUpdateNewPreCheckoutQuery
}

func (*UpdateNewPreCheckoutQuery) UpdateType() string {
	return TypeUpdateNewPreCheckoutQuery
}

// A new incoming event; for bots only
type UpdateNewCustomEvent struct {
	meta
	// A JSON-serialized event
	Event string `json:"event"`
}

func (entity *UpdateNewCustomEvent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCustomEvent

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCustomEvent) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCustomEvent) GetType() string {
	return TypeUpdateNewCustomEvent
}

func (*UpdateNewCustomEvent) UpdateType() string {
	return TypeUpdateNewCustomEvent
}

// A new incoming query; for bots only
type UpdateNewCustomQuery struct {
	meta
	// The query identifier
	Id JsonInt64 `json:"id"`
	// JSON-serialized query data
	Data string `json:"data"`
	// Query timeout
	Timeout int32 `json:"timeout"`
}

func (entity *UpdateNewCustomQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCustomQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCustomQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCustomQuery) GetType() string {
	return TypeUpdateNewCustomQuery
}

func (*UpdateNewCustomQuery) UpdateType() string {
	return TypeUpdateNewCustomQuery
}

// A poll was updated; for bots only
type UpdatePoll struct {
	meta
	// New data about the poll
	Poll *Poll `json:"poll"`
}

func (entity *UpdatePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePoll

	return json.Marshal((*stub)(entity))
}

func (*UpdatePoll) GetClass() string {
	return ClassUpdate
}

func (*UpdatePoll) GetType() string {
	return TypeUpdatePoll
}

func (*UpdatePoll) UpdateType() string {
	return TypeUpdatePoll
}

// A user changed the answer to a poll; for bots only
type UpdatePollAnswer struct {
	meta
	// Unique poll identifier
	PollId JsonInt64 `json:"poll_id"`
	// The user, who changed the answer to the poll
	UserId int64 `json:"user_id"`
	// 0-based identifiers of answer options, chosen by the user
	OptionIds []int32 `json:"option_ids"`
}

func (entity *UpdatePollAnswer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePollAnswer

	return json.Marshal((*stub)(entity))
}

func (*UpdatePollAnswer) GetClass() string {
	return ClassUpdate
}

func (*UpdatePollAnswer) GetType() string {
	return TypeUpdatePollAnswer
}

func (*UpdatePollAnswer) UpdateType() string {
	return TypeUpdatePollAnswer
}

// User rights changed in a chat; for bots only
type UpdateChatMember struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the user, changing the rights
	ActorUserId int64 `json:"actor_user_id"`
	// Point in time (Unix timestamp) when the user rights was changed
	Date int32 `json:"date"`
	// If user has joined the chat using an invite link, the invite link; may be null
	InviteLink *ChatInviteLink `json:"invite_link"`
	// Previous chat member
	OldChatMember *ChatMember `json:"old_chat_member"`
	// New chat member
	NewChatMember *ChatMember `json:"new_chat_member"`
}

func (entity *UpdateChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatMember

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatMember) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatMember) GetType() string {
	return TypeUpdateChatMember
}

func (*UpdateChatMember) UpdateType() string {
	return TypeUpdateChatMember
}

// A user sent a join request to a chat; for bots only
type UpdateNewChatJoinRequest struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Join request
	Request *ChatJoinRequest `json:"request"`
	// Chat identifier of the private chat with the user
	UserChatId int64 `json:"user_chat_id"`
	// The invite link, which was used to send join request; may be null
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *UpdateNewChatJoinRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChatJoinRequest

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChatJoinRequest) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChatJoinRequest) GetType() string {
	return TypeUpdateNewChatJoinRequest
}

func (*UpdateNewChatJoinRequest) UpdateType() string {
	return TypeUpdateNewChatJoinRequest
}

// Contains a list of updates
type Updates struct {
	meta
	// List of updates
	Updates []Update `json:"updates"`
}

func (entity *Updates) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Updates

	return json.Marshal((*stub)(entity))
}

func (*Updates) GetClass() string {
	return ClassUpdates
}

func (*Updates) GetType() string {
	return TypeUpdates
}

func (updates *Updates) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Updates []json.RawMessage `json:"updates"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldUpdates, _ := UnmarshalListOfUpdate(tmp.Updates)
	updates.Updates = fieldUpdates

	return nil
}

// The log is written to stderr or an OS specific log
type LogStreamDefault struct {
	meta
}

func (entity *LogStreamDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamDefault

	return json.Marshal((*stub)(entity))
}

func (*LogStreamDefault) GetClass() string {
	return ClassLogStream
}

func (*LogStreamDefault) GetType() string {
	return TypeLogStreamDefault
}

func (*LogStreamDefault) LogStreamType() string {
	return TypeLogStreamDefault
}

// The log is written to a file
type LogStreamFile struct {
	meta
	// Path to the file to where the internal TDLib log will be written
	Path string `json:"path"`
	// The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
	MaxFileSize int64 `json:"max_file_size"`
	// Pass true to additionally redirect stderr to the log file. Ignored on Windows
	RedirectStderr bool `json:"redirect_stderr"`
}

func (entity *LogStreamFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamFile

	return json.Marshal((*stub)(entity))
}

func (*LogStreamFile) GetClass() string {
	return ClassLogStream
}

func (*LogStreamFile) GetType() string {
	return TypeLogStreamFile
}

func (*LogStreamFile) LogStreamType() string {
	return TypeLogStreamFile
}

// The log is written nowhere
type LogStreamEmpty struct {
	meta
}

func (entity *LogStreamEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamEmpty

	return json.Marshal((*stub)(entity))
}

func (*LogStreamEmpty) GetClass() string {
	return ClassLogStream
}

func (*LogStreamEmpty) GetType() string {
	return TypeLogStreamEmpty
}

func (*LogStreamEmpty) LogStreamType() string {
	return TypeLogStreamEmpty
}

// Contains a TDLib internal log verbosity level
type LogVerbosityLevel struct {
	meta
	// Log verbosity level
	VerbosityLevel int32 `json:"verbosity_level"`
}

func (entity *LogVerbosityLevel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogVerbosityLevel

	return json.Marshal((*stub)(entity))
}

func (*LogVerbosityLevel) GetClass() string {
	return ClassLogVerbosityLevel
}

func (*LogVerbosityLevel) GetType() string {
	return TypeLogVerbosityLevel
}

// Contains a list of available TDLib internal log tags
type LogTags struct {
	meta
	// List of log tags
	Tags []string `json:"tags"`
}

func (entity *LogTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogTags

	return json.Marshal((*stub)(entity))
}

func (*LogTags) GetClass() string {
	return ClassLogTags
}

func (*LogTags) GetType() string {
	return TypeLogTags
}

// Contains custom information about the user
type UserSupportInfo struct {
	meta
	// Information message
	Message *FormattedText `json:"message"`
	// Information author
	Author string `json:"author"`
	// Information change date
	Date int32 `json:"date"`
}

func (entity *UserSupportInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserSupportInfo

	return json.Marshal((*stub)(entity))
}

func (*UserSupportInfo) GetClass() string {
	return ClassUserSupportInfo
}

func (*UserSupportInfo) GetType() string {
	return TypeUserSupportInfo
}

// A simple object containing a number; for testing only
type TestInt struct {
	meta
	// Number
	Value int32 `json:"value"`
}

func (entity *TestInt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestInt

	return json.Marshal((*stub)(entity))
}

func (*TestInt) GetClass() string {
	return ClassTestInt
}

func (*TestInt) GetType() string {
	return TypeTestInt
}

// A simple object containing a string; for testing only
type TestString struct {
	meta
	// String
	Value string `json:"value"`
}

func (entity *TestString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestString

	return json.Marshal((*stub)(entity))
}

func (*TestString) GetClass() string {
	return ClassTestString
}

func (*TestString) GetType() string {
	return TypeTestString
}

// A simple object containing a sequence of bytes; for testing only
type TestBytes struct {
	meta
	// Bytes
	Value []byte `json:"value"`
}

func (entity *TestBytes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestBytes

	return json.Marshal((*stub)(entity))
}

func (*TestBytes) GetClass() string {
	return ClassTestBytes
}

func (*TestBytes) GetType() string {
	return TypeTestBytes
}

// A simple object containing a vector of numbers; for testing only
type TestVectorInt struct {
	meta
	// Vector of numbers
	Value []int32 `json:"value"`
}

func (entity *TestVectorInt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorInt

	return json.Marshal((*stub)(entity))
}

func (*TestVectorInt) GetClass() string {
	return ClassTestVectorInt
}

func (*TestVectorInt) GetType() string {
	return TypeTestVectorInt
}

// A simple object containing a vector of objects that hold a number; for testing only
type TestVectorIntObject struct {
	meta
	// Vector of objects
	Value []*TestInt `json:"value"`
}

func (entity *TestVectorIntObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorIntObject

	return json.Marshal((*stub)(entity))
}

func (*TestVectorIntObject) GetClass() string {
	return ClassTestVectorIntObject
}

func (*TestVectorIntObject) GetType() string {
	return TypeTestVectorIntObject
}

// A simple object containing a vector of strings; for testing only
type TestVectorString struct {
	meta
	// Vector of strings
	Value []string `json:"value"`
}

func (entity *TestVectorString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorString

	return json.Marshal((*stub)(entity))
}

func (*TestVectorString) GetClass() string {
	return ClassTestVectorString
}

func (*TestVectorString) GetType() string {
	return TypeTestVectorString
}

// A simple object containing a vector of objects that hold a string; for testing only
type TestVectorStringObject struct {
	meta
	// Vector of objects
	Value []*TestString `json:"value"`
}

func (entity *TestVectorStringObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorStringObject

	return json.Marshal((*stub)(entity))
}

func (*TestVectorStringObject) GetClass() string {
	return ClassTestVectorStringObject
}

func (*TestVectorStringObject) GetType() string {
	return TypeTestVectorStringObject
}
