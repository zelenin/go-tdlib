// AUTOGENERATED

package client

import (
	"encoding/json"
)

const (
	ClassAuthenticationCodeType                 = "AuthenticationCodeType"
	ClassEmailAddressAuthentication             = "EmailAddressAuthentication"
	ClassEmailAddressResetState                 = "EmailAddressResetState"
	ClassAuthorizationState                     = "AuthorizationState"
	ClassFirebaseDeviceVerificationParameters   = "FirebaseDeviceVerificationParameters"
	ClassInputFile                              = "InputFile"
	ClassThumbnailFormat                        = "ThumbnailFormat"
	ClassMaskPoint                              = "MaskPoint"
	ClassStickerFormat                          = "StickerFormat"
	ClassStickerType                            = "StickerType"
	ClassStickerFullType                        = "StickerFullType"
	ClassPollType                               = "PollType"
	ClassUserType                               = "UserType"
	ClassBusinessAwayMessageSchedule            = "BusinessAwayMessageSchedule"
	ClassChatPhotoStickerType                   = "ChatPhotoStickerType"
	ClassInputChatPhoto                         = "InputChatPhoto"
	ClassStarSubscriptionType                   = "StarSubscriptionType"
	ClassStarTransactionDirection               = "StarTransactionDirection"
	ClassBotTransactionPurpose                  = "BotTransactionPurpose"
	ClassChatTransactionPurpose                 = "ChatTransactionPurpose"
	ClassUserTransactionPurpose                 = "UserTransactionPurpose"
	ClassStarTransactionPartner                 = "StarTransactionPartner"
	ClassGiveawayParticipantStatus              = "GiveawayParticipantStatus"
	ClassGiveawayInfo                           = "GiveawayInfo"
	ClassGiveawayPrize                          = "GiveawayPrize"
	ClassChatMemberStatus                       = "ChatMemberStatus"
	ClassChatMembersFilter                      = "ChatMembersFilter"
	ClassSupergroupMembersFilter                = "SupergroupMembersFilter"
	ClassInviteLinkChatType                     = "InviteLinkChatType"
	ClassSecretChatState                        = "SecretChatState"
	ClassMessageSender                          = "MessageSender"
	ClassMessageReadDate                        = "MessageReadDate"
	ClassMessageOrigin                          = "MessageOrigin"
	ClassReactionType                           = "ReactionType"
	ClassMessageEffectType                      = "MessageEffectType"
	ClassMessageSendingState                    = "MessageSendingState"
	ClassMessageReplyTo                         = "MessageReplyTo"
	ClassInputMessageReplyTo                    = "InputMessageReplyTo"
	ClassMessageSource                          = "MessageSource"
	ClassReportChatSponsoredMessageResult       = "ReportChatSponsoredMessageResult"
	ClassNotificationSettingsScope              = "NotificationSettingsScope"
	ClassReactionNotificationSource             = "ReactionNotificationSource"
	ClassChatType                               = "ChatType"
	ClassChatList                               = "ChatList"
	ClassChatSource                             = "ChatSource"
	ClassChatAvailableReactions                 = "ChatAvailableReactions"
	ClassPublicChatType                         = "PublicChatType"
	ClassChatActionBar                          = "ChatActionBar"
	ClassKeyboardButtonType                     = "KeyboardButtonType"
	ClassInlineKeyboardButtonType               = "InlineKeyboardButtonType"
	ClassReplyMarkup                            = "ReplyMarkup"
	ClassLoginUrlInfo                           = "LoginUrlInfo"
	ClassWebAppOpenMode                         = "WebAppOpenMode"
	ClassSavedMessagesTopicType                 = "SavedMessagesTopicType"
	ClassRichText                               = "RichText"
	ClassPageBlockHorizontalAlignment           = "PageBlockHorizontalAlignment"
	ClassPageBlockVerticalAlignment             = "PageBlockVerticalAlignment"
	ClassPageBlock                              = "PageBlock"
	ClassLinkPreviewAlbumMedia                  = "LinkPreviewAlbumMedia"
	ClassLinkPreviewType                        = "LinkPreviewType"
	ClassCollectibleItemType                    = "CollectibleItemType"
	ClassInputCredentials                       = "InputCredentials"
	ClassPaymentProvider                        = "PaymentProvider"
	ClassPaymentFormType                        = "PaymentFormType"
	ClassPaymentReceiptType                     = "PaymentReceiptType"
	ClassInputInvoice                           = "InputInvoice"
	ClassPaidMedia                              = "PaidMedia"
	ClassPassportElementType                    = "PassportElementType"
	ClassPassportElement                        = "PassportElement"
	ClassInputPassportElement                   = "InputPassportElement"
	ClassPassportElementErrorSource             = "PassportElementErrorSource"
	ClassInputPassportElementErrorSource        = "InputPassportElementErrorSource"
	ClassMessageContent                         = "MessageContent"
	ClassTextEntityType                         = "TextEntityType"
	ClassInputPaidMediaType                     = "InputPaidMediaType"
	ClassMessageSchedulingState                 = "MessageSchedulingState"
	ClassMessageSelfDestructType                = "MessageSelfDestructType"
	ClassInputMessageContent                    = "InputMessageContent"
	ClassSearchMessagesFilter                   = "SearchMessagesFilter"
	ClassChatAction                             = "ChatAction"
	ClassUserStatus                             = "UserStatus"
	ClassEmojiCategorySource                    = "EmojiCategorySource"
	ClassEmojiCategoryType                      = "EmojiCategoryType"
	ClassStoryAreaType                          = "StoryAreaType"
	ClassInputStoryAreaType                     = "InputStoryAreaType"
	ClassStoryContent                           = "StoryContent"
	ClassInputStoryContent                      = "InputStoryContent"
	ClassStoryList                              = "StoryList"
	ClassStoryOrigin                            = "StoryOrigin"
	ClassStoryInteractionType                   = "StoryInteractionType"
	ClassPublicForward                          = "PublicForward"
	ClassChatBoostSource                        = "ChatBoostSource"
	ClassResendCodeReason                       = "ResendCodeReason"
	ClassCallDiscardReason                      = "CallDiscardReason"
	ClassCallServerType                         = "CallServerType"
	ClassCallState                              = "CallState"
	ClassGroupCallVideoQuality                  = "GroupCallVideoQuality"
	ClassCallProblem                            = "CallProblem"
	ClassFirebaseAuthenticationSettings         = "FirebaseAuthenticationSettings"
	ClassReactionUnavailabilityReason           = "ReactionUnavailabilityReason"
	ClassDiceStickers                           = "DiceStickers"
	ClassSpeechRecognitionResult                = "SpeechRecognitionResult"
	ClassBotWriteAccessAllowReason              = "BotWriteAccessAllowReason"
	ClassTargetChat                             = "TargetChat"
	ClassInputInlineQueryResult                 = "InputInlineQueryResult"
	ClassInlineQueryResult                      = "InlineQueryResult"
	ClassInlineQueryResultsButtonType           = "InlineQueryResultsButtonType"
	ClassCallbackQueryPayload                   = "CallbackQueryPayload"
	ClassChatEventAction                        = "ChatEventAction"
	ClassLanguagePackStringValue                = "LanguagePackStringValue"
	ClassPremiumLimitType                       = "PremiumLimitType"
	ClassPremiumFeature                         = "PremiumFeature"
	ClassBusinessFeature                        = "BusinessFeature"
	ClassPremiumStoryFeature                    = "PremiumStoryFeature"
	ClassPremiumSource                          = "PremiumSource"
	ClassStorePaymentPurpose                    = "StorePaymentPurpose"
	ClassTelegramPaymentPurpose                 = "TelegramPaymentPurpose"
	ClassDeviceToken                            = "DeviceToken"
	ClassBackgroundFill                         = "BackgroundFill"
	ClassBackgroundType                         = "BackgroundType"
	ClassInputBackground                        = "InputBackground"
	ClassCanSendStoryResult                     = "CanSendStoryResult"
	ClassCanTransferOwnershipResult             = "CanTransferOwnershipResult"
	ClassCheckChatUsernameResult                = "CheckChatUsernameResult"
	ClassCheckStickerSetNameResult              = "CheckStickerSetNameResult"
	ClassResetPasswordResult                    = "ResetPasswordResult"
	ClassMessageFileType                        = "MessageFileType"
	ClassPushMessageContent                     = "PushMessageContent"
	ClassNotificationType                       = "NotificationType"
	ClassNotificationGroupType                  = "NotificationGroupType"
	ClassOptionValue                            = "OptionValue"
	ClassJsonValue                              = "JsonValue"
	ClassStoryPrivacySettings                   = "StoryPrivacySettings"
	ClassUserPrivacySettingRule                 = "UserPrivacySettingRule"
	ClassUserPrivacySetting                     = "UserPrivacySetting"
	ClassCanSendMessageToUserResult             = "CanSendMessageToUserResult"
	ClassSessionType                            = "SessionType"
	ClassReportReason                           = "ReportReason"
	ClassReportChatResult                       = "ReportChatResult"
	ClassReportStoryResult                      = "ReportStoryResult"
	ClassInternalLinkType                       = "InternalLinkType"
	ClassBlockList                              = "BlockList"
	ClassFileType                               = "FileType"
	ClassNetworkType                            = "NetworkType"
	ClassNetworkStatisticsEntry                 = "NetworkStatisticsEntry"
	ClassAutosaveSettingsScope                  = "AutosaveSettingsScope"
	ClassConnectionState                        = "ConnectionState"
	ClassTopChatCategory                        = "TopChatCategory"
	ClassTMeUrlType                             = "TMeUrlType"
	ClassSuggestedAction                        = "SuggestedAction"
	ClassTextParseMode                          = "TextParseMode"
	ClassProxyType                              = "ProxyType"
	ClassStatisticalGraph                       = "StatisticalGraph"
	ClassChatStatisticsObjectType               = "ChatStatisticsObjectType"
	ClassChatStatistics                         = "ChatStatistics"
	ClassRevenueWithdrawalState                 = "RevenueWithdrawalState"
	ClassChatRevenueTransactionType             = "ChatRevenueTransactionType"
	ClassVectorPathCommand                      = "VectorPathCommand"
	ClassBotCommandScope                        = "BotCommandScope"
	ClassPhoneNumberCodeType                    = "PhoneNumberCodeType"
	ClassUpdate                                 = "Update"
	ClassLogStream                              = "LogStream"
	ClassError                                  = "Error"
	ClassOk                                     = "Ok"
	ClassAuthenticationCodeInfo                 = "AuthenticationCodeInfo"
	ClassEmailAddressAuthenticationCodeInfo     = "EmailAddressAuthenticationCodeInfo"
	ClassTextEntity                             = "TextEntity"
	ClassTextEntities                           = "TextEntities"
	ClassFormattedText                          = "FormattedText"
	ClassTermsOfService                         = "TermsOfService"
	ClassPasswordState                          = "PasswordState"
	ClassRecoveryEmailAddress                   = "RecoveryEmailAddress"
	ClassTemporaryPasswordState                 = "TemporaryPasswordState"
	ClassLocalFile                              = "LocalFile"
	ClassRemoteFile                             = "RemoteFile"
	ClassFile                                   = "File"
	ClassPhotoSize                              = "PhotoSize"
	ClassMinithumbnail                          = "Minithumbnail"
	ClassThumbnail                              = "Thumbnail"
	ClassMaskPosition                           = "MaskPosition"
	ClassClosedVectorPath                       = "ClosedVectorPath"
	ClassOutline                                = "Outline"
	ClassPollOption                             = "PollOption"
	ClassAnimation                              = "Animation"
	ClassAudio                                  = "Audio"
	ClassDocument                               = "Document"
	ClassPhoto                                  = "Photo"
	ClassSticker                                = "Sticker"
	ClassVideo                                  = "Video"
	ClassVideoNote                              = "VideoNote"
	ClassVoiceNote                              = "VoiceNote"
	ClassAnimatedEmoji                          = "AnimatedEmoji"
	ClassContact                                = "Contact"
	ClassLocation                               = "Location"
	ClassVenue                                  = "Venue"
	ClassGame                                   = "Game"
	ClassWebApp                                 = "WebApp"
	ClassPoll                                   = "Poll"
	ClassAlternativeVideo                       = "AlternativeVideo"
	ClassBackground                             = "Background"
	ClassBackgrounds                            = "Backgrounds"
	ClassChatBackground                         = "ChatBackground"
	ClassProfilePhoto                           = "ProfilePhoto"
	ClassChatPhotoInfo                          = "ChatPhotoInfo"
	ClassBotCommand                             = "BotCommand"
	ClassBotCommands                            = "BotCommands"
	ClassBotMenuButton                          = "BotMenuButton"
	ClassChatLocation                           = "ChatLocation"
	ClassBirthdate                              = "Birthdate"
	ClassCloseBirthdayUser                      = "CloseBirthdayUser"
	ClassBusinessLocation                       = "BusinessLocation"
	ClassBusinessRecipients                     = "BusinessRecipients"
	ClassBusinessAwayMessageSettings            = "BusinessAwayMessageSettings"
	ClassBusinessGreetingMessageSettings        = "BusinessGreetingMessageSettings"
	ClassBusinessConnectedBot                   = "BusinessConnectedBot"
	ClassBusinessStartPage                      = "BusinessStartPage"
	ClassInputBusinessStartPage                 = "InputBusinessStartPage"
	ClassBusinessOpeningHoursInterval           = "BusinessOpeningHoursInterval"
	ClassBusinessOpeningHours                   = "BusinessOpeningHours"
	ClassBusinessInfo                           = "BusinessInfo"
	ClassBusinessChatLink                       = "BusinessChatLink"
	ClassBusinessChatLinks                      = "BusinessChatLinks"
	ClassInputBusinessChatLink                  = "InputBusinessChatLink"
	ClassBusinessChatLinkInfo                   = "BusinessChatLinkInfo"
	ClassChatPhotoSticker                       = "ChatPhotoSticker"
	ClassAnimatedChatPhoto                      = "AnimatedChatPhoto"
	ClassChatPhoto                              = "ChatPhoto"
	ClassChatPhotos                             = "ChatPhotos"
	ClassChatPermissions                        = "ChatPermissions"
	ClassChatAdministratorRights                = "ChatAdministratorRights"
	ClassStarSubscriptionPricing                = "StarSubscriptionPricing"
	ClassStarSubscription                       = "StarSubscription"
	ClassStarSubscriptions                      = "StarSubscriptions"
	ClassProductInfo                            = "ProductInfo"
	ClassPremiumPaymentOption                   = "PremiumPaymentOption"
	ClassPremiumStatePaymentOption              = "PremiumStatePaymentOption"
	ClassPremiumGiftCodePaymentOption           = "PremiumGiftCodePaymentOption"
	ClassPremiumGiftCodePaymentOptions          = "PremiumGiftCodePaymentOptions"
	ClassPremiumGiftCodeInfo                    = "PremiumGiftCodeInfo"
	ClassStarPaymentOption                      = "StarPaymentOption"
	ClassStarPaymentOptions                     = "StarPaymentOptions"
	ClassStarGiveawayWinnerOption               = "StarGiveawayWinnerOption"
	ClassStarGiveawayPaymentOption              = "StarGiveawayPaymentOption"
	ClassStarGiveawayPaymentOptions             = "StarGiveawayPaymentOptions"
	ClassGift                                   = "Gift"
	ClassGifts                                  = "Gifts"
	ClassUserGift                               = "UserGift"
	ClassUserGifts                              = "UserGifts"
	ClassStarTransaction                        = "StarTransaction"
	ClassStarTransactions                       = "StarTransactions"
	ClassAccentColor                            = "AccentColor"
	ClassProfileAccentColors                    = "ProfileAccentColors"
	ClassProfileAccentColor                     = "ProfileAccentColor"
	ClassEmojiStatus                            = "EmojiStatus"
	ClassEmojiStatuses                          = "EmojiStatuses"
	ClassUsernames                              = "Usernames"
	ClassUser                                   = "User"
	ClassBotInfo                                = "BotInfo"
	ClassUserFullInfo                           = "UserFullInfo"
	ClassUsers                                  = "Users"
	ClassFoundUsers                             = "FoundUsers"
	ClassChatAdministrator                      = "ChatAdministrator"
	ClassChatAdministrators                     = "ChatAdministrators"
	ClassChatMember                             = "ChatMember"
	ClassChatMembers                            = "ChatMembers"
	ClassChatInviteLink                         = "ChatInviteLink"
	ClassChatInviteLinks                        = "ChatInviteLinks"
	ClassChatInviteLinkCount                    = "ChatInviteLinkCount"
	ClassChatInviteLinkCounts                   = "ChatInviteLinkCounts"
	ClassChatInviteLinkMember                   = "ChatInviteLinkMember"
	ClassChatInviteLinkMembers                  = "ChatInviteLinkMembers"
	ClassChatInviteLinkSubscriptionInfo         = "ChatInviteLinkSubscriptionInfo"
	ClassChatInviteLinkInfo                     = "ChatInviteLinkInfo"
	ClassChatJoinRequest                        = "ChatJoinRequest"
	ClassChatJoinRequests                       = "ChatJoinRequests"
	ClassChatJoinRequestsInfo                   = "ChatJoinRequestsInfo"
	ClassBasicGroup                             = "BasicGroup"
	ClassBasicGroupFullInfo                     = "BasicGroupFullInfo"
	ClassSupergroup                             = "Supergroup"
	ClassSupergroupFullInfo                     = "SupergroupFullInfo"
	ClassSecretChat                             = "SecretChat"
	ClassMessageSenders                         = "MessageSenders"
	ClassChatMessageSender                      = "ChatMessageSender"
	ClassChatMessageSenders                     = "ChatMessageSenders"
	ClassMessageViewer                          = "MessageViewer"
	ClassMessageViewers                         = "MessageViewers"
	ClassForwardSource                          = "ForwardSource"
	ClassPaidReactor                            = "PaidReactor"
	ClassMessageForwardInfo                     = "MessageForwardInfo"
	ClassMessageImportInfo                      = "MessageImportInfo"
	ClassMessageReplyInfo                       = "MessageReplyInfo"
	ClassMessageReaction                        = "MessageReaction"
	ClassMessageReactions                       = "MessageReactions"
	ClassMessageInteractionInfo                 = "MessageInteractionInfo"
	ClassUnreadReaction                         = "UnreadReaction"
	ClassMessageEffect                          = "MessageEffect"
	ClassTextQuote                              = "TextQuote"
	ClassInputTextQuote                         = "InputTextQuote"
	ClassFactCheck                              = "FactCheck"
	ClassMessage                                = "Message"
	ClassMessages                               = "Messages"
	ClassFoundMessages                          = "FoundMessages"
	ClassFoundChatMessages                      = "FoundChatMessages"
	ClassMessagePosition                        = "MessagePosition"
	ClassMessagePositions                       = "MessagePositions"
	ClassMessageCalendarDay                     = "MessageCalendarDay"
	ClassMessageCalendar                        = "MessageCalendar"
	ClassBusinessMessage                        = "BusinessMessage"
	ClassBusinessMessages                       = "BusinessMessages"
	ClassMessageSponsor                         = "MessageSponsor"
	ClassSponsoredMessage                       = "SponsoredMessage"
	ClassSponsoredMessages                      = "SponsoredMessages"
	ClassReportOption                           = "ReportOption"
	ClassFileDownload                           = "FileDownload"
	ClassDownloadedFileCounts                   = "DownloadedFileCounts"
	ClassFoundFileDownloads                     = "FoundFileDownloads"
	ClassChatNotificationSettings               = "ChatNotificationSettings"
	ClassScopeNotificationSettings              = "ScopeNotificationSettings"
	ClassReactionNotificationSettings           = "ReactionNotificationSettings"
	ClassDraftMessage                           = "DraftMessage"
	ClassChatFolderIcon                         = "ChatFolderIcon"
	ClassChatFolder                             = "ChatFolder"
	ClassChatFolderInfo                         = "ChatFolderInfo"
	ClassChatFolderInviteLink                   = "ChatFolderInviteLink"
	ClassChatFolderInviteLinks                  = "ChatFolderInviteLinks"
	ClassChatFolderInviteLinkInfo               = "ChatFolderInviteLinkInfo"
	ClassRecommendedChatFolder                  = "RecommendedChatFolder"
	ClassRecommendedChatFolders                 = "RecommendedChatFolders"
	ClassArchiveChatListSettings                = "ArchiveChatListSettings"
	ClassChatLists                              = "ChatLists"
	ClassChatPosition                           = "ChatPosition"
	ClassSavedMessagesTag                       = "SavedMessagesTag"
	ClassSavedMessagesTags                      = "SavedMessagesTags"
	ClassBusinessBotManageBar                   = "BusinessBotManageBar"
	ClassVideoChat                              = "VideoChat"
	ClassChat                                   = "Chat"
	ClassChats                                  = "Chats"
	ClassFailedToAddMember                      = "FailedToAddMember"
	ClassFailedToAddMembers                     = "FailedToAddMembers"
	ClassCreatedBasicGroupChat                  = "CreatedBasicGroupChat"
	ClassKeyboardButton                         = "KeyboardButton"
	ClassInlineKeyboardButton                   = "InlineKeyboardButton"
	ClassThemeParameters                        = "ThemeParameters"
	ClassFoundWebApp                            = "FoundWebApp"
	ClassWebAppInfo                             = "WebAppInfo"
	ClassMainWebApp                             = "MainWebApp"
	ClassWebAppOpenParameters                   = "WebAppOpenParameters"
	ClassMessageThreadInfo                      = "MessageThreadInfo"
	ClassSavedMessagesTopic                     = "SavedMessagesTopic"
	ClassForumTopicIcon                         = "ForumTopicIcon"
	ClassForumTopicInfo                         = "ForumTopicInfo"
	ClassForumTopic                             = "ForumTopic"
	ClassForumTopics                            = "ForumTopics"
	ClassLinkPreviewOptions                     = "LinkPreviewOptions"
	ClassSharedUser                             = "SharedUser"
	ClassSharedChat                             = "SharedChat"
	ClassThemeSettings                          = "ThemeSettings"
	ClassPageBlockCaption                       = "PageBlockCaption"
	ClassPageBlockListItem                      = "PageBlockListItem"
	ClassPageBlockTableCell                     = "PageBlockTableCell"
	ClassPageBlockRelatedArticle                = "PageBlockRelatedArticle"
	ClassWebPageInstantView                     = "WebPageInstantView"
	ClassLinkPreview                            = "LinkPreview"
	ClassCountryInfo                            = "CountryInfo"
	ClassCountries                              = "Countries"
	ClassPhoneNumberInfo                        = "PhoneNumberInfo"
	ClassCollectibleItemInfo                    = "CollectibleItemInfo"
	ClassBankCardActionOpenUrl                  = "BankCardActionOpenUrl"
	ClassBankCardInfo                           = "BankCardInfo"
	ClassAddress                                = "Address"
	ClassLocationAddress                        = "LocationAddress"
	ClassLabeledPricePart                       = "LabeledPricePart"
	ClassInvoice                                = "Invoice"
	ClassOrderInfo                              = "OrderInfo"
	ClassShippingOption                         = "ShippingOption"
	ClassSavedCredentials                       = "SavedCredentials"
	ClassPaymentOption                          = "PaymentOption"
	ClassPaymentForm                            = "PaymentForm"
	ClassValidatedOrderInfo                     = "ValidatedOrderInfo"
	ClassPaymentResult                          = "PaymentResult"
	ClassPaymentReceipt                         = "PaymentReceipt"
	ClassGiveawayParameters                     = "GiveawayParameters"
	ClassDatedFile                              = "DatedFile"
	ClassDate                                   = "Date"
	ClassPersonalDetails                        = "PersonalDetails"
	ClassIdentityDocument                       = "IdentityDocument"
	ClassInputIdentityDocument                  = "InputIdentityDocument"
	ClassPersonalDocument                       = "PersonalDocument"
	ClassInputPersonalDocument                  = "InputPersonalDocument"
	ClassPassportElements                       = "PassportElements"
	ClassPassportElementError                   = "PassportElementError"
	ClassPassportSuitableElement                = "PassportSuitableElement"
	ClassPassportRequiredElement                = "PassportRequiredElement"
	ClassPassportAuthorizationForm              = "PassportAuthorizationForm"
	ClassPassportElementsWithErrors             = "PassportElementsWithErrors"
	ClassEncryptedCredentials                   = "EncryptedCredentials"
	ClassEncryptedPassportElement               = "EncryptedPassportElement"
	ClassInputPassportElementError              = "InputPassportElementError"
	ClassInputThumbnail                         = "InputThumbnail"
	ClassInputPaidMedia                         = "InputPaidMedia"
	ClassMessageSendOptions                     = "MessageSendOptions"
	ClassMessageCopyOptions                     = "MessageCopyOptions"
	ClassMessageProperties                      = "MessageProperties"
	ClassEmojiKeyword                           = "EmojiKeyword"
	ClassEmojiKeywords                          = "EmojiKeywords"
	ClassStickers                               = "Stickers"
	ClassEmojis                                 = "Emojis"
	ClassStickerSet                             = "StickerSet"
	ClassStickerSetInfo                         = "StickerSetInfo"
	ClassStickerSets                            = "StickerSets"
	ClassTrendingStickerSets                    = "TrendingStickerSets"
	ClassEmojiCategory                          = "EmojiCategory"
	ClassEmojiCategories                        = "EmojiCategories"
	ClassCurrentWeather                         = "CurrentWeather"
	ClassStoryAreaPosition                      = "StoryAreaPosition"
	ClassStoryArea                              = "StoryArea"
	ClassInputStoryArea                         = "InputStoryArea"
	ClassInputStoryAreas                        = "InputStoryAreas"
	ClassStoryVideo                             = "StoryVideo"
	ClassStoryRepostInfo                        = "StoryRepostInfo"
	ClassStoryInteractionInfo                   = "StoryInteractionInfo"
	ClassStory                                  = "Story"
	ClassStories                                = "Stories"
	ClassFoundStories                           = "FoundStories"
	ClassStoryFullId                            = "StoryFullId"
	ClassStoryInfo                              = "StoryInfo"
	ClassChatActiveStories                      = "ChatActiveStories"
	ClassStoryInteraction                       = "StoryInteraction"
	ClassStoryInteractions                      = "StoryInteractions"
	ClassQuickReplyMessage                      = "QuickReplyMessage"
	ClassQuickReplyMessages                     = "QuickReplyMessages"
	ClassQuickReplyShortcut                     = "QuickReplyShortcut"
	ClassPublicForwards                         = "PublicForwards"
	ClassBotMediaPreview                        = "BotMediaPreview"
	ClassBotMediaPreviews                       = "BotMediaPreviews"
	ClassBotMediaPreviewInfo                    = "BotMediaPreviewInfo"
	ClassChatBoostLevelFeatures                 = "ChatBoostLevelFeatures"
	ClassChatBoostFeatures                      = "ChatBoostFeatures"
	ClassPrepaidGiveaway                        = "PrepaidGiveaway"
	ClassChatBoostStatus                        = "ChatBoostStatus"
	ClassChatBoost                              = "ChatBoost"
	ClassFoundChatBoosts                        = "FoundChatBoosts"
	ClassChatBoostSlot                          = "ChatBoostSlot"
	ClassChatBoostSlots                         = "ChatBoostSlots"
	ClassCallProtocol                           = "CallProtocol"
	ClassCallServer                             = "CallServer"
	ClassCallId                                 = "CallId"
	ClassGroupCallId                            = "GroupCallId"
	ClassGroupCallStream                        = "GroupCallStream"
	ClassGroupCallStreams                       = "GroupCallStreams"
	ClassRtmpUrl                                = "RtmpUrl"
	ClassGroupCallRecentSpeaker                 = "GroupCallRecentSpeaker"
	ClassGroupCall                              = "GroupCall"
	ClassGroupCallVideoSourceGroup              = "GroupCallVideoSourceGroup"
	ClassGroupCallParticipantVideoInfo          = "GroupCallParticipantVideoInfo"
	ClassGroupCallParticipant                   = "GroupCallParticipant"
	ClassCall                                   = "Call"
	ClassPhoneNumberAuthenticationSettings      = "PhoneNumberAuthenticationSettings"
	ClassAddedReaction                          = "AddedReaction"
	ClassAddedReactions                         = "AddedReactions"
	ClassAvailableReaction                      = "AvailableReaction"
	ClassAvailableReactions                     = "AvailableReactions"
	ClassEmojiReaction                          = "EmojiReaction"
	ClassAnimations                             = "Animations"
	ClassImportedContacts                       = "ImportedContacts"
	ClassBusinessConnection                     = "BusinessConnection"
	ClassAttachmentMenuBotColor                 = "AttachmentMenuBotColor"
	ClassAttachmentMenuBot                      = "AttachmentMenuBot"
	ClassSentWebAppMessage                      = "SentWebAppMessage"
	ClassHttpUrl                                = "HttpUrl"
	ClassUserLink                               = "UserLink"
	ClassTargetChatTypes                        = "TargetChatTypes"
	ClassInlineQueryResultsButton               = "InlineQueryResultsButton"
	ClassInlineQueryResults                     = "InlineQueryResults"
	ClassPreparedInlineMessageId                = "PreparedInlineMessageId"
	ClassPreparedInlineMessage                  = "PreparedInlineMessage"
	ClassCallbackQueryAnswer                    = "CallbackQueryAnswer"
	ClassCustomRequestResult                    = "CustomRequestResult"
	ClassGameHighScore                          = "GameHighScore"
	ClassGameHighScores                         = "GameHighScores"
	ClassChatEvent                              = "ChatEvent"
	ClassChatEvents                             = "ChatEvents"
	ClassChatEventLogFilters                    = "ChatEventLogFilters"
	ClassLanguagePackString                     = "LanguagePackString"
	ClassLanguagePackStrings                    = "LanguagePackStrings"
	ClassLanguagePackInfo                       = "LanguagePackInfo"
	ClassLocalizationTargetInfo                 = "LocalizationTargetInfo"
	ClassPremiumLimit                           = "PremiumLimit"
	ClassPremiumFeatures                        = "PremiumFeatures"
	ClassBusinessFeatures                       = "BusinessFeatures"
	ClassPremiumFeaturePromotionAnimation       = "PremiumFeaturePromotionAnimation"
	ClassBusinessFeaturePromotionAnimation      = "BusinessFeaturePromotionAnimation"
	ClassPremiumState                           = "PremiumState"
	ClassPushReceiverId                         = "PushReceiverId"
	ClassChatTheme                              = "ChatTheme"
	ClassTimeZone                               = "TimeZone"
	ClassTimeZones                              = "TimeZones"
	ClassHashtags                               = "Hashtags"
	ClassNotificationSound                      = "NotificationSound"
	ClassNotificationSounds                     = "NotificationSounds"
	ClassNotification                           = "Notification"
	ClassNotificationGroup                      = "NotificationGroup"
	ClassJsonObjectMember                       = "JsonObjectMember"
	ClassUserPrivacySettingRules                = "UserPrivacySettingRules"
	ClassReadDatePrivacySettings                = "ReadDatePrivacySettings"
	ClassNewChatPrivacySettings                 = "NewChatPrivacySettings"
	ClassAccountTtl                             = "AccountTtl"
	ClassMessageAutoDeleteTime                  = "MessageAutoDeleteTime"
	ClassSession                                = "Session"
	ClassSessions                               = "Sessions"
	ClassUnconfirmedSession                     = "UnconfirmedSession"
	ClassConnectedWebsite                       = "ConnectedWebsite"
	ClassConnectedWebsites                      = "ConnectedWebsites"
	ClassMessageLink                            = "MessageLink"
	ClassMessageLinkInfo                        = "MessageLinkInfo"
	ClassChatBoostLink                          = "ChatBoostLink"
	ClassChatBoostLinkInfo                      = "ChatBoostLinkInfo"
	ClassFilePart                               = "FilePart"
	ClassStorageStatisticsByFileType            = "StorageStatisticsByFileType"
	ClassStorageStatisticsByChat                = "StorageStatisticsByChat"
	ClassStorageStatistics                      = "StorageStatistics"
	ClassStorageStatisticsFast                  = "StorageStatisticsFast"
	ClassDatabaseStatistics                     = "DatabaseStatistics"
	ClassNetworkStatistics                      = "NetworkStatistics"
	ClassAutoDownloadSettings                   = "AutoDownloadSettings"
	ClassAutoDownloadSettingsPresets            = "AutoDownloadSettingsPresets"
	ClassScopeAutosaveSettings                  = "ScopeAutosaveSettings"
	ClassAutosaveSettingsException              = "AutosaveSettingsException"
	ClassAutosaveSettings                       = "AutosaveSettings"
	ClassFoundPosition                          = "FoundPosition"
	ClassFoundPositions                         = "FoundPositions"
	ClassTMeUrl                                 = "TMeUrl"
	ClassTMeUrls                                = "TMeUrls"
	ClassCount                                  = "Count"
	ClassText                                   = "Text"
	ClassSeconds                                = "Seconds"
	ClassFileDownloadedPrefixSize               = "FileDownloadedPrefixSize"
	ClassDeepLinkInfo                           = "DeepLinkInfo"
	ClassProxy                                  = "Proxy"
	ClassProxies                                = "Proxies"
	ClassInputSticker                           = "InputSticker"
	ClassDateRange                              = "DateRange"
	ClassStatisticalValue                       = "StatisticalValue"
	ClassChatStatisticsInteractionInfo          = "ChatStatisticsInteractionInfo"
	ClassChatStatisticsMessageSenderInfo        = "ChatStatisticsMessageSenderInfo"
	ClassChatStatisticsAdministratorActionsInfo = "ChatStatisticsAdministratorActionsInfo"
	ClassChatStatisticsInviterInfo              = "ChatStatisticsInviterInfo"
	ClassChatRevenueAmount                      = "ChatRevenueAmount"
	ClassChatRevenueStatistics                  = "ChatRevenueStatistics"
	ClassMessageStatistics                      = "MessageStatistics"
	ClassStoryStatistics                        = "StoryStatistics"
	ClassChatRevenueTransaction                 = "ChatRevenueTransaction"
	ClassChatRevenueTransactions                = "ChatRevenueTransactions"
	ClassStarRevenueStatus                      = "StarRevenueStatus"
	ClassStarRevenueStatistics                  = "StarRevenueStatistics"
	ClassPoint                                  = "Point"
	ClassUpdates                                = "Updates"
	ClassLogVerbosityLevel                      = "LogVerbosityLevel"
	ClassLogTags                                = "LogTags"
	ClassUserSupportInfo                        = "UserSupportInfo"
	ClassTestInt                                = "TestInt"
	ClassTestString                             = "TestString"
	ClassTestBytes                              = "TestBytes"
	ClassTestVectorInt                          = "TestVectorInt"
	ClassTestVectorIntObject                    = "TestVectorIntObject"
	ClassTestVectorString                       = "TestVectorString"
	ClassTestVectorStringObject                 = "TestVectorStringObject"
)

const (
	TypeError                                                   = "error"
	TypeOk                                                      = "ok"
	TypeAuthenticationCodeTypeTelegramMessage                   = "authenticationCodeTypeTelegramMessage"
	TypeAuthenticationCodeTypeSms                               = "authenticationCodeTypeSms"
	TypeAuthenticationCodeTypeSmsWord                           = "authenticationCodeTypeSmsWord"
	TypeAuthenticationCodeTypeSmsPhrase                         = "authenticationCodeTypeSmsPhrase"
	TypeAuthenticationCodeTypeCall                              = "authenticationCodeTypeCall"
	TypeAuthenticationCodeTypeFlashCall                         = "authenticationCodeTypeFlashCall"
	TypeAuthenticationCodeTypeMissedCall                        = "authenticationCodeTypeMissedCall"
	TypeAuthenticationCodeTypeFragment                          = "authenticationCodeTypeFragment"
	TypeAuthenticationCodeTypeFirebaseAndroid                   = "authenticationCodeTypeFirebaseAndroid"
	TypeAuthenticationCodeTypeFirebaseIos                       = "authenticationCodeTypeFirebaseIos"
	TypeAuthenticationCodeInfo                                  = "authenticationCodeInfo"
	TypeEmailAddressAuthenticationCodeInfo                      = "emailAddressAuthenticationCodeInfo"
	TypeEmailAddressAuthenticationCode                          = "emailAddressAuthenticationCode"
	TypeEmailAddressAuthenticationAppleId                       = "emailAddressAuthenticationAppleId"
	TypeEmailAddressAuthenticationGoogleId                      = "emailAddressAuthenticationGoogleId"
	TypeEmailAddressResetStateAvailable                         = "emailAddressResetStateAvailable"
	TypeEmailAddressResetStatePending                           = "emailAddressResetStatePending"
	TypeTextEntity                                              = "textEntity"
	TypeTextEntities                                            = "textEntities"
	TypeFormattedText                                           = "formattedText"
	TypeTermsOfService                                          = "termsOfService"
	TypeAuthorizationStateWaitTdlibParameters                   = "authorizationStateWaitTdlibParameters"
	TypeAuthorizationStateWaitPhoneNumber                       = "authorizationStateWaitPhoneNumber"
	TypeAuthorizationStateWaitEmailAddress                      = "authorizationStateWaitEmailAddress"
	TypeAuthorizationStateWaitEmailCode                         = "authorizationStateWaitEmailCode"
	TypeAuthorizationStateWaitCode                              = "authorizationStateWaitCode"
	TypeAuthorizationStateWaitOtherDeviceConfirmation           = "authorizationStateWaitOtherDeviceConfirmation"
	TypeAuthorizationStateWaitRegistration                      = "authorizationStateWaitRegistration"
	TypeAuthorizationStateWaitPassword                          = "authorizationStateWaitPassword"
	TypeAuthorizationStateReady                                 = "authorizationStateReady"
	TypeAuthorizationStateLoggingOut                            = "authorizationStateLoggingOut"
	TypeAuthorizationStateClosing                               = "authorizationStateClosing"
	TypeAuthorizationStateClosed                                = "authorizationStateClosed"
	TypeFirebaseDeviceVerificationParametersSafetyNet           = "firebaseDeviceVerificationParametersSafetyNet"
	TypeFirebaseDeviceVerificationParametersPlayIntegrity       = "firebaseDeviceVerificationParametersPlayIntegrity"
	TypePasswordState                                           = "passwordState"
	TypeRecoveryEmailAddress                                    = "recoveryEmailAddress"
	TypeTemporaryPasswordState                                  = "temporaryPasswordState"
	TypeLocalFile                                               = "localFile"
	TypeRemoteFile                                              = "remoteFile"
	TypeFile                                                    = "file"
	TypeInputFileId                                             = "inputFileId"
	TypeInputFileRemote                                         = "inputFileRemote"
	TypeInputFileLocal                                          = "inputFileLocal"
	TypeInputFileGenerated                                      = "inputFileGenerated"
	TypePhotoSize                                               = "photoSize"
	TypeMinithumbnail                                           = "minithumbnail"
	TypeThumbnailFormatJpeg                                     = "thumbnailFormatJpeg"
	TypeThumbnailFormatGif                                      = "thumbnailFormatGif"
	TypeThumbnailFormatMpeg4                                    = "thumbnailFormatMpeg4"
	TypeThumbnailFormatPng                                      = "thumbnailFormatPng"
	TypeThumbnailFormatTgs                                      = "thumbnailFormatTgs"
	TypeThumbnailFormatWebm                                     = "thumbnailFormatWebm"
	TypeThumbnailFormatWebp                                     = "thumbnailFormatWebp"
	TypeThumbnail                                               = "thumbnail"
	TypeMaskPointForehead                                       = "maskPointForehead"
	TypeMaskPointEyes                                           = "maskPointEyes"
	TypeMaskPointMouth                                          = "maskPointMouth"
	TypeMaskPointChin                                           = "maskPointChin"
	TypeMaskPosition                                            = "maskPosition"
	TypeStickerFormatWebp                                       = "stickerFormatWebp"
	TypeStickerFormatTgs                                        = "stickerFormatTgs"
	TypeStickerFormatWebm                                       = "stickerFormatWebm"
	TypeStickerTypeRegular                                      = "stickerTypeRegular"
	TypeStickerTypeMask                                         = "stickerTypeMask"
	TypeStickerTypeCustomEmoji                                  = "stickerTypeCustomEmoji"
	TypeStickerFullTypeRegular                                  = "stickerFullTypeRegular"
	TypeStickerFullTypeMask                                     = "stickerFullTypeMask"
	TypeStickerFullTypeCustomEmoji                              = "stickerFullTypeCustomEmoji"
	TypeClosedVectorPath                                        = "closedVectorPath"
	TypeOutline                                                 = "outline"
	TypePollOption                                              = "pollOption"
	TypePollTypeRegular                                         = "pollTypeRegular"
	TypePollTypeQuiz                                            = "pollTypeQuiz"
	TypeAnimation                                               = "animation"
	TypeAudio                                                   = "audio"
	TypeDocument                                                = "document"
	TypePhoto                                                   = "photo"
	TypeSticker                                                 = "sticker"
	TypeVideo                                                   = "video"
	TypeVideoNote                                               = "videoNote"
	TypeVoiceNote                                               = "voiceNote"
	TypeAnimatedEmoji                                           = "animatedEmoji"
	TypeContact                                                 = "contact"
	TypeLocation                                                = "location"
	TypeVenue                                                   = "venue"
	TypeGame                                                    = "game"
	TypeWebApp                                                  = "webApp"
	TypePoll                                                    = "poll"
	TypeAlternativeVideo                                        = "alternativeVideo"
	TypeBackground                                              = "background"
	TypeBackgrounds                                             = "backgrounds"
	TypeChatBackground                                          = "chatBackground"
	TypeProfilePhoto                                            = "profilePhoto"
	TypeChatPhotoInfo                                           = "chatPhotoInfo"
	TypeUserTypeRegular                                         = "userTypeRegular"
	TypeUserTypeDeleted                                         = "userTypeDeleted"
	TypeUserTypeBot                                             = "userTypeBot"
	TypeUserTypeUnknown                                         = "userTypeUnknown"
	TypeBotCommand                                              = "botCommand"
	TypeBotCommands                                             = "botCommands"
	TypeBotMenuButton                                           = "botMenuButton"
	TypeChatLocation                                            = "chatLocation"
	TypeBirthdate                                               = "birthdate"
	TypeCloseBirthdayUser                                       = "closeBirthdayUser"
	TypeBusinessAwayMessageScheduleAlways                       = "businessAwayMessageScheduleAlways"
	TypeBusinessAwayMessageScheduleOutsideOfOpeningHours        = "businessAwayMessageScheduleOutsideOfOpeningHours"
	TypeBusinessAwayMessageScheduleCustom                       = "businessAwayMessageScheduleCustom"
	TypeBusinessLocation                                        = "businessLocation"
	TypeBusinessRecipients                                      = "businessRecipients"
	TypeBusinessAwayMessageSettings                             = "businessAwayMessageSettings"
	TypeBusinessGreetingMessageSettings                         = "businessGreetingMessageSettings"
	TypeBusinessConnectedBot                                    = "businessConnectedBot"
	TypeBusinessStartPage                                       = "businessStartPage"
	TypeInputBusinessStartPage                                  = "inputBusinessStartPage"
	TypeBusinessOpeningHoursInterval                            = "businessOpeningHoursInterval"
	TypeBusinessOpeningHours                                    = "businessOpeningHours"
	TypeBusinessInfo                                            = "businessInfo"
	TypeBusinessChatLink                                        = "businessChatLink"
	TypeBusinessChatLinks                                       = "businessChatLinks"
	TypeInputBusinessChatLink                                   = "inputBusinessChatLink"
	TypeBusinessChatLinkInfo                                    = "businessChatLinkInfo"
	TypeChatPhotoStickerTypeRegularOrMask                       = "chatPhotoStickerTypeRegularOrMask"
	TypeChatPhotoStickerTypeCustomEmoji                         = "chatPhotoStickerTypeCustomEmoji"
	TypeChatPhotoSticker                                        = "chatPhotoSticker"
	TypeAnimatedChatPhoto                                       = "animatedChatPhoto"
	TypeChatPhoto                                               = "chatPhoto"
	TypeChatPhotos                                              = "chatPhotos"
	TypeInputChatPhotoPrevious                                  = "inputChatPhotoPrevious"
	TypeInputChatPhotoStatic                                    = "inputChatPhotoStatic"
	TypeInputChatPhotoAnimation                                 = "inputChatPhotoAnimation"
	TypeInputChatPhotoSticker                                   = "inputChatPhotoSticker"
	TypeChatPermissions                                         = "chatPermissions"
	TypeChatAdministratorRights                                 = "chatAdministratorRights"
	TypeStarSubscriptionTypeChannel                             = "starSubscriptionTypeChannel"
	TypeStarSubscriptionTypeBot                                 = "starSubscriptionTypeBot"
	TypeStarSubscriptionPricing                                 = "starSubscriptionPricing"
	TypeStarSubscription                                        = "starSubscription"
	TypeStarSubscriptions                                       = "starSubscriptions"
	TypeProductInfo                                             = "productInfo"
	TypePremiumPaymentOption                                    = "premiumPaymentOption"
	TypePremiumStatePaymentOption                               = "premiumStatePaymentOption"
	TypePremiumGiftCodePaymentOption                            = "premiumGiftCodePaymentOption"
	TypePremiumGiftCodePaymentOptions                           = "premiumGiftCodePaymentOptions"
	TypePremiumGiftCodeInfo                                     = "premiumGiftCodeInfo"
	TypeStarPaymentOption                                       = "starPaymentOption"
	TypeStarPaymentOptions                                      = "starPaymentOptions"
	TypeStarGiveawayWinnerOption                                = "starGiveawayWinnerOption"
	TypeStarGiveawayPaymentOption                               = "starGiveawayPaymentOption"
	TypeStarGiveawayPaymentOptions                              = "starGiveawayPaymentOptions"
	TypeGift                                                    = "gift"
	TypeGifts                                                   = "gifts"
	TypeUserGift                                                = "userGift"
	TypeUserGifts                                               = "userGifts"
	TypeStarTransactionDirectionIncoming                        = "starTransactionDirectionIncoming"
	TypeStarTransactionDirectionOutgoing                        = "starTransactionDirectionOutgoing"
	TypeBotTransactionPurposePaidMedia                          = "botTransactionPurposePaidMedia"
	TypeBotTransactionPurposeInvoicePayment                     = "botTransactionPurposeInvoicePayment"
	TypeBotTransactionPurposeSubscription                       = "botTransactionPurposeSubscription"
	TypeChatTransactionPurposePaidMedia                         = "chatTransactionPurposePaidMedia"
	TypeChatTransactionPurposeJoin                              = "chatTransactionPurposeJoin"
	TypeChatTransactionPurposeReaction                          = "chatTransactionPurposeReaction"
	TypeChatTransactionPurposeGiveaway                          = "chatTransactionPurposeGiveaway"
	TypeUserTransactionPurposeGiftedStars                       = "userTransactionPurposeGiftedStars"
	TypeUserTransactionPurposeGiftSell                          = "userTransactionPurposeGiftSell"
	TypeUserTransactionPurposeGiftSend                          = "userTransactionPurposeGiftSend"
	TypeStarTransactionPartnerTelegram                          = "starTransactionPartnerTelegram"
	TypeStarTransactionPartnerAppStore                          = "starTransactionPartnerAppStore"
	TypeStarTransactionPartnerGooglePlay                        = "starTransactionPartnerGooglePlay"
	TypeStarTransactionPartnerFragment                          = "starTransactionPartnerFragment"
	TypeStarTransactionPartnerTelegramAds                       = "starTransactionPartnerTelegramAds"
	TypeStarTransactionPartnerTelegramApi                       = "starTransactionPartnerTelegramApi"
	TypeStarTransactionPartnerBot                               = "starTransactionPartnerBot"
	TypeStarTransactionPartnerBusiness                          = "starTransactionPartnerBusiness"
	TypeStarTransactionPartnerChat                              = "starTransactionPartnerChat"
	TypeStarTransactionPartnerUser                              = "starTransactionPartnerUser"
	TypeStarTransactionPartnerUnsupported                       = "starTransactionPartnerUnsupported"
	TypeStarTransaction                                         = "starTransaction"
	TypeStarTransactions                                        = "starTransactions"
	TypeGiveawayParticipantStatusEligible                       = "giveawayParticipantStatusEligible"
	TypeGiveawayParticipantStatusParticipating                  = "giveawayParticipantStatusParticipating"
	TypeGiveawayParticipantStatusAlreadyWasMember               = "giveawayParticipantStatusAlreadyWasMember"
	TypeGiveawayParticipantStatusAdministrator                  = "giveawayParticipantStatusAdministrator"
	TypeGiveawayParticipantStatusDisallowedCountry              = "giveawayParticipantStatusDisallowedCountry"
	TypeGiveawayInfoOngoing                                     = "giveawayInfoOngoing"
	TypeGiveawayInfoCompleted                                   = "giveawayInfoCompleted"
	TypeGiveawayPrizePremium                                    = "giveawayPrizePremium"
	TypeGiveawayPrizeStars                                      = "giveawayPrizeStars"
	TypeAccentColor                                             = "accentColor"
	TypeProfileAccentColors                                     = "profileAccentColors"
	TypeProfileAccentColor                                      = "profileAccentColor"
	TypeEmojiStatus                                             = "emojiStatus"
	TypeEmojiStatuses                                           = "emojiStatuses"
	TypeUsernames                                               = "usernames"
	TypeUser                                                    = "user"
	TypeBotInfo                                                 = "botInfo"
	TypeUserFullInfo                                            = "userFullInfo"
	TypeUsers                                                   = "users"
	TypeFoundUsers                                              = "foundUsers"
	TypeChatAdministrator                                       = "chatAdministrator"
	TypeChatAdministrators                                      = "chatAdministrators"
	TypeChatMemberStatusCreator                                 = "chatMemberStatusCreator"
	TypeChatMemberStatusAdministrator                           = "chatMemberStatusAdministrator"
	TypeChatMemberStatusMember                                  = "chatMemberStatusMember"
	TypeChatMemberStatusRestricted                              = "chatMemberStatusRestricted"
	TypeChatMemberStatusLeft                                    = "chatMemberStatusLeft"
	TypeChatMemberStatusBanned                                  = "chatMemberStatusBanned"
	TypeChatMember                                              = "chatMember"
	TypeChatMembers                                             = "chatMembers"
	TypeChatMembersFilterContacts                               = "chatMembersFilterContacts"
	TypeChatMembersFilterAdministrators                         = "chatMembersFilterAdministrators"
	TypeChatMembersFilterMembers                                = "chatMembersFilterMembers"
	TypeChatMembersFilterMention                                = "chatMembersFilterMention"
	TypeChatMembersFilterRestricted                             = "chatMembersFilterRestricted"
	TypeChatMembersFilterBanned                                 = "chatMembersFilterBanned"
	TypeChatMembersFilterBots                                   = "chatMembersFilterBots"
	TypeSupergroupMembersFilterRecent                           = "supergroupMembersFilterRecent"
	TypeSupergroupMembersFilterContacts                         = "supergroupMembersFilterContacts"
	TypeSupergroupMembersFilterAdministrators                   = "supergroupMembersFilterAdministrators"
	TypeSupergroupMembersFilterSearch                           = "supergroupMembersFilterSearch"
	TypeSupergroupMembersFilterRestricted                       = "supergroupMembersFilterRestricted"
	TypeSupergroupMembersFilterBanned                           = "supergroupMembersFilterBanned"
	TypeSupergroupMembersFilterMention                          = "supergroupMembersFilterMention"
	TypeSupergroupMembersFilterBots                             = "supergroupMembersFilterBots"
	TypeChatInviteLink                                          = "chatInviteLink"
	TypeChatInviteLinks                                         = "chatInviteLinks"
	TypeChatInviteLinkCount                                     = "chatInviteLinkCount"
	TypeChatInviteLinkCounts                                    = "chatInviteLinkCounts"
	TypeChatInviteLinkMember                                    = "chatInviteLinkMember"
	TypeChatInviteLinkMembers                                   = "chatInviteLinkMembers"
	TypeInviteLinkChatTypeBasicGroup                            = "inviteLinkChatTypeBasicGroup"
	TypeInviteLinkChatTypeSupergroup                            = "inviteLinkChatTypeSupergroup"
	TypeInviteLinkChatTypeChannel                               = "inviteLinkChatTypeChannel"
	TypeChatInviteLinkSubscriptionInfo                          = "chatInviteLinkSubscriptionInfo"
	TypeChatInviteLinkInfo                                      = "chatInviteLinkInfo"
	TypeChatJoinRequest                                         = "chatJoinRequest"
	TypeChatJoinRequests                                        = "chatJoinRequests"
	TypeChatJoinRequestsInfo                                    = "chatJoinRequestsInfo"
	TypeBasicGroup                                              = "basicGroup"
	TypeBasicGroupFullInfo                                      = "basicGroupFullInfo"
	TypeSupergroup                                              = "supergroup"
	TypeSupergroupFullInfo                                      = "supergroupFullInfo"
	TypeSecretChatStatePending                                  = "secretChatStatePending"
	TypeSecretChatStateReady                                    = "secretChatStateReady"
	TypeSecretChatStateClosed                                   = "secretChatStateClosed"
	TypeSecretChat                                              = "secretChat"
	TypeMessageSenderUser                                       = "messageSenderUser"
	TypeMessageSenderChat                                       = "messageSenderChat"
	TypeMessageSenders                                          = "messageSenders"
	TypeChatMessageSender                                       = "chatMessageSender"
	TypeChatMessageSenders                                      = "chatMessageSenders"
	TypeMessageReadDateRead                                     = "messageReadDateRead"
	TypeMessageReadDateUnread                                   = "messageReadDateUnread"
	TypeMessageReadDateTooOld                                   = "messageReadDateTooOld"
	TypeMessageReadDateUserPrivacyRestricted                    = "messageReadDateUserPrivacyRestricted"
	TypeMessageReadDateMyPrivacyRestricted                      = "messageReadDateMyPrivacyRestricted"
	TypeMessageViewer                                           = "messageViewer"
	TypeMessageViewers                                          = "messageViewers"
	TypeMessageOriginUser                                       = "messageOriginUser"
	TypeMessageOriginHiddenUser                                 = "messageOriginHiddenUser"
	TypeMessageOriginChat                                       = "messageOriginChat"
	TypeMessageOriginChannel                                    = "messageOriginChannel"
	TypeForwardSource                                           = "forwardSource"
	TypeReactionTypeEmoji                                       = "reactionTypeEmoji"
	TypeReactionTypeCustomEmoji                                 = "reactionTypeCustomEmoji"
	TypeReactionTypePaid                                        = "reactionTypePaid"
	TypePaidReactor                                             = "paidReactor"
	TypeMessageForwardInfo                                      = "messageForwardInfo"
	TypeMessageImportInfo                                       = "messageImportInfo"
	TypeMessageReplyInfo                                        = "messageReplyInfo"
	TypeMessageReaction                                         = "messageReaction"
	TypeMessageReactions                                        = "messageReactions"
	TypeMessageInteractionInfo                                  = "messageInteractionInfo"
	TypeUnreadReaction                                          = "unreadReaction"
	TypeMessageEffectTypeEmojiReaction                          = "messageEffectTypeEmojiReaction"
	TypeMessageEffectTypePremiumSticker                         = "messageEffectTypePremiumSticker"
	TypeMessageEffect                                           = "messageEffect"
	TypeMessageSendingStatePending                              = "messageSendingStatePending"
	TypeMessageSendingStateFailed                               = "messageSendingStateFailed"
	TypeTextQuote                                               = "textQuote"
	TypeInputTextQuote                                          = "inputTextQuote"
	TypeMessageReplyToMessage                                   = "messageReplyToMessage"
	TypeMessageReplyToStory                                     = "messageReplyToStory"
	TypeInputMessageReplyToMessage                              = "inputMessageReplyToMessage"
	TypeInputMessageReplyToExternalMessage                      = "inputMessageReplyToExternalMessage"
	TypeInputMessageReplyToStory                                = "inputMessageReplyToStory"
	TypeFactCheck                                               = "factCheck"
	TypeMessage                                                 = "message"
	TypeMessages                                                = "messages"
	TypeFoundMessages                                           = "foundMessages"
	TypeFoundChatMessages                                       = "foundChatMessages"
	TypeMessagePosition                                         = "messagePosition"
	TypeMessagePositions                                        = "messagePositions"
	TypeMessageCalendarDay                                      = "messageCalendarDay"
	TypeMessageCalendar                                         = "messageCalendar"
	TypeBusinessMessage                                         = "businessMessage"
	TypeBusinessMessages                                        = "businessMessages"
	TypeMessageSourceChatHistory                                = "messageSourceChatHistory"
	TypeMessageSourceMessageThreadHistory                       = "messageSourceMessageThreadHistory"
	TypeMessageSourceForumTopicHistory                          = "messageSourceForumTopicHistory"
	TypeMessageSourceHistoryPreview                             = "messageSourceHistoryPreview"
	TypeMessageSourceChatList                                   = "messageSourceChatList"
	TypeMessageSourceSearch                                     = "messageSourceSearch"
	TypeMessageSourceChatEventLog                               = "messageSourceChatEventLog"
	TypeMessageSourceNotification                               = "messageSourceNotification"
	TypeMessageSourceScreenshot                                 = "messageSourceScreenshot"
	TypeMessageSourceOther                                      = "messageSourceOther"
	TypeMessageSponsor                                          = "messageSponsor"
	TypeSponsoredMessage                                        = "sponsoredMessage"
	TypeSponsoredMessages                                       = "sponsoredMessages"
	TypeReportOption                                            = "reportOption"
	TypeReportChatSponsoredMessageResultOk                      = "reportChatSponsoredMessageResultOk"
	TypeReportChatSponsoredMessageResultFailed                  = "reportChatSponsoredMessageResultFailed"
	TypeReportChatSponsoredMessageResultOptionRequired          = "reportChatSponsoredMessageResultOptionRequired"
	TypeReportChatSponsoredMessageResultAdsHidden               = "reportChatSponsoredMessageResultAdsHidden"
	TypeReportChatSponsoredMessageResultPremiumRequired         = "reportChatSponsoredMessageResultPremiumRequired"
	TypeFileDownload                                            = "fileDownload"
	TypeDownloadedFileCounts                                    = "downloadedFileCounts"
	TypeFoundFileDownloads                                      = "foundFileDownloads"
	TypeNotificationSettingsScopePrivateChats                   = "notificationSettingsScopePrivateChats"
	TypeNotificationSettingsScopeGroupChats                     = "notificationSettingsScopeGroupChats"
	TypeNotificationSettingsScopeChannelChats                   = "notificationSettingsScopeChannelChats"
	TypeChatNotificationSettings                                = "chatNotificationSettings"
	TypeScopeNotificationSettings                               = "scopeNotificationSettings"
	TypeReactionNotificationSourceNone                          = "reactionNotificationSourceNone"
	TypeReactionNotificationSourceContacts                      = "reactionNotificationSourceContacts"
	TypeReactionNotificationSourceAll                           = "reactionNotificationSourceAll"
	TypeReactionNotificationSettings                            = "reactionNotificationSettings"
	TypeDraftMessage                                            = "draftMessage"
	TypeChatTypePrivate                                         = "chatTypePrivate"
	TypeChatTypeBasicGroup                                      = "chatTypeBasicGroup"
	TypeChatTypeSupergroup                                      = "chatTypeSupergroup"
	TypeChatTypeSecret                                          = "chatTypeSecret"
	TypeChatFolderIcon                                          = "chatFolderIcon"
	TypeChatFolder                                              = "chatFolder"
	TypeChatFolderInfo                                          = "chatFolderInfo"
	TypeChatFolderInviteLink                                    = "chatFolderInviteLink"
	TypeChatFolderInviteLinks                                   = "chatFolderInviteLinks"
	TypeChatFolderInviteLinkInfo                                = "chatFolderInviteLinkInfo"
	TypeRecommendedChatFolder                                   = "recommendedChatFolder"
	TypeRecommendedChatFolders                                  = "recommendedChatFolders"
	TypeArchiveChatListSettings                                 = "archiveChatListSettings"
	TypeChatListMain                                            = "chatListMain"
	TypeChatListArchive                                         = "chatListArchive"
	TypeChatListFolder                                          = "chatListFolder"
	TypeChatLists                                               = "chatLists"
	TypeChatSourceMtprotoProxy                                  = "chatSourceMtprotoProxy"
	TypeChatSourcePublicServiceAnnouncement                     = "chatSourcePublicServiceAnnouncement"
	TypeChatPosition                                            = "chatPosition"
	TypeChatAvailableReactionsAll                               = "chatAvailableReactionsAll"
	TypeChatAvailableReactionsSome                              = "chatAvailableReactionsSome"
	TypeSavedMessagesTag                                        = "savedMessagesTag"
	TypeSavedMessagesTags                                       = "savedMessagesTags"
	TypeBusinessBotManageBar                                    = "businessBotManageBar"
	TypeVideoChat                                               = "videoChat"
	TypeChat                                                    = "chat"
	TypeChats                                                   = "chats"
	TypeFailedToAddMember                                       = "failedToAddMember"
	TypeFailedToAddMembers                                      = "failedToAddMembers"
	TypeCreatedBasicGroupChat                                   = "createdBasicGroupChat"
	TypePublicChatTypeHasUsername                               = "publicChatTypeHasUsername"
	TypePublicChatTypeIsLocationBased                           = "publicChatTypeIsLocationBased"
	TypeChatActionBarReportSpam                                 = "chatActionBarReportSpam"
	TypeChatActionBarInviteMembers                              = "chatActionBarInviteMembers"
	TypeChatActionBarReportAddBlock                             = "chatActionBarReportAddBlock"
	TypeChatActionBarAddContact                                 = "chatActionBarAddContact"
	TypeChatActionBarSharePhoneNumber                           = "chatActionBarSharePhoneNumber"
	TypeChatActionBarJoinRequest                                = "chatActionBarJoinRequest"
	TypeKeyboardButtonTypeText                                  = "keyboardButtonTypeText"
	TypeKeyboardButtonTypeRequestPhoneNumber                    = "keyboardButtonTypeRequestPhoneNumber"
	TypeKeyboardButtonTypeRequestLocation                       = "keyboardButtonTypeRequestLocation"
	TypeKeyboardButtonTypeRequestPoll                           = "keyboardButtonTypeRequestPoll"
	TypeKeyboardButtonTypeRequestUsers                          = "keyboardButtonTypeRequestUsers"
	TypeKeyboardButtonTypeRequestChat                           = "keyboardButtonTypeRequestChat"
	TypeKeyboardButtonTypeWebApp                                = "keyboardButtonTypeWebApp"
	TypeKeyboardButton                                          = "keyboardButton"
	TypeInlineKeyboardButtonTypeUrl                             = "inlineKeyboardButtonTypeUrl"
	TypeInlineKeyboardButtonTypeLoginUrl                        = "inlineKeyboardButtonTypeLoginUrl"
	TypeInlineKeyboardButtonTypeWebApp                          = "inlineKeyboardButtonTypeWebApp"
	TypeInlineKeyboardButtonTypeCallback                        = "inlineKeyboardButtonTypeCallback"
	TypeInlineKeyboardButtonTypeCallbackWithPassword            = "inlineKeyboardButtonTypeCallbackWithPassword"
	TypeInlineKeyboardButtonTypeCallbackGame                    = "inlineKeyboardButtonTypeCallbackGame"
	TypeInlineKeyboardButtonTypeSwitchInline                    = "inlineKeyboardButtonTypeSwitchInline"
	TypeInlineKeyboardButtonTypeBuy                             = "inlineKeyboardButtonTypeBuy"
	TypeInlineKeyboardButtonTypeUser                            = "inlineKeyboardButtonTypeUser"
	TypeInlineKeyboardButtonTypeCopyText                        = "inlineKeyboardButtonTypeCopyText"
	TypeInlineKeyboardButton                                    = "inlineKeyboardButton"
	TypeReplyMarkupRemoveKeyboard                               = "replyMarkupRemoveKeyboard"
	TypeReplyMarkupForceReply                                   = "replyMarkupForceReply"
	TypeReplyMarkupShowKeyboard                                 = "replyMarkupShowKeyboard"
	TypeReplyMarkupInlineKeyboard                               = "replyMarkupInlineKeyboard"
	TypeLoginUrlInfoOpen                                        = "loginUrlInfoOpen"
	TypeLoginUrlInfoRequestConfirmation                         = "loginUrlInfoRequestConfirmation"
	TypeThemeParameters                                         = "themeParameters"
	TypeWebAppOpenModeCompact                                   = "webAppOpenModeCompact"
	TypeWebAppOpenModeFullSize                                  = "webAppOpenModeFullSize"
	TypeWebAppOpenModeFullScreen                                = "webAppOpenModeFullScreen"
	TypeFoundWebApp                                             = "foundWebApp"
	TypeWebAppInfo                                              = "webAppInfo"
	TypeMainWebApp                                              = "mainWebApp"
	TypeWebAppOpenParameters                                    = "webAppOpenParameters"
	TypeMessageThreadInfo                                       = "messageThreadInfo"
	TypeSavedMessagesTopicTypeMyNotes                           = "savedMessagesTopicTypeMyNotes"
	TypeSavedMessagesTopicTypeAuthorHidden                      = "savedMessagesTopicTypeAuthorHidden"
	TypeSavedMessagesTopicTypeSavedFromChat                     = "savedMessagesTopicTypeSavedFromChat"
	TypeSavedMessagesTopic                                      = "savedMessagesTopic"
	TypeForumTopicIcon                                          = "forumTopicIcon"
	TypeForumTopicInfo                                          = "forumTopicInfo"
	TypeForumTopic                                              = "forumTopic"
	TypeForumTopics                                             = "forumTopics"
	TypeLinkPreviewOptions                                      = "linkPreviewOptions"
	TypeSharedUser                                              = "sharedUser"
	TypeSharedChat                                              = "sharedChat"
	TypeThemeSettings                                           = "themeSettings"
	TypeRichTextPlain                                           = "richTextPlain"
	TypeRichTextBold                                            = "richTextBold"
	TypeRichTextItalic                                          = "richTextItalic"
	TypeRichTextUnderline                                       = "richTextUnderline"
	TypeRichTextStrikethrough                                   = "richTextStrikethrough"
	TypeRichTextFixed                                           = "richTextFixed"
	TypeRichTextUrl                                             = "richTextUrl"
	TypeRichTextEmailAddress                                    = "richTextEmailAddress"
	TypeRichTextSubscript                                       = "richTextSubscript"
	TypeRichTextSuperscript                                     = "richTextSuperscript"
	TypeRichTextMarked                                          = "richTextMarked"
	TypeRichTextPhoneNumber                                     = "richTextPhoneNumber"
	TypeRichTextIcon                                            = "richTextIcon"
	TypeRichTextReference                                       = "richTextReference"
	TypeRichTextAnchor                                          = "richTextAnchor"
	TypeRichTextAnchorLink                                      = "richTextAnchorLink"
	TypeRichTexts                                               = "richTexts"
	TypePageBlockCaption                                        = "pageBlockCaption"
	TypePageBlockListItem                                       = "pageBlockListItem"
	TypePageBlockHorizontalAlignmentLeft                        = "pageBlockHorizontalAlignmentLeft"
	TypePageBlockHorizontalAlignmentCenter                      = "pageBlockHorizontalAlignmentCenter"
	TypePageBlockHorizontalAlignmentRight                       = "pageBlockHorizontalAlignmentRight"
	TypePageBlockVerticalAlignmentTop                           = "pageBlockVerticalAlignmentTop"
	TypePageBlockVerticalAlignmentMiddle                        = "pageBlockVerticalAlignmentMiddle"
	TypePageBlockVerticalAlignmentBottom                        = "pageBlockVerticalAlignmentBottom"
	TypePageBlockTableCell                                      = "pageBlockTableCell"
	TypePageBlockRelatedArticle                                 = "pageBlockRelatedArticle"
	TypePageBlockTitle                                          = "pageBlockTitle"
	TypePageBlockSubtitle                                       = "pageBlockSubtitle"
	TypePageBlockAuthorDate                                     = "pageBlockAuthorDate"
	TypePageBlockHeader                                         = "pageBlockHeader"
	TypePageBlockSubheader                                      = "pageBlockSubheader"
	TypePageBlockKicker                                         = "pageBlockKicker"
	TypePageBlockParagraph                                      = "pageBlockParagraph"
	TypePageBlockPreformatted                                   = "pageBlockPreformatted"
	TypePageBlockFooter                                         = "pageBlockFooter"
	TypePageBlockDivider                                        = "pageBlockDivider"
	TypePageBlockAnchor                                         = "pageBlockAnchor"
	TypePageBlockList                                           = "pageBlockList"
	TypePageBlockBlockQuote                                     = "pageBlockBlockQuote"
	TypePageBlockPullQuote                                      = "pageBlockPullQuote"
	TypePageBlockAnimation                                      = "pageBlockAnimation"
	TypePageBlockAudio                                          = "pageBlockAudio"
	TypePageBlockPhoto                                          = "pageBlockPhoto"
	TypePageBlockVideo                                          = "pageBlockVideo"
	TypePageBlockVoiceNote                                      = "pageBlockVoiceNote"
	TypePageBlockCover                                          = "pageBlockCover"
	TypePageBlockEmbedded                                       = "pageBlockEmbedded"
	TypePageBlockEmbeddedPost                                   = "pageBlockEmbeddedPost"
	TypePageBlockCollage                                        = "pageBlockCollage"
	TypePageBlockSlideshow                                      = "pageBlockSlideshow"
	TypePageBlockChatLink                                       = "pageBlockChatLink"
	TypePageBlockTable                                          = "pageBlockTable"
	TypePageBlockDetails                                        = "pageBlockDetails"
	TypePageBlockRelatedArticles                                = "pageBlockRelatedArticles"
	TypePageBlockMap                                            = "pageBlockMap"
	TypeWebPageInstantView                                      = "webPageInstantView"
	TypeLinkPreviewAlbumMediaPhoto                              = "linkPreviewAlbumMediaPhoto"
	TypeLinkPreviewAlbumMediaVideo                              = "linkPreviewAlbumMediaVideo"
	TypeLinkPreviewTypeAlbum                                    = "linkPreviewTypeAlbum"
	TypeLinkPreviewTypeAnimation                                = "linkPreviewTypeAnimation"
	TypeLinkPreviewTypeApp                                      = "linkPreviewTypeApp"
	TypeLinkPreviewTypeArticle                                  = "linkPreviewTypeArticle"
	TypeLinkPreviewTypeAudio                                    = "linkPreviewTypeAudio"
	TypeLinkPreviewTypeBackground                               = "linkPreviewTypeBackground"
	TypeLinkPreviewTypeChannelBoost                             = "linkPreviewTypeChannelBoost"
	TypeLinkPreviewTypeChat                                     = "linkPreviewTypeChat"
	TypeLinkPreviewTypeDocument                                 = "linkPreviewTypeDocument"
	TypeLinkPreviewTypeEmbeddedAnimationPlayer                  = "linkPreviewTypeEmbeddedAnimationPlayer"
	TypeLinkPreviewTypeEmbeddedAudioPlayer                      = "linkPreviewTypeEmbeddedAudioPlayer"
	TypeLinkPreviewTypeEmbeddedVideoPlayer                      = "linkPreviewTypeEmbeddedVideoPlayer"
	TypeLinkPreviewTypeExternalAudio                            = "linkPreviewTypeExternalAudio"
	TypeLinkPreviewTypeExternalVideo                            = "linkPreviewTypeExternalVideo"
	TypeLinkPreviewTypeInvoice                                  = "linkPreviewTypeInvoice"
	TypeLinkPreviewTypeMessage                                  = "linkPreviewTypeMessage"
	TypeLinkPreviewTypePhoto                                    = "linkPreviewTypePhoto"
	TypeLinkPreviewTypePremiumGiftCode                          = "linkPreviewTypePremiumGiftCode"
	TypeLinkPreviewTypeShareableChatFolder                      = "linkPreviewTypeShareableChatFolder"
	TypeLinkPreviewTypeSticker                                  = "linkPreviewTypeSticker"
	TypeLinkPreviewTypeStickerSet                               = "linkPreviewTypeStickerSet"
	TypeLinkPreviewTypeStory                                    = "linkPreviewTypeStory"
	TypeLinkPreviewTypeSupergroupBoost                          = "linkPreviewTypeSupergroupBoost"
	TypeLinkPreviewTypeTheme                                    = "linkPreviewTypeTheme"
	TypeLinkPreviewTypeUnsupported                              = "linkPreviewTypeUnsupported"
	TypeLinkPreviewTypeUser                                     = "linkPreviewTypeUser"
	TypeLinkPreviewTypeVideo                                    = "linkPreviewTypeVideo"
	TypeLinkPreviewTypeVideoChat                                = "linkPreviewTypeVideoChat"
	TypeLinkPreviewTypeVideoNote                                = "linkPreviewTypeVideoNote"
	TypeLinkPreviewTypeVoiceNote                                = "linkPreviewTypeVoiceNote"
	TypeLinkPreviewTypeWebApp                                   = "linkPreviewTypeWebApp"
	TypeLinkPreview                                             = "linkPreview"
	TypeCountryInfo                                             = "countryInfo"
	TypeCountries                                               = "countries"
	TypePhoneNumberInfo                                         = "phoneNumberInfo"
	TypeCollectibleItemTypeUsername                             = "collectibleItemTypeUsername"
	TypeCollectibleItemTypePhoneNumber                          = "collectibleItemTypePhoneNumber"
	TypeCollectibleItemInfo                                     = "collectibleItemInfo"
	TypeBankCardActionOpenUrl                                   = "bankCardActionOpenUrl"
	TypeBankCardInfo                                            = "bankCardInfo"
	TypeAddress                                                 = "address"
	TypeLocationAddress                                         = "locationAddress"
	TypeLabeledPricePart                                        = "labeledPricePart"
	TypeInvoice                                                 = "invoice"
	TypeOrderInfo                                               = "orderInfo"
	TypeShippingOption                                          = "shippingOption"
	TypeSavedCredentials                                        = "savedCredentials"
	TypeInputCredentialsSaved                                   = "inputCredentialsSaved"
	TypeInputCredentialsNew                                     = "inputCredentialsNew"
	TypeInputCredentialsApplePay                                = "inputCredentialsApplePay"
	TypeInputCredentialsGooglePay                               = "inputCredentialsGooglePay"
	TypePaymentProviderSmartGlocal                              = "paymentProviderSmartGlocal"
	TypePaymentProviderStripe                                   = "paymentProviderStripe"
	TypePaymentProviderOther                                    = "paymentProviderOther"
	TypePaymentOption                                           = "paymentOption"
	TypePaymentFormTypeRegular                                  = "paymentFormTypeRegular"
	TypePaymentFormTypeStars                                    = "paymentFormTypeStars"
	TypePaymentFormTypeStarSubscription                         = "paymentFormTypeStarSubscription"
	TypePaymentForm                                             = "paymentForm"
	TypeValidatedOrderInfo                                      = "validatedOrderInfo"
	TypePaymentResult                                           = "paymentResult"
	TypePaymentReceiptTypeRegular                               = "paymentReceiptTypeRegular"
	TypePaymentReceiptTypeStars                                 = "paymentReceiptTypeStars"
	TypePaymentReceipt                                          = "paymentReceipt"
	TypeInputInvoiceMessage                                     = "inputInvoiceMessage"
	TypeInputInvoiceName                                        = "inputInvoiceName"
	TypeInputInvoiceTelegram                                    = "inputInvoiceTelegram"
	TypePaidMediaPreview                                        = "paidMediaPreview"
	TypePaidMediaPhoto                                          = "paidMediaPhoto"
	TypePaidMediaVideo                                          = "paidMediaVideo"
	TypePaidMediaUnsupported                                    = "paidMediaUnsupported"
	TypeGiveawayParameters                                      = "giveawayParameters"
	TypeDatedFile                                               = "datedFile"
	TypePassportElementTypePersonalDetails                      = "passportElementTypePersonalDetails"
	TypePassportElementTypePassport                             = "passportElementTypePassport"
	TypePassportElementTypeDriverLicense                        = "passportElementTypeDriverLicense"
	TypePassportElementTypeIdentityCard                         = "passportElementTypeIdentityCard"
	TypePassportElementTypeInternalPassport                     = "passportElementTypeInternalPassport"
	TypePassportElementTypeAddress                              = "passportElementTypeAddress"
	TypePassportElementTypeUtilityBill                          = "passportElementTypeUtilityBill"
	TypePassportElementTypeBankStatement                        = "passportElementTypeBankStatement"
	TypePassportElementTypeRentalAgreement                      = "passportElementTypeRentalAgreement"
	TypePassportElementTypePassportRegistration                 = "passportElementTypePassportRegistration"
	TypePassportElementTypeTemporaryRegistration                = "passportElementTypeTemporaryRegistration"
	TypePassportElementTypePhoneNumber                          = "passportElementTypePhoneNumber"
	TypePassportElementTypeEmailAddress                         = "passportElementTypeEmailAddress"
	TypeDate                                                    = "date"
	TypePersonalDetails                                         = "personalDetails"
	TypeIdentityDocument                                        = "identityDocument"
	TypeInputIdentityDocument                                   = "inputIdentityDocument"
	TypePersonalDocument                                        = "personalDocument"
	TypeInputPersonalDocument                                   = "inputPersonalDocument"
	TypePassportElementPersonalDetails                          = "passportElementPersonalDetails"
	TypePassportElementPassport                                 = "passportElementPassport"
	TypePassportElementDriverLicense                            = "passportElementDriverLicense"
	TypePassportElementIdentityCard                             = "passportElementIdentityCard"
	TypePassportElementInternalPassport                         = "passportElementInternalPassport"
	TypePassportElementAddress                                  = "passportElementAddress"
	TypePassportElementUtilityBill                              = "passportElementUtilityBill"
	TypePassportElementBankStatement                            = "passportElementBankStatement"
	TypePassportElementRentalAgreement                          = "passportElementRentalAgreement"
	TypePassportElementPassportRegistration                     = "passportElementPassportRegistration"
	TypePassportElementTemporaryRegistration                    = "passportElementTemporaryRegistration"
	TypePassportElementPhoneNumber                              = "passportElementPhoneNumber"
	TypePassportElementEmailAddress                             = "passportElementEmailAddress"
	TypeInputPassportElementPersonalDetails                     = "inputPassportElementPersonalDetails"
	TypeInputPassportElementPassport                            = "inputPassportElementPassport"
	TypeInputPassportElementDriverLicense                       = "inputPassportElementDriverLicense"
	TypeInputPassportElementIdentityCard                        = "inputPassportElementIdentityCard"
	TypeInputPassportElementInternalPassport                    = "inputPassportElementInternalPassport"
	TypeInputPassportElementAddress                             = "inputPassportElementAddress"
	TypeInputPassportElementUtilityBill                         = "inputPassportElementUtilityBill"
	TypeInputPassportElementBankStatement                       = "inputPassportElementBankStatement"
	TypeInputPassportElementRentalAgreement                     = "inputPassportElementRentalAgreement"
	TypeInputPassportElementPassportRegistration                = "inputPassportElementPassportRegistration"
	TypeInputPassportElementTemporaryRegistration               = "inputPassportElementTemporaryRegistration"
	TypeInputPassportElementPhoneNumber                         = "inputPassportElementPhoneNumber"
	TypeInputPassportElementEmailAddress                        = "inputPassportElementEmailAddress"
	TypePassportElements                                        = "passportElements"
	TypePassportElementErrorSourceUnspecified                   = "passportElementErrorSourceUnspecified"
	TypePassportElementErrorSourceDataField                     = "passportElementErrorSourceDataField"
	TypePassportElementErrorSourceFrontSide                     = "passportElementErrorSourceFrontSide"
	TypePassportElementErrorSourceReverseSide                   = "passportElementErrorSourceReverseSide"
	TypePassportElementErrorSourceSelfie                        = "passportElementErrorSourceSelfie"
	TypePassportElementErrorSourceTranslationFile               = "passportElementErrorSourceTranslationFile"
	TypePassportElementErrorSourceTranslationFiles              = "passportElementErrorSourceTranslationFiles"
	TypePassportElementErrorSourceFile                          = "passportElementErrorSourceFile"
	TypePassportElementErrorSourceFiles                         = "passportElementErrorSourceFiles"
	TypePassportElementError                                    = "passportElementError"
	TypePassportSuitableElement                                 = "passportSuitableElement"
	TypePassportRequiredElement                                 = "passportRequiredElement"
	TypePassportAuthorizationForm                               = "passportAuthorizationForm"
	TypePassportElementsWithErrors                              = "passportElementsWithErrors"
	TypeEncryptedCredentials                                    = "encryptedCredentials"
	TypeEncryptedPassportElement                                = "encryptedPassportElement"
	TypeInputPassportElementErrorSourceUnspecified              = "inputPassportElementErrorSourceUnspecified"
	TypeInputPassportElementErrorSourceDataField                = "inputPassportElementErrorSourceDataField"
	TypeInputPassportElementErrorSourceFrontSide                = "inputPassportElementErrorSourceFrontSide"
	TypeInputPassportElementErrorSourceReverseSide              = "inputPassportElementErrorSourceReverseSide"
	TypeInputPassportElementErrorSourceSelfie                   = "inputPassportElementErrorSourceSelfie"
	TypeInputPassportElementErrorSourceTranslationFile          = "inputPassportElementErrorSourceTranslationFile"
	TypeInputPassportElementErrorSourceTranslationFiles         = "inputPassportElementErrorSourceTranslationFiles"
	TypeInputPassportElementErrorSourceFile                     = "inputPassportElementErrorSourceFile"
	TypeInputPassportElementErrorSourceFiles                    = "inputPassportElementErrorSourceFiles"
	TypeInputPassportElementError                               = "inputPassportElementError"
	TypeMessageText                                             = "messageText"
	TypeMessageAnimation                                        = "messageAnimation"
	TypeMessageAudio                                            = "messageAudio"
	TypeMessageDocument                                         = "messageDocument"
	TypeMessagePaidMedia                                        = "messagePaidMedia"
	TypeMessagePhoto                                            = "messagePhoto"
	TypeMessageSticker                                          = "messageSticker"
	TypeMessageVideo                                            = "messageVideo"
	TypeMessageVideoNote                                        = "messageVideoNote"
	TypeMessageVoiceNote                                        = "messageVoiceNote"
	TypeMessageExpiredPhoto                                     = "messageExpiredPhoto"
	TypeMessageExpiredVideo                                     = "messageExpiredVideo"
	TypeMessageExpiredVideoNote                                 = "messageExpiredVideoNote"
	TypeMessageExpiredVoiceNote                                 = "messageExpiredVoiceNote"
	TypeMessageLocation                                         = "messageLocation"
	TypeMessageVenue                                            = "messageVenue"
	TypeMessageContact                                          = "messageContact"
	TypeMessageAnimatedEmoji                                    = "messageAnimatedEmoji"
	TypeMessageDice                                             = "messageDice"
	TypeMessageGame                                             = "messageGame"
	TypeMessagePoll                                             = "messagePoll"
	TypeMessageStory                                            = "messageStory"
	TypeMessageInvoice                                          = "messageInvoice"
	TypeMessageCall                                             = "messageCall"
	TypeMessageVideoChatScheduled                               = "messageVideoChatScheduled"
	TypeMessageVideoChatStarted                                 = "messageVideoChatStarted"
	TypeMessageVideoChatEnded                                   = "messageVideoChatEnded"
	TypeMessageInviteVideoChatParticipants                      = "messageInviteVideoChatParticipants"
	TypeMessageBasicGroupChatCreate                             = "messageBasicGroupChatCreate"
	TypeMessageSupergroupChatCreate                             = "messageSupergroupChatCreate"
	TypeMessageChatChangeTitle                                  = "messageChatChangeTitle"
	TypeMessageChatChangePhoto                                  = "messageChatChangePhoto"
	TypeMessageChatDeletePhoto                                  = "messageChatDeletePhoto"
	TypeMessageChatAddMembers                                   = "messageChatAddMembers"
	TypeMessageChatJoinByLink                                   = "messageChatJoinByLink"
	TypeMessageChatJoinByRequest                                = "messageChatJoinByRequest"
	TypeMessageChatDeleteMember                                 = "messageChatDeleteMember"
	TypeMessageChatUpgradeTo                                    = "messageChatUpgradeTo"
	TypeMessageChatUpgradeFrom                                  = "messageChatUpgradeFrom"
	TypeMessagePinMessage                                       = "messagePinMessage"
	TypeMessageScreenshotTaken                                  = "messageScreenshotTaken"
	TypeMessageChatSetBackground                                = "messageChatSetBackground"
	TypeMessageChatSetTheme                                     = "messageChatSetTheme"
	TypeMessageChatSetMessageAutoDeleteTime                     = "messageChatSetMessageAutoDeleteTime"
	TypeMessageChatBoost                                        = "messageChatBoost"
	TypeMessageForumTopicCreated                                = "messageForumTopicCreated"
	TypeMessageForumTopicEdited                                 = "messageForumTopicEdited"
	TypeMessageForumTopicIsClosedToggled                        = "messageForumTopicIsClosedToggled"
	TypeMessageForumTopicIsHiddenToggled                        = "messageForumTopicIsHiddenToggled"
	TypeMessageSuggestProfilePhoto                              = "messageSuggestProfilePhoto"
	TypeMessageCustomServiceAction                              = "messageCustomServiceAction"
	TypeMessageGameScore                                        = "messageGameScore"
	TypeMessagePaymentSuccessful                                = "messagePaymentSuccessful"
	TypeMessagePaymentSuccessfulBot                             = "messagePaymentSuccessfulBot"
	TypeMessagePaymentRefunded                                  = "messagePaymentRefunded"
	TypeMessageGiftedPremium                                    = "messageGiftedPremium"
	TypeMessagePremiumGiftCode                                  = "messagePremiumGiftCode"
	TypeMessageGiveawayCreated                                  = "messageGiveawayCreated"
	TypeMessageGiveaway                                         = "messageGiveaway"
	TypeMessageGiveawayCompleted                                = "messageGiveawayCompleted"
	TypeMessageGiveawayWinners                                  = "messageGiveawayWinners"
	TypeMessageGiftedStars                                      = "messageGiftedStars"
	TypeMessageGiveawayPrizeStars                               = "messageGiveawayPrizeStars"
	TypeMessageGift                                             = "messageGift"
	TypeMessageContactRegistered                                = "messageContactRegistered"
	TypeMessageUsersShared                                      = "messageUsersShared"
	TypeMessageChatShared                                       = "messageChatShared"
	TypeMessageBotWriteAccessAllowed                            = "messageBotWriteAccessAllowed"
	TypeMessageWebAppDataSent                                   = "messageWebAppDataSent"
	TypeMessageWebAppDataReceived                               = "messageWebAppDataReceived"
	TypeMessagePassportDataSent                                 = "messagePassportDataSent"
	TypeMessagePassportDataReceived                             = "messagePassportDataReceived"
	TypeMessageProximityAlertTriggered                          = "messageProximityAlertTriggered"
	TypeMessageUnsupported                                      = "messageUnsupported"
	TypeTextEntityTypeMention                                   = "textEntityTypeMention"
	TypeTextEntityTypeHashtag                                   = "textEntityTypeHashtag"
	TypeTextEntityTypeCashtag                                   = "textEntityTypeCashtag"
	TypeTextEntityTypeBotCommand                                = "textEntityTypeBotCommand"
	TypeTextEntityTypeUrl                                       = "textEntityTypeUrl"
	TypeTextEntityTypeEmailAddress                              = "textEntityTypeEmailAddress"
	TypeTextEntityTypePhoneNumber                               = "textEntityTypePhoneNumber"
	TypeTextEntityTypeBankCardNumber                            = "textEntityTypeBankCardNumber"
	TypeTextEntityTypeBold                                      = "textEntityTypeBold"
	TypeTextEntityTypeItalic                                    = "textEntityTypeItalic"
	TypeTextEntityTypeUnderline                                 = "textEntityTypeUnderline"
	TypeTextEntityTypeStrikethrough                             = "textEntityTypeStrikethrough"
	TypeTextEntityTypeSpoiler                                   = "textEntityTypeSpoiler"
	TypeTextEntityTypeCode                                      = "textEntityTypeCode"
	TypeTextEntityTypePre                                       = "textEntityTypePre"
	TypeTextEntityTypePreCode                                   = "textEntityTypePreCode"
	TypeTextEntityTypeBlockQuote                                = "textEntityTypeBlockQuote"
	TypeTextEntityTypeExpandableBlockQuote                      = "textEntityTypeExpandableBlockQuote"
	TypeTextEntityTypeTextUrl                                   = "textEntityTypeTextUrl"
	TypeTextEntityTypeMentionName                               = "textEntityTypeMentionName"
	TypeTextEntityTypeCustomEmoji                               = "textEntityTypeCustomEmoji"
	TypeTextEntityTypeMediaTimestamp                            = "textEntityTypeMediaTimestamp"
	TypeInputThumbnail                                          = "inputThumbnail"
	TypeInputPaidMediaTypePhoto                                 = "inputPaidMediaTypePhoto"
	TypeInputPaidMediaTypeVideo                                 = "inputPaidMediaTypeVideo"
	TypeInputPaidMedia                                          = "inputPaidMedia"
	TypeMessageSchedulingStateSendAtDate                        = "messageSchedulingStateSendAtDate"
	TypeMessageSchedulingStateSendWhenOnline                    = "messageSchedulingStateSendWhenOnline"
	TypeMessageSchedulingStateSendWhenVideoProcessed            = "messageSchedulingStateSendWhenVideoProcessed"
	TypeMessageSelfDestructTypeTimer                            = "messageSelfDestructTypeTimer"
	TypeMessageSelfDestructTypeImmediately                      = "messageSelfDestructTypeImmediately"
	TypeMessageSendOptions                                      = "messageSendOptions"
	TypeMessageCopyOptions                                      = "messageCopyOptions"
	TypeInputMessageText                                        = "inputMessageText"
	TypeInputMessageAnimation                                   = "inputMessageAnimation"
	TypeInputMessageAudio                                       = "inputMessageAudio"
	TypeInputMessageDocument                                    = "inputMessageDocument"
	TypeInputMessagePaidMedia                                   = "inputMessagePaidMedia"
	TypeInputMessagePhoto                                       = "inputMessagePhoto"
	TypeInputMessageSticker                                     = "inputMessageSticker"
	TypeInputMessageVideo                                       = "inputMessageVideo"
	TypeInputMessageVideoNote                                   = "inputMessageVideoNote"
	TypeInputMessageVoiceNote                                   = "inputMessageVoiceNote"
	TypeInputMessageLocation                                    = "inputMessageLocation"
	TypeInputMessageVenue                                       = "inputMessageVenue"
	TypeInputMessageContact                                     = "inputMessageContact"
	TypeInputMessageDice                                        = "inputMessageDice"
	TypeInputMessageGame                                        = "inputMessageGame"
	TypeInputMessageInvoice                                     = "inputMessageInvoice"
	TypeInputMessagePoll                                        = "inputMessagePoll"
	TypeInputMessageStory                                       = "inputMessageStory"
	TypeInputMessageForwarded                                   = "inputMessageForwarded"
	TypeMessageProperties                                       = "messageProperties"
	TypeSearchMessagesFilterEmpty                               = "searchMessagesFilterEmpty"
	TypeSearchMessagesFilterAnimation                           = "searchMessagesFilterAnimation"
	TypeSearchMessagesFilterAudio                               = "searchMessagesFilterAudio"
	TypeSearchMessagesFilterDocument                            = "searchMessagesFilterDocument"
	TypeSearchMessagesFilterPhoto                               = "searchMessagesFilterPhoto"
	TypeSearchMessagesFilterVideo                               = "searchMessagesFilterVideo"
	TypeSearchMessagesFilterVoiceNote                           = "searchMessagesFilterVoiceNote"
	TypeSearchMessagesFilterPhotoAndVideo                       = "searchMessagesFilterPhotoAndVideo"
	TypeSearchMessagesFilterUrl                                 = "searchMessagesFilterUrl"
	TypeSearchMessagesFilterChatPhoto                           = "searchMessagesFilterChatPhoto"
	TypeSearchMessagesFilterVideoNote                           = "searchMessagesFilterVideoNote"
	TypeSearchMessagesFilterVoiceAndVideoNote                   = "searchMessagesFilterVoiceAndVideoNote"
	TypeSearchMessagesFilterMention                             = "searchMessagesFilterMention"
	TypeSearchMessagesFilterUnreadMention                       = "searchMessagesFilterUnreadMention"
	TypeSearchMessagesFilterUnreadReaction                      = "searchMessagesFilterUnreadReaction"
	TypeSearchMessagesFilterFailedToSend                        = "searchMessagesFilterFailedToSend"
	TypeSearchMessagesFilterPinned                              = "searchMessagesFilterPinned"
	TypeChatActionTyping                                        = "chatActionTyping"
	TypeChatActionRecordingVideo                                = "chatActionRecordingVideo"
	TypeChatActionUploadingVideo                                = "chatActionUploadingVideo"
	TypeChatActionRecordingVoiceNote                            = "chatActionRecordingVoiceNote"
	TypeChatActionUploadingVoiceNote                            = "chatActionUploadingVoiceNote"
	TypeChatActionUploadingPhoto                                = "chatActionUploadingPhoto"
	TypeChatActionUploadingDocument                             = "chatActionUploadingDocument"
	TypeChatActionChoosingSticker                               = "chatActionChoosingSticker"
	TypeChatActionChoosingLocation                              = "chatActionChoosingLocation"
	TypeChatActionChoosingContact                               = "chatActionChoosingContact"
	TypeChatActionStartPlayingGame                              = "chatActionStartPlayingGame"
	TypeChatActionRecordingVideoNote                            = "chatActionRecordingVideoNote"
	TypeChatActionUploadingVideoNote                            = "chatActionUploadingVideoNote"
	TypeChatActionWatchingAnimations                            = "chatActionWatchingAnimations"
	TypeChatActionCancel                                        = "chatActionCancel"
	TypeUserStatusEmpty                                         = "userStatusEmpty"
	TypeUserStatusOnline                                        = "userStatusOnline"
	TypeUserStatusOffline                                       = "userStatusOffline"
	TypeUserStatusRecently                                      = "userStatusRecently"
	TypeUserStatusLastWeek                                      = "userStatusLastWeek"
	TypeUserStatusLastMonth                                     = "userStatusLastMonth"
	TypeEmojiKeyword                                            = "emojiKeyword"
	TypeEmojiKeywords                                           = "emojiKeywords"
	TypeStickers                                                = "stickers"
	TypeEmojis                                                  = "emojis"
	TypeStickerSet                                              = "stickerSet"
	TypeStickerSetInfo                                          = "stickerSetInfo"
	TypeStickerSets                                             = "stickerSets"
	TypeTrendingStickerSets                                     = "trendingStickerSets"
	TypeEmojiCategorySourceSearch                               = "emojiCategorySourceSearch"
	TypeEmojiCategorySourcePremium                              = "emojiCategorySourcePremium"
	TypeEmojiCategory                                           = "emojiCategory"
	TypeEmojiCategories                                         = "emojiCategories"
	TypeEmojiCategoryTypeDefault                                = "emojiCategoryTypeDefault"
	TypeEmojiCategoryTypeRegularStickers                        = "emojiCategoryTypeRegularStickers"
	TypeEmojiCategoryTypeEmojiStatus                            = "emojiCategoryTypeEmojiStatus"
	TypeEmojiCategoryTypeChatPhoto                              = "emojiCategoryTypeChatPhoto"
	TypeCurrentWeather                                          = "currentWeather"
	TypeStoryAreaPosition                                       = "storyAreaPosition"
	TypeStoryAreaTypeLocation                                   = "storyAreaTypeLocation"
	TypeStoryAreaTypeVenue                                      = "storyAreaTypeVenue"
	TypeStoryAreaTypeSuggestedReaction                          = "storyAreaTypeSuggestedReaction"
	TypeStoryAreaTypeMessage                                    = "storyAreaTypeMessage"
	TypeStoryAreaTypeLink                                       = "storyAreaTypeLink"
	TypeStoryAreaTypeWeather                                    = "storyAreaTypeWeather"
	TypeStoryArea                                               = "storyArea"
	TypeInputStoryAreaTypeLocation                              = "inputStoryAreaTypeLocation"
	TypeInputStoryAreaTypeFoundVenue                            = "inputStoryAreaTypeFoundVenue"
	TypeInputStoryAreaTypePreviousVenue                         = "inputStoryAreaTypePreviousVenue"
	TypeInputStoryAreaTypeSuggestedReaction                     = "inputStoryAreaTypeSuggestedReaction"
	TypeInputStoryAreaTypeMessage                               = "inputStoryAreaTypeMessage"
	TypeInputStoryAreaTypeLink                                  = "inputStoryAreaTypeLink"
	TypeInputStoryAreaTypeWeather                               = "inputStoryAreaTypeWeather"
	TypeInputStoryArea                                          = "inputStoryArea"
	TypeInputStoryAreas                                         = "inputStoryAreas"
	TypeStoryVideo                                              = "storyVideo"
	TypeStoryContentPhoto                                       = "storyContentPhoto"
	TypeStoryContentVideo                                       = "storyContentVideo"
	TypeStoryContentUnsupported                                 = "storyContentUnsupported"
	TypeInputStoryContentPhoto                                  = "inputStoryContentPhoto"
	TypeInputStoryContentVideo                                  = "inputStoryContentVideo"
	TypeStoryListMain                                           = "storyListMain"
	TypeStoryListArchive                                        = "storyListArchive"
	TypeStoryOriginPublicStory                                  = "storyOriginPublicStory"
	TypeStoryOriginHiddenUser                                   = "storyOriginHiddenUser"
	TypeStoryRepostInfo                                         = "storyRepostInfo"
	TypeStoryInteractionInfo                                    = "storyInteractionInfo"
	TypeStory                                                   = "story"
	TypeStories                                                 = "stories"
	TypeFoundStories                                            = "foundStories"
	TypeStoryFullId                                             = "storyFullId"
	TypeStoryInfo                                               = "storyInfo"
	TypeChatActiveStories                                       = "chatActiveStories"
	TypeStoryInteractionTypeView                                = "storyInteractionTypeView"
	TypeStoryInteractionTypeForward                             = "storyInteractionTypeForward"
	TypeStoryInteractionTypeRepost                              = "storyInteractionTypeRepost"
	TypeStoryInteraction                                        = "storyInteraction"
	TypeStoryInteractions                                       = "storyInteractions"
	TypeQuickReplyMessage                                       = "quickReplyMessage"
	TypeQuickReplyMessages                                      = "quickReplyMessages"
	TypeQuickReplyShortcut                                      = "quickReplyShortcut"
	TypePublicForwardMessage                                    = "publicForwardMessage"
	TypePublicForwardStory                                      = "publicForwardStory"
	TypePublicForwards                                          = "publicForwards"
	TypeBotMediaPreview                                         = "botMediaPreview"
	TypeBotMediaPreviews                                        = "botMediaPreviews"
	TypeBotMediaPreviewInfo                                     = "botMediaPreviewInfo"
	TypeChatBoostLevelFeatures                                  = "chatBoostLevelFeatures"
	TypeChatBoostFeatures                                       = "chatBoostFeatures"
	TypeChatBoostSourceGiftCode                                 = "chatBoostSourceGiftCode"
	TypeChatBoostSourceGiveaway                                 = "chatBoostSourceGiveaway"
	TypeChatBoostSourcePremium                                  = "chatBoostSourcePremium"
	TypePrepaidGiveaway                                         = "prepaidGiveaway"
	TypeChatBoostStatus                                         = "chatBoostStatus"
	TypeChatBoost                                               = "chatBoost"
	TypeFoundChatBoosts                                         = "foundChatBoosts"
	TypeChatBoostSlot                                           = "chatBoostSlot"
	TypeChatBoostSlots                                          = "chatBoostSlots"
	TypeResendCodeReasonUserRequest                             = "resendCodeReasonUserRequest"
	TypeResendCodeReasonVerificationFailed                      = "resendCodeReasonVerificationFailed"
	TypeCallDiscardReasonEmpty                                  = "callDiscardReasonEmpty"
	TypeCallDiscardReasonMissed                                 = "callDiscardReasonMissed"
	TypeCallDiscardReasonDeclined                               = "callDiscardReasonDeclined"
	TypeCallDiscardReasonDisconnected                           = "callDiscardReasonDisconnected"
	TypeCallDiscardReasonHungUp                                 = "callDiscardReasonHungUp"
	TypeCallProtocol                                            = "callProtocol"
	TypeCallServerTypeTelegramReflector                         = "callServerTypeTelegramReflector"
	TypeCallServerTypeWebrtc                                    = "callServerTypeWebrtc"
	TypeCallServer                                              = "callServer"
	TypeCallId                                                  = "callId"
	TypeGroupCallId                                             = "groupCallId"
	TypeCallStatePending                                        = "callStatePending"
	TypeCallStateExchangingKeys                                 = "callStateExchangingKeys"
	TypeCallStateReady                                          = "callStateReady"
	TypeCallStateHangingUp                                      = "callStateHangingUp"
	TypeCallStateDiscarded                                      = "callStateDiscarded"
	TypeCallStateError                                          = "callStateError"
	TypeGroupCallVideoQualityThumbnail                          = "groupCallVideoQualityThumbnail"
	TypeGroupCallVideoQualityMedium                             = "groupCallVideoQualityMedium"
	TypeGroupCallVideoQualityFull                               = "groupCallVideoQualityFull"
	TypeGroupCallStream                                         = "groupCallStream"
	TypeGroupCallStreams                                        = "groupCallStreams"
	TypeRtmpUrl                                                 = "rtmpUrl"
	TypeGroupCallRecentSpeaker                                  = "groupCallRecentSpeaker"
	TypeGroupCall                                               = "groupCall"
	TypeGroupCallVideoSourceGroup                               = "groupCallVideoSourceGroup"
	TypeGroupCallParticipantVideoInfo                           = "groupCallParticipantVideoInfo"
	TypeGroupCallParticipant                                    = "groupCallParticipant"
	TypeCallProblemEcho                                         = "callProblemEcho"
	TypeCallProblemNoise                                        = "callProblemNoise"
	TypeCallProblemInterruptions                                = "callProblemInterruptions"
	TypeCallProblemDistortedSpeech                              = "callProblemDistortedSpeech"
	TypeCallProblemSilentLocal                                  = "callProblemSilentLocal"
	TypeCallProblemSilentRemote                                 = "callProblemSilentRemote"
	TypeCallProblemDropped                                      = "callProblemDropped"
	TypeCallProblemDistortedVideo                               = "callProblemDistortedVideo"
	TypeCallProblemPixelatedVideo                               = "callProblemPixelatedVideo"
	TypeCall                                                    = "call"
	TypeFirebaseAuthenticationSettingsAndroid                   = "firebaseAuthenticationSettingsAndroid"
	TypeFirebaseAuthenticationSettingsIos                       = "firebaseAuthenticationSettingsIos"
	TypePhoneNumberAuthenticationSettings                       = "phoneNumberAuthenticationSettings"
	TypeAddedReaction                                           = "addedReaction"
	TypeAddedReactions                                          = "addedReactions"
	TypeAvailableReaction                                       = "availableReaction"
	TypeAvailableReactions                                      = "availableReactions"
	TypeEmojiReaction                                           = "emojiReaction"
	TypeReactionUnavailabilityReasonAnonymousAdministrator      = "reactionUnavailabilityReasonAnonymousAdministrator"
	TypeReactionUnavailabilityReasonGuest                       = "reactionUnavailabilityReasonGuest"
	TypeAnimations                                              = "animations"
	TypeDiceStickersRegular                                     = "diceStickersRegular"
	TypeDiceStickersSlotMachine                                 = "diceStickersSlotMachine"
	TypeImportedContacts                                        = "importedContacts"
	TypeSpeechRecognitionResultPending                          = "speechRecognitionResultPending"
	TypeSpeechRecognitionResultText                             = "speechRecognitionResultText"
	TypeSpeechRecognitionResultError                            = "speechRecognitionResultError"
	TypeBusinessConnection                                      = "businessConnection"
	TypeAttachmentMenuBotColor                                  = "attachmentMenuBotColor"
	TypeAttachmentMenuBot                                       = "attachmentMenuBot"
	TypeSentWebAppMessage                                       = "sentWebAppMessage"
	TypeBotWriteAccessAllowReasonConnectedWebsite               = "botWriteAccessAllowReasonConnectedWebsite"
	TypeBotWriteAccessAllowReasonAddedToAttachmentMenu          = "botWriteAccessAllowReasonAddedToAttachmentMenu"
	TypeBotWriteAccessAllowReasonLaunchedWebApp                 = "botWriteAccessAllowReasonLaunchedWebApp"
	TypeBotWriteAccessAllowReasonAcceptedRequest                = "botWriteAccessAllowReasonAcceptedRequest"
	TypeHttpUrl                                                 = "httpUrl"
	TypeUserLink                                                = "userLink"
	TypeTargetChatTypes                                         = "targetChatTypes"
	TypeTargetChatCurrent                                       = "targetChatCurrent"
	TypeTargetChatChosen                                        = "targetChatChosen"
	TypeTargetChatInternalLink                                  = "targetChatInternalLink"
	TypeInputInlineQueryResultAnimation                         = "inputInlineQueryResultAnimation"
	TypeInputInlineQueryResultArticle                           = "inputInlineQueryResultArticle"
	TypeInputInlineQueryResultAudio                             = "inputInlineQueryResultAudio"
	TypeInputInlineQueryResultContact                           = "inputInlineQueryResultContact"
	TypeInputInlineQueryResultDocument                          = "inputInlineQueryResultDocument"
	TypeInputInlineQueryResultGame                              = "inputInlineQueryResultGame"
	TypeInputInlineQueryResultLocation                          = "inputInlineQueryResultLocation"
	TypeInputInlineQueryResultPhoto                             = "inputInlineQueryResultPhoto"
	TypeInputInlineQueryResultSticker                           = "inputInlineQueryResultSticker"
	TypeInputInlineQueryResultVenue                             = "inputInlineQueryResultVenue"
	TypeInputInlineQueryResultVideo                             = "inputInlineQueryResultVideo"
	TypeInputInlineQueryResultVoiceNote                         = "inputInlineQueryResultVoiceNote"
	TypeInlineQueryResultArticle                                = "inlineQueryResultArticle"
	TypeInlineQueryResultContact                                = "inlineQueryResultContact"
	TypeInlineQueryResultLocation                               = "inlineQueryResultLocation"
	TypeInlineQueryResultVenue                                  = "inlineQueryResultVenue"
	TypeInlineQueryResultGame                                   = "inlineQueryResultGame"
	TypeInlineQueryResultAnimation                              = "inlineQueryResultAnimation"
	TypeInlineQueryResultAudio                                  = "inlineQueryResultAudio"
	TypeInlineQueryResultDocument                               = "inlineQueryResultDocument"
	TypeInlineQueryResultPhoto                                  = "inlineQueryResultPhoto"
	TypeInlineQueryResultSticker                                = "inlineQueryResultSticker"
	TypeInlineQueryResultVideo                                  = "inlineQueryResultVideo"
	TypeInlineQueryResultVoiceNote                              = "inlineQueryResultVoiceNote"
	TypeInlineQueryResultsButtonTypeStartBot                    = "inlineQueryResultsButtonTypeStartBot"
	TypeInlineQueryResultsButtonTypeWebApp                      = "inlineQueryResultsButtonTypeWebApp"
	TypeInlineQueryResultsButton                                = "inlineQueryResultsButton"
	TypeInlineQueryResults                                      = "inlineQueryResults"
	TypePreparedInlineMessageId                                 = "preparedInlineMessageId"
	TypePreparedInlineMessage                                   = "preparedInlineMessage"
	TypeCallbackQueryPayloadData                                = "callbackQueryPayloadData"
	TypeCallbackQueryPayloadDataWithPassword                    = "callbackQueryPayloadDataWithPassword"
	TypeCallbackQueryPayloadGame                                = "callbackQueryPayloadGame"
	TypeCallbackQueryAnswer                                     = "callbackQueryAnswer"
	TypeCustomRequestResult                                     = "customRequestResult"
	TypeGameHighScore                                           = "gameHighScore"
	TypeGameHighScores                                          = "gameHighScores"
	TypeChatEventMessageEdited                                  = "chatEventMessageEdited"
	TypeChatEventMessageDeleted                                 = "chatEventMessageDeleted"
	TypeChatEventMessagePinned                                  = "chatEventMessagePinned"
	TypeChatEventMessageUnpinned                                = "chatEventMessageUnpinned"
	TypeChatEventPollStopped                                    = "chatEventPollStopped"
	TypeChatEventMemberJoined                                   = "chatEventMemberJoined"
	TypeChatEventMemberJoinedByInviteLink                       = "chatEventMemberJoinedByInviteLink"
	TypeChatEventMemberJoinedByRequest                          = "chatEventMemberJoinedByRequest"
	TypeChatEventMemberInvited                                  = "chatEventMemberInvited"
	TypeChatEventMemberLeft                                     = "chatEventMemberLeft"
	TypeChatEventMemberPromoted                                 = "chatEventMemberPromoted"
	TypeChatEventMemberRestricted                               = "chatEventMemberRestricted"
	TypeChatEventMemberSubscriptionExtended                     = "chatEventMemberSubscriptionExtended"
	TypeChatEventAvailableReactionsChanged                      = "chatEventAvailableReactionsChanged"
	TypeChatEventBackgroundChanged                              = "chatEventBackgroundChanged"
	TypeChatEventDescriptionChanged                             = "chatEventDescriptionChanged"
	TypeChatEventEmojiStatusChanged                             = "chatEventEmojiStatusChanged"
	TypeChatEventLinkedChatChanged                              = "chatEventLinkedChatChanged"
	TypeChatEventLocationChanged                                = "chatEventLocationChanged"
	TypeChatEventMessageAutoDeleteTimeChanged                   = "chatEventMessageAutoDeleteTimeChanged"
	TypeChatEventPermissionsChanged                             = "chatEventPermissionsChanged"
	TypeChatEventPhotoChanged                                   = "chatEventPhotoChanged"
	TypeChatEventSlowModeDelayChanged                           = "chatEventSlowModeDelayChanged"
	TypeChatEventStickerSetChanged                              = "chatEventStickerSetChanged"
	TypeChatEventCustomEmojiStickerSetChanged                   = "chatEventCustomEmojiStickerSetChanged"
	TypeChatEventTitleChanged                                   = "chatEventTitleChanged"
	TypeChatEventUsernameChanged                                = "chatEventUsernameChanged"
	TypeChatEventActiveUsernamesChanged                         = "chatEventActiveUsernamesChanged"
	TypeChatEventAccentColorChanged                             = "chatEventAccentColorChanged"
	TypeChatEventProfileAccentColorChanged                      = "chatEventProfileAccentColorChanged"
	TypeChatEventHasProtectedContentToggled                     = "chatEventHasProtectedContentToggled"
	TypeChatEventInvitesToggled                                 = "chatEventInvitesToggled"
	TypeChatEventIsAllHistoryAvailableToggled                   = "chatEventIsAllHistoryAvailableToggled"
	TypeChatEventHasAggressiveAntiSpamEnabledToggled            = "chatEventHasAggressiveAntiSpamEnabledToggled"
	TypeChatEventSignMessagesToggled                            = "chatEventSignMessagesToggled"
	TypeChatEventShowMessageSenderToggled                       = "chatEventShowMessageSenderToggled"
	TypeChatEventInviteLinkEdited                               = "chatEventInviteLinkEdited"
	TypeChatEventInviteLinkRevoked                              = "chatEventInviteLinkRevoked"
	TypeChatEventInviteLinkDeleted                              = "chatEventInviteLinkDeleted"
	TypeChatEventVideoChatCreated                               = "chatEventVideoChatCreated"
	TypeChatEventVideoChatEnded                                 = "chatEventVideoChatEnded"
	TypeChatEventVideoChatMuteNewParticipantsToggled            = "chatEventVideoChatMuteNewParticipantsToggled"
	TypeChatEventVideoChatParticipantIsMutedToggled             = "chatEventVideoChatParticipantIsMutedToggled"
	TypeChatEventVideoChatParticipantVolumeLevelChanged         = "chatEventVideoChatParticipantVolumeLevelChanged"
	TypeChatEventIsForumToggled                                 = "chatEventIsForumToggled"
	TypeChatEventForumTopicCreated                              = "chatEventForumTopicCreated"
	TypeChatEventForumTopicEdited                               = "chatEventForumTopicEdited"
	TypeChatEventForumTopicToggleIsClosed                       = "chatEventForumTopicToggleIsClosed"
	TypeChatEventForumTopicToggleIsHidden                       = "chatEventForumTopicToggleIsHidden"
	TypeChatEventForumTopicDeleted                              = "chatEventForumTopicDeleted"
	TypeChatEventForumTopicPinned                               = "chatEventForumTopicPinned"
	TypeChatEvent                                               = "chatEvent"
	TypeChatEvents                                              = "chatEvents"
	TypeChatEventLogFilters                                     = "chatEventLogFilters"
	TypeLanguagePackStringValueOrdinary                         = "languagePackStringValueOrdinary"
	TypeLanguagePackStringValuePluralized                       = "languagePackStringValuePluralized"
	TypeLanguagePackStringValueDeleted                          = "languagePackStringValueDeleted"
	TypeLanguagePackString                                      = "languagePackString"
	TypeLanguagePackStrings                                     = "languagePackStrings"
	TypeLanguagePackInfo                                        = "languagePackInfo"
	TypeLocalizationTargetInfo                                  = "localizationTargetInfo"
	TypePremiumLimitTypeSupergroupCount                         = "premiumLimitTypeSupergroupCount"
	TypePremiumLimitTypePinnedChatCount                         = "premiumLimitTypePinnedChatCount"
	TypePremiumLimitTypeCreatedPublicChatCount                  = "premiumLimitTypeCreatedPublicChatCount"
	TypePremiumLimitTypeSavedAnimationCount                     = "premiumLimitTypeSavedAnimationCount"
	TypePremiumLimitTypeFavoriteStickerCount                    = "premiumLimitTypeFavoriteStickerCount"
	TypePremiumLimitTypeChatFolderCount                         = "premiumLimitTypeChatFolderCount"
	TypePremiumLimitTypeChatFolderChosenChatCount               = "premiumLimitTypeChatFolderChosenChatCount"
	TypePremiumLimitTypePinnedArchivedChatCount                 = "premiumLimitTypePinnedArchivedChatCount"
	TypePremiumLimitTypePinnedSavedMessagesTopicCount           = "premiumLimitTypePinnedSavedMessagesTopicCount"
	TypePremiumLimitTypeCaptionLength                           = "premiumLimitTypeCaptionLength"
	TypePremiumLimitTypeBioLength                               = "premiumLimitTypeBioLength"
	TypePremiumLimitTypeChatFolderInviteLinkCount               = "premiumLimitTypeChatFolderInviteLinkCount"
	TypePremiumLimitTypeShareableChatFolderCount                = "premiumLimitTypeShareableChatFolderCount"
	TypePremiumLimitTypeActiveStoryCount                        = "premiumLimitTypeActiveStoryCount"
	TypePremiumLimitTypeWeeklySentStoryCount                    = "premiumLimitTypeWeeklySentStoryCount"
	TypePremiumLimitTypeMonthlySentStoryCount                   = "premiumLimitTypeMonthlySentStoryCount"
	TypePremiumLimitTypeStoryCaptionLength                      = "premiumLimitTypeStoryCaptionLength"
	TypePremiumLimitTypeStorySuggestedReactionAreaCount         = "premiumLimitTypeStorySuggestedReactionAreaCount"
	TypePremiumLimitTypeSimilarChatCount                        = "premiumLimitTypeSimilarChatCount"
	TypePremiumFeatureIncreasedLimits                           = "premiumFeatureIncreasedLimits"
	TypePremiumFeatureIncreasedUploadFileSize                   = "premiumFeatureIncreasedUploadFileSize"
	TypePremiumFeatureImprovedDownloadSpeed                     = "premiumFeatureImprovedDownloadSpeed"
	TypePremiumFeatureVoiceRecognition                          = "premiumFeatureVoiceRecognition"
	TypePremiumFeatureDisabledAds                               = "premiumFeatureDisabledAds"
	TypePremiumFeatureUniqueReactions                           = "premiumFeatureUniqueReactions"
	TypePremiumFeatureUniqueStickers                            = "premiumFeatureUniqueStickers"
	TypePremiumFeatureCustomEmoji                               = "premiumFeatureCustomEmoji"
	TypePremiumFeatureAdvancedChatManagement                    = "premiumFeatureAdvancedChatManagement"
	TypePremiumFeatureProfileBadge                              = "premiumFeatureProfileBadge"
	TypePremiumFeatureEmojiStatus                               = "premiumFeatureEmojiStatus"
	TypePremiumFeatureAnimatedProfilePhoto                      = "premiumFeatureAnimatedProfilePhoto"
	TypePremiumFeatureForumTopicIcon                            = "premiumFeatureForumTopicIcon"
	TypePremiumFeatureAppIcons                                  = "premiumFeatureAppIcons"
	TypePremiumFeatureRealTimeChatTranslation                   = "premiumFeatureRealTimeChatTranslation"
	TypePremiumFeatureUpgradedStories                           = "premiumFeatureUpgradedStories"
	TypePremiumFeatureChatBoost                                 = "premiumFeatureChatBoost"
	TypePremiumFeatureAccentColor                               = "premiumFeatureAccentColor"
	TypePremiumFeatureBackgroundForBoth                         = "premiumFeatureBackgroundForBoth"
	TypePremiumFeatureSavedMessagesTags                         = "premiumFeatureSavedMessagesTags"
	TypePremiumFeatureMessagePrivacy                            = "premiumFeatureMessagePrivacy"
	TypePremiumFeatureLastSeenTimes                             = "premiumFeatureLastSeenTimes"
	TypePremiumFeatureBusiness                                  = "premiumFeatureBusiness"
	TypePremiumFeatureMessageEffects                            = "premiumFeatureMessageEffects"
	TypeBusinessFeatureLocation                                 = "businessFeatureLocation"
	TypeBusinessFeatureOpeningHours                             = "businessFeatureOpeningHours"
	TypeBusinessFeatureQuickReplies                             = "businessFeatureQuickReplies"
	TypeBusinessFeatureGreetingMessage                          = "businessFeatureGreetingMessage"
	TypeBusinessFeatureAwayMessage                              = "businessFeatureAwayMessage"
	TypeBusinessFeatureAccountLinks                             = "businessFeatureAccountLinks"
	TypeBusinessFeatureStartPage                                = "businessFeatureStartPage"
	TypeBusinessFeatureBots                                     = "businessFeatureBots"
	TypeBusinessFeatureEmojiStatus                              = "businessFeatureEmojiStatus"
	TypeBusinessFeatureChatFolderTags                           = "businessFeatureChatFolderTags"
	TypeBusinessFeatureUpgradedStories                          = "businessFeatureUpgradedStories"
	TypePremiumStoryFeaturePriorityOrder                        = "premiumStoryFeaturePriorityOrder"
	TypePremiumStoryFeatureStealthMode                          = "premiumStoryFeatureStealthMode"
	TypePremiumStoryFeaturePermanentViewsHistory                = "premiumStoryFeaturePermanentViewsHistory"
	TypePremiumStoryFeatureCustomExpirationDuration             = "premiumStoryFeatureCustomExpirationDuration"
	TypePremiumStoryFeatureSaveStories                          = "premiumStoryFeatureSaveStories"
	TypePremiumStoryFeatureLinksAndFormatting                   = "premiumStoryFeatureLinksAndFormatting"
	TypePremiumStoryFeatureVideoQuality                         = "premiumStoryFeatureVideoQuality"
	TypePremiumLimit                                            = "premiumLimit"
	TypePremiumFeatures                                         = "premiumFeatures"
	TypeBusinessFeatures                                        = "businessFeatures"
	TypePremiumSourceLimitExceeded                              = "premiumSourceLimitExceeded"
	TypePremiumSourceFeature                                    = "premiumSourceFeature"
	TypePremiumSourceBusinessFeature                            = "premiumSourceBusinessFeature"
	TypePremiumSourceStoryFeature                               = "premiumSourceStoryFeature"
	TypePremiumSourceLink                                       = "premiumSourceLink"
	TypePremiumSourceSettings                                   = "premiumSourceSettings"
	TypePremiumFeaturePromotionAnimation                        = "premiumFeaturePromotionAnimation"
	TypeBusinessFeaturePromotionAnimation                       = "businessFeaturePromotionAnimation"
	TypePremiumState                                            = "premiumState"
	TypeStorePaymentPurposePremiumSubscription                  = "storePaymentPurposePremiumSubscription"
	TypeStorePaymentPurposePremiumGiftCodes                     = "storePaymentPurposePremiumGiftCodes"
	TypeStorePaymentPurposePremiumGiveaway                      = "storePaymentPurposePremiumGiveaway"
	TypeStorePaymentPurposeStarGiveaway                         = "storePaymentPurposeStarGiveaway"
	TypeStorePaymentPurposeStars                                = "storePaymentPurposeStars"
	TypeStorePaymentPurposeGiftedStars                          = "storePaymentPurposeGiftedStars"
	TypeTelegramPaymentPurposePremiumGiftCodes                  = "telegramPaymentPurposePremiumGiftCodes"
	TypeTelegramPaymentPurposePremiumGiveaway                   = "telegramPaymentPurposePremiumGiveaway"
	TypeTelegramPaymentPurposeStars                             = "telegramPaymentPurposeStars"
	TypeTelegramPaymentPurposeGiftedStars                       = "telegramPaymentPurposeGiftedStars"
	TypeTelegramPaymentPurposeStarGiveaway                      = "telegramPaymentPurposeStarGiveaway"
	TypeTelegramPaymentPurposeJoinChat                          = "telegramPaymentPurposeJoinChat"
	TypeDeviceTokenFirebaseCloudMessaging                       = "deviceTokenFirebaseCloudMessaging"
	TypeDeviceTokenApplePush                                    = "deviceTokenApplePush"
	TypeDeviceTokenApplePushVoIP                                = "deviceTokenApplePushVoIP"
	TypeDeviceTokenWindowsPush                                  = "deviceTokenWindowsPush"
	TypeDeviceTokenMicrosoftPush                                = "deviceTokenMicrosoftPush"
	TypeDeviceTokenMicrosoftPushVoIP                            = "deviceTokenMicrosoftPushVoIP"
	TypeDeviceTokenWebPush                                      = "deviceTokenWebPush"
	TypeDeviceTokenSimplePush                                   = "deviceTokenSimplePush"
	TypeDeviceTokenUbuntuPush                                   = "deviceTokenUbuntuPush"
	TypeDeviceTokenBlackBerryPush                               = "deviceTokenBlackBerryPush"
	TypeDeviceTokenTizenPush                                    = "deviceTokenTizenPush"
	TypeDeviceTokenHuaweiPush                                   = "deviceTokenHuaweiPush"
	TypePushReceiverId                                          = "pushReceiverId"
	TypeBackgroundFillSolid                                     = "backgroundFillSolid"
	TypeBackgroundFillGradient                                  = "backgroundFillGradient"
	TypeBackgroundFillFreeformGradient                          = "backgroundFillFreeformGradient"
	TypeBackgroundTypeWallpaper                                 = "backgroundTypeWallpaper"
	TypeBackgroundTypePattern                                   = "backgroundTypePattern"
	TypeBackgroundTypeFill                                      = "backgroundTypeFill"
	TypeBackgroundTypeChatTheme                                 = "backgroundTypeChatTheme"
	TypeInputBackgroundLocal                                    = "inputBackgroundLocal"
	TypeInputBackgroundRemote                                   = "inputBackgroundRemote"
	TypeInputBackgroundPrevious                                 = "inputBackgroundPrevious"
	TypeChatTheme                                               = "chatTheme"
	TypeTimeZone                                                = "timeZone"
	TypeTimeZones                                               = "timeZones"
	TypeHashtags                                                = "hashtags"
	TypeCanSendStoryResultOk                                    = "canSendStoryResultOk"
	TypeCanSendStoryResultPremiumNeeded                         = "canSendStoryResultPremiumNeeded"
	TypeCanSendStoryResultBoostNeeded                           = "canSendStoryResultBoostNeeded"
	TypeCanSendStoryResultActiveStoryLimitExceeded              = "canSendStoryResultActiveStoryLimitExceeded"
	TypeCanSendStoryResultWeeklyLimitExceeded                   = "canSendStoryResultWeeklyLimitExceeded"
	TypeCanSendStoryResultMonthlyLimitExceeded                  = "canSendStoryResultMonthlyLimitExceeded"
	TypeCanTransferOwnershipResultOk                            = "canTransferOwnershipResultOk"
	TypeCanTransferOwnershipResultPasswordNeeded                = "canTransferOwnershipResultPasswordNeeded"
	TypeCanTransferOwnershipResultPasswordTooFresh              = "canTransferOwnershipResultPasswordTooFresh"
	TypeCanTransferOwnershipResultSessionTooFresh               = "canTransferOwnershipResultSessionTooFresh"
	TypeCheckChatUsernameResultOk                               = "checkChatUsernameResultOk"
	TypeCheckChatUsernameResultUsernameInvalid                  = "checkChatUsernameResultUsernameInvalid"
	TypeCheckChatUsernameResultUsernameOccupied                 = "checkChatUsernameResultUsernameOccupied"
	TypeCheckChatUsernameResultUsernamePurchasable              = "checkChatUsernameResultUsernamePurchasable"
	TypeCheckChatUsernameResultPublicChatsTooMany               = "checkChatUsernameResultPublicChatsTooMany"
	TypeCheckChatUsernameResultPublicGroupsUnavailable          = "checkChatUsernameResultPublicGroupsUnavailable"
	TypeCheckStickerSetNameResultOk                             = "checkStickerSetNameResultOk"
	TypeCheckStickerSetNameResultNameInvalid                    = "checkStickerSetNameResultNameInvalid"
	TypeCheckStickerSetNameResultNameOccupied                   = "checkStickerSetNameResultNameOccupied"
	TypeResetPasswordResultOk                                   = "resetPasswordResultOk"
	TypeResetPasswordResultPending                              = "resetPasswordResultPending"
	TypeResetPasswordResultDeclined                             = "resetPasswordResultDeclined"
	TypeMessageFileTypePrivate                                  = "messageFileTypePrivate"
	TypeMessageFileTypeGroup                                    = "messageFileTypeGroup"
	TypeMessageFileTypeUnknown                                  = "messageFileTypeUnknown"
	TypePushMessageContentHidden                                = "pushMessageContentHidden"
	TypePushMessageContentAnimation                             = "pushMessageContentAnimation"
	TypePushMessageContentAudio                                 = "pushMessageContentAudio"
	TypePushMessageContentContact                               = "pushMessageContentContact"
	TypePushMessageContentContactRegistered                     = "pushMessageContentContactRegistered"
	TypePushMessageContentDocument                              = "pushMessageContentDocument"
	TypePushMessageContentGame                                  = "pushMessageContentGame"
	TypePushMessageContentGameScore                             = "pushMessageContentGameScore"
	TypePushMessageContentInvoice                               = "pushMessageContentInvoice"
	TypePushMessageContentLocation                              = "pushMessageContentLocation"
	TypePushMessageContentPaidMedia                             = "pushMessageContentPaidMedia"
	TypePushMessageContentPhoto                                 = "pushMessageContentPhoto"
	TypePushMessageContentPoll                                  = "pushMessageContentPoll"
	TypePushMessageContentPremiumGiftCode                       = "pushMessageContentPremiumGiftCode"
	TypePushMessageContentGiveaway                              = "pushMessageContentGiveaway"
	TypePushMessageContentGift                                  = "pushMessageContentGift"
	TypePushMessageContentScreenshotTaken                       = "pushMessageContentScreenshotTaken"
	TypePushMessageContentSticker                               = "pushMessageContentSticker"
	TypePushMessageContentStory                                 = "pushMessageContentStory"
	TypePushMessageContentText                                  = "pushMessageContentText"
	TypePushMessageContentVideo                                 = "pushMessageContentVideo"
	TypePushMessageContentVideoNote                             = "pushMessageContentVideoNote"
	TypePushMessageContentVoiceNote                             = "pushMessageContentVoiceNote"
	TypePushMessageContentBasicGroupChatCreate                  = "pushMessageContentBasicGroupChatCreate"
	TypePushMessageContentChatAddMembers                        = "pushMessageContentChatAddMembers"
	TypePushMessageContentChatChangePhoto                       = "pushMessageContentChatChangePhoto"
	TypePushMessageContentChatChangeTitle                       = "pushMessageContentChatChangeTitle"
	TypePushMessageContentChatSetBackground                     = "pushMessageContentChatSetBackground"
	TypePushMessageContentChatSetTheme                          = "pushMessageContentChatSetTheme"
	TypePushMessageContentChatDeleteMember                      = "pushMessageContentChatDeleteMember"
	TypePushMessageContentChatJoinByLink                        = "pushMessageContentChatJoinByLink"
	TypePushMessageContentChatJoinByRequest                     = "pushMessageContentChatJoinByRequest"
	TypePushMessageContentRecurringPayment                      = "pushMessageContentRecurringPayment"
	TypePushMessageContentSuggestProfilePhoto                   = "pushMessageContentSuggestProfilePhoto"
	TypePushMessageContentMessageForwards                       = "pushMessageContentMessageForwards"
	TypePushMessageContentMediaAlbum                            = "pushMessageContentMediaAlbum"
	TypeNotificationTypeNewMessage                              = "notificationTypeNewMessage"
	TypeNotificationTypeNewSecretChat                           = "notificationTypeNewSecretChat"
	TypeNotificationTypeNewCall                                 = "notificationTypeNewCall"
	TypeNotificationTypeNewPushMessage                          = "notificationTypeNewPushMessage"
	TypeNotificationGroupTypeMessages                           = "notificationGroupTypeMessages"
	TypeNotificationGroupTypeMentions                           = "notificationGroupTypeMentions"
	TypeNotificationGroupTypeSecretChat                         = "notificationGroupTypeSecretChat"
	TypeNotificationGroupTypeCalls                              = "notificationGroupTypeCalls"
	TypeNotificationSound                                       = "notificationSound"
	TypeNotificationSounds                                      = "notificationSounds"
	TypeNotification                                            = "notification"
	TypeNotificationGroup                                       = "notificationGroup"
	TypeOptionValueBoolean                                      = "optionValueBoolean"
	TypeOptionValueEmpty                                        = "optionValueEmpty"
	TypeOptionValueInteger                                      = "optionValueInteger"
	TypeOptionValueString                                       = "optionValueString"
	TypeJsonObjectMember                                        = "jsonObjectMember"
	TypeJsonValueNull                                           = "jsonValueNull"
	TypeJsonValueBoolean                                        = "jsonValueBoolean"
	TypeJsonValueNumber                                         = "jsonValueNumber"
	TypeJsonValueString                                         = "jsonValueString"
	TypeJsonValueArray                                          = "jsonValueArray"
	TypeJsonValueObject                                         = "jsonValueObject"
	TypeStoryPrivacySettingsEveryone                            = "storyPrivacySettingsEveryone"
	TypeStoryPrivacySettingsContacts                            = "storyPrivacySettingsContacts"
	TypeStoryPrivacySettingsCloseFriends                        = "storyPrivacySettingsCloseFriends"
	TypeStoryPrivacySettingsSelectedUsers                       = "storyPrivacySettingsSelectedUsers"
	TypeUserPrivacySettingRuleAllowAll                          = "userPrivacySettingRuleAllowAll"
	TypeUserPrivacySettingRuleAllowContacts                     = "userPrivacySettingRuleAllowContacts"
	TypeUserPrivacySettingRuleAllowBots                         = "userPrivacySettingRuleAllowBots"
	TypeUserPrivacySettingRuleAllowPremiumUsers                 = "userPrivacySettingRuleAllowPremiumUsers"
	TypeUserPrivacySettingRuleAllowUsers                        = "userPrivacySettingRuleAllowUsers"
	TypeUserPrivacySettingRuleAllowChatMembers                  = "userPrivacySettingRuleAllowChatMembers"
	TypeUserPrivacySettingRuleRestrictAll                       = "userPrivacySettingRuleRestrictAll"
	TypeUserPrivacySettingRuleRestrictContacts                  = "userPrivacySettingRuleRestrictContacts"
	TypeUserPrivacySettingRuleRestrictBots                      = "userPrivacySettingRuleRestrictBots"
	TypeUserPrivacySettingRuleRestrictUsers                     = "userPrivacySettingRuleRestrictUsers"
	TypeUserPrivacySettingRuleRestrictChatMembers               = "userPrivacySettingRuleRestrictChatMembers"
	TypeUserPrivacySettingRules                                 = "userPrivacySettingRules"
	TypeUserPrivacySettingShowStatus                            = "userPrivacySettingShowStatus"
	TypeUserPrivacySettingShowProfilePhoto                      = "userPrivacySettingShowProfilePhoto"
	TypeUserPrivacySettingShowLinkInForwardedMessages           = "userPrivacySettingShowLinkInForwardedMessages"
	TypeUserPrivacySettingShowPhoneNumber                       = "userPrivacySettingShowPhoneNumber"
	TypeUserPrivacySettingShowBio                               = "userPrivacySettingShowBio"
	TypeUserPrivacySettingShowBirthdate                         = "userPrivacySettingShowBirthdate"
	TypeUserPrivacySettingAllowChatInvites                      = "userPrivacySettingAllowChatInvites"
	TypeUserPrivacySettingAllowCalls                            = "userPrivacySettingAllowCalls"
	TypeUserPrivacySettingAllowPeerToPeerCalls                  = "userPrivacySettingAllowPeerToPeerCalls"
	TypeUserPrivacySettingAllowFindingByPhoneNumber             = "userPrivacySettingAllowFindingByPhoneNumber"
	TypeUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"
	TypeUserPrivacySettingAutosaveGifts                         = "userPrivacySettingAutosaveGifts"
	TypeReadDatePrivacySettings                                 = "readDatePrivacySettings"
	TypeNewChatPrivacySettings                                  = "newChatPrivacySettings"
	TypeCanSendMessageToUserResultOk                            = "canSendMessageToUserResultOk"
	TypeCanSendMessageToUserResultUserIsDeleted                 = "canSendMessageToUserResultUserIsDeleted"
	TypeCanSendMessageToUserResultUserRestrictsNewChats         = "canSendMessageToUserResultUserRestrictsNewChats"
	TypeAccountTtl                                              = "accountTtl"
	TypeMessageAutoDeleteTime                                   = "messageAutoDeleteTime"
	TypeSessionTypeAndroid                                      = "sessionTypeAndroid"
	TypeSessionTypeApple                                        = "sessionTypeApple"
	TypeSessionTypeBrave                                        = "sessionTypeBrave"
	TypeSessionTypeChrome                                       = "sessionTypeChrome"
	TypeSessionTypeEdge                                         = "sessionTypeEdge"
	TypeSessionTypeFirefox                                      = "sessionTypeFirefox"
	TypeSessionTypeIpad                                         = "sessionTypeIpad"
	TypeSessionTypeIphone                                       = "sessionTypeIphone"
	TypeSessionTypeLinux                                        = "sessionTypeLinux"
	TypeSessionTypeMac                                          = "sessionTypeMac"
	TypeSessionTypeOpera                                        = "sessionTypeOpera"
	TypeSessionTypeSafari                                       = "sessionTypeSafari"
	TypeSessionTypeUbuntu                                       = "sessionTypeUbuntu"
	TypeSessionTypeUnknown                                      = "sessionTypeUnknown"
	TypeSessionTypeVivaldi                                      = "sessionTypeVivaldi"
	TypeSessionTypeWindows                                      = "sessionTypeWindows"
	TypeSessionTypeXbox                                         = "sessionTypeXbox"
	TypeSession                                                 = "session"
	TypeSessions                                                = "sessions"
	TypeUnconfirmedSession                                      = "unconfirmedSession"
	TypeConnectedWebsite                                        = "connectedWebsite"
	TypeConnectedWebsites                                       = "connectedWebsites"
	TypeReportReasonSpam                                        = "reportReasonSpam"
	TypeReportReasonViolence                                    = "reportReasonViolence"
	TypeReportReasonPornography                                 = "reportReasonPornography"
	TypeReportReasonChildAbuse                                  = "reportReasonChildAbuse"
	TypeReportReasonCopyright                                   = "reportReasonCopyright"
	TypeReportReasonUnrelatedLocation                           = "reportReasonUnrelatedLocation"
	TypeReportReasonFake                                        = "reportReasonFake"
	TypeReportReasonIllegalDrugs                                = "reportReasonIllegalDrugs"
	TypeReportReasonPersonalDetails                             = "reportReasonPersonalDetails"
	TypeReportReasonCustom                                      = "reportReasonCustom"
	TypeReportChatResultOk                                      = "reportChatResultOk"
	TypeReportChatResultOptionRequired                          = "reportChatResultOptionRequired"
	TypeReportChatResultTextRequired                            = "reportChatResultTextRequired"
	TypeReportChatResultMessagesRequired                        = "reportChatResultMessagesRequired"
	TypeReportStoryResultOk                                     = "reportStoryResultOk"
	TypeReportStoryResultOptionRequired                         = "reportStoryResultOptionRequired"
	TypeReportStoryResultTextRequired                           = "reportStoryResultTextRequired"
	TypeInternalLinkTypeActiveSessions                          = "internalLinkTypeActiveSessions"
	TypeInternalLinkTypeAttachmentMenuBot                       = "internalLinkTypeAttachmentMenuBot"
	TypeInternalLinkTypeAuthenticationCode                      = "internalLinkTypeAuthenticationCode"
	TypeInternalLinkTypeBackground                              = "internalLinkTypeBackground"
	TypeInternalLinkTypeBotAddToChannel                         = "internalLinkTypeBotAddToChannel"
	TypeInternalLinkTypeBotStart                                = "internalLinkTypeBotStart"
	TypeInternalLinkTypeBotStartInGroup                         = "internalLinkTypeBotStartInGroup"
	TypeInternalLinkTypeBusinessChat                            = "internalLinkTypeBusinessChat"
	TypeInternalLinkTypeBuyStars                                = "internalLinkTypeBuyStars"
	TypeInternalLinkTypeChangePhoneNumber                       = "internalLinkTypeChangePhoneNumber"
	TypeInternalLinkTypeChatBoost                               = "internalLinkTypeChatBoost"
	TypeInternalLinkTypeChatFolderInvite                        = "internalLinkTypeChatFolderInvite"
	TypeInternalLinkTypeChatFolderSettings                      = "internalLinkTypeChatFolderSettings"
	TypeInternalLinkTypeChatInvite                              = "internalLinkTypeChatInvite"
	TypeInternalLinkTypeDefaultMessageAutoDeleteTimerSettings   = "internalLinkTypeDefaultMessageAutoDeleteTimerSettings"
	TypeInternalLinkTypeEditProfileSettings                     = "internalLinkTypeEditProfileSettings"
	TypeInternalLinkTypeGame                                    = "internalLinkTypeGame"
	TypeInternalLinkTypeInstantView                             = "internalLinkTypeInstantView"
	TypeInternalLinkTypeInvoice                                 = "internalLinkTypeInvoice"
	TypeInternalLinkTypeLanguagePack                            = "internalLinkTypeLanguagePack"
	TypeInternalLinkTypeLanguageSettings                        = "internalLinkTypeLanguageSettings"
	TypeInternalLinkTypeMainWebApp                              = "internalLinkTypeMainWebApp"
	TypeInternalLinkTypeMessage                                 = "internalLinkTypeMessage"
	TypeInternalLinkTypeMessageDraft                            = "internalLinkTypeMessageDraft"
	TypeInternalLinkTypePassportDataRequest                     = "internalLinkTypePassportDataRequest"
	TypeInternalLinkTypePhoneNumberConfirmation                 = "internalLinkTypePhoneNumberConfirmation"
	TypeInternalLinkTypePremiumFeatures                         = "internalLinkTypePremiumFeatures"
	TypeInternalLinkTypePremiumGift                             = "internalLinkTypePremiumGift"
	TypeInternalLinkTypePremiumGiftCode                         = "internalLinkTypePremiumGiftCode"
	TypeInternalLinkTypePrivacyAndSecuritySettings              = "internalLinkTypePrivacyAndSecuritySettings"
	TypeInternalLinkTypeProxy                                   = "internalLinkTypeProxy"
	TypeInternalLinkTypePublicChat                              = "internalLinkTypePublicChat"
	TypeInternalLinkTypeQrCodeAuthentication                    = "internalLinkTypeQrCodeAuthentication"
	TypeInternalLinkTypeRestorePurchases                        = "internalLinkTypeRestorePurchases"
	TypeInternalLinkTypeSettings                                = "internalLinkTypeSettings"
	TypeInternalLinkTypeStickerSet                              = "internalLinkTypeStickerSet"
	TypeInternalLinkTypeStory                                   = "internalLinkTypeStory"
	TypeInternalLinkTypeTheme                                   = "internalLinkTypeTheme"
	TypeInternalLinkTypeThemeSettings                           = "internalLinkTypeThemeSettings"
	TypeInternalLinkTypeUnknownDeepLink                         = "internalLinkTypeUnknownDeepLink"
	TypeInternalLinkTypeUnsupportedProxy                        = "internalLinkTypeUnsupportedProxy"
	TypeInternalLinkTypeUserPhoneNumber                         = "internalLinkTypeUserPhoneNumber"
	TypeInternalLinkTypeUserToken                               = "internalLinkTypeUserToken"
	TypeInternalLinkTypeVideoChat                               = "internalLinkTypeVideoChat"
	TypeInternalLinkTypeWebApp                                  = "internalLinkTypeWebApp"
	TypeMessageLink                                             = "messageLink"
	TypeMessageLinkInfo                                         = "messageLinkInfo"
	TypeChatBoostLink                                           = "chatBoostLink"
	TypeChatBoostLinkInfo                                       = "chatBoostLinkInfo"
	TypeBlockListMain                                           = "blockListMain"
	TypeBlockListStories                                        = "blockListStories"
	TypeFilePart                                                = "filePart"
	TypeFileTypeNone                                            = "fileTypeNone"
	TypeFileTypeAnimation                                       = "fileTypeAnimation"
	TypeFileTypeAudio                                           = "fileTypeAudio"
	TypeFileTypeDocument                                        = "fileTypeDocument"
	TypeFileTypeNotificationSound                               = "fileTypeNotificationSound"
	TypeFileTypePhoto                                           = "fileTypePhoto"
	TypeFileTypePhotoStory                                      = "fileTypePhotoStory"
	TypeFileTypeProfilePhoto                                    = "fileTypeProfilePhoto"
	TypeFileTypeSecret                                          = "fileTypeSecret"
	TypeFileTypeSecretThumbnail                                 = "fileTypeSecretThumbnail"
	TypeFileTypeSecure                                          = "fileTypeSecure"
	TypeFileTypeSticker                                         = "fileTypeSticker"
	TypeFileTypeThumbnail                                       = "fileTypeThumbnail"
	TypeFileTypeUnknown                                         = "fileTypeUnknown"
	TypeFileTypeVideo                                           = "fileTypeVideo"
	TypeFileTypeVideoNote                                       = "fileTypeVideoNote"
	TypeFileTypeVideoStory                                      = "fileTypeVideoStory"
	TypeFileTypeVoiceNote                                       = "fileTypeVoiceNote"
	TypeFileTypeWallpaper                                       = "fileTypeWallpaper"
	TypeStorageStatisticsByFileType                             = "storageStatisticsByFileType"
	TypeStorageStatisticsByChat                                 = "storageStatisticsByChat"
	TypeStorageStatistics                                       = "storageStatistics"
	TypeStorageStatisticsFast                                   = "storageStatisticsFast"
	TypeDatabaseStatistics                                      = "databaseStatistics"
	TypeNetworkTypeNone                                         = "networkTypeNone"
	TypeNetworkTypeMobile                                       = "networkTypeMobile"
	TypeNetworkTypeMobileRoaming                                = "networkTypeMobileRoaming"
	TypeNetworkTypeWiFi                                         = "networkTypeWiFi"
	TypeNetworkTypeOther                                        = "networkTypeOther"
	TypeNetworkStatisticsEntryFile                              = "networkStatisticsEntryFile"
	TypeNetworkStatisticsEntryCall                              = "networkStatisticsEntryCall"
	TypeNetworkStatistics                                       = "networkStatistics"
	TypeAutoDownloadSettings                                    = "autoDownloadSettings"
	TypeAutoDownloadSettingsPresets                             = "autoDownloadSettingsPresets"
	TypeAutosaveSettingsScopePrivateChats                       = "autosaveSettingsScopePrivateChats"
	TypeAutosaveSettingsScopeGroupChats                         = "autosaveSettingsScopeGroupChats"
	TypeAutosaveSettingsScopeChannelChats                       = "autosaveSettingsScopeChannelChats"
	TypeAutosaveSettingsScopeChat                               = "autosaveSettingsScopeChat"
	TypeScopeAutosaveSettings                                   = "scopeAutosaveSettings"
	TypeAutosaveSettingsException                               = "autosaveSettingsException"
	TypeAutosaveSettings                                        = "autosaveSettings"
	TypeConnectionStateWaitingForNetwork                        = "connectionStateWaitingForNetwork"
	TypeConnectionStateConnectingToProxy                        = "connectionStateConnectingToProxy"
	TypeConnectionStateConnecting                               = "connectionStateConnecting"
	TypeConnectionStateUpdating                                 = "connectionStateUpdating"
	TypeConnectionStateReady                                    = "connectionStateReady"
	TypeTopChatCategoryUsers                                    = "topChatCategoryUsers"
	TypeTopChatCategoryBots                                     = "topChatCategoryBots"
	TypeTopChatCategoryGroups                                   = "topChatCategoryGroups"
	TypeTopChatCategoryChannels                                 = "topChatCategoryChannels"
	TypeTopChatCategoryInlineBots                               = "topChatCategoryInlineBots"
	TypeTopChatCategoryWebAppBots                               = "topChatCategoryWebAppBots"
	TypeTopChatCategoryCalls                                    = "topChatCategoryCalls"
	TypeTopChatCategoryForwardChats                             = "topChatCategoryForwardChats"
	TypeFoundPosition                                           = "foundPosition"
	TypeFoundPositions                                          = "foundPositions"
	TypeTMeUrlTypeUser                                          = "tMeUrlTypeUser"
	TypeTMeUrlTypeSupergroup                                    = "tMeUrlTypeSupergroup"
	TypeTMeUrlTypeChatInvite                                    = "tMeUrlTypeChatInvite"
	TypeTMeUrlTypeStickerSet                                    = "tMeUrlTypeStickerSet"
	TypeTMeUrl                                                  = "tMeUrl"
	TypeTMeUrls                                                 = "tMeUrls"
	TypeSuggestedActionEnableArchiveAndMuteNewChats             = "suggestedActionEnableArchiveAndMuteNewChats"
	TypeSuggestedActionCheckPassword                            = "suggestedActionCheckPassword"
	TypeSuggestedActionCheckPhoneNumber                         = "suggestedActionCheckPhoneNumber"
	TypeSuggestedActionViewChecksHint                           = "suggestedActionViewChecksHint"
	TypeSuggestedActionConvertToBroadcastGroup                  = "suggestedActionConvertToBroadcastGroup"
	TypeSuggestedActionSetPassword                              = "suggestedActionSetPassword"
	TypeSuggestedActionUpgradePremium                           = "suggestedActionUpgradePremium"
	TypeSuggestedActionRestorePremium                           = "suggestedActionRestorePremium"
	TypeSuggestedActionSubscribeToAnnualPremium                 = "suggestedActionSubscribeToAnnualPremium"
	TypeSuggestedActionGiftPremiumForChristmas                  = "suggestedActionGiftPremiumForChristmas"
	TypeSuggestedActionSetBirthdate                             = "suggestedActionSetBirthdate"
	TypeSuggestedActionExtendPremium                            = "suggestedActionExtendPremium"
	TypeSuggestedActionExtendStarSubscriptions                  = "suggestedActionExtendStarSubscriptions"
	TypeCount                                                   = "count"
	TypeText                                                    = "text"
	TypeSeconds                                                 = "seconds"
	TypeFileDownloadedPrefixSize                                = "fileDownloadedPrefixSize"
	TypeDeepLinkInfo                                            = "deepLinkInfo"
	TypeTextParseModeMarkdown                                   = "textParseModeMarkdown"
	TypeTextParseModeHTML                                       = "textParseModeHTML"
	TypeProxyTypeSocks5                                         = "proxyTypeSocks5"
	TypeProxyTypeHttp                                           = "proxyTypeHttp"
	TypeProxyTypeMtproto                                        = "proxyTypeMtproto"
	TypeProxy                                                   = "proxy"
	TypeProxies                                                 = "proxies"
	TypeInputSticker                                            = "inputSticker"
	TypeDateRange                                               = "dateRange"
	TypeStatisticalValue                                        = "statisticalValue"
	TypeStatisticalGraphData                                    = "statisticalGraphData"
	TypeStatisticalGraphAsync                                   = "statisticalGraphAsync"
	TypeStatisticalGraphError                                   = "statisticalGraphError"
	TypeChatStatisticsObjectTypeMessage                         = "chatStatisticsObjectTypeMessage"
	TypeChatStatisticsObjectTypeStory                           = "chatStatisticsObjectTypeStory"
	TypeChatStatisticsInteractionInfo                           = "chatStatisticsInteractionInfo"
	TypeChatStatisticsMessageSenderInfo                         = "chatStatisticsMessageSenderInfo"
	TypeChatStatisticsAdministratorActionsInfo                  = "chatStatisticsAdministratorActionsInfo"
	TypeChatStatisticsInviterInfo                               = "chatStatisticsInviterInfo"
	TypeChatStatisticsSupergroup                                = "chatStatisticsSupergroup"
	TypeChatStatisticsChannel                                   = "chatStatisticsChannel"
	TypeChatRevenueAmount                                       = "chatRevenueAmount"
	TypeChatRevenueStatistics                                   = "chatRevenueStatistics"
	TypeMessageStatistics                                       = "messageStatistics"
	TypeStoryStatistics                                         = "storyStatistics"
	TypeRevenueWithdrawalStatePending                           = "revenueWithdrawalStatePending"
	TypeRevenueWithdrawalStateSucceeded                         = "revenueWithdrawalStateSucceeded"
	TypeRevenueWithdrawalStateFailed                            = "revenueWithdrawalStateFailed"
	TypeChatRevenueTransactionTypeEarnings                      = "chatRevenueTransactionTypeEarnings"
	TypeChatRevenueTransactionTypeWithdrawal                    = "chatRevenueTransactionTypeWithdrawal"
	TypeChatRevenueTransactionTypeRefund                        = "chatRevenueTransactionTypeRefund"
	TypeChatRevenueTransaction                                  = "chatRevenueTransaction"
	TypeChatRevenueTransactions                                 = "chatRevenueTransactions"
	TypeStarRevenueStatus                                       = "starRevenueStatus"
	TypeStarRevenueStatistics                                   = "starRevenueStatistics"
	TypePoint                                                   = "point"
	TypeVectorPathCommandLine                                   = "vectorPathCommandLine"
	TypeVectorPathCommandCubicBezierCurve                       = "vectorPathCommandCubicBezierCurve"
	TypeBotCommandScopeDefault                                  = "botCommandScopeDefault"
	TypeBotCommandScopeAllPrivateChats                          = "botCommandScopeAllPrivateChats"
	TypeBotCommandScopeAllGroupChats                            = "botCommandScopeAllGroupChats"
	TypeBotCommandScopeAllChatAdministrators                    = "botCommandScopeAllChatAdministrators"
	TypeBotCommandScopeChat                                     = "botCommandScopeChat"
	TypeBotCommandScopeChatAdministrators                       = "botCommandScopeChatAdministrators"
	TypeBotCommandScopeChatMember                               = "botCommandScopeChatMember"
	TypePhoneNumberCodeTypeChange                               = "phoneNumberCodeTypeChange"
	TypePhoneNumberCodeTypeVerify                               = "phoneNumberCodeTypeVerify"
	TypePhoneNumberCodeTypeConfirmOwnership                     = "phoneNumberCodeTypeConfirmOwnership"
	TypeUpdateAuthorizationState                                = "updateAuthorizationState"
	TypeUpdateNewMessage                                        = "updateNewMessage"
	TypeUpdateMessageSendAcknowledged                           = "updateMessageSendAcknowledged"
	TypeUpdateMessageSendSucceeded                              = "updateMessageSendSucceeded"
	TypeUpdateMessageSendFailed                                 = "updateMessageSendFailed"
	TypeUpdateMessageContent                                    = "updateMessageContent"
	TypeUpdateMessageEdited                                     = "updateMessageEdited"
	TypeUpdateMessageIsPinned                                   = "updateMessageIsPinned"
	TypeUpdateMessageInteractionInfo                            = "updateMessageInteractionInfo"
	TypeUpdateMessageContentOpened                              = "updateMessageContentOpened"
	TypeUpdateMessageMentionRead                                = "updateMessageMentionRead"
	TypeUpdateMessageUnreadReactions                            = "updateMessageUnreadReactions"
	TypeUpdateMessageFactCheck                                  = "updateMessageFactCheck"
	TypeUpdateMessageLiveLocationViewed                         = "updateMessageLiveLocationViewed"
	TypeUpdateVideoPublished                                    = "updateVideoPublished"
	TypeUpdateNewChat                                           = "updateNewChat"
	TypeUpdateChatTitle                                         = "updateChatTitle"
	TypeUpdateChatPhoto                                         = "updateChatPhoto"
	TypeUpdateChatAccentColors                                  = "updateChatAccentColors"
	TypeUpdateChatPermissions                                   = "updateChatPermissions"
	TypeUpdateChatLastMessage                                   = "updateChatLastMessage"
	TypeUpdateChatPosition                                      = "updateChatPosition"
	TypeUpdateChatAddedToList                                   = "updateChatAddedToList"
	TypeUpdateChatRemovedFromList                               = "updateChatRemovedFromList"
	TypeUpdateChatReadInbox                                     = "updateChatReadInbox"
	TypeUpdateChatReadOutbox                                    = "updateChatReadOutbox"
	TypeUpdateChatActionBar                                     = "updateChatActionBar"
	TypeUpdateChatBusinessBotManageBar                          = "updateChatBusinessBotManageBar"
	TypeUpdateChatAvailableReactions                            = "updateChatAvailableReactions"
	TypeUpdateChatDraftMessage                                  = "updateChatDraftMessage"
	TypeUpdateChatEmojiStatus                                   = "updateChatEmojiStatus"
	TypeUpdateChatMessageSender                                 = "updateChatMessageSender"
	TypeUpdateChatMessageAutoDeleteTime                         = "updateChatMessageAutoDeleteTime"
	TypeUpdateChatNotificationSettings                          = "updateChatNotificationSettings"
	TypeUpdateChatPendingJoinRequests                           = "updateChatPendingJoinRequests"
	TypeUpdateChatReplyMarkup                                   = "updateChatReplyMarkup"
	TypeUpdateChatBackground                                    = "updateChatBackground"
	TypeUpdateChatTheme                                         = "updateChatTheme"
	TypeUpdateChatUnreadMentionCount                            = "updateChatUnreadMentionCount"
	TypeUpdateChatUnreadReactionCount                           = "updateChatUnreadReactionCount"
	TypeUpdateChatVideoChat                                     = "updateChatVideoChat"
	TypeUpdateChatDefaultDisableNotification                    = "updateChatDefaultDisableNotification"
	TypeUpdateChatHasProtectedContent                           = "updateChatHasProtectedContent"
	TypeUpdateChatIsTranslatable                                = "updateChatIsTranslatable"
	TypeUpdateChatIsMarkedAsUnread                              = "updateChatIsMarkedAsUnread"
	TypeUpdateChatViewAsTopics                                  = "updateChatViewAsTopics"
	TypeUpdateChatBlockList                                     = "updateChatBlockList"
	TypeUpdateChatHasScheduledMessages                          = "updateChatHasScheduledMessages"
	TypeUpdateChatFolders                                       = "updateChatFolders"
	TypeUpdateChatOnlineMemberCount                             = "updateChatOnlineMemberCount"
	TypeUpdateSavedMessagesTopic                                = "updateSavedMessagesTopic"
	TypeUpdateSavedMessagesTopicCount                           = "updateSavedMessagesTopicCount"
	TypeUpdateQuickReplyShortcut                                = "updateQuickReplyShortcut"
	TypeUpdateQuickReplyShortcutDeleted                         = "updateQuickReplyShortcutDeleted"
	TypeUpdateQuickReplyShortcuts                               = "updateQuickReplyShortcuts"
	TypeUpdateQuickReplyShortcutMessages                        = "updateQuickReplyShortcutMessages"
	TypeUpdateForumTopicInfo                                    = "updateForumTopicInfo"
	TypeUpdateScopeNotificationSettings                         = "updateScopeNotificationSettings"
	TypeUpdateReactionNotificationSettings                      = "updateReactionNotificationSettings"
	TypeUpdateNotification                                      = "updateNotification"
	TypeUpdateNotificationGroup                                 = "updateNotificationGroup"
	TypeUpdateActiveNotifications                               = "updateActiveNotifications"
	TypeUpdateHavePendingNotifications                          = "updateHavePendingNotifications"
	TypeUpdateDeleteMessages                                    = "updateDeleteMessages"
	TypeUpdateChatAction                                        = "updateChatAction"
	TypeUpdateUserStatus                                        = "updateUserStatus"
	TypeUpdateUser                                              = "updateUser"
	TypeUpdateBasicGroup                                        = "updateBasicGroup"
	TypeUpdateSupergroup                                        = "updateSupergroup"
	TypeUpdateSecretChat                                        = "updateSecretChat"
	TypeUpdateUserFullInfo                                      = "updateUserFullInfo"
	TypeUpdateBasicGroupFullInfo                                = "updateBasicGroupFullInfo"
	TypeUpdateSupergroupFullInfo                                = "updateSupergroupFullInfo"
	TypeUpdateServiceNotification                               = "updateServiceNotification"
	TypeUpdateFile                                              = "updateFile"
	TypeUpdateFileGenerationStart                               = "updateFileGenerationStart"
	TypeUpdateFileGenerationStop                                = "updateFileGenerationStop"
	TypeUpdateFileDownloads                                     = "updateFileDownloads"
	TypeUpdateFileAddedToDownloads                              = "updateFileAddedToDownloads"
	TypeUpdateFileDownload                                      = "updateFileDownload"
	TypeUpdateFileRemovedFromDownloads                          = "updateFileRemovedFromDownloads"
	TypeUpdateApplicationVerificationRequired                   = "updateApplicationVerificationRequired"
	TypeUpdateCall                                              = "updateCall"
	TypeUpdateGroupCall                                         = "updateGroupCall"
	TypeUpdateGroupCallParticipant                              = "updateGroupCallParticipant"
	TypeUpdateNewCallSignalingData                              = "updateNewCallSignalingData"
	TypeUpdateUserPrivacySettingRules                           = "updateUserPrivacySettingRules"
	TypeUpdateUnreadMessageCount                                = "updateUnreadMessageCount"
	TypeUpdateUnreadChatCount                                   = "updateUnreadChatCount"
	TypeUpdateStory                                             = "updateStory"
	TypeUpdateStoryDeleted                                      = "updateStoryDeleted"
	TypeUpdateStorySendSucceeded                                = "updateStorySendSucceeded"
	TypeUpdateStorySendFailed                                   = "updateStorySendFailed"
	TypeUpdateChatActiveStories                                 = "updateChatActiveStories"
	TypeUpdateStoryListChatCount                                = "updateStoryListChatCount"
	TypeUpdateStoryStealthMode                                  = "updateStoryStealthMode"
	TypeUpdateOption                                            = "updateOption"
	TypeUpdateStickerSet                                        = "updateStickerSet"
	TypeUpdateInstalledStickerSets                              = "updateInstalledStickerSets"
	TypeUpdateTrendingStickerSets                               = "updateTrendingStickerSets"
	TypeUpdateRecentStickers                                    = "updateRecentStickers"
	TypeUpdateFavoriteStickers                                  = "updateFavoriteStickers"
	TypeUpdateSavedAnimations                                   = "updateSavedAnimations"
	TypeUpdateSavedNotificationSounds                           = "updateSavedNotificationSounds"
	TypeUpdateDefaultBackground                                 = "updateDefaultBackground"
	TypeUpdateChatThemes                                        = "updateChatThemes"
	TypeUpdateAccentColors                                      = "updateAccentColors"
	TypeUpdateProfileAccentColors                               = "updateProfileAccentColors"
	TypeUpdateLanguagePackStrings                               = "updateLanguagePackStrings"
	TypeUpdateConnectionState                                   = "updateConnectionState"
	TypeUpdateTermsOfService                                    = "updateTermsOfService"
	TypeUpdateUnconfirmedSession                                = "updateUnconfirmedSession"
	TypeUpdateAttachmentMenuBots                                = "updateAttachmentMenuBots"
	TypeUpdateWebAppMessageSent                                 = "updateWebAppMessageSent"
	TypeUpdateActiveEmojiReactions                              = "updateActiveEmojiReactions"
	TypeUpdateAvailableMessageEffects                           = "updateAvailableMessageEffects"
	TypeUpdateDefaultReactionType                               = "updateDefaultReactionType"
	TypeUpdateSavedMessagesTags                                 = "updateSavedMessagesTags"
	TypeUpdateActiveLiveLocationMessages                        = "updateActiveLiveLocationMessages"
	TypeUpdateOwnedStarCount                                    = "updateOwnedStarCount"
	TypeUpdateChatRevenueAmount                                 = "updateChatRevenueAmount"
	TypeUpdateStarRevenueStatus                                 = "updateStarRevenueStatus"
	TypeUpdateSpeechRecognitionTrial                            = "updateSpeechRecognitionTrial"
	TypeUpdateDiceEmojis                                        = "updateDiceEmojis"
	TypeUpdateAnimatedEmojiMessageClicked                       = "updateAnimatedEmojiMessageClicked"
	TypeUpdateAnimationSearchParameters                         = "updateAnimationSearchParameters"
	TypeUpdateSuggestedActions                                  = "updateSuggestedActions"
	TypeUpdateSpeedLimitNotification                            = "updateSpeedLimitNotification"
	TypeUpdateContactCloseBirthdays                             = "updateContactCloseBirthdays"
	TypeUpdateAutosaveSettings                                  = "updateAutosaveSettings"
	TypeUpdateBusinessConnection                                = "updateBusinessConnection"
	TypeUpdateNewBusinessMessage                                = "updateNewBusinessMessage"
	TypeUpdateBusinessMessageEdited                             = "updateBusinessMessageEdited"
	TypeUpdateBusinessMessagesDeleted                           = "updateBusinessMessagesDeleted"
	TypeUpdateNewInlineQuery                                    = "updateNewInlineQuery"
	TypeUpdateNewChosenInlineResult                             = "updateNewChosenInlineResult"
	TypeUpdateNewCallbackQuery                                  = "updateNewCallbackQuery"
	TypeUpdateNewInlineCallbackQuery                            = "updateNewInlineCallbackQuery"
	TypeUpdateNewBusinessCallbackQuery                          = "updateNewBusinessCallbackQuery"
	TypeUpdateNewShippingQuery                                  = "updateNewShippingQuery"
	TypeUpdateNewPreCheckoutQuery                               = "updateNewPreCheckoutQuery"
	TypeUpdateNewCustomEvent                                    = "updateNewCustomEvent"
	TypeUpdateNewCustomQuery                                    = "updateNewCustomQuery"
	TypeUpdatePoll                                              = "updatePoll"
	TypeUpdatePollAnswer                                        = "updatePollAnswer"
	TypeUpdateChatMember                                        = "updateChatMember"
	TypeUpdateNewChatJoinRequest                                = "updateNewChatJoinRequest"
	TypeUpdateChatBoost                                         = "updateChatBoost"
	TypeUpdateMessageReaction                                   = "updateMessageReaction"
	TypeUpdateMessageReactions                                  = "updateMessageReactions"
	TypeUpdatePaidMediaPurchased                                = "updatePaidMediaPurchased"
	TypeUpdates                                                 = "updates"
	TypeLogStreamDefault                                        = "logStreamDefault"
	TypeLogStreamFile                                           = "logStreamFile"
	TypeLogStreamEmpty                                          = "logStreamEmpty"
	TypeLogVerbosityLevel                                       = "logVerbosityLevel"
	TypeLogTags                                                 = "logTags"
	TypeUserSupportInfo                                         = "userSupportInfo"
	TypeTestInt                                                 = "testInt"
	TypeTestString                                              = "testString"
	TypeTestBytes                                               = "testBytes"
	TypeTestVectorInt                                           = "testVectorInt"
	TypeTestVectorIntObject                                     = "testVectorIntObject"
	TypeTestVectorString                                        = "testVectorString"
	TypeTestVectorStringObject                                  = "testVectorStringObject"
)

// Provides information about the method by which an authentication code is delivered to the user
type AuthenticationCodeType interface {
	AuthenticationCodeTypeType() string
}

// Contains authentication data for an email address
type EmailAddressAuthentication interface {
	EmailAddressAuthenticationType() string
}

// Describes reset state of an email address
type EmailAddressResetState interface {
	EmailAddressResetStateType() string
}

// Represents the current authorization state of the TDLib client
type AuthorizationState interface {
	AuthorizationStateType() string
}

// Describes parameters to be used for device verification
type FirebaseDeviceVerificationParameters interface {
	FirebaseDeviceVerificationParametersType() string
}

// Points to a file
type InputFile interface {
	InputFileType() string
}

// Describes format of a thumbnail
type ThumbnailFormat interface {
	ThumbnailFormatType() string
}

// Part of the face, relative to which a mask is placed
type MaskPoint interface {
	MaskPointType() string
}

// Describes format of a sticker
type StickerFormat interface {
	StickerFormatType() string
}

// Describes type of sticker
type StickerType interface {
	StickerTypeType() string
}

// Contains full information about sticker type
type StickerFullType interface {
	StickerFullTypeType() string
}

// Describes the type of poll
type PollType interface {
	PollTypeType() string
}

// Represents the type of user. The following types are possible: regular users, deleted users and bots
type UserType interface {
	UserTypeType() string
}

// Describes conditions for sending of away messages by a Telegram Business account
type BusinessAwayMessageSchedule interface {
	BusinessAwayMessageScheduleType() string
}

// Describes type of sticker, which was used to create a chat photo
type ChatPhotoStickerType interface {
	ChatPhotoStickerTypeType() string
}

// Describes a photo to be set as a user profile or chat photo
type InputChatPhoto interface {
	InputChatPhotoType() string
}

// Describes type of subscription paid in Telegram Stars
type StarSubscriptionType interface {
	StarSubscriptionTypeType() string
}

// Describes direction of a transaction with Telegram Stars
type StarTransactionDirection interface {
	StarTransactionDirectionType() string
}

// Describes purpose of a transaction with a bot
type BotTransactionPurpose interface {
	BotTransactionPurposeType() string
}

// Describes purpose of a transaction with a supergroup or a channel
type ChatTransactionPurpose interface {
	ChatTransactionPurposeType() string
}

// Describes purpose of a transaction with a user
type UserTransactionPurpose interface {
	UserTransactionPurposeType() string
}

// Describes source or recipient of a transaction with Telegram Stars
type StarTransactionPartner interface {
	StarTransactionPartnerType() string
}

// Contains information about status of a user in a giveaway
type GiveawayParticipantStatus interface {
	GiveawayParticipantStatusType() string
}

// Contains information about a giveaway
type GiveawayInfo interface {
	GiveawayInfoType() string
}

// Contains information about a giveaway prize
type GiveawayPrize interface {
	GiveawayPrizeType() string
}

// Provides information about the status of a member in a chat
type ChatMemberStatus interface {
	ChatMemberStatusType() string
}

// Specifies the kind of chat members to return in searchChatMembers
type ChatMembersFilter interface {
	ChatMembersFilterType() string
}

// Specifies the kind of chat members to return in getSupergroupMembers
type SupergroupMembersFilter interface {
	SupergroupMembersFilterType() string
}

// Describes the type of chat to which points an invite link
type InviteLinkChatType interface {
	InviteLinkChatTypeType() string
}

// Describes the current secret chat state
type SecretChatState interface {
	SecretChatStateType() string
}

// Contains information about the sender of a message
type MessageSender interface {
	MessageSenderType() string
}

// Describes read date of a recent outgoing message in a private chat
type MessageReadDate interface {
	MessageReadDateType() string
}

// Contains information about the origin of a message
type MessageOrigin interface {
	MessageOriginType() string
}

// Describes type of message reaction
type ReactionType interface {
	ReactionTypeType() string
}

// Describes type of emoji effect
type MessageEffectType interface {
	MessageEffectTypeType() string
}

// Contains information about the sending state of the message
type MessageSendingState interface {
	MessageSendingStateType() string
}

// Contains information about the message or the story a message is replying to
type MessageReplyTo interface {
	MessageReplyToType() string
}

// Contains information about the message or the story to be replied
type InputMessageReplyTo interface {
	InputMessageReplyToType() string
}

// Describes source of a message
type MessageSource interface {
	MessageSourceType() string
}

// Describes result of sponsored message report
type ReportChatSponsoredMessageResult interface {
	ReportChatSponsoredMessageResultType() string
}

// Describes the types of chats to which notification settings are relevant
type NotificationSettingsScope interface {
	NotificationSettingsScopeType() string
}

// Describes sources of reactions for which notifications will be shown
type ReactionNotificationSource interface {
	ReactionNotificationSourceType() string
}

// Describes the type of chat
type ChatType interface {
	ChatTypeType() string
}

// Describes a list of chats
type ChatList interface {
	ChatListType() string
}

// Describes a reason why an external chat is shown in a chat list
type ChatSource interface {
	ChatSourceType() string
}

// Describes reactions available in the chat
type ChatAvailableReactions interface {
	ChatAvailableReactionsType() string
}

// Describes type of public chat
type PublicChatType interface {
	PublicChatTypeType() string
}

// Describes actions which must be possible to do through a chat action bar
type ChatActionBar interface {
	ChatActionBarType() string
}

// Describes a keyboard button type
type KeyboardButtonType interface {
	KeyboardButtonTypeType() string
}

// Describes the type of inline keyboard button
type InlineKeyboardButtonType interface {
	InlineKeyboardButtonTypeType() string
}

// Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots
type ReplyMarkup interface {
	ReplyMarkupType() string
}

// Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl
type LoginUrlInfo interface {
	LoginUrlInfoType() string
}

// Describes mode in which a Web App is opened
type WebAppOpenMode interface {
	WebAppOpenModeType() string
}

// Describes type of Saved Messages topic
type SavedMessagesTopicType interface {
	SavedMessagesTopicTypeType() string
}

// Describes a formatted text object
type RichText interface {
	RichTextType() string
}

// Describes a horizontal alignment of a table cell content
type PageBlockHorizontalAlignment interface {
	PageBlockHorizontalAlignmentType() string
}

// Describes a Vertical alignment of a table cell content
type PageBlockVerticalAlignment interface {
	PageBlockVerticalAlignmentType() string
}

// Describes a block of an instant view for a web page
type PageBlock interface {
	PageBlockType() string
}

// Describes a media from a link preview album
type LinkPreviewAlbumMedia interface {
	LinkPreviewAlbumMediaType() string
}

// Describes type of link preview
type LinkPreviewType interface {
	LinkPreviewTypeType() string
}

// Describes a collectible item that can be purchased at https://fragment.com
type CollectibleItemType interface {
	CollectibleItemTypeType() string
}

// Contains information about the payment method chosen by the user
type InputCredentials interface {
	InputCredentialsType() string
}

// Contains information about a payment provider
type PaymentProvider interface {
	PaymentProviderType() string
}

// Describes type of payment form
type PaymentFormType interface {
	PaymentFormTypeType() string
}

// Describes type of successful payment
type PaymentReceiptType interface {
	PaymentReceiptTypeType() string
}

// Describes an invoice to process
type InputInvoice interface {
	InputInvoiceType() string
}

// Describes a paid media
type PaidMedia interface {
	PaidMediaType() string
}

// Contains the type of Telegram Passport element
type PassportElementType interface {
	PassportElementTypeType() string
}

// Contains information about a Telegram Passport element
type PassportElement interface {
	PassportElementType() string
}

// Contains information about a Telegram Passport element to be saved
type InputPassportElement interface {
	InputPassportElementType() string
}

// Contains the description of an error in a Telegram Passport element
type PassportElementErrorSource interface {
	PassportElementErrorSourceType() string
}

// Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementErrorSource interface {
	InputPassportElementErrorSourceType() string
}

// Contains the content of a message
type MessageContent interface {
	MessageContentType() string
}

// Represents a part of the text which must be formatted differently
type TextEntityType interface {
	TextEntityTypeType() string
}

// Describes type of paid media to sent
type InputPaidMediaType interface {
	InputPaidMediaTypeType() string
}

// Contains information about the time when a scheduled message will be sent
type MessageSchedulingState interface {
	MessageSchedulingStateType() string
}

// Describes when a message will be self-destructed
type MessageSelfDestructType interface {
	MessageSelfDestructTypeType() string
}

// The content of a message to send
type InputMessageContent interface {
	InputMessageContentType() string
}

// Represents a filter for message search results
type SearchMessagesFilter interface {
	SearchMessagesFilterType() string
}

// Describes the different types of activity in a chat
type ChatAction interface {
	ChatActionType() string
}

// Describes the last time the user was online
type UserStatus interface {
	UserStatusType() string
}

// Describes source of stickers for an emoji category
type EmojiCategorySource interface {
	EmojiCategorySourceType() string
}

// Describes type of emoji category
type EmojiCategoryType interface {
	EmojiCategoryTypeType() string
}

// Describes type of clickable area on a story media
type StoryAreaType interface {
	StoryAreaTypeType() string
}

// Describes type of clickable area on a story media to be added
type InputStoryAreaType interface {
	InputStoryAreaTypeType() string
}

// Contains the content of a story
type StoryContent interface {
	StoryContentType() string
}

// The content of a story to send
type InputStoryContent interface {
	InputStoryContentType() string
}

// Describes a list of stories
type StoryList interface {
	StoryListType() string
}

// Contains information about the origin of a story that was reposted
type StoryOrigin interface {
	StoryOriginType() string
}

// Describes type of interaction with a story
type StoryInteractionType interface {
	StoryInteractionTypeType() string
}

// Describes a public forward or repost of a story
type PublicForward interface {
	PublicForwardType() string
}

// Describes source of a chat boost
type ChatBoostSource interface {
	ChatBoostSourceType() string
}

// Describes the reason why a code needs to be re-sent
type ResendCodeReason interface {
	ResendCodeReasonType() string
}

// Describes the reason why a call was discarded
type CallDiscardReason interface {
	CallDiscardReasonType() string
}

// Describes the type of call server
type CallServerType interface {
	CallServerTypeType() string
}

// Describes the current call state
type CallState interface {
	CallStateType() string
}

// Describes the quality of a group call video
type GroupCallVideoQuality interface {
	GroupCallVideoQualityType() string
}

// Describes the exact type of problem with a call
type CallProblem interface {
	CallProblemType() string
}

// Contains settings for Firebase Authentication in the official applications
type FirebaseAuthenticationSettings interface {
	FirebaseAuthenticationSettingsType() string
}

// Describes why the current user can't add reactions to the message, despite some other users can
type ReactionUnavailabilityReason interface {
	ReactionUnavailabilityReasonType() string
}

// Contains animated stickers which must be used for dice animation rendering
type DiceStickers interface {
	DiceStickersType() string
}

// Describes result of speech recognition in a voice note
type SpeechRecognitionResult interface {
	SpeechRecognitionResultType() string
}

// Describes a reason why a bot was allowed to write messages to the current user
type BotWriteAccessAllowReason interface {
	BotWriteAccessAllowReasonType() string
}

// Describes the target chat to be opened
type TargetChat interface {
	TargetChatType() string
}

// Represents a single result of an inline query; for bots only
type InputInlineQueryResult interface {
	InputInlineQueryResultType() string
}

// Represents a single result of an inline query
type InlineQueryResult interface {
	InlineQueryResultType() string
}

// Represents type of button in results of inline query
type InlineQueryResultsButtonType interface {
	InlineQueryResultsButtonTypeType() string
}

// Represents a payload of a callback query
type CallbackQueryPayload interface {
	CallbackQueryPayloadType() string
}

// Represents a chat event
type ChatEventAction interface {
	ChatEventActionType() string
}

// Represents the value of a string in a language pack
type LanguagePackStringValue interface {
	LanguagePackStringValueType() string
}

// Describes type of limit, increased for Premium users
type PremiumLimitType interface {
	PremiumLimitTypeType() string
}

// Describes a feature available to Premium users
type PremiumFeature interface {
	PremiumFeatureType() string
}

// Describes a feature available to Business user accounts
type BusinessFeature interface {
	BusinessFeatureType() string
}

// Describes a story feature available to Premium users
type PremiumStoryFeature interface {
	PremiumStoryFeatureType() string
}

// Describes a source from which the Premium features screen is opened
type PremiumSource interface {
	PremiumSourceType() string
}

// Describes a purpose of an in-store payment
type StorePaymentPurpose interface {
	StorePaymentPurposeType() string
}

// Describes a purpose of a payment toward Telegram
type TelegramPaymentPurpose interface {
	TelegramPaymentPurposeType() string
}

// Represents a data needed to subscribe for push notifications through registerDevice method. To use specific push notification service, the correct application platform must be specified and a valid server authentication data must be uploaded at https://my.telegram.org
type DeviceToken interface {
	DeviceTokenType() string
}

// Describes a fill of a background
type BackgroundFill interface {
	BackgroundFillType() string
}

// Describes the type of background
type BackgroundType interface {
	BackgroundTypeType() string
}

// Contains information about background to set
type InputBackground interface {
	InputBackgroundType() string
}

// Represents result of checking whether the current user can send a story in the specific chat
type CanSendStoryResult interface {
	CanSendStoryResultType() string
}

// Represents result of checking whether the current session can be used to transfer a chat ownership to another user
type CanTransferOwnershipResult interface {
	CanTransferOwnershipResultType() string
}

// Represents result of checking whether a username can be set for a chat
type CheckChatUsernameResult interface {
	CheckChatUsernameResultType() string
}

// Represents result of checking whether a name can be used for a new sticker set
type CheckStickerSetNameResult interface {
	CheckStickerSetNameResultType() string
}

// Represents result of 2-step verification password reset
type ResetPasswordResult interface {
	ResetPasswordResultType() string
}

// Contains information about a file with messages exported from another app
type MessageFileType interface {
	MessageFileTypeType() string
}

// Contains content of a push message notification
type PushMessageContent interface {
	PushMessageContentType() string
}

// Contains detailed information about a notification
type NotificationType interface {
	NotificationTypeType() string
}

// Describes the type of notifications in a notification group
type NotificationGroupType interface {
	NotificationGroupTypeType() string
}

// Represents the value of an option
type OptionValue interface {
	OptionValueType() string
}

// Represents a JSON value
type JsonValue interface {
	JsonValueType() string
}

// Describes privacy settings of a story
type StoryPrivacySettings interface {
	StoryPrivacySettingsType() string
}

// Represents a single rule for managing user privacy settings
type UserPrivacySettingRule interface {
	UserPrivacySettingRuleType() string
}

// Describes available user privacy settings
type UserPrivacySetting interface {
	UserPrivacySettingType() string
}

// Describes result of canSendMessageToUser
type CanSendMessageToUserResult interface {
	CanSendMessageToUserResultType() string
}

// Represents the type of session
type SessionType interface {
	SessionTypeType() string
}

// Describes the reason why a chat is reported
type ReportReason interface {
	ReportReasonType() string
}

// Describes result of chat report
type ReportChatResult interface {
	ReportChatResultType() string
}

// Describes result of story report
type ReportStoryResult interface {
	ReportStoryResultType() string
}

// Describes an internal https://t.me or tg: link, which must be processed by the application in a special way
type InternalLinkType interface {
	InternalLinkTypeType() string
}

// Describes type of block list
type BlockList interface {
	BlockListType() string
}

// Represents the type of file
type FileType interface {
	FileTypeType() string
}

// Represents the type of network
type NetworkType interface {
	NetworkTypeType() string
}

// Contains statistics about network usage
type NetworkStatisticsEntry interface {
	NetworkStatisticsEntryType() string
}

// Describes scope of autosave settings
type AutosaveSettingsScope interface {
	AutosaveSettingsScopeType() string
}

// Describes the current state of the connection to Telegram servers
type ConnectionState interface {
	ConnectionStateType() string
}

// Represents the categories of chats for which a list of frequently used chats can be retrieved
type TopChatCategory interface {
	TopChatCategoryType() string
}

// Describes the type of URL linking to an internal Telegram entity
type TMeUrlType interface {
	TMeUrlTypeType() string
}

// Describes an action suggested to the current user
type SuggestedAction interface {
	SuggestedActionType() string
}

// Describes the way the text needs to be parsed for text entities
type TextParseMode interface {
	TextParseModeType() string
}

// Describes the type of proxy server
type ProxyType interface {
	ProxyTypeType() string
}

// Describes a statistical graph
type StatisticalGraph interface {
	StatisticalGraphType() string
}

// Describes type of object, for which statistics are provided
type ChatStatisticsObjectType interface {
	ChatStatisticsObjectTypeType() string
}

// Contains a detailed statistics about a chat
type ChatStatistics interface {
	ChatStatisticsType() string
}

// Describes state of a revenue withdrawal
type RevenueWithdrawalState interface {
	RevenueWithdrawalStateType() string
}

// Describes type of transaction for revenue earned from sponsored messages in a chat
type ChatRevenueTransactionType interface {
	ChatRevenueTransactionTypeType() string
}

// Represents a vector path command
type VectorPathCommand interface {
	VectorPathCommandType() string
}

// Represents the scope to which bot commands are relevant
type BotCommandScope interface {
	BotCommandScopeType() string
}

// Describes type of the request for which a code is sent to a phone number
type PhoneNumberCodeType interface {
	PhoneNumberCodeTypeType() string
}

// Contains notifications about data changes
type Update interface {
	UpdateType() string
}

// Describes a stream to which TDLib internal log is written
type LogStream interface {
	LogStreamType() string
}

// An object of this type can be returned on every function call, in case of an error
type Error struct {
	meta
	// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
	Code int32 `json:"code"`
	// Error message; subject to future changes
	Message string `json:"message"`
}

func (entity *Error) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Error

	return json.Marshal((*stub)(entity))
}

func (*Error) GetClass() string {
	return ClassError
}

func (*Error) GetType() string {
	return TypeError
}

// An object of this type is returned on a successful function call for certain functions
type Ok struct {
	meta
}

func (entity *Ok) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Ok

	return json.Marshal((*stub)(entity))
}

func (*Ok) GetClass() string {
	return ClassOk
}

func (*Ok) GetType() string {
	return TypeOk
}

// A digit-only authentication code is delivered via a private Telegram message, which can be viewed from another active session
type AuthenticationCodeTypeTelegramMessage struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeTelegramMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeTelegramMessage

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeTelegramMessage) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeTelegramMessage) GetType() string {
	return TypeAuthenticationCodeTypeTelegramMessage
}

func (*AuthenticationCodeTypeTelegramMessage) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeTelegramMessage
}

// A digit-only authentication code is delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code
type AuthenticationCodeTypeSms struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeSms) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeSms

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeSms) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeSms) GetType() string {
	return TypeAuthenticationCodeTypeSms
}

func (*AuthenticationCodeTypeSms) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeSms
}

// An authentication code is a word delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code
type AuthenticationCodeTypeSmsWord struct {
	meta
	// The first letters of the word if known
	FirstLetter string `json:"first_letter"`
}

func (entity *AuthenticationCodeTypeSmsWord) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeSmsWord

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeSmsWord) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeSmsWord) GetType() string {
	return TypeAuthenticationCodeTypeSmsWord
}

func (*AuthenticationCodeTypeSmsWord) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeSmsWord
}

// An authentication code is a phrase from multiple words delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code
type AuthenticationCodeTypeSmsPhrase struct {
	meta
	// The first word of the phrase if known
	FirstWord string `json:"first_word"`
}

func (entity *AuthenticationCodeTypeSmsPhrase) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeSmsPhrase

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeSmsPhrase) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeSmsPhrase) GetType() string {
	return TypeAuthenticationCodeTypeSmsPhrase
}

func (*AuthenticationCodeTypeSmsPhrase) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeSmsPhrase
}

// A digit-only authentication code is delivered via a phone call to the specified phone number
type AuthenticationCodeTypeCall struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeCall) GetType() string {
	return TypeAuthenticationCodeTypeCall
}

func (*AuthenticationCodeTypeCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeCall
}

// An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically
type AuthenticationCodeTypeFlashCall struct {
	meta
	// Pattern of the phone number from which the call will be made
	Pattern string `json:"pattern"`
}

func (entity *AuthenticationCodeTypeFlashCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFlashCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFlashCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFlashCall) GetType() string {
	return TypeAuthenticationCodeTypeFlashCall
}

func (*AuthenticationCodeTypeFlashCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFlashCall
}

// An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user
type AuthenticationCodeTypeMissedCall struct {
	meta
	// Prefix of the phone number from which the call will be made
	PhoneNumberPrefix string `json:"phone_number_prefix"`
	// Number of digits in the code, excluding the prefix
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeMissedCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeMissedCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeMissedCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeMissedCall) GetType() string {
	return TypeAuthenticationCodeTypeMissedCall
}

func (*AuthenticationCodeTypeMissedCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeMissedCall
}

// A digit-only authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT
type AuthenticationCodeTypeFragment struct {
	meta
	// URL to open to receive the code
	Url string `json:"url"`
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeFragment) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFragment

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFragment) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFragment) GetType() string {
	return TypeAuthenticationCodeTypeFragment
}

func (*AuthenticationCodeTypeFragment) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFragment
}

// A digit-only authentication code is delivered via Firebase Authentication to the official Android application
type AuthenticationCodeTypeFirebaseAndroid struct {
	meta
	// Parameters to be used for device verification
	DeviceVerificationParameters FirebaseDeviceVerificationParameters `json:"device_verification_parameters"`
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeFirebaseAndroid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFirebaseAndroid

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFirebaseAndroid) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFirebaseAndroid) GetType() string {
	return TypeAuthenticationCodeTypeFirebaseAndroid
}

func (*AuthenticationCodeTypeFirebaseAndroid) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFirebaseAndroid
}

func (authenticationCodeTypeFirebaseAndroid *AuthenticationCodeTypeFirebaseAndroid) UnmarshalJSON(data []byte) error {
	var tmp struct {
		DeviceVerificationParameters json.RawMessage `json:"device_verification_parameters"`
		Length                       int32           `json:"length"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	authenticationCodeTypeFirebaseAndroid.Length = tmp.Length

	fieldDeviceVerificationParameters, _ := UnmarshalFirebaseDeviceVerificationParameters(tmp.DeviceVerificationParameters)
	authenticationCodeTypeFirebaseAndroid.DeviceVerificationParameters = fieldDeviceVerificationParameters

	return nil
}

// A digit-only authentication code is delivered via Firebase Authentication to the official iOS application
type AuthenticationCodeTypeFirebaseIos struct {
	meta
	// Receipt of successful application token validation to compare with receipt from push notification
	Receipt string `json:"receipt"`
	// Time after the next authentication method is expected to be used if verification push notification isn't received, in seconds
	PushTimeout int32 `json:"push_timeout"`
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeFirebaseIos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFirebaseIos

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFirebaseIos) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFirebaseIos) GetType() string {
	return TypeAuthenticationCodeTypeFirebaseIos
}

func (*AuthenticationCodeTypeFirebaseIos) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFirebaseIos
}

// Information about the authentication code that was sent
type AuthenticationCodeInfo struct {
	meta
	// A phone number that is being authenticated
	PhoneNumber string `json:"phone_number"`
	// The way the code was sent to the user
	Type AuthenticationCodeType `json:"type"`
	// The way the next code will be sent to the user; may be null
	NextType AuthenticationCodeType `json:"next_type"`
	// Timeout before the code can be re-sent, in seconds
	Timeout int32 `json:"timeout"`
}

func (entity *AuthenticationCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeInfo) GetClass() string {
	return ClassAuthenticationCodeInfo
}

func (*AuthenticationCodeInfo) GetType() string {
	return TypeAuthenticationCodeInfo
}

func (authenticationCodeInfo *AuthenticationCodeInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PhoneNumber string          `json:"phone_number"`
		Type        json.RawMessage `json:"type"`
		NextType    json.RawMessage `json:"next_type"`
		Timeout     int32           `json:"timeout"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	authenticationCodeInfo.PhoneNumber = tmp.PhoneNumber
	authenticationCodeInfo.Timeout = tmp.Timeout

	fieldType, _ := UnmarshalAuthenticationCodeType(tmp.Type)
	authenticationCodeInfo.Type = fieldType

	fieldNextType, _ := UnmarshalAuthenticationCodeType(tmp.NextType)
	authenticationCodeInfo.NextType = fieldNextType

	return nil
}

// Information about the email address authentication code that was sent
type EmailAddressAuthenticationCodeInfo struct {
	meta
	// Pattern of the email address to which an authentication code was sent
	EmailAddressPattern string `json:"email_address_pattern"`
	// Length of the code; 0 if unknown
	Length int32 `json:"length"`
}

func (entity *EmailAddressAuthenticationCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationCodeInfo) GetClass() string {
	return ClassEmailAddressAuthenticationCodeInfo
}

func (*EmailAddressAuthenticationCodeInfo) GetType() string {
	return TypeEmailAddressAuthenticationCodeInfo
}

// An authentication code delivered to a user's email address
type EmailAddressAuthenticationCode struct {
	meta
	// The code
	Code string `json:"code"`
}

func (entity *EmailAddressAuthenticationCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationCode

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationCode) GetClass() string {
	return ClassEmailAddressAuthentication
}

func (*EmailAddressAuthenticationCode) GetType() string {
	return TypeEmailAddressAuthenticationCode
}

func (*EmailAddressAuthenticationCode) EmailAddressAuthenticationType() string {
	return TypeEmailAddressAuthenticationCode
}

// An authentication token received through Apple ID
type EmailAddressAuthenticationAppleId struct {
	meta
	// The token
	Token string `json:"token"`
}

func (entity *EmailAddressAuthenticationAppleId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationAppleId

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationAppleId) GetClass() string {
	return ClassEmailAddressAuthentication
}

func (*EmailAddressAuthenticationAppleId) GetType() string {
	return TypeEmailAddressAuthenticationAppleId
}

func (*EmailAddressAuthenticationAppleId) EmailAddressAuthenticationType() string {
	return TypeEmailAddressAuthenticationAppleId
}

// An authentication token received through Google ID
type EmailAddressAuthenticationGoogleId struct {
	meta
	// The token
	Token string `json:"token"`
}

func (entity *EmailAddressAuthenticationGoogleId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationGoogleId

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationGoogleId) GetClass() string {
	return ClassEmailAddressAuthentication
}

func (*EmailAddressAuthenticationGoogleId) GetType() string {
	return TypeEmailAddressAuthenticationGoogleId
}

func (*EmailAddressAuthenticationGoogleId) EmailAddressAuthenticationType() string {
	return TypeEmailAddressAuthenticationGoogleId
}

// Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number
type EmailAddressResetStateAvailable struct {
	meta
	// Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
	WaitPeriod int32 `json:"wait_period"`
}

func (entity *EmailAddressResetStateAvailable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressResetStateAvailable

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressResetStateAvailable) GetClass() string {
	return ClassEmailAddressResetState
}

func (*EmailAddressResetStateAvailable) GetType() string {
	return TypeEmailAddressResetStateAvailable
}

func (*EmailAddressResetStateAvailable) EmailAddressResetStateType() string {
	return TypeEmailAddressResetStateAvailable
}

// Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible
type EmailAddressResetStatePending struct {
	meta
	// Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
	ResetIn int32 `json:"reset_in"`
}

func (entity *EmailAddressResetStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressResetStatePending

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressResetStatePending) GetClass() string {
	return ClassEmailAddressResetState
}

func (*EmailAddressResetStatePending) GetType() string {
	return TypeEmailAddressResetStatePending
}

func (*EmailAddressResetStatePending) EmailAddressResetStateType() string {
	return TypeEmailAddressResetStatePending
}

// Represents a part of the text that needs to be formatted in some unusual way
type TextEntity struct {
	meta
	// Offset of the entity, in UTF-16 code units
	Offset int32 `json:"offset"`
	// Length of the entity, in UTF-16 code units
	Length int32 `json:"length"`
	// Type of the entity
	Type TextEntityType `json:"type"`
}

func (entity *TextEntity) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntity

	return json.Marshal((*stub)(entity))
}

func (*TextEntity) GetClass() string {
	return ClassTextEntity
}

func (*TextEntity) GetType() string {
	return TypeTextEntity
}

func (textEntity *TextEntity) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Offset int32           `json:"offset"`
		Length int32           `json:"length"`
		Type   json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	textEntity.Offset = tmp.Offset
	textEntity.Length = tmp.Length

	fieldType, _ := UnmarshalTextEntityType(tmp.Type)
	textEntity.Type = fieldType

	return nil
}

// Contains a list of text entities
type TextEntities struct {
	meta
	// List of text entities
	Entities []*TextEntity `json:"entities"`
}

func (entity *TextEntities) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntities

	return json.Marshal((*stub)(entity))
}

func (*TextEntities) GetClass() string {
	return ClassTextEntities
}

func (*TextEntities) GetType() string {
	return TypeTextEntities
}

// A text with some entities
type FormattedText struct {
	meta
	// The text
	Text string `json:"text"`
	// Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
	Entities []*TextEntity `json:"entities"`
}

func (entity *FormattedText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FormattedText

	return json.Marshal((*stub)(entity))
}

func (*FormattedText) GetClass() string {
	return ClassFormattedText
}

func (*FormattedText) GetType() string {
	return TypeFormattedText
}

// Contains Telegram terms of service
type TermsOfService struct {
	meta
	// Text of the terms of service
	Text *FormattedText `json:"text"`
	// The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
	MinUserAge int32 `json:"min_user_age"`
	// True, if a blocking popup with terms of service must be shown to the user
	ShowPopup bool `json:"show_popup"`
}

func (entity *TermsOfService) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TermsOfService

	return json.Marshal((*stub)(entity))
}

func (*TermsOfService) GetClass() string {
	return ClassTermsOfService
}

func (*TermsOfService) GetType() string {
	return TypeTermsOfService
}

// Initialization parameters are needed. Call setTdlibParameters to provide them
type AuthorizationStateWaitTdlibParameters struct {
	meta
}

func (entity *AuthorizationStateWaitTdlibParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitTdlibParameters

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitTdlibParameters) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitTdlibParameters) GetType() string {
	return TypeAuthorizationStateWaitTdlibParameters
}

func (*AuthorizationStateWaitTdlibParameters) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitTdlibParameters
}

// TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
type AuthorizationStateWaitPhoneNumber struct {
	meta
}

func (entity *AuthorizationStateWaitPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitPhoneNumber) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitPhoneNumber) GetType() string {
	return TypeAuthorizationStateWaitPhoneNumber
}

func (*AuthorizationStateWaitPhoneNumber) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitPhoneNumber
}

// TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed
type AuthorizationStateWaitEmailAddress struct {
	meta
	// True, if authorization through Apple ID is allowed
	AllowAppleId bool `json:"allow_apple_id"`
	// True, if authorization through Google ID is allowed
	AllowGoogleId bool `json:"allow_google_id"`
}

func (entity *AuthorizationStateWaitEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitEmailAddress) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitEmailAddress) GetType() string {
	return TypeAuthorizationStateWaitEmailAddress
}

func (*AuthorizationStateWaitEmailAddress) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitEmailAddress
}

// TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code
type AuthorizationStateWaitEmailCode struct {
	meta
	// True, if authorization through Apple ID is allowed
	AllowAppleId bool `json:"allow_apple_id"`
	// True, if authorization through Google ID is allowed
	AllowGoogleId bool `json:"allow_google_id"`
	// Information about the sent authentication code
	CodeInfo *EmailAddressAuthenticationCodeInfo `json:"code_info"`
	// Reset state of the email address; may be null if the email address can't be reset
	EmailAddressResetState EmailAddressResetState `json:"email_address_reset_state"`
}

func (entity *AuthorizationStateWaitEmailCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitEmailCode

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitEmailCode) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitEmailCode) GetType() string {
	return TypeAuthorizationStateWaitEmailCode
}

func (*AuthorizationStateWaitEmailCode) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitEmailCode
}

func (authorizationStateWaitEmailCode *AuthorizationStateWaitEmailCode) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AllowAppleId           bool                                `json:"allow_apple_id"`
		AllowGoogleId          bool                                `json:"allow_google_id"`
		CodeInfo               *EmailAddressAuthenticationCodeInfo `json:"code_info"`
		EmailAddressResetState json.RawMessage                     `json:"email_address_reset_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	authorizationStateWaitEmailCode.AllowAppleId = tmp.AllowAppleId
	authorizationStateWaitEmailCode.AllowGoogleId = tmp.AllowGoogleId
	authorizationStateWaitEmailCode.CodeInfo = tmp.CodeInfo

	fieldEmailAddressResetState, _ := UnmarshalEmailAddressResetState(tmp.EmailAddressResetState)
	authorizationStateWaitEmailCode.EmailAddressResetState = fieldEmailAddressResetState

	return nil
}

// TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code
type AuthorizationStateWaitCode struct {
	meta
	// Information about the authorization code that was sent
	CodeInfo *AuthenticationCodeInfo `json:"code_info"`
}

func (entity *AuthorizationStateWaitCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitCode

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitCode) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitCode) GetType() string {
	return TypeAuthorizationStateWaitCode
}

func (*AuthorizationStateWaitCode) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitCode
}

// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
type AuthorizationStateWaitOtherDeviceConfirmation struct {
	meta
	// A tg:// URL for the QR code. The link will be updated frequently
	Link string `json:"link"`
}

func (entity *AuthorizationStateWaitOtherDeviceConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitOtherDeviceConfirmation

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) GetType() string {
	return TypeAuthorizationStateWaitOtherDeviceConfirmation
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitOtherDeviceConfirmation
}

// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data
type AuthorizationStateWaitRegistration struct {
	meta
	// Telegram terms of service
	TermsOfService *TermsOfService `json:"terms_of_service"`
}

func (entity *AuthorizationStateWaitRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitRegistration

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitRegistration) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitRegistration) GetType() string {
	return TypeAuthorizationStateWaitRegistration
}

func (*AuthorizationStateWaitRegistration) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitRegistration
}

// The user has been authorized, but needs to enter a 2-step verification password to start using the application. Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week
type AuthorizationStateWaitPassword struct {
	meta
	// Hint for the password; may be empty
	PasswordHint string `json:"password_hint"`
	// True, if a recovery email address has been set up
	HasRecoveryEmailAddress bool `json:"has_recovery_email_address"`
	// True, if some Telegram Passport elements were saved
	HasPassportData bool `json:"has_passport_data"`
	// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
	RecoveryEmailAddressPattern string `json:"recovery_email_address_pattern"`
}

func (entity *AuthorizationStateWaitPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitPassword

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitPassword) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitPassword) GetType() string {
	return TypeAuthorizationStateWaitPassword
}

func (*AuthorizationStateWaitPassword) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitPassword
}

// The user has been successfully authorized. TDLib is now ready to answer general requests
type AuthorizationStateReady struct {
	meta
}

func (entity *AuthorizationStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateReady

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateReady) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateReady) GetType() string {
	return TypeAuthorizationStateReady
}

func (*AuthorizationStateReady) AuthorizationStateType() string {
	return TypeAuthorizationStateReady
}

// The user is currently logging out
type AuthorizationStateLoggingOut struct {
	meta
}

func (entity *AuthorizationStateLoggingOut) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateLoggingOut

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateLoggingOut) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateLoggingOut) GetType() string {
	return TypeAuthorizationStateLoggingOut
}

func (*AuthorizationStateLoggingOut) AuthorizationStateType() string {
	return TypeAuthorizationStateLoggingOut
}

// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
type AuthorizationStateClosing struct {
	meta
}

func (entity *AuthorizationStateClosing) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateClosing

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateClosing) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateClosing) GetType() string {
	return TypeAuthorizationStateClosing
}

func (*AuthorizationStateClosing) AuthorizationStateType() string {
	return TypeAuthorizationStateClosing
}

// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one must create a new instance of the TDLib client
type AuthorizationStateClosed struct {
	meta
}

func (entity *AuthorizationStateClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateClosed

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateClosed) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateClosed) GetType() string {
	return TypeAuthorizationStateClosed
}

func (*AuthorizationStateClosed) AuthorizationStateType() string {
	return TypeAuthorizationStateClosed
}

// Device verification must be performed with the SafetyNet Attestation API
type FirebaseDeviceVerificationParametersSafetyNet struct {
	meta
	// Nonce to pass to the SafetyNet Attestation API
	Nonce []byte `json:"nonce"`
}

func (entity *FirebaseDeviceVerificationParametersSafetyNet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FirebaseDeviceVerificationParametersSafetyNet

	return json.Marshal((*stub)(entity))
}

func (*FirebaseDeviceVerificationParametersSafetyNet) GetClass() string {
	return ClassFirebaseDeviceVerificationParameters
}

func (*FirebaseDeviceVerificationParametersSafetyNet) GetType() string {
	return TypeFirebaseDeviceVerificationParametersSafetyNet
}

func (*FirebaseDeviceVerificationParametersSafetyNet) FirebaseDeviceVerificationParametersType() string {
	return TypeFirebaseDeviceVerificationParametersSafetyNet
}

// Device verification must be performed with the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic)
type FirebaseDeviceVerificationParametersPlayIntegrity struct {
	meta
	// Base64url-encoded nonce to pass to the Play Integrity API
	Nonce string `json:"nonce"`
	// Cloud project number to pass to the Play Integrity API
	CloudProjectNumber JsonInt64 `json:"cloud_project_number"`
}

func (entity *FirebaseDeviceVerificationParametersPlayIntegrity) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FirebaseDeviceVerificationParametersPlayIntegrity

	return json.Marshal((*stub)(entity))
}

func (*FirebaseDeviceVerificationParametersPlayIntegrity) GetClass() string {
	return ClassFirebaseDeviceVerificationParameters
}

func (*FirebaseDeviceVerificationParametersPlayIntegrity) GetType() string {
	return TypeFirebaseDeviceVerificationParametersPlayIntegrity
}

func (*FirebaseDeviceVerificationParametersPlayIntegrity) FirebaseDeviceVerificationParametersType() string {
	return TypeFirebaseDeviceVerificationParametersPlayIntegrity
}

// Represents the current state of 2-step verification
type PasswordState struct {
	meta
	// True, if a 2-step verification password is set
	HasPassword bool `json:"has_password"`
	// Hint for the password; may be empty
	PasswordHint string `json:"password_hint"`
	// True, if a recovery email is set
	HasRecoveryEmailAddress bool `json:"has_recovery_email_address"`
	// True, if some Telegram Passport elements were saved
	HasPassportData bool `json:"has_passport_data"`
	// Information about the recovery email address to which the confirmation email was sent; may be null
	RecoveryEmailAddressCodeInfo *EmailAddressAuthenticationCodeInfo `json:"recovery_email_address_code_info"`
	// Pattern of the email address set up for logging in
	LoginEmailAddressPattern string `json:"login_email_address_pattern"`
	// If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
	PendingResetDate int32 `json:"pending_reset_date"`
}

func (entity *PasswordState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PasswordState

	return json.Marshal((*stub)(entity))
}

func (*PasswordState) GetClass() string {
	return ClassPasswordState
}

func (*PasswordState) GetType() string {
	return TypePasswordState
}

// Contains information about the current recovery email address
type RecoveryEmailAddress struct {
	meta
	// Recovery email address
	RecoveryEmailAddress string `json:"recovery_email_address"`
}

func (entity *RecoveryEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecoveryEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*RecoveryEmailAddress) GetClass() string {
	return ClassRecoveryEmailAddress
}

func (*RecoveryEmailAddress) GetType() string {
	return TypeRecoveryEmailAddress
}

// Returns information about the availability of a temporary password, which can be used for payments
type TemporaryPasswordState struct {
	meta
	// True, if a temporary password is available
	HasPassword bool `json:"has_password"`
	// Time left before the temporary password expires, in seconds
	ValidFor int32 `json:"valid_for"`
}

func (entity *TemporaryPasswordState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TemporaryPasswordState

	return json.Marshal((*stub)(entity))
}

func (*TemporaryPasswordState) GetClass() string {
	return ClassTemporaryPasswordState
}

func (*TemporaryPasswordState) GetType() string {
	return TypeTemporaryPasswordState
}

// Represents a local file
type LocalFile struct {
	meta
	// Local path to the locally available file part; may be empty
	Path string `json:"path"`
	// True, if it is possible to download or generate the file
	CanBeDownloaded bool `json:"can_be_downloaded"`
	// True, if the file can be deleted
	CanBeDeleted bool `json:"can_be_deleted"`
	// True, if the file is currently being downloaded (or a local copy is being generated by some other means)
	IsDownloadingActive bool `json:"is_downloading_active"`
	// True, if the local copy is fully available
	IsDownloadingCompleted bool `json:"is_downloading_completed"`
	// Download will be started from this offset. downloaded_prefix_size is calculated from this offset
	DownloadOffset int64 `json:"download_offset"`
	// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
	DownloadedPrefixSize int64 `json:"downloaded_prefix_size"`
	// Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
	DownloadedSize int64 `json:"downloaded_size"`
}

func (entity *LocalFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocalFile

	return json.Marshal((*stub)(entity))
}

func (*LocalFile) GetClass() string {
	return ClassLocalFile
}

func (*LocalFile) GetType() string {
	return TypeLocalFile
}

// Represents a remote file
type RemoteFile struct {
	meta
	// Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
	Id string `json:"id"`
	// Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
	UniqueId string `json:"unique_id"`
	// True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
	IsUploadingActive bool `json:"is_uploading_active"`
	// True, if a remote copy is fully available
	IsUploadingCompleted bool `json:"is_uploading_completed"`
	// Size of the remote available part of the file, in bytes; 0 if unknown
	UploadedSize int64 `json:"uploaded_size"`
}

func (entity *RemoteFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RemoteFile

	return json.Marshal((*stub)(entity))
}

func (*RemoteFile) GetClass() string {
	return ClassRemoteFile
}

func (*RemoteFile) GetType() string {
	return TypeRemoteFile
}

// Represents a file
type File struct {
	meta
	// Unique file identifier
	Id int32 `json:"id"`
	// File size, in bytes; 0 if unknown
	Size int64 `json:"size"`
	// Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
	ExpectedSize int64 `json:"expected_size"`
	// Information about the local copy of the file
	Local *LocalFile `json:"local"`
	// Information about the remote copy of the file
	Remote *RemoteFile `json:"remote"`
}

func (entity *File) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub File

	return json.Marshal((*stub)(entity))
}

func (*File) GetClass() string {
	return ClassFile
}

func (*File) GetType() string {
	return TypeFile
}

// A file defined by its unique identifier
type InputFileId struct {
	meta
	// Unique file identifier
	Id int32 `json:"id"`
}

func (entity *InputFileId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileId

	return json.Marshal((*stub)(entity))
}

func (*InputFileId) GetClass() string {
	return ClassInputFile
}

func (*InputFileId) GetType() string {
	return TypeInputFileId
}

func (*InputFileId) InputFileType() string {
	return TypeInputFileId
}

// A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
type InputFileRemote struct {
	meta
	// Remote file identifier
	Id string `json:"id"`
}

func (entity *InputFileRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileRemote

	return json.Marshal((*stub)(entity))
}

func (*InputFileRemote) GetClass() string {
	return ClassInputFile
}

func (*InputFileRemote) GetType() string {
	return TypeInputFileRemote
}

func (*InputFileRemote) InputFileType() string {
	return TypeInputFileRemote
}

// A file defined by a local path
type InputFileLocal struct {
	meta
	// Local path to the file
	Path string `json:"path"`
}

func (entity *InputFileLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileLocal

	return json.Marshal((*stub)(entity))
}

func (*InputFileLocal) GetClass() string {
	return ClassInputFile
}

func (*InputFileLocal) GetType() string {
	return TypeInputFileLocal
}

func (*InputFileLocal) InputFileType() string {
	return TypeInputFileLocal
}

// A file generated by the application. The application must handle updates updateFileGenerationStart and updateFileGenerationStop to generate the file when asked by TDLib
type InputFileGenerated struct {
	meta
	// Local path to a file from which the file is generated. The path doesn't have to be a valid path and is used by TDLib only to detect name and MIME type of the generated file
	OriginalPath string `json:"original_path"`
	// String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
	Conversion string `json:"conversion"`
	// Expected size of the generated file, in bytes; pass 0 if unknown
	ExpectedSize int64 `json:"expected_size"`
}

func (entity *InputFileGenerated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileGenerated

	return json.Marshal((*stub)(entity))
}

func (*InputFileGenerated) GetClass() string {
	return ClassInputFile
}

func (*InputFileGenerated) GetType() string {
	return TypeInputFileGenerated
}

func (*InputFileGenerated) InputFileType() string {
	return TypeInputFileGenerated
}

// Describes an image in JPEG format
type PhotoSize struct {
	meta
	// Image type (see https://core.telegram.org/constructor/photoSize)
	Type string `json:"type"`
	// Information about the image file
	Photo *File `json:"photo"`
	// Image width
	Width int32 `json:"width"`
	// Image height
	Height int32 `json:"height"`
	// Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
	ProgressiveSizes []int32 `json:"progressive_sizes"`
}

func (entity *PhotoSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhotoSize

	return json.Marshal((*stub)(entity))
}

func (*PhotoSize) GetClass() string {
	return ClassPhotoSize
}

func (*PhotoSize) GetType() string {
	return TypePhotoSize
}

// Thumbnail image of a very poor quality and low resolution
type Minithumbnail struct {
	meta
	// Thumbnail width, usually doesn't exceed 40
	Width int32 `json:"width"`
	// Thumbnail height, usually doesn't exceed 40
	Height int32 `json:"height"`
	// The thumbnail in JPEG format
	Data []byte `json:"data"`
}

func (entity *Minithumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Minithumbnail

	return json.Marshal((*stub)(entity))
}

func (*Minithumbnail) GetClass() string {
	return ClassMinithumbnail
}

func (*Minithumbnail) GetType() string {
	return TypeMinithumbnail
}

// The thumbnail is in JPEG format
type ThumbnailFormatJpeg struct {
	meta
}

func (entity *ThumbnailFormatJpeg) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatJpeg

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatJpeg) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatJpeg) GetType() string {
	return TypeThumbnailFormatJpeg
}

func (*ThumbnailFormatJpeg) ThumbnailFormatType() string {
	return TypeThumbnailFormatJpeg
}

// The thumbnail is in static GIF format. It will be used only for some bot inline query results
type ThumbnailFormatGif struct {
	meta
}

func (entity *ThumbnailFormatGif) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatGif

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatGif) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatGif) GetType() string {
	return TypeThumbnailFormatGif
}

func (*ThumbnailFormatGif) ThumbnailFormatType() string {
	return TypeThumbnailFormatGif
}

// The thumbnail is in MPEG4 format. It will be used only for some animations and videos
type ThumbnailFormatMpeg4 struct {
	meta
}

func (entity *ThumbnailFormatMpeg4) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatMpeg4

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatMpeg4) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatMpeg4) GetType() string {
	return TypeThumbnailFormatMpeg4
}

func (*ThumbnailFormatMpeg4) ThumbnailFormatType() string {
	return TypeThumbnailFormatMpeg4
}

// The thumbnail is in PNG format. It will be used only for background patterns
type ThumbnailFormatPng struct {
	meta
}

func (entity *ThumbnailFormatPng) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatPng

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatPng) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatPng) GetType() string {
	return TypeThumbnailFormatPng
}

func (*ThumbnailFormatPng) ThumbnailFormatType() string {
	return TypeThumbnailFormatPng
}

// The thumbnail is in TGS format. It will be used only for sticker sets
type ThumbnailFormatTgs struct {
	meta
}

func (entity *ThumbnailFormatTgs) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatTgs

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatTgs) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatTgs) GetType() string {
	return TypeThumbnailFormatTgs
}

func (*ThumbnailFormatTgs) ThumbnailFormatType() string {
	return TypeThumbnailFormatTgs
}

// The thumbnail is in WEBM format. It will be used only for sticker sets
type ThumbnailFormatWebm struct {
	meta
}

func (entity *ThumbnailFormatWebm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatWebm

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatWebm) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatWebm) GetType() string {
	return TypeThumbnailFormatWebm
}

func (*ThumbnailFormatWebm) ThumbnailFormatType() string {
	return TypeThumbnailFormatWebm
}

// The thumbnail is in WEBP format. It will be used only for some stickers and sticker sets
type ThumbnailFormatWebp struct {
	meta
}

func (entity *ThumbnailFormatWebp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThumbnailFormatWebp

	return json.Marshal((*stub)(entity))
}

func (*ThumbnailFormatWebp) GetClass() string {
	return ClassThumbnailFormat
}

func (*ThumbnailFormatWebp) GetType() string {
	return TypeThumbnailFormatWebp
}

func (*ThumbnailFormatWebp) ThumbnailFormatType() string {
	return TypeThumbnailFormatWebp
}

// Represents a thumbnail
type Thumbnail struct {
	meta
	// Thumbnail format
	Format ThumbnailFormat `json:"format"`
	// Thumbnail width
	Width int32 `json:"width"`
	// Thumbnail height
	Height int32 `json:"height"`
	// The thumbnail
	File *File `json:"file"`
}

func (entity *Thumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Thumbnail

	return json.Marshal((*stub)(entity))
}

func (*Thumbnail) GetClass() string {
	return ClassThumbnail
}

func (*Thumbnail) GetType() string {
	return TypeThumbnail
}

func (thumbnail *Thumbnail) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Format json.RawMessage `json:"format"`
		Width  int32           `json:"width"`
		Height int32           `json:"height"`
		File   *File           `json:"file"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	thumbnail.Width = tmp.Width
	thumbnail.Height = tmp.Height
	thumbnail.File = tmp.File

	fieldFormat, _ := UnmarshalThumbnailFormat(tmp.Format)
	thumbnail.Format = fieldFormat

	return nil
}

// The mask is placed relatively to the forehead
type MaskPointForehead struct {
	meta
}

func (entity *MaskPointForehead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointForehead

	return json.Marshal((*stub)(entity))
}

func (*MaskPointForehead) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointForehead) GetType() string {
	return TypeMaskPointForehead
}

func (*MaskPointForehead) MaskPointType() string {
	return TypeMaskPointForehead
}

// The mask is placed relatively to the eyes
type MaskPointEyes struct {
	meta
}

func (entity *MaskPointEyes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointEyes

	return json.Marshal((*stub)(entity))
}

func (*MaskPointEyes) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointEyes) GetType() string {
	return TypeMaskPointEyes
}

func (*MaskPointEyes) MaskPointType() string {
	return TypeMaskPointEyes
}

// The mask is placed relatively to the mouth
type MaskPointMouth struct {
	meta
}

func (entity *MaskPointMouth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointMouth

	return json.Marshal((*stub)(entity))
}

func (*MaskPointMouth) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointMouth) GetType() string {
	return TypeMaskPointMouth
}

func (*MaskPointMouth) MaskPointType() string {
	return TypeMaskPointMouth
}

// The mask is placed relatively to the chin
type MaskPointChin struct {
	meta
}

func (entity *MaskPointChin) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointChin

	return json.Marshal((*stub)(entity))
}

func (*MaskPointChin) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointChin) GetType() string {
	return TypeMaskPointChin
}

func (*MaskPointChin) MaskPointType() string {
	return TypeMaskPointChin
}

// Position on a photo where a mask is placed
type MaskPosition struct {
	meta
	// Part of the face, relative to which the mask is placed
	Point MaskPoint `json:"point"`
	// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
	XShift float64 `json:"x_shift"`
	// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
	YShift float64 `json:"y_shift"`
	// Mask scaling coefficient. (For example, 2.0 means a doubled size)
	Scale float64 `json:"scale"`
}

func (entity *MaskPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPosition

	return json.Marshal((*stub)(entity))
}

func (*MaskPosition) GetClass() string {
	return ClassMaskPosition
}

func (*MaskPosition) GetType() string {
	return TypeMaskPosition
}

func (maskPosition *MaskPosition) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Point  json.RawMessage `json:"point"`
		XShift float64         `json:"x_shift"`
		YShift float64         `json:"y_shift"`
		Scale  float64         `json:"scale"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	maskPosition.XShift = tmp.XShift
	maskPosition.YShift = tmp.YShift
	maskPosition.Scale = tmp.Scale

	fieldPoint, _ := UnmarshalMaskPoint(tmp.Point)
	maskPosition.Point = fieldPoint

	return nil
}

// The sticker is an image in WEBP format
type StickerFormatWebp struct {
	meta
}

func (entity *StickerFormatWebp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFormatWebp

	return json.Marshal((*stub)(entity))
}

func (*StickerFormatWebp) GetClass() string {
	return ClassStickerFormat
}

func (*StickerFormatWebp) GetType() string {
	return TypeStickerFormatWebp
}

func (*StickerFormatWebp) StickerFormatType() string {
	return TypeStickerFormatWebp
}

// The sticker is an animation in TGS format
type StickerFormatTgs struct {
	meta
}

func (entity *StickerFormatTgs) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFormatTgs

	return json.Marshal((*stub)(entity))
}

func (*StickerFormatTgs) GetClass() string {
	return ClassStickerFormat
}

func (*StickerFormatTgs) GetType() string {
	return TypeStickerFormatTgs
}

func (*StickerFormatTgs) StickerFormatType() string {
	return TypeStickerFormatTgs
}

// The sticker is a video in WEBM format
type StickerFormatWebm struct {
	meta
}

func (entity *StickerFormatWebm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFormatWebm

	return json.Marshal((*stub)(entity))
}

func (*StickerFormatWebm) GetClass() string {
	return ClassStickerFormat
}

func (*StickerFormatWebm) GetType() string {
	return TypeStickerFormatWebm
}

func (*StickerFormatWebm) StickerFormatType() string {
	return TypeStickerFormatWebm
}

// The sticker is a regular sticker
type StickerTypeRegular struct {
	meta
}

func (entity *StickerTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*StickerTypeRegular) GetClass() string {
	return ClassStickerType
}

func (*StickerTypeRegular) GetType() string {
	return TypeStickerTypeRegular
}

func (*StickerTypeRegular) StickerTypeType() string {
	return TypeStickerTypeRegular
}

// The sticker is a mask in WEBP format to be placed on photos or videos
type StickerTypeMask struct {
	meta
}

func (entity *StickerTypeMask) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerTypeMask

	return json.Marshal((*stub)(entity))
}

func (*StickerTypeMask) GetClass() string {
	return ClassStickerType
}

func (*StickerTypeMask) GetType() string {
	return TypeStickerTypeMask
}

func (*StickerTypeMask) StickerTypeType() string {
	return TypeStickerTypeMask
}

// The sticker is a custom emoji to be used inside message text and caption
type StickerTypeCustomEmoji struct {
	meta
}

func (entity *StickerTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*StickerTypeCustomEmoji) GetClass() string {
	return ClassStickerType
}

func (*StickerTypeCustomEmoji) GetType() string {
	return TypeStickerTypeCustomEmoji
}

func (*StickerTypeCustomEmoji) StickerTypeType() string {
	return TypeStickerTypeCustomEmoji
}

// The sticker is a regular sticker
type StickerFullTypeRegular struct {
	meta
	// Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
	PremiumAnimation *File `json:"premium_animation"`
}

func (entity *StickerFullTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFullTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*StickerFullTypeRegular) GetClass() string {
	return ClassStickerFullType
}

func (*StickerFullTypeRegular) GetType() string {
	return TypeStickerFullTypeRegular
}

func (*StickerFullTypeRegular) StickerFullTypeType() string {
	return TypeStickerFullTypeRegular
}

// The sticker is a mask in WEBP format to be placed on photos or videos
type StickerFullTypeMask struct {
	meta
	// Position where the mask is placed; may be null
	MaskPosition *MaskPosition `json:"mask_position"`
}

func (entity *StickerFullTypeMask) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFullTypeMask

	return json.Marshal((*stub)(entity))
}

func (*StickerFullTypeMask) GetClass() string {
	return ClassStickerFullType
}

func (*StickerFullTypeMask) GetType() string {
	return TypeStickerFullTypeMask
}

func (*StickerFullTypeMask) StickerFullTypeType() string {
	return TypeStickerFullTypeMask
}

// The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji
type StickerFullTypeCustomEmoji struct {
	meta
	// Identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
	// True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
	NeedsRepainting bool `json:"needs_repainting"`
}

func (entity *StickerFullTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerFullTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*StickerFullTypeCustomEmoji) GetClass() string {
	return ClassStickerFullType
}

func (*StickerFullTypeCustomEmoji) GetType() string {
	return TypeStickerFullTypeCustomEmoji
}

func (*StickerFullTypeCustomEmoji) StickerFullTypeType() string {
	return TypeStickerFullTypeCustomEmoji
}

// Represents a closed vector path. The path begins at the end point of the last command. The coordinate system origin is in the upper-left corner
type ClosedVectorPath struct {
	meta
	// List of vector path commands
	Commands []VectorPathCommand `json:"commands"`
}

func (entity *ClosedVectorPath) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ClosedVectorPath

	return json.Marshal((*stub)(entity))
}

func (*ClosedVectorPath) GetClass() string {
	return ClassClosedVectorPath
}

func (*ClosedVectorPath) GetType() string {
	return TypeClosedVectorPath
}

func (closedVectorPath *ClosedVectorPath) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Commands []json.RawMessage `json:"commands"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldCommands, _ := UnmarshalListOfVectorPathCommand(tmp.Commands)
	closedVectorPath.Commands = fieldCommands

	return nil
}

// Represents outline of an image
type Outline struct {
	meta
	// The list of closed vector paths
	Paths []*ClosedVectorPath `json:"paths"`
}

func (entity *Outline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Outline

	return json.Marshal((*stub)(entity))
}

func (*Outline) GetClass() string {
	return ClassOutline
}

func (*Outline) GetType() string {
	return TypeOutline
}

// Describes one answer option of a poll
type PollOption struct {
	meta
	// Option text; 1-100 characters. Only custom emoji entities are allowed
	Text *FormattedText `json:"text"`
	// Number of voters for this option, available only for closed or voted polls
	VoterCount int32 `json:"voter_count"`
	// The percentage of votes for this option; 0-100
	VotePercentage int32 `json:"vote_percentage"`
	// True, if the option was chosen by the user
	IsChosen bool `json:"is_chosen"`
	// True, if the option is being chosen by a pending setPollAnswer request
	IsBeingChosen bool `json:"is_being_chosen"`
}

func (entity *PollOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollOption

	return json.Marshal((*stub)(entity))
}

func (*PollOption) GetClass() string {
	return ClassPollOption
}

func (*PollOption) GetType() string {
	return TypePollOption
}

// A regular poll
type PollTypeRegular struct {
	meta
	// True, if multiple answer options can be chosen simultaneously
	AllowMultipleAnswers bool `json:"allow_multiple_answers"`
}

func (entity *PollTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*PollTypeRegular) GetClass() string {
	return ClassPollType
}

func (*PollTypeRegular) GetType() string {
	return TypePollTypeRegular
}

func (*PollTypeRegular) PollTypeType() string {
	return TypePollTypeRegular
}

// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
type PollTypeQuiz struct {
	meta
	// 0-based identifier of the correct answer option; -1 for a yet unanswered poll
	CorrectOptionId int32 `json:"correct_option_id"`
	// Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
	Explanation *FormattedText `json:"explanation"`
}

func (entity *PollTypeQuiz) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollTypeQuiz

	return json.Marshal((*stub)(entity))
}

func (*PollTypeQuiz) GetClass() string {
	return ClassPollType
}

func (*PollTypeQuiz) GetType() string {
	return TypePollTypeQuiz
}

func (*PollTypeQuiz) PollTypeType() string {
	return TypePollTypeQuiz
}

// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
type Animation struct {
	meta
	// Duration of the animation, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Width of the animation
	Width int32 `json:"width"`
	// Height of the animation
	Height int32 `json:"height"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file, usually "image/gif" or "video/mp4"
	MimeType string `json:"mime_type"`
	// True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// Animation minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Animation thumbnail in JPEG or MPEG4 format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the animation
	Animation *File `json:"animation"`
}

func (entity *Animation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Animation

	return json.Marshal((*stub)(entity))
}

func (*Animation) GetClass() string {
	return ClassAnimation
}

func (*Animation) GetType() string {
	return TypeAnimation
}

// Describes an audio file. Audio is usually in MP3 or M4A format
type Audio struct {
	meta
	// Duration of the audio, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Title of the audio; as defined by the sender
	Title string `json:"title"`
	// Performer of the audio; as defined by the sender
	Performer string `json:"performer"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// The MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// The minithumbnail of the album cover; may be null
	AlbumCoverMinithumbnail *Minithumbnail `json:"album_cover_minithumbnail"`
	// The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is expected to be extracted from the downloaded audio file; may be null
	AlbumCoverThumbnail *Thumbnail `json:"album_cover_thumbnail"`
	// Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
	ExternalAlbumCovers []*Thumbnail `json:"external_album_covers"`
	// File containing the audio
	Audio *File `json:"audio"`
}

func (entity *Audio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Audio

	return json.Marshal((*stub)(entity))
}

func (*Audio) GetClass() string {
	return ClassAudio
}

func (*Audio) GetType() string {
	return TypeAudio
}

// Describes a document of any type
type Document struct {
	meta
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// Document minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the document
	Document *File `json:"document"`
}

func (entity *Document) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Document

	return json.Marshal((*stub)(entity))
}

func (*Document) GetClass() string {
	return ClassDocument
}

func (*Document) GetType() string {
	return TypeDocument
}

// Describes a photo
type Photo struct {
	meta
	// True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// Photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Available variants of the photo, in different sizes
	Sizes []*PhotoSize `json:"sizes"`
}

func (entity *Photo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Photo

	return json.Marshal((*stub)(entity))
}

func (*Photo) GetClass() string {
	return ClassPhoto
}

func (*Photo) GetType() string {
	return TypePhoto
}

// Describes a sticker
type Sticker struct {
	meta
	// Unique sticker identifier within the set; 0 if none
	Id JsonInt64 `json:"id"`
	// Identifier of the sticker set to which the sticker belongs; 0 if none
	SetId JsonInt64 `json:"set_id"`
	// Sticker width; as defined by the sender
	Width int32 `json:"width"`
	// Sticker height; as defined by the sender
	Height int32 `json:"height"`
	// Emoji corresponding to the sticker
	Emoji string `json:"emoji"`
	// Sticker format
	Format StickerFormat `json:"format"`
	// Sticker's full type
	FullType StickerFullType `json:"full_type"`
	// Sticker thumbnail in WEBP or JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the sticker
	Sticker *File `json:"sticker"`
}

func (entity *Sticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Sticker

	return json.Marshal((*stub)(entity))
}

func (*Sticker) GetClass() string {
	return ClassSticker
}

func (*Sticker) GetType() string {
	return TypeSticker
}

func (sticker *Sticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id        JsonInt64       `json:"id"`
		SetId     JsonInt64       `json:"set_id"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
		Emoji     string          `json:"emoji"`
		Format    json.RawMessage `json:"format"`
		FullType  json.RawMessage `json:"full_type"`
		Thumbnail *Thumbnail      `json:"thumbnail"`
		Sticker   *File           `json:"sticker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	sticker.Id = tmp.Id
	sticker.SetId = tmp.SetId
	sticker.Width = tmp.Width
	sticker.Height = tmp.Height
	sticker.Emoji = tmp.Emoji
	sticker.Thumbnail = tmp.Thumbnail
	sticker.Sticker = tmp.Sticker

	fieldFormat, _ := UnmarshalStickerFormat(tmp.Format)
	sticker.Format = fieldFormat

	fieldFullType, _ := UnmarshalStickerFullType(tmp.FullType)
	sticker.FullType = fieldFullType

	return nil
}

// Describes a video file
type Video struct {
	meta
	// Duration of the video, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Video width; as defined by the sender
	Width int32 `json:"width"`
	// Video height; as defined by the sender
	Height int32 `json:"height"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// True, if the video is expected to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *Video) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Video

	return json.Marshal((*stub)(entity))
}

func (*Video) GetClass() string {
	return ClassVideo
}

func (*Video) GetType() string {
	return TypeVideo
}

// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
type VideoNote struct {
	meta
	// Duration of the video, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
	Waveform []byte `json:"waveform"`
	// Video width and height; as defined by the sender
	Length int32 `json:"length"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail in JPEG format; as defined by the sender; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Result of speech recognition in the video note; may be null
	SpeechRecognitionResult SpeechRecognitionResult `json:"speech_recognition_result"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *VideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VideoNote

	return json.Marshal((*stub)(entity))
}

func (*VideoNote) GetClass() string {
	return ClassVideoNote
}

func (*VideoNote) GetType() string {
	return TypeVideoNote
}

func (videoNote *VideoNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Duration                int32           `json:"duration"`
		Waveform                []byte          `json:"waveform"`
		Length                  int32           `json:"length"`
		Minithumbnail           *Minithumbnail  `json:"minithumbnail"`
		Thumbnail               *Thumbnail      `json:"thumbnail"`
		SpeechRecognitionResult json.RawMessage `json:"speech_recognition_result"`
		Video                   *File           `json:"video"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	videoNote.Duration = tmp.Duration
	videoNote.Waveform = tmp.Waveform
	videoNote.Length = tmp.Length
	videoNote.Minithumbnail = tmp.Minithumbnail
	videoNote.Thumbnail = tmp.Thumbnail
	videoNote.Video = tmp.Video

	fieldSpeechRecognitionResult, _ := UnmarshalSpeechRecognitionResult(tmp.SpeechRecognitionResult)
	videoNote.SpeechRecognitionResult = fieldSpeechRecognitionResult

	return nil
}

// Describes a voice note
type VoiceNote struct {
	meta
	// Duration of the voice note, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// A waveform representation of the voice note in 5-bit format
	Waveform []byte `json:"waveform"`
	// MIME type of the file; as defined by the sender. Usually, one of "audio/ogg" for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4" for an M4A audio
	MimeType string `json:"mime_type"`
	// Result of speech recognition in the voice note; may be null
	SpeechRecognitionResult SpeechRecognitionResult `json:"speech_recognition_result"`
	// File containing the voice note
	Voice *File `json:"voice"`
}

func (entity *VoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VoiceNote

	return json.Marshal((*stub)(entity))
}

func (*VoiceNote) GetClass() string {
	return ClassVoiceNote
}

func (*VoiceNote) GetType() string {
	return TypeVoiceNote
}

func (voiceNote *VoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Duration                int32           `json:"duration"`
		Waveform                []byte          `json:"waveform"`
		MimeType                string          `json:"mime_type"`
		SpeechRecognitionResult json.RawMessage `json:"speech_recognition_result"`
		Voice                   *File           `json:"voice"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	voiceNote.Duration = tmp.Duration
	voiceNote.Waveform = tmp.Waveform
	voiceNote.MimeType = tmp.MimeType
	voiceNote.Voice = tmp.Voice

	fieldSpeechRecognitionResult, _ := UnmarshalSpeechRecognitionResult(tmp.SpeechRecognitionResult)
	voiceNote.SpeechRecognitionResult = fieldSpeechRecognitionResult

	return nil
}

// Describes an animated or custom representation of an emoji
type AnimatedEmoji struct {
	meta
	// Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, then it can have arbitrary format
	Sticker *Sticker `json:"sticker"`
	// Expected width of the sticker, which can be used if the sticker is null
	StickerWidth int32 `json:"sticker_width"`
	// Expected height of the sticker, which can be used if the sticker is null
	StickerHeight int32 `json:"sticker_height"`
	// Emoji modifier fitzpatrick type; 0-6; 0 if none
	FitzpatrickType int32 `json:"fitzpatrick_type"`
	// File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
	Sound *File `json:"sound"`
}

func (entity *AnimatedEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AnimatedEmoji

	return json.Marshal((*stub)(entity))
}

func (*AnimatedEmoji) GetClass() string {
	return ClassAnimatedEmoji
}

func (*AnimatedEmoji) GetType() string {
	return TypeAnimatedEmoji
}

// Describes a user contact
type Contact struct {
	meta
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// First name of the user; 1-255 characters in length
	FirstName string `json:"first_name"`
	// Last name of the user
	LastName string `json:"last_name"`
	// Additional data about the user in a form of vCard; 0-2048 bytes in length
	Vcard string `json:"vcard"`
	// Identifier of the user, if known; 0 otherwise
	UserId int64 `json:"user_id"`
}

func (entity *Contact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Contact

	return json.Marshal((*stub)(entity))
}

func (*Contact) GetClass() string {
	return ClassContact
}

func (*Contact) GetType() string {
	return TypeContact
}

// Describes a location on planet Earth
type Location struct {
	meta
	// Latitude of the location in degrees; as defined by the sender
	Latitude float64 `json:"latitude"`
	// Longitude of the location, in degrees; as defined by the sender
	Longitude float64 `json:"longitude"`
	// The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
	HorizontalAccuracy float64 `json:"horizontal_accuracy"`
}

func (entity *Location) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Location

	return json.Marshal((*stub)(entity))
}

func (*Location) GetClass() string {
	return ClassLocation
}

func (*Location) GetType() string {
	return TypeLocation
}

// Describes a venue
type Venue struct {
	meta
	// Venue location; as defined by the sender
	Location *Location `json:"location"`
	// Venue name; as defined by the sender
	Title string `json:"title"`
	// Venue address; as defined by the sender
	Address string `json:"address"`
	// Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
	Provider string `json:"provider"`
	// Identifier of the venue in the provider database; as defined by the sender
	Id string `json:"id"`
	// Type of the venue in the provider database; as defined by the sender
	Type string `json:"type"`
}

func (entity *Venue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Venue

	return json.Marshal((*stub)(entity))
}

func (*Venue) GetClass() string {
	return ClassVenue
}

func (*Venue) GetType() string {
	return TypeVenue
}

// Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
type Game struct {
	meta
	// Unique game identifier
	Id JsonInt64 `json:"id"`
	// Game short name
	ShortName string `json:"short_name"`
	// Game title
	Title string `json:"title"`
	// Game text, usually containing scoreboards for a game
	Text *FormattedText `json:"text"`
	// Game description
	Description string `json:"description"`
	// Game photo
	Photo *Photo `json:"photo"`
	// Game animation; may be null
	Animation *Animation `json:"animation"`
}

func (entity *Game) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Game

	return json.Marshal((*stub)(entity))
}

func (*Game) GetClass() string {
	return ClassGame
}

func (*Game) GetType() string {
	return TypeGame
}

// Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
type WebApp struct {
	meta
	// Web App short name
	ShortName string `json:"short_name"`
	// Web App title
	Title string `json:"title"`
	// Web App description
	Description string `json:"description"`
	// Web App photo
	Photo *Photo `json:"photo"`
	// Web App animation; may be null
	Animation *Animation `json:"animation"`
}

func (entity *WebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebApp

	return json.Marshal((*stub)(entity))
}

func (*WebApp) GetClass() string {
	return ClassWebApp
}

func (*WebApp) GetType() string {
	return TypeWebApp
}

// Describes a poll
type Poll struct {
	meta
	// Unique poll identifier
	Id JsonInt64 `json:"id"`
	// Poll question; 1-300 characters. Only custom emoji entities are allowed
	Question *FormattedText `json:"question"`
	// List of poll answer options
	Options []*PollOption `json:"options"`
	// Total number of voters, participating in the poll
	TotalVoterCount int32 `json:"total_voter_count"`
	// Identifiers of recent voters, if the poll is non-anonymous
	RecentVoterIds []MessageSender `json:"recent_voter_ids"`
	// True, if the poll is anonymous
	IsAnonymous bool `json:"is_anonymous"`
	// Type of the poll
	Type PollType `json:"type"`
	// Amount of time the poll will be active after creation, in seconds
	OpenPeriod int32 `json:"open_period"`
	// Point in time (Unix timestamp) when the poll will automatically be closed
	CloseDate int32 `json:"close_date"`
	// True, if the poll is closed
	IsClosed bool `json:"is_closed"`
}

func (entity *Poll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Poll

	return json.Marshal((*stub)(entity))
}

func (*Poll) GetClass() string {
	return ClassPoll
}

func (*Poll) GetType() string {
	return TypePoll
}

func (poll *Poll) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id              JsonInt64         `json:"id"`
		Question        *FormattedText    `json:"question"`
		Options         []*PollOption     `json:"options"`
		TotalVoterCount int32             `json:"total_voter_count"`
		RecentVoterIds  []json.RawMessage `json:"recent_voter_ids"`
		IsAnonymous     bool              `json:"is_anonymous"`
		Type            json.RawMessage   `json:"type"`
		OpenPeriod      int32             `json:"open_period"`
		CloseDate       int32             `json:"close_date"`
		IsClosed        bool              `json:"is_closed"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	poll.Id = tmp.Id
	poll.Question = tmp.Question
	poll.Options = tmp.Options
	poll.TotalVoterCount = tmp.TotalVoterCount
	poll.IsAnonymous = tmp.IsAnonymous
	poll.OpenPeriod = tmp.OpenPeriod
	poll.CloseDate = tmp.CloseDate
	poll.IsClosed = tmp.IsClosed

	fieldRecentVoterIds, _ := UnmarshalListOfMessageSender(tmp.RecentVoterIds)
	poll.RecentVoterIds = fieldRecentVoterIds

	fieldType, _ := UnmarshalPollType(tmp.Type)
	poll.Type = fieldType

	return nil
}

// Describes an alternative re-encoded quality of a video file
type AlternativeVideo struct {
	meta
	// Video width
	Width int32 `json:"width"`
	// Video height
	Height int32 `json:"height"`
	// Codec used for video file encoding, for example, "h264", "h265", or "av1"
	Codec string `json:"codec"`
	// HLS file describing the video
	HlsFile *File `json:"hls_file"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *AlternativeVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AlternativeVideo

	return json.Marshal((*stub)(entity))
}

func (*AlternativeVideo) GetClass() string {
	return ClassAlternativeVideo
}

func (*AlternativeVideo) GetType() string {
	return TypeAlternativeVideo
}

// Describes a chat background
type Background struct {
	meta
	// Unique background identifier
	Id JsonInt64 `json:"id"`
	// True, if this is one of default backgrounds
	IsDefault bool `json:"is_default"`
	// True, if the background is dark and is recommended to be used with dark theme
	IsDark bool `json:"is_dark"`
	// Unique background name
	Name string `json:"name"`
	// Document with the background; may be null. Null only for filled and chat theme backgrounds
	Document *Document `json:"document"`
	// Type of the background
	Type BackgroundType `json:"type"`
}

func (entity *Background) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Background

	return json.Marshal((*stub)(entity))
}

func (*Background) GetClass() string {
	return ClassBackground
}

func (*Background) GetType() string {
	return TypeBackground
}

func (background *Background) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id        JsonInt64       `json:"id"`
		IsDefault bool            `json:"is_default"`
		IsDark    bool            `json:"is_dark"`
		Name      string          `json:"name"`
		Document  *Document       `json:"document"`
		Type      json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	background.Id = tmp.Id
	background.IsDefault = tmp.IsDefault
	background.IsDark = tmp.IsDark
	background.Name = tmp.Name
	background.Document = tmp.Document

	fieldType, _ := UnmarshalBackgroundType(tmp.Type)
	background.Type = fieldType

	return nil
}

// Contains a list of backgrounds
type Backgrounds struct {
	meta
	// A list of backgrounds
	Backgrounds []*Background `json:"backgrounds"`
}

func (entity *Backgrounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Backgrounds

	return json.Marshal((*stub)(entity))
}

func (*Backgrounds) GetClass() string {
	return ClassBackgrounds
}

func (*Backgrounds) GetType() string {
	return TypeBackgrounds
}

// Describes a background set for a specific chat
type ChatBackground struct {
	meta
	// The background
	Background *Background `json:"background"`
	// Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
	DarkThemeDimming int32 `json:"dark_theme_dimming"`
}

func (entity *ChatBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBackground

	return json.Marshal((*stub)(entity))
}

func (*ChatBackground) GetClass() string {
	return ClassChatBackground
}

func (*ChatBackground) GetType() string {
	return TypeChatBackground
}

// Describes a user profile photo
type ProfilePhoto struct {
	meta
	// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
	Id JsonInt64 `json:"id"`
	// A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
	Small *File `json:"small"`
	// A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
	Big *File `json:"big"`
	// User profile photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// True, if the photo has animated variant
	HasAnimation bool `json:"has_animation"`
	// True, if the photo is visible only for the current user
	IsPersonal bool `json:"is_personal"`
}

func (entity *ProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*ProfilePhoto) GetClass() string {
	return ClassProfilePhoto
}

func (*ProfilePhoto) GetType() string {
	return TypeProfilePhoto
}

// Contains basic information about the photo of a chat
type ChatPhotoInfo struct {
	meta
	// A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
	Small *File `json:"small"`
	// A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
	Big *File `json:"big"`
	// Chat photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// True, if the photo has animated variant
	HasAnimation bool `json:"has_animation"`
	// True, if the photo is visible only for the current user
	IsPersonal bool `json:"is_personal"`
}

func (entity *ChatPhotoInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoInfo) GetClass() string {
	return ClassChatPhotoInfo
}

func (*ChatPhotoInfo) GetType() string {
	return TypeChatPhotoInfo
}

// A regular user
type UserTypeRegular struct {
	meta
}

func (entity *UserTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*UserTypeRegular) GetClass() string {
	return ClassUserType
}

func (*UserTypeRegular) GetType() string {
	return TypeUserTypeRegular
}

func (*UserTypeRegular) UserTypeType() string {
	return TypeUserTypeRegular
}

// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
type UserTypeDeleted struct {
	meta
}

func (entity *UserTypeDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeDeleted

	return json.Marshal((*stub)(entity))
}

func (*UserTypeDeleted) GetClass() string {
	return ClassUserType
}

func (*UserTypeDeleted) GetType() string {
	return TypeUserTypeDeleted
}

func (*UserTypeDeleted) UserTypeType() string {
	return TypeUserTypeDeleted
}

// A bot (see https://core.telegram.org/bots)
type UserTypeBot struct {
	meta
	// True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
	CanBeEdited bool `json:"can_be_edited"`
	// True, if the bot can be invited to basic group and supergroup chats
	CanJoinGroups bool `json:"can_join_groups"`
	// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
	CanReadAllGroupMessages bool `json:"can_read_all_group_messages"`
	// True, if the bot has the main Web App
	HasMainWebApp bool `json:"has_main_web_app"`
	// True, if the bot supports inline queries
	IsInline bool `json:"is_inline"`
	// Placeholder for inline queries (displayed on the application input field)
	InlineQueryPlaceholder string `json:"inline_query_placeholder"`
	// True, if the location of the user is expected to be sent with every inline query to this bot
	NeedLocation bool `json:"need_location"`
	// True, if the bot supports connection to Telegram Business accounts
	CanConnectToBusiness bool `json:"can_connect_to_business"`
	// True, if the bot can be added to attachment or side menu
	CanBeAddedToAttachmentMenu bool `json:"can_be_added_to_attachment_menu"`
	// The number of recently active users of the bot
	ActiveUserCount int32 `json:"active_user_count"`
}

func (entity *UserTypeBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeBot

	return json.Marshal((*stub)(entity))
}

func (*UserTypeBot) GetClass() string {
	return ClassUserType
}

func (*UserTypeBot) GetType() string {
	return TypeUserTypeBot
}

func (*UserTypeBot) UserTypeType() string {
	return TypeUserTypeBot
}

// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
type UserTypeUnknown struct {
	meta
}

func (entity *UserTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*UserTypeUnknown) GetClass() string {
	return ClassUserType
}

func (*UserTypeUnknown) GetType() string {
	return TypeUserTypeUnknown
}

func (*UserTypeUnknown) UserTypeType() string {
	return TypeUserTypeUnknown
}

// Represents a command supported by a bot
type BotCommand struct {
	meta
	// Text of the bot command
	Command string `json:"command"`
	// Description of the bot command
	Description string `json:"description"`
}

func (entity *BotCommand) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommand

	return json.Marshal((*stub)(entity))
}

func (*BotCommand) GetClass() string {
	return ClassBotCommand
}

func (*BotCommand) GetType() string {
	return TypeBotCommand
}

// Contains a list of bot commands
type BotCommands struct {
	meta
	// Bot's user identifier
	BotUserId int64 `json:"bot_user_id"`
	// List of bot commands
	Commands []*BotCommand `json:"commands"`
}

func (entity *BotCommands) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommands

	return json.Marshal((*stub)(entity))
}

func (*BotCommands) GetClass() string {
	return ClassBotCommands
}

func (*BotCommands) GetType() string {
	return TypeBotCommands
}

// Describes a button to be shown instead of bot commands menu button
type BotMenuButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// URL of a Web App to open when the button is pressed. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the link must be passed to openWebApp
	Url string `json:"url"`
}

func (entity *BotMenuButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotMenuButton

	return json.Marshal((*stub)(entity))
}

func (*BotMenuButton) GetClass() string {
	return ClassBotMenuButton
}

func (*BotMenuButton) GetType() string {
	return TypeBotMenuButton
}

// Represents a location to which a chat is connected
type ChatLocation struct {
	meta
	// The location
	Location *Location `json:"location"`
	// Location address; 1-64 characters, as defined by the chat owner
	Address string `json:"address"`
}

func (entity *ChatLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatLocation) GetClass() string {
	return ClassChatLocation
}

func (*ChatLocation) GetType() string {
	return TypeChatLocation
}

// Represents a birthdate of a user
type Birthdate struct {
	meta
	// Day of the month; 1-31
	Day int32 `json:"day"`
	// Month of the year; 1-12
	Month int32 `json:"month"`
	// Birth year; 0 if unknown
	Year int32 `json:"year"`
}

func (entity *Birthdate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Birthdate

	return json.Marshal((*stub)(entity))
}

func (*Birthdate) GetClass() string {
	return ClassBirthdate
}

func (*Birthdate) GetType() string {
	return TypeBirthdate
}

// Describes a user that had or will have a birthday soon
type CloseBirthdayUser struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Birthdate of the user
	Birthdate *Birthdate `json:"birthdate"`
}

func (entity *CloseBirthdayUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CloseBirthdayUser

	return json.Marshal((*stub)(entity))
}

func (*CloseBirthdayUser) GetClass() string {
	return ClassCloseBirthdayUser
}

func (*CloseBirthdayUser) GetType() string {
	return TypeCloseBirthdayUser
}

// Send away messages always
type BusinessAwayMessageScheduleAlways struct {
	meta
}

func (entity *BusinessAwayMessageScheduleAlways) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessAwayMessageScheduleAlways

	return json.Marshal((*stub)(entity))
}

func (*BusinessAwayMessageScheduleAlways) GetClass() string {
	return ClassBusinessAwayMessageSchedule
}

func (*BusinessAwayMessageScheduleAlways) GetType() string {
	return TypeBusinessAwayMessageScheduleAlways
}

func (*BusinessAwayMessageScheduleAlways) BusinessAwayMessageScheduleType() string {
	return TypeBusinessAwayMessageScheduleAlways
}

// Send away messages outside of the business opening hours
type BusinessAwayMessageScheduleOutsideOfOpeningHours struct {
	meta
}

func (entity *BusinessAwayMessageScheduleOutsideOfOpeningHours) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessAwayMessageScheduleOutsideOfOpeningHours

	return json.Marshal((*stub)(entity))
}

func (*BusinessAwayMessageScheduleOutsideOfOpeningHours) GetClass() string {
	return ClassBusinessAwayMessageSchedule
}

func (*BusinessAwayMessageScheduleOutsideOfOpeningHours) GetType() string {
	return TypeBusinessAwayMessageScheduleOutsideOfOpeningHours
}

func (*BusinessAwayMessageScheduleOutsideOfOpeningHours) BusinessAwayMessageScheduleType() string {
	return TypeBusinessAwayMessageScheduleOutsideOfOpeningHours
}

// Send away messages only in the specified time span
type BusinessAwayMessageScheduleCustom struct {
	meta
	// Point in time (Unix timestamp) when the away messages will start to be sent
	StartDate int32 `json:"start_date"`
	// Point in time (Unix timestamp) when the away messages will stop to be sent
	EndDate int32 `json:"end_date"`
}

func (entity *BusinessAwayMessageScheduleCustom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessAwayMessageScheduleCustom

	return json.Marshal((*stub)(entity))
}

func (*BusinessAwayMessageScheduleCustom) GetClass() string {
	return ClassBusinessAwayMessageSchedule
}

func (*BusinessAwayMessageScheduleCustom) GetType() string {
	return TypeBusinessAwayMessageScheduleCustom
}

func (*BusinessAwayMessageScheduleCustom) BusinessAwayMessageScheduleType() string {
	return TypeBusinessAwayMessageScheduleCustom
}

// Represents a location of a business
type BusinessLocation struct {
	meta
	// The location; may be null if not specified
	Location *Location `json:"location"`
	// Location address; 1-96 characters
	Address string `json:"address"`
}

func (entity *BusinessLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessLocation

	return json.Marshal((*stub)(entity))
}

func (*BusinessLocation) GetClass() string {
	return ClassBusinessLocation
}

func (*BusinessLocation) GetType() string {
	return TypeBusinessLocation
}

// Describes private chats chosen for automatic interaction with a business
type BusinessRecipients struct {
	meta
	// Identifiers of selected private chats
	ChatIds []int64 `json:"chat_ids"`
	// Identifiers of private chats that are always excluded; for businessConnectedBot only
	ExcludedChatIds []int64 `json:"excluded_chat_ids"`
	// True, if all existing private chats are selected
	SelectExistingChats bool `json:"select_existing_chats"`
	// True, if all new private chats are selected
	SelectNewChats bool `json:"select_new_chats"`
	// True, if all private chats with contacts are selected
	SelectContacts bool `json:"select_contacts"`
	// True, if all private chats with non-contacts are selected
	SelectNonContacts bool `json:"select_non_contacts"`
	// If true, then all private chats except the selected are chosen. Otherwise, only the selected chats are chosen
	ExcludeSelected bool `json:"exclude_selected"`
}

func (entity *BusinessRecipients) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessRecipients

	return json.Marshal((*stub)(entity))
}

func (*BusinessRecipients) GetClass() string {
	return ClassBusinessRecipients
}

func (*BusinessRecipients) GetType() string {
	return TypeBusinessRecipients
}

// Describes settings for messages that are automatically sent by a Telegram Business account when it is away
type BusinessAwayMessageSettings struct {
	meta
	// Unique quick reply shortcut identifier for the away messages
	ShortcutId int32 `json:"shortcut_id"`
	// Chosen recipients of the away messages
	Recipients *BusinessRecipients `json:"recipients"`
	// Settings used to check whether the current user is away
	Schedule BusinessAwayMessageSchedule `json:"schedule"`
	// True, if the messages must not be sent if the account was online in the last 10 minutes
	OfflineOnly bool `json:"offline_only"`
}

func (entity *BusinessAwayMessageSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessAwayMessageSettings

	return json.Marshal((*stub)(entity))
}

func (*BusinessAwayMessageSettings) GetClass() string {
	return ClassBusinessAwayMessageSettings
}

func (*BusinessAwayMessageSettings) GetType() string {
	return TypeBusinessAwayMessageSettings
}

func (businessAwayMessageSettings *BusinessAwayMessageSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ShortcutId  int32               `json:"shortcut_id"`
		Recipients  *BusinessRecipients `json:"recipients"`
		Schedule    json.RawMessage     `json:"schedule"`
		OfflineOnly bool                `json:"offline_only"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	businessAwayMessageSettings.ShortcutId = tmp.ShortcutId
	businessAwayMessageSettings.Recipients = tmp.Recipients
	businessAwayMessageSettings.OfflineOnly = tmp.OfflineOnly

	fieldSchedule, _ := UnmarshalBusinessAwayMessageSchedule(tmp.Schedule)
	businessAwayMessageSettings.Schedule = fieldSchedule

	return nil
}

// Describes settings for greeting messages that are automatically sent by a Telegram Business account as response to incoming messages in an inactive private chat
type BusinessGreetingMessageSettings struct {
	meta
	// Unique quick reply shortcut identifier for the greeting messages
	ShortcutId int32 `json:"shortcut_id"`
	// Chosen recipients of the greeting messages
	Recipients *BusinessRecipients `json:"recipients"`
	// The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28
	InactivityDays int32 `json:"inactivity_days"`
}

func (entity *BusinessGreetingMessageSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessGreetingMessageSettings

	return json.Marshal((*stub)(entity))
}

func (*BusinessGreetingMessageSettings) GetClass() string {
	return ClassBusinessGreetingMessageSettings
}

func (*BusinessGreetingMessageSettings) GetType() string {
	return TypeBusinessGreetingMessageSettings
}

// Describes a bot connected to a business account
type BusinessConnectedBot struct {
	meta
	// User identifier of the bot
	BotUserId int64 `json:"bot_user_id"`
	// Private chats that will be accessible to the bot
	Recipients *BusinessRecipients `json:"recipients"`
	// True, if the bot can send messages to the private chats; false otherwise
	CanReply bool `json:"can_reply"`
}

func (entity *BusinessConnectedBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessConnectedBot

	return json.Marshal((*stub)(entity))
}

func (*BusinessConnectedBot) GetClass() string {
	return ClassBusinessConnectedBot
}

func (*BusinessConnectedBot) GetType() string {
	return TypeBusinessConnectedBot
}

// Describes settings for a business account start page
type BusinessStartPage struct {
	meta
	// Title text of the start page
	Title string `json:"title"`
	// Message text of the start page
	Message string `json:"message"`
	// Greeting sticker of the start page; may be null if none
	Sticker *Sticker `json:"sticker"`
}

func (entity *BusinessStartPage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessStartPage

	return json.Marshal((*stub)(entity))
}

func (*BusinessStartPage) GetClass() string {
	return ClassBusinessStartPage
}

func (*BusinessStartPage) GetType() string {
	return TypeBusinessStartPage
}

// Describes settings for a business account start page to set
type InputBusinessStartPage struct {
	meta
	// Title text of the start page; 0-getOption("business_start_page_title_length_max") characters
	Title string `json:"title"`
	// Message text of the start page; 0-getOption("business_start_page_message_length_max") characters
	Message string `json:"message"`
	// Greeting sticker of the start page; pass null if none. The sticker must belong to a sticker set and must not be a custom emoji
	Sticker InputFile `json:"sticker"`
}

func (entity *InputBusinessStartPage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBusinessStartPage

	return json.Marshal((*stub)(entity))
}

func (*InputBusinessStartPage) GetClass() string {
	return ClassInputBusinessStartPage
}

func (*InputBusinessStartPage) GetType() string {
	return TypeInputBusinessStartPage
}

func (inputBusinessStartPage *InputBusinessStartPage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Title   string          `json:"title"`
		Message string          `json:"message"`
		Sticker json.RawMessage `json:"sticker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputBusinessStartPage.Title = tmp.Title
	inputBusinessStartPage.Message = tmp.Message

	fieldSticker, _ := UnmarshalInputFile(tmp.Sticker)
	inputBusinessStartPage.Sticker = fieldSticker

	return nil
}

// Describes an interval of time when the business is open
type BusinessOpeningHoursInterval struct {
	meta
	// The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0-7*24*60
	StartMinute int32 `json:"start_minute"`
	// The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1-8*24*60
	EndMinute int32 `json:"end_minute"`
}

func (entity *BusinessOpeningHoursInterval) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessOpeningHoursInterval

	return json.Marshal((*stub)(entity))
}

func (*BusinessOpeningHoursInterval) GetClass() string {
	return ClassBusinessOpeningHoursInterval
}

func (*BusinessOpeningHoursInterval) GetType() string {
	return TypeBusinessOpeningHoursInterval
}

// Describes opening hours of a business
type BusinessOpeningHours struct {
	meta
	// Unique time zone identifier
	TimeZoneId string `json:"time_zone_id"`
	// Intervals of the time when the business is open
	OpeningHours []*BusinessOpeningHoursInterval `json:"opening_hours"`
}

func (entity *BusinessOpeningHours) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessOpeningHours

	return json.Marshal((*stub)(entity))
}

func (*BusinessOpeningHours) GetClass() string {
	return ClassBusinessOpeningHours
}

func (*BusinessOpeningHours) GetType() string {
	return TypeBusinessOpeningHours
}

// Contains information about a Telegram Business account
type BusinessInfo struct {
	meta
	// Location of the business; may be null if none
	Location *BusinessLocation `json:"location"`
	// Opening hours of the business; may be null if none. The hours are guaranteed to be valid and has already been split by week days
	OpeningHours *BusinessOpeningHours `json:"opening_hours"`
	// Opening hours of the business in the local time; may be null if none. The hours are guaranteed to be valid and has already been split by week days. Local time zone identifier will be empty. An updateUserFullInfo update is not triggered when value of this field changes
	LocalOpeningHours *BusinessOpeningHours `json:"local_opening_hours"`
	// Time left before the business will open the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
	NextOpenIn int32 `json:"next_open_in"`
	// Time left before the business will close the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
	NextCloseIn int32 `json:"next_close_in"`
	// The greeting message; may be null if none or the Business account is not of the current user
	GreetingMessageSettings *BusinessGreetingMessageSettings `json:"greeting_message_settings"`
	// The away message; may be null if none or the Business account is not of the current user
	AwayMessageSettings *BusinessAwayMessageSettings `json:"away_message_settings"`
	// Information about start page of the account; may be null if none
	StartPage *BusinessStartPage `json:"start_page"`
}

func (entity *BusinessInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessInfo

	return json.Marshal((*stub)(entity))
}

func (*BusinessInfo) GetClass() string {
	return ClassBusinessInfo
}

func (*BusinessInfo) GetType() string {
	return TypeBusinessInfo
}

// Contains information about a business chat link
type BusinessChatLink struct {
	meta
	// The HTTPS link
	Link string `json:"link"`
	// Message draft text that will be added to the input field
	Text *FormattedText `json:"text"`
	// Link title
	Title string `json:"title"`
	// Number of times the link was used
	ViewCount int32 `json:"view_count"`
}

func (entity *BusinessChatLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessChatLink

	return json.Marshal((*stub)(entity))
}

func (*BusinessChatLink) GetClass() string {
	return ClassBusinessChatLink
}

func (*BusinessChatLink) GetType() string {
	return TypeBusinessChatLink
}

// Contains a list of business chat links created by the user
type BusinessChatLinks struct {
	meta
	// List of links
	Links []*BusinessChatLink `json:"links"`
}

func (entity *BusinessChatLinks) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessChatLinks

	return json.Marshal((*stub)(entity))
}

func (*BusinessChatLinks) GetClass() string {
	return ClassBusinessChatLinks
}

func (*BusinessChatLinks) GetType() string {
	return TypeBusinessChatLinks
}

// Describes a business chat link to create or edit
type InputBusinessChatLink struct {
	meta
	// Message draft text that will be added to the input field
	Text *FormattedText `json:"text"`
	// Link title
	Title string `json:"title"`
}

func (entity *InputBusinessChatLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBusinessChatLink

	return json.Marshal((*stub)(entity))
}

func (*InputBusinessChatLink) GetClass() string {
	return ClassInputBusinessChatLink
}

func (*InputBusinessChatLink) GetType() string {
	return TypeInputBusinessChatLink
}

// Contains information about a business chat link
type BusinessChatLinkInfo struct {
	meta
	// Identifier of the private chat that created the link
	ChatId int64 `json:"chat_id"`
	// Message draft text that must be added to the input field
	Text *FormattedText `json:"text"`
}

func (entity *BusinessChatLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessChatLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*BusinessChatLinkInfo) GetClass() string {
	return ClassBusinessChatLinkInfo
}

func (*BusinessChatLinkInfo) GetType() string {
	return TypeBusinessChatLinkInfo
}

// Information about the sticker, which was used to create the chat photo
type ChatPhotoStickerTypeRegularOrMask struct {
	meta
	// Sticker set identifier
	StickerSetId JsonInt64 `json:"sticker_set_id"`
	// Identifier of the sticker in the set
	StickerId JsonInt64 `json:"sticker_id"`
}

func (entity *ChatPhotoStickerTypeRegularOrMask) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoStickerTypeRegularOrMask

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoStickerTypeRegularOrMask) GetClass() string {
	return ClassChatPhotoStickerType
}

func (*ChatPhotoStickerTypeRegularOrMask) GetType() string {
	return TypeChatPhotoStickerTypeRegularOrMask
}

func (*ChatPhotoStickerTypeRegularOrMask) ChatPhotoStickerTypeType() string {
	return TypeChatPhotoStickerTypeRegularOrMask
}

// Information about the custom emoji, which was used to create the chat photo
type ChatPhotoStickerTypeCustomEmoji struct {
	meta
	// Identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *ChatPhotoStickerTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoStickerTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoStickerTypeCustomEmoji) GetClass() string {
	return ClassChatPhotoStickerType
}

func (*ChatPhotoStickerTypeCustomEmoji) GetType() string {
	return TypeChatPhotoStickerTypeCustomEmoji
}

func (*ChatPhotoStickerTypeCustomEmoji) ChatPhotoStickerTypeType() string {
	return TypeChatPhotoStickerTypeCustomEmoji
}

// Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it
type ChatPhotoSticker struct {
	meta
	// Type of the sticker
	Type ChatPhotoStickerType `json:"type"`
	// The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
	BackgroundFill BackgroundFill `json:"background_fill"`
}

func (entity *ChatPhotoSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotoSticker

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotoSticker) GetClass() string {
	return ClassChatPhotoSticker
}

func (*ChatPhotoSticker) GetType() string {
	return TypeChatPhotoSticker
}

func (chatPhotoSticker *ChatPhotoSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type           json.RawMessage `json:"type"`
		BackgroundFill json.RawMessage `json:"background_fill"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldType, _ := UnmarshalChatPhotoStickerType(tmp.Type)
	chatPhotoSticker.Type = fieldType

	fieldBackgroundFill, _ := UnmarshalBackgroundFill(tmp.BackgroundFill)
	chatPhotoSticker.BackgroundFill = fieldBackgroundFill

	return nil
}

// Animated variant of a chat photo in MPEG4 format
type AnimatedChatPhoto struct {
	meta
	// Animation width and height
	Length int32 `json:"length"`
	// Information about the animation file
	File *File `json:"file"`
	// Timestamp of the frame, used as a static chat photo
	MainFrameTimestamp float64 `json:"main_frame_timestamp"`
}

func (entity *AnimatedChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AnimatedChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*AnimatedChatPhoto) GetClass() string {
	return ClassAnimatedChatPhoto
}

func (*AnimatedChatPhoto) GetType() string {
	return TypeAnimatedChatPhoto
}

// Describes a chat or user profile photo
type ChatPhoto struct {
	meta
	// Unique photo identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the photo has been added
	AddedDate int32 `json:"added_date"`
	// Photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Available variants of the photo in JPEG format, in different size
	Sizes []*PhotoSize `json:"sizes"`
	// A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
	Animation *AnimatedChatPhoto `json:"animation"`
	// A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
	SmallAnimation *AnimatedChatPhoto `json:"small_animation"`
	// Sticker-based version of the chat photo; may be null
	Sticker *ChatPhotoSticker `json:"sticker"`
}

func (entity *ChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*ChatPhoto) GetClass() string {
	return ClassChatPhoto
}

func (*ChatPhoto) GetType() string {
	return TypeChatPhoto
}

// Contains a list of chat or user profile photos
type ChatPhotos struct {
	meta
	// Total number of photos
	TotalCount int32 `json:"total_count"`
	// List of photos
	Photos []*ChatPhoto `json:"photos"`
}

func (entity *ChatPhotos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhotos

	return json.Marshal((*stub)(entity))
}

func (*ChatPhotos) GetClass() string {
	return ClassChatPhotos
}

func (*ChatPhotos) GetType() string {
	return TypeChatPhotos
}

// A previously used profile photo of the current user
type InputChatPhotoPrevious struct {
	meta
	// Identifier of the current user's profile photo to reuse
	ChatPhotoId JsonInt64 `json:"chat_photo_id"`
}

func (entity *InputChatPhotoPrevious) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoPrevious

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoPrevious) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoPrevious) GetType() string {
	return TypeInputChatPhotoPrevious
}

func (*InputChatPhotoPrevious) InputChatPhotoType() string {
	return TypeInputChatPhotoPrevious
}

// A static photo in JPEG format
type InputChatPhotoStatic struct {
	meta
	// Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
	Photo InputFile `json:"photo"`
}

func (entity *InputChatPhotoStatic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoStatic

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoStatic) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoStatic) GetType() string {
	return TypeInputChatPhotoStatic
}

func (*InputChatPhotoStatic) InputChatPhotoType() string {
	return TypeInputChatPhotoStatic
}

func (inputChatPhotoStatic *InputChatPhotoStatic) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Photo json.RawMessage `json:"photo"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldPhoto, _ := UnmarshalInputFile(tmp.Photo)
	inputChatPhotoStatic.Photo = fieldPhoto

	return nil
}

// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size
type InputChatPhotoAnimation struct {
	meta
	// Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
	Animation InputFile `json:"animation"`
	// Timestamp of the frame, which will be used as static chat photo
	MainFrameTimestamp float64 `json:"main_frame_timestamp"`
}

func (entity *InputChatPhotoAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoAnimation) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoAnimation) GetType() string {
	return TypeInputChatPhotoAnimation
}

func (*InputChatPhotoAnimation) InputChatPhotoType() string {
	return TypeInputChatPhotoAnimation
}

func (inputChatPhotoAnimation *InputChatPhotoAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Animation          json.RawMessage `json:"animation"`
		MainFrameTimestamp float64         `json:"main_frame_timestamp"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputChatPhotoAnimation.MainFrameTimestamp = tmp.MainFrameTimestamp

	fieldAnimation, _ := UnmarshalInputFile(tmp.Animation)
	inputChatPhotoAnimation.Animation = fieldAnimation

	return nil
}

// A sticker on a custom background
type InputChatPhotoSticker struct {
	meta
	// Information about the sticker
	Sticker *ChatPhotoSticker `json:"sticker"`
}

func (entity *InputChatPhotoSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputChatPhotoSticker

	return json.Marshal((*stub)(entity))
}

func (*InputChatPhotoSticker) GetClass() string {
	return ClassInputChatPhoto
}

func (*InputChatPhotoSticker) GetType() string {
	return TypeInputChatPhotoSticker
}

func (*InputChatPhotoSticker) InputChatPhotoType() string {
	return TypeInputChatPhotoSticker
}

// Describes actions that a user is allowed to take in a chat
type ChatPermissions struct {
	meta
	// True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
	CanSendBasicMessages bool `json:"can_send_basic_messages"`
	// True, if the user can send music files
	CanSendAudios bool `json:"can_send_audios"`
	// True, if the user can send documents
	CanSendDocuments bool `json:"can_send_documents"`
	// True, if the user can send photos
	CanSendPhotos bool `json:"can_send_photos"`
	// True, if the user can send videos
	CanSendVideos bool `json:"can_send_videos"`
	// True, if the user can send video notes
	CanSendVideoNotes bool `json:"can_send_video_notes"`
	// True, if the user can send voice notes
	CanSendVoiceNotes bool `json:"can_send_voice_notes"`
	// True, if the user can send polls
	CanSendPolls bool `json:"can_send_polls"`
	// True, if the user can send animations, games, stickers, and dice and use inline bots
	CanSendOtherMessages bool `json:"can_send_other_messages"`
	// True, if the user may add a link preview to their messages
	CanAddLinkPreviews bool `json:"can_add_link_previews"`
	// True, if the user can change the chat title, photo, and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// True, if the user can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// True, if the user can pin messages
	CanPinMessages bool `json:"can_pin_messages"`
	// True, if the user can create topics
	CanCreateTopics bool `json:"can_create_topics"`
}

func (entity *ChatPermissions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPermissions

	return json.Marshal((*stub)(entity))
}

func (*ChatPermissions) GetClass() string {
	return ClassChatPermissions
}

func (*ChatPermissions) GetType() string {
	return TypeChatPermissions
}

// Describes rights of the administrator
type ChatAdministratorRights struct {
	meta
	// True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
	CanManageChat bool `json:"can_manage_chat"`
	// True, if the administrator can change the chat title, photo, and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// True, if the administrator can create channel posts or view channel statistics; applicable to channels only
	CanPostMessages bool `json:"can_post_messages"`
	// True, if the administrator can edit messages of other users and pin messages; applicable to channels only
	CanEditMessages bool `json:"can_edit_messages"`
	// True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`
	// True, if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
	CanRestrictMembers bool `json:"can_restrict_members"`
	// True, if the administrator can pin messages; applicable to basic groups and supergroups only
	CanPinMessages bool `json:"can_pin_messages"`
	// True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only
	CanManageTopics bool `json:"can_manage_topics"`
	// True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
	CanPromoteMembers bool `json:"can_promote_members"`
	// True, if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats"`
	// True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only
	CanPostStories bool `json:"can_post_stories"`
	// True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only
	CanEditStories bool `json:"can_edit_stories"`
	// True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only
	CanDeleteStories bool `json:"can_delete_stories"`
	// True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
	IsAnonymous bool `json:"is_anonymous"`
}

func (entity *ChatAdministratorRights) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministratorRights

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministratorRights) GetClass() string {
	return ClassChatAdministratorRights
}

func (*ChatAdministratorRights) GetType() string {
	return TypeChatAdministratorRights
}

// Describes a subscription to a channel chat
type StarSubscriptionTypeChannel struct {
	meta
	// True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again
	CanReuse bool `json:"can_reuse"`
	// The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore
	InviteLink string `json:"invite_link"`
}

func (entity *StarSubscriptionTypeChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarSubscriptionTypeChannel

	return json.Marshal((*stub)(entity))
}

func (*StarSubscriptionTypeChannel) GetClass() string {
	return ClassStarSubscriptionType
}

func (*StarSubscriptionTypeChannel) GetType() string {
	return TypeStarSubscriptionTypeChannel
}

func (*StarSubscriptionTypeChannel) StarSubscriptionTypeType() string {
	return TypeStarSubscriptionTypeChannel
}

// Describes a subscription in a bot or a business account
type StarSubscriptionTypeBot struct {
	meta
	// True, if the subscription was canceled by the bot and can't be extended
	IsCanceledByBot bool `json:"is_canceled_by_bot"`
	// Subscription invoice title
	Title string `json:"title"`
	// Subscription invoice photo
	Photo *Photo `json:"photo"`
	// The link to the subscription invoice
	InvoiceLink string `json:"invoice_link"`
}

func (entity *StarSubscriptionTypeBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarSubscriptionTypeBot

	return json.Marshal((*stub)(entity))
}

func (*StarSubscriptionTypeBot) GetClass() string {
	return ClassStarSubscriptionType
}

func (*StarSubscriptionTypeBot) GetType() string {
	return TypeStarSubscriptionTypeBot
}

func (*StarSubscriptionTypeBot) StarSubscriptionTypeType() string {
	return TypeStarSubscriptionTypeBot
}

// Describes subscription plan paid in Telegram Stars
type StarSubscriptionPricing struct {
	meta
	// The number of seconds between consecutive Telegram Star debiting
	Period int32 `json:"period"`
	// The amount of Telegram Stars that must be paid for each period
	StarCount int64 `json:"star_count"`
}

func (entity *StarSubscriptionPricing) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarSubscriptionPricing

	return json.Marshal((*stub)(entity))
}

func (*StarSubscriptionPricing) GetClass() string {
	return ClassStarSubscriptionPricing
}

func (*StarSubscriptionPricing) GetType() string {
	return TypeStarSubscriptionPricing
}

// Contains information about subscription to a channel chat, a bot, or a business account that was paid in Telegram Stars
type StarSubscription struct {
	meta
	// Unique identifier of the subscription
	Id string `json:"id"`
	// Identifier of the chat that is subscribed
	ChatId int64 `json:"chat_id"`
	// Point in time (Unix timestamp) when the subscription will expire or expired
	ExpirationDate int32 `json:"expiration_date"`
	// True, if the subscription was canceled
	IsCanceled bool `json:"is_canceled"`
	// True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it
	IsExpiring bool `json:"is_expiring"`
	// The subscription plan
	Pricing *StarSubscriptionPricing `json:"pricing"`
	// Type of the subscription
	Type StarSubscriptionType `json:"type"`
}

func (entity *StarSubscription) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarSubscription

	return json.Marshal((*stub)(entity))
}

func (*StarSubscription) GetClass() string {
	return ClassStarSubscription
}

func (*StarSubscription) GetType() string {
	return TypeStarSubscription
}

func (starSubscription *StarSubscription) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id             string                   `json:"id"`
		ChatId         int64                    `json:"chat_id"`
		ExpirationDate int32                    `json:"expiration_date"`
		IsCanceled     bool                     `json:"is_canceled"`
		IsExpiring     bool                     `json:"is_expiring"`
		Pricing        *StarSubscriptionPricing `json:"pricing"`
		Type           json.RawMessage          `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starSubscription.Id = tmp.Id
	starSubscription.ChatId = tmp.ChatId
	starSubscription.ExpirationDate = tmp.ExpirationDate
	starSubscription.IsCanceled = tmp.IsCanceled
	starSubscription.IsExpiring = tmp.IsExpiring
	starSubscription.Pricing = tmp.Pricing

	fieldType, _ := UnmarshalStarSubscriptionType(tmp.Type)
	starSubscription.Type = fieldType

	return nil
}

// Represents a list of Telegram Star subscriptions
type StarSubscriptions struct {
	meta
	// The amount of owned Telegram Stars
	StarCount int64 `json:"star_count"`
	// List of subscriptions for Telegram Stars
	Subscriptions []*StarSubscription `json:"subscriptions"`
	// The number of Telegram Stars required to buy to extend subscriptions expiring soon
	RequiredStarCount int64 `json:"required_star_count"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *StarSubscriptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarSubscriptions

	return json.Marshal((*stub)(entity))
}

func (*StarSubscriptions) GetClass() string {
	return ClassStarSubscriptions
}

func (*StarSubscriptions) GetType() string {
	return TypeStarSubscriptions
}

// Contains information about a product that can be paid with invoice
type ProductInfo struct {
	meta
	// Product title
	Title string `json:"title"`
	// Product description
	Description *FormattedText `json:"description"`
	// Product photo; may be null
	Photo *Photo `json:"photo"`
}

func (entity *ProductInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProductInfo

	return json.Marshal((*stub)(entity))
}

func (*ProductInfo) GetClass() string {
	return ClassProductInfo
}

func (*ProductInfo) GetType() string {
	return TypeProductInfo
}

// Describes an option for buying Telegram Premium to a user
type PremiumPaymentOption struct {
	meta
	// ISO 4217 currency code for Telegram Premium subscription payment
	Currency string `json:"currency"`
	// The amount to pay, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// The discount associated with this option, as a percentage
	DiscountPercentage int32 `json:"discount_percentage"`
	// Number of months the Telegram Premium subscription will be active. Use getPremiumInfoSticker to get the sticker to be used as representation of the Telegram Premium subscription
	MonthCount int32 `json:"month_count"`
	// Identifier of the store product associated with the option
	StoreProductId string `json:"store_product_id"`
	// An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
	PaymentLink InternalLinkType `json:"payment_link"`
}

func (entity *PremiumPaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumPaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PremiumPaymentOption) GetClass() string {
	return ClassPremiumPaymentOption
}

func (*PremiumPaymentOption) GetType() string {
	return TypePremiumPaymentOption
}

func (premiumPaymentOption *PremiumPaymentOption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Currency           string          `json:"currency"`
		Amount             int64           `json:"amount"`
		DiscountPercentage int32           `json:"discount_percentage"`
		MonthCount         int32           `json:"month_count"`
		StoreProductId     string          `json:"store_product_id"`
		PaymentLink        json.RawMessage `json:"payment_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumPaymentOption.Currency = tmp.Currency
	premiumPaymentOption.Amount = tmp.Amount
	premiumPaymentOption.DiscountPercentage = tmp.DiscountPercentage
	premiumPaymentOption.MonthCount = tmp.MonthCount
	premiumPaymentOption.StoreProductId = tmp.StoreProductId

	fieldPaymentLink, _ := UnmarshalInternalLinkType(tmp.PaymentLink)
	premiumPaymentOption.PaymentLink = fieldPaymentLink

	return nil
}

// Describes an option for buying or upgrading Telegram Premium for self
type PremiumStatePaymentOption struct {
	meta
	// Information about the payment option
	PaymentOption *PremiumPaymentOption `json:"payment_option"`
	// True, if this is the currently used Telegram Premium subscription option
	IsCurrent bool `json:"is_current"`
	// True, if the payment option can be used to upgrade the existing Telegram Premium subscription
	IsUpgrade bool `json:"is_upgrade"`
	// Identifier of the last in-store transaction for the currently used option
	LastTransactionId string `json:"last_transaction_id"`
}

func (entity *PremiumStatePaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStatePaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PremiumStatePaymentOption) GetClass() string {
	return ClassPremiumStatePaymentOption
}

func (*PremiumStatePaymentOption) GetType() string {
	return TypePremiumStatePaymentOption
}

// Describes an option for creating Telegram Premium gift codes or Telegram Premium giveaway. Use telegramPaymentPurposePremiumGiftCodes or telegramPaymentPurposePremiumGiveaway for out-of-store payments
type PremiumGiftCodePaymentOption struct {
	meta
	// ISO 4217 currency code for Telegram Premium gift code payment
	Currency string `json:"currency"`
	// The amount to pay, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// The discount associated with this option, as a percentage
	DiscountPercentage int32 `json:"discount_percentage"`
	// Number of users which will be able to activate the gift codes
	WinnerCount int32 `json:"winner_count"`
	// Number of months the Telegram Premium subscription will be active
	MonthCount int32 `json:"month_count"`
	// Identifier of the store product associated with the option; may be empty if none
	StoreProductId string `json:"store_product_id"`
	// Number of times the store product must be paid
	StoreProductQuantity int32 `json:"store_product_quantity"`
	// A sticker to be shown along with the gift code; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *PremiumGiftCodePaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumGiftCodePaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PremiumGiftCodePaymentOption) GetClass() string {
	return ClassPremiumGiftCodePaymentOption
}

func (*PremiumGiftCodePaymentOption) GetType() string {
	return TypePremiumGiftCodePaymentOption
}

// Contains a list of options for creating Telegram Premium gift codes or Telegram Premium giveaway
type PremiumGiftCodePaymentOptions struct {
	meta
	// The list of options
	Options []*PremiumGiftCodePaymentOption `json:"options"`
}

func (entity *PremiumGiftCodePaymentOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumGiftCodePaymentOptions

	return json.Marshal((*stub)(entity))
}

func (*PremiumGiftCodePaymentOptions) GetClass() string {
	return ClassPremiumGiftCodePaymentOptions
}

func (*PremiumGiftCodePaymentOptions) GetType() string {
	return TypePremiumGiftCodePaymentOptions
}

// Contains information about a Telegram Premium gift code
type PremiumGiftCodeInfo struct {
	meta
	// Identifier of a chat or a user that created the gift code; may be null if unknown. If null and the code is from messagePremiumGiftCode message, then creator_id from the message can be used
	CreatorId MessageSender `json:"creator_id"`
	// Point in time (Unix timestamp) when the code was created
	CreationDate int32 `json:"creation_date"`
	// True, if the gift code was created for a giveaway
	IsFromGiveaway bool `json:"is_from_giveaway"`
	// Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
	GiveawayMessageId int64 `json:"giveaway_message_id"`
	// Number of months the Telegram Premium subscription will be active after code activation
	MonthCount int32 `json:"month_count"`
	// Identifier of a user for which the code was created; 0 if none
	UserId int64 `json:"user_id"`
	// Point in time (Unix timestamp) when the code was activated; 0 if none
	UseDate int32 `json:"use_date"`
}

func (entity *PremiumGiftCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumGiftCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*PremiumGiftCodeInfo) GetClass() string {
	return ClassPremiumGiftCodeInfo
}

func (*PremiumGiftCodeInfo) GetType() string {
	return TypePremiumGiftCodeInfo
}

func (premiumGiftCodeInfo *PremiumGiftCodeInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		CreatorId         json.RawMessage `json:"creator_id"`
		CreationDate      int32           `json:"creation_date"`
		IsFromGiveaway    bool            `json:"is_from_giveaway"`
		GiveawayMessageId int64           `json:"giveaway_message_id"`
		MonthCount        int32           `json:"month_count"`
		UserId            int64           `json:"user_id"`
		UseDate           int32           `json:"use_date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumGiftCodeInfo.CreationDate = tmp.CreationDate
	premiumGiftCodeInfo.IsFromGiveaway = tmp.IsFromGiveaway
	premiumGiftCodeInfo.GiveawayMessageId = tmp.GiveawayMessageId
	premiumGiftCodeInfo.MonthCount = tmp.MonthCount
	premiumGiftCodeInfo.UserId = tmp.UserId
	premiumGiftCodeInfo.UseDate = tmp.UseDate

	fieldCreatorId, _ := UnmarshalMessageSender(tmp.CreatorId)
	premiumGiftCodeInfo.CreatorId = fieldCreatorId

	return nil
}

// Describes an option for buying Telegram Stars. Use telegramPaymentPurposeStars for out-of-store payments
type StarPaymentOption struct {
	meta
	// ISO 4217 currency code for the payment
	Currency string `json:"currency"`
	// The amount to pay, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of Telegram Stars that will be purchased
	StarCount int64 `json:"star_count"`
	// Identifier of the store product associated with the option; may be empty if none
	StoreProductId string `json:"store_product_id"`
	// True, if the option must be shown only in the full list of payment options
	IsAdditional bool `json:"is_additional"`
}

func (entity *StarPaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarPaymentOption

	return json.Marshal((*stub)(entity))
}

func (*StarPaymentOption) GetClass() string {
	return ClassStarPaymentOption
}

func (*StarPaymentOption) GetType() string {
	return TypeStarPaymentOption
}

// Contains a list of options for buying Telegram Stars
type StarPaymentOptions struct {
	meta
	// The list of options
	Options []*StarPaymentOption `json:"options"`
}

func (entity *StarPaymentOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarPaymentOptions

	return json.Marshal((*stub)(entity))
}

func (*StarPaymentOptions) GetClass() string {
	return ClassStarPaymentOptions
}

func (*StarPaymentOptions) GetType() string {
	return TypeStarPaymentOptions
}

// Describes an option for the number of winners of a Telegram Star giveaway
type StarGiveawayWinnerOption struct {
	meta
	// The number of users that will be chosen as winners
	WinnerCount int32 `json:"winner_count"`
	// The number of Telegram Stars that will be won by the winners of the giveaway
	WonStarCount int64 `json:"won_star_count"`
	// True, if the option must be chosen by default
	IsDefault bool `json:"is_default"`
}

func (entity *StarGiveawayWinnerOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarGiveawayWinnerOption

	return json.Marshal((*stub)(entity))
}

func (*StarGiveawayWinnerOption) GetClass() string {
	return ClassStarGiveawayWinnerOption
}

func (*StarGiveawayWinnerOption) GetType() string {
	return TypeStarGiveawayWinnerOption
}

// Describes an option for creating Telegram Star giveaway. Use telegramPaymentPurposeStarGiveaway for out-of-store payments
type StarGiveawayPaymentOption struct {
	meta
	// ISO 4217 currency code for the payment
	Currency string `json:"currency"`
	// The amount to pay, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of Telegram Stars that will be distributed among winners
	StarCount int64 `json:"star_count"`
	// Identifier of the store product associated with the option; may be empty if none
	StoreProductId string `json:"store_product_id"`
	// Number of times the chat will be boosted for one year if the option is chosen
	YearlyBoostCount int32 `json:"yearly_boost_count"`
	// Allowed options for the number of giveaway winners
	WinnerOptions []*StarGiveawayWinnerOption `json:"winner_options"`
	// True, if the option must be chosen by default
	IsDefault bool `json:"is_default"`
	// True, if the option must be shown only in the full list of payment options
	IsAdditional bool `json:"is_additional"`
}

func (entity *StarGiveawayPaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarGiveawayPaymentOption

	return json.Marshal((*stub)(entity))
}

func (*StarGiveawayPaymentOption) GetClass() string {
	return ClassStarGiveawayPaymentOption
}

func (*StarGiveawayPaymentOption) GetType() string {
	return TypeStarGiveawayPaymentOption
}

// Contains a list of options for creating Telegram Star giveaway
type StarGiveawayPaymentOptions struct {
	meta
	// The list of options
	Options []*StarGiveawayPaymentOption `json:"options"`
}

func (entity *StarGiveawayPaymentOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarGiveawayPaymentOptions

	return json.Marshal((*stub)(entity))
}

func (*StarGiveawayPaymentOptions) GetClass() string {
	return ClassStarGiveawayPaymentOptions
}

func (*StarGiveawayPaymentOptions) GetType() string {
	return TypeStarGiveawayPaymentOptions
}

// Describes a gift that can be sent to another user
type Gift struct {
	meta
	// Unique identifier of the gift
	Id JsonInt64 `json:"id"`
	// The sticker representing the gift
	Sticker *Sticker `json:"sticker"`
	// Number of Telegram Stars that must be paid for the gift
	StarCount int64 `json:"star_count"`
	// Number of Telegram Stars that can be claimed by the receiver instead of the gift by default. If the gift was paid with just bought Telegram Stars, then full value can be claimed
	DefaultSellStarCount int64 `json:"default_sell_star_count"`
	// True, if the gift is a birthday gift
	IsForBirthday bool `json:"is_for_birthday"`
	// Number of remaining times the gift can be purchased by all users; 0 if not limited or the gift was sold out
	RemainingCount int32 `json:"remaining_count"`
	// Number of total times the gift can be purchased by all users; 0 if not limited
	TotalCount int32 `json:"total_count"`
	// Point in time (Unix timestamp) when the gift was send for the first time; for sold out gifts only
	FirstSendDate int32 `json:"first_send_date"`
	// Point in time (Unix timestamp) when the gift was send for the last time; for sold out gifts only
	LastSendDate int32 `json:"last_send_date"`
}

func (entity *Gift) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Gift

	return json.Marshal((*stub)(entity))
}

func (*Gift) GetClass() string {
	return ClassGift
}

func (*Gift) GetType() string {
	return TypeGift
}

// Contains a list of gifts that can be sent to another user
type Gifts struct {
	meta
	// The list of gifts
	Gifts []*Gift `json:"gifts"`
}

func (entity *Gifts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Gifts

	return json.Marshal((*stub)(entity))
}

func (*Gifts) GetClass() string {
	return ClassGifts
}

func (*Gifts) GetType() string {
	return TypeGifts
}

// Represents a gift received by a user
type UserGift struct {
	meta
	// Identifier of the user that sent the gift; 0 if unknown
	SenderUserId int64 `json:"sender_user_id"`
	// Message added to the gift
	Text *FormattedText `json:"text"`
	// True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone are able to see them
	IsPrivate bool `json:"is_private"`
	// True, if the gift is displayed on the user's profile page; may be false only for the receiver of the gift
	IsSaved bool `json:"is_saved"`
	// Point in time (Unix timestamp) when the gift was sent
	Date int32 `json:"date"`
	// The gift
	Gift *Gift `json:"gift"`
	// Identifier of the message with the gift in the chat with the sender of the gift; can be 0 or an identifier of a deleted message; only for the gift receiver
	MessageId int64 `json:"message_id"`
	// Number of Telegram Stars that can be claimed by the receiver instead of the gift; 0 if the gift can't be sold by the current user
	SellStarCount int64 `json:"sell_star_count"`
}

func (entity *UserGift) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserGift

	return json.Marshal((*stub)(entity))
}

func (*UserGift) GetClass() string {
	return ClassUserGift
}

func (*UserGift) GetType() string {
	return TypeUserGift
}

// Represents a list of gifts received by a user
type UserGifts struct {
	meta
	// The total number of received gifts
	TotalCount int32 `json:"total_count"`
	// The list of gifts
	Gifts []*UserGift `json:"gifts"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *UserGifts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserGifts

	return json.Marshal((*stub)(entity))
}

func (*UserGifts) GetClass() string {
	return ClassUserGifts
}

func (*UserGifts) GetType() string {
	return TypeUserGifts
}

// The transaction is incoming and increases the number of owned Telegram Stars
type StarTransactionDirectionIncoming struct {
	meta
}

func (entity *StarTransactionDirectionIncoming) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionDirectionIncoming

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionDirectionIncoming) GetClass() string {
	return ClassStarTransactionDirection
}

func (*StarTransactionDirectionIncoming) GetType() string {
	return TypeStarTransactionDirectionIncoming
}

func (*StarTransactionDirectionIncoming) StarTransactionDirectionType() string {
	return TypeStarTransactionDirectionIncoming
}

// The transaction is outgoing and decreases the number of owned Telegram Stars
type StarTransactionDirectionOutgoing struct {
	meta
}

func (entity *StarTransactionDirectionOutgoing) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionDirectionOutgoing

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionDirectionOutgoing) GetClass() string {
	return ClassStarTransactionDirection
}

func (*StarTransactionDirectionOutgoing) GetType() string {
	return TypeStarTransactionDirectionOutgoing
}

func (*StarTransactionDirectionOutgoing) StarTransactionDirectionType() string {
	return TypeStarTransactionDirectionOutgoing
}

// Paid media were bought
type BotTransactionPurposePaidMedia struct {
	meta
	// The bought media if the transaction wasn't refunded
	Media []PaidMedia `json:"media"`
	// Bot-provided payload; for bots only
	Payload string `json:"payload"`
}

func (entity *BotTransactionPurposePaidMedia) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotTransactionPurposePaidMedia

	return json.Marshal((*stub)(entity))
}

func (*BotTransactionPurposePaidMedia) GetClass() string {
	return ClassBotTransactionPurpose
}

func (*BotTransactionPurposePaidMedia) GetType() string {
	return TypeBotTransactionPurposePaidMedia
}

func (*BotTransactionPurposePaidMedia) BotTransactionPurposeType() string {
	return TypeBotTransactionPurposePaidMedia
}

func (botTransactionPurposePaidMedia *BotTransactionPurposePaidMedia) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Media   []json.RawMessage `json:"media"`
		Payload string            `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	botTransactionPurposePaidMedia.Payload = tmp.Payload

	fieldMedia, _ := UnmarshalListOfPaidMedia(tmp.Media)
	botTransactionPurposePaidMedia.Media = fieldMedia

	return nil
}

// User bought a product from the bot
type BotTransactionPurposeInvoicePayment struct {
	meta
	// Information about the bought product; may be null if not applicable
	ProductInfo *ProductInfo `json:"product_info"`
	// Invoice payload; for bots only
	InvoicePayload []byte `json:"invoice_payload"`
}

func (entity *BotTransactionPurposeInvoicePayment) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotTransactionPurposeInvoicePayment

	return json.Marshal((*stub)(entity))
}

func (*BotTransactionPurposeInvoicePayment) GetClass() string {
	return ClassBotTransactionPurpose
}

func (*BotTransactionPurposeInvoicePayment) GetType() string {
	return TypeBotTransactionPurposeInvoicePayment
}

func (*BotTransactionPurposeInvoicePayment) BotTransactionPurposeType() string {
	return TypeBotTransactionPurposeInvoicePayment
}

// User bought a subscription in a bot or a business account
type BotTransactionPurposeSubscription struct {
	meta
	// The number of seconds between consecutive Telegram Star debiting
	Period int32 `json:"period"`
	// Information about the bought subscription; may be null if not applicable
	ProductInfo *ProductInfo `json:"product_info"`
	// Invoice payload; for bots only
	InvoicePayload []byte `json:"invoice_payload"`
}

func (entity *BotTransactionPurposeSubscription) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotTransactionPurposeSubscription

	return json.Marshal((*stub)(entity))
}

func (*BotTransactionPurposeSubscription) GetClass() string {
	return ClassBotTransactionPurpose
}

func (*BotTransactionPurposeSubscription) GetType() string {
	return TypeBotTransactionPurposeSubscription
}

func (*BotTransactionPurposeSubscription) BotTransactionPurposeType() string {
	return TypeBotTransactionPurposeSubscription
}

// Paid media were bought
type ChatTransactionPurposePaidMedia struct {
	meta
	// Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message
	MessageId int64 `json:"message_id"`
	// The bought media if the transaction wasn't refunded
	Media []PaidMedia `json:"media"`
}

func (entity *ChatTransactionPurposePaidMedia) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTransactionPurposePaidMedia

	return json.Marshal((*stub)(entity))
}

func (*ChatTransactionPurposePaidMedia) GetClass() string {
	return ClassChatTransactionPurpose
}

func (*ChatTransactionPurposePaidMedia) GetType() string {
	return TypeChatTransactionPurposePaidMedia
}

func (*ChatTransactionPurposePaidMedia) ChatTransactionPurposeType() string {
	return TypeChatTransactionPurposePaidMedia
}

func (chatTransactionPurposePaidMedia *ChatTransactionPurposePaidMedia) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageId int64             `json:"message_id"`
		Media     []json.RawMessage `json:"media"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatTransactionPurposePaidMedia.MessageId = tmp.MessageId

	fieldMedia, _ := UnmarshalListOfPaidMedia(tmp.Media)
	chatTransactionPurposePaidMedia.Media = fieldMedia

	return nil
}

// User joined the channel and subscribed to regular payments in Telegram Stars
type ChatTransactionPurposeJoin struct {
	meta
	// The number of seconds between consecutive Telegram Star debiting
	Period int32 `json:"period"`
}

func (entity *ChatTransactionPurposeJoin) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTransactionPurposeJoin

	return json.Marshal((*stub)(entity))
}

func (*ChatTransactionPurposeJoin) GetClass() string {
	return ClassChatTransactionPurpose
}

func (*ChatTransactionPurposeJoin) GetType() string {
	return TypeChatTransactionPurposeJoin
}

func (*ChatTransactionPurposeJoin) ChatTransactionPurposeType() string {
	return TypeChatTransactionPurposeJoin
}

// User paid for a reaction
type ChatTransactionPurposeReaction struct {
	meta
	// Identifier of the reacted message; can be 0 or an identifier of a deleted message
	MessageId int64 `json:"message_id"`
}

func (entity *ChatTransactionPurposeReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTransactionPurposeReaction

	return json.Marshal((*stub)(entity))
}

func (*ChatTransactionPurposeReaction) GetClass() string {
	return ClassChatTransactionPurpose
}

func (*ChatTransactionPurposeReaction) GetType() string {
	return TypeChatTransactionPurposeReaction
}

func (*ChatTransactionPurposeReaction) ChatTransactionPurposeType() string {
	return TypeChatTransactionPurposeReaction
}

// User received Telegram Stars from a giveaway
type ChatTransactionPurposeGiveaway struct {
	meta
	// Identifier of the message with giveaway; can be 0 or an identifier of a deleted message
	GiveawayMessageId int64 `json:"giveaway_message_id"`
}

func (entity *ChatTransactionPurposeGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTransactionPurposeGiveaway

	return json.Marshal((*stub)(entity))
}

func (*ChatTransactionPurposeGiveaway) GetClass() string {
	return ClassChatTransactionPurpose
}

func (*ChatTransactionPurposeGiveaway) GetType() string {
	return TypeChatTransactionPurposeGiveaway
}

func (*ChatTransactionPurposeGiveaway) ChatTransactionPurposeType() string {
	return TypeChatTransactionPurposeGiveaway
}

// A user gifted Telegram Stars
type UserTransactionPurposeGiftedStars struct {
	meta
	// A sticker to be shown in the transaction information; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *UserTransactionPurposeGiftedStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTransactionPurposeGiftedStars

	return json.Marshal((*stub)(entity))
}

func (*UserTransactionPurposeGiftedStars) GetClass() string {
	return ClassUserTransactionPurpose
}

func (*UserTransactionPurposeGiftedStars) GetType() string {
	return TypeUserTransactionPurposeGiftedStars
}

func (*UserTransactionPurposeGiftedStars) UserTransactionPurposeType() string {
	return TypeUserTransactionPurposeGiftedStars
}

// The user sold a gift received from another user or bot
type UserTransactionPurposeGiftSell struct {
	meta
	// The gift
	Gift *Gift `json:"gift"`
}

func (entity *UserTransactionPurposeGiftSell) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTransactionPurposeGiftSell

	return json.Marshal((*stub)(entity))
}

func (*UserTransactionPurposeGiftSell) GetClass() string {
	return ClassUserTransactionPurpose
}

func (*UserTransactionPurposeGiftSell) GetType() string {
	return TypeUserTransactionPurposeGiftSell
}

func (*UserTransactionPurposeGiftSell) UserTransactionPurposeType() string {
	return TypeUserTransactionPurposeGiftSell
}

// The user or the bot sent a gift to a user
type UserTransactionPurposeGiftSend struct {
	meta
	// The gift
	Gift *Gift `json:"gift"`
}

func (entity *UserTransactionPurposeGiftSend) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTransactionPurposeGiftSend

	return json.Marshal((*stub)(entity))
}

func (*UserTransactionPurposeGiftSend) GetClass() string {
	return ClassUserTransactionPurpose
}

func (*UserTransactionPurposeGiftSend) GetType() string {
	return TypeUserTransactionPurposeGiftSend
}

func (*UserTransactionPurposeGiftSend) UserTransactionPurposeType() string {
	return TypeUserTransactionPurposeGiftSend
}

// The transaction is a transaction with Telegram through a bot
type StarTransactionPartnerTelegram struct {
	meta
}

func (entity *StarTransactionPartnerTelegram) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerTelegram

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerTelegram) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerTelegram) GetType() string {
	return TypeStarTransactionPartnerTelegram
}

func (*StarTransactionPartnerTelegram) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerTelegram
}

// The transaction is a transaction with App Store
type StarTransactionPartnerAppStore struct {
	meta
}

func (entity *StarTransactionPartnerAppStore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerAppStore

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerAppStore) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerAppStore) GetType() string {
	return TypeStarTransactionPartnerAppStore
}

func (*StarTransactionPartnerAppStore) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerAppStore
}

// The transaction is a transaction with Google Play
type StarTransactionPartnerGooglePlay struct {
	meta
}

func (entity *StarTransactionPartnerGooglePlay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerGooglePlay

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerGooglePlay) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerGooglePlay) GetType() string {
	return TypeStarTransactionPartnerGooglePlay
}

func (*StarTransactionPartnerGooglePlay) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerGooglePlay
}

// The transaction is a transaction with Fragment
type StarTransactionPartnerFragment struct {
	meta
	// State of the withdrawal; may be null for refunds from Fragment or for Telegram Stars bought on Fragment
	WithdrawalState RevenueWithdrawalState `json:"withdrawal_state"`
}

func (entity *StarTransactionPartnerFragment) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerFragment

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerFragment) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerFragment) GetType() string {
	return TypeStarTransactionPartnerFragment
}

func (*StarTransactionPartnerFragment) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerFragment
}

func (starTransactionPartnerFragment *StarTransactionPartnerFragment) UnmarshalJSON(data []byte) error {
	var tmp struct {
		WithdrawalState json.RawMessage `json:"withdrawal_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldWithdrawalState, _ := UnmarshalRevenueWithdrawalState(tmp.WithdrawalState)
	starTransactionPartnerFragment.WithdrawalState = fieldWithdrawalState

	return nil
}

// The transaction is a transaction with Telegram Ad platform
type StarTransactionPartnerTelegramAds struct {
	meta
}

func (entity *StarTransactionPartnerTelegramAds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerTelegramAds

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerTelegramAds) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerTelegramAds) GetType() string {
	return TypeStarTransactionPartnerTelegramAds
}

func (*StarTransactionPartnerTelegramAds) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerTelegramAds
}

// The transaction is a transaction with Telegram for API usage
type StarTransactionPartnerTelegramApi struct {
	meta
	// The number of billed requests
	RequestCount int32 `json:"request_count"`
}

func (entity *StarTransactionPartnerTelegramApi) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerTelegramApi

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerTelegramApi) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerTelegramApi) GetType() string {
	return TypeStarTransactionPartnerTelegramApi
}

func (*StarTransactionPartnerTelegramApi) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerTelegramApi
}

// The transaction is a transaction with a bot
type StarTransactionPartnerBot struct {
	meta
	// Identifier of the bot
	UserId int64 `json:"user_id"`
	// Purpose of the transaction
	Purpose BotTransactionPurpose `json:"purpose"`
}

func (entity *StarTransactionPartnerBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerBot

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerBot) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerBot) GetType() string {
	return TypeStarTransactionPartnerBot
}

func (*StarTransactionPartnerBot) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerBot
}

func (starTransactionPartnerBot *StarTransactionPartnerBot) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId  int64           `json:"user_id"`
		Purpose json.RawMessage `json:"purpose"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starTransactionPartnerBot.UserId = tmp.UserId

	fieldPurpose, _ := UnmarshalBotTransactionPurpose(tmp.Purpose)
	starTransactionPartnerBot.Purpose = fieldPurpose

	return nil
}

// The transaction is a transaction with a business account
type StarTransactionPartnerBusiness struct {
	meta
	// Identifier of the business account user
	UserId int64 `json:"user_id"`
	// The bought media if the transaction wasn't refunded
	Media []PaidMedia `json:"media"`
}

func (entity *StarTransactionPartnerBusiness) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerBusiness

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerBusiness) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerBusiness) GetType() string {
	return TypeStarTransactionPartnerBusiness
}

func (*StarTransactionPartnerBusiness) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerBusiness
}

func (starTransactionPartnerBusiness *StarTransactionPartnerBusiness) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int64             `json:"user_id"`
		Media  []json.RawMessage `json:"media"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starTransactionPartnerBusiness.UserId = tmp.UserId

	fieldMedia, _ := UnmarshalListOfPaidMedia(tmp.Media)
	starTransactionPartnerBusiness.Media = fieldMedia

	return nil
}

// The transaction is a transaction with a supergroup or a channel chat
type StarTransactionPartnerChat struct {
	meta
	// Identifier of the chat
	ChatId int64 `json:"chat_id"`
	// Purpose of the transaction
	Purpose ChatTransactionPurpose `json:"purpose"`
}

func (entity *StarTransactionPartnerChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerChat

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerChat) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerChat) GetType() string {
	return TypeStarTransactionPartnerChat
}

func (*StarTransactionPartnerChat) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerChat
}

func (starTransactionPartnerChat *StarTransactionPartnerChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId  int64           `json:"chat_id"`
		Purpose json.RawMessage `json:"purpose"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starTransactionPartnerChat.ChatId = tmp.ChatId

	fieldPurpose, _ := UnmarshalChatTransactionPurpose(tmp.Purpose)
	starTransactionPartnerChat.Purpose = fieldPurpose

	return nil
}

// The transaction is a transaction with another user
type StarTransactionPartnerUser struct {
	meta
	// Identifier of the user; 0 if the user was anonymous
	UserId int64 `json:"user_id"`
	// Purpose of the transaction
	Purpose UserTransactionPurpose `json:"purpose"`
}

func (entity *StarTransactionPartnerUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerUser

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerUser) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerUser) GetType() string {
	return TypeStarTransactionPartnerUser
}

func (*StarTransactionPartnerUser) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerUser
}

func (starTransactionPartnerUser *StarTransactionPartnerUser) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId  int64           `json:"user_id"`
		Purpose json.RawMessage `json:"purpose"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starTransactionPartnerUser.UserId = tmp.UserId

	fieldPurpose, _ := UnmarshalUserTransactionPurpose(tmp.Purpose)
	starTransactionPartnerUser.Purpose = fieldPurpose

	return nil
}

// The transaction is a transaction with unknown partner
type StarTransactionPartnerUnsupported struct {
	meta
}

func (entity *StarTransactionPartnerUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactionPartnerUnsupported

	return json.Marshal((*stub)(entity))
}

func (*StarTransactionPartnerUnsupported) GetClass() string {
	return ClassStarTransactionPartner
}

func (*StarTransactionPartnerUnsupported) GetType() string {
	return TypeStarTransactionPartnerUnsupported
}

func (*StarTransactionPartnerUnsupported) StarTransactionPartnerType() string {
	return TypeStarTransactionPartnerUnsupported
}

// Represents a transaction changing the amount of owned Telegram Stars
type StarTransaction struct {
	meta
	// Unique identifier of the transaction
	Id string `json:"id"`
	// The amount of added owned Telegram Stars; negative for outgoing transactions
	StarCount int64 `json:"star_count"`
	// True, if the transaction is a refund of a previous transaction
	IsRefund bool `json:"is_refund"`
	// Point in time (Unix timestamp) when the transaction was completed
	Date int32 `json:"date"`
	// Source of the incoming transaction, or its recipient for outgoing transactions
	Partner StarTransactionPartner `json:"partner"`
}

func (entity *StarTransaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransaction

	return json.Marshal((*stub)(entity))
}

func (*StarTransaction) GetClass() string {
	return ClassStarTransaction
}

func (*StarTransaction) GetType() string {
	return TypeStarTransaction
}

func (starTransaction *StarTransaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id        string          `json:"id"`
		StarCount int64           `json:"star_count"`
		IsRefund  bool            `json:"is_refund"`
		Date      int32           `json:"date"`
		Partner   json.RawMessage `json:"partner"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starTransaction.Id = tmp.Id
	starTransaction.StarCount = tmp.StarCount
	starTransaction.IsRefund = tmp.IsRefund
	starTransaction.Date = tmp.Date

	fieldPartner, _ := UnmarshalStarTransactionPartner(tmp.Partner)
	starTransaction.Partner = fieldPartner

	return nil
}

// Represents a list of Telegram Star transactions
type StarTransactions struct {
	meta
	// The amount of owned Telegram Stars
	StarCount int64 `json:"star_count"`
	// List of transactions with Telegram Stars
	Transactions []*StarTransaction `json:"transactions"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *StarTransactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarTransactions

	return json.Marshal((*stub)(entity))
}

func (*StarTransactions) GetClass() string {
	return ClassStarTransactions
}

func (*StarTransactions) GetType() string {
	return TypeStarTransactions
}

// The user is eligible for the giveaway
type GiveawayParticipantStatusEligible struct {
	meta
}

func (entity *GiveawayParticipantStatusEligible) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayParticipantStatusEligible

	return json.Marshal((*stub)(entity))
}

func (*GiveawayParticipantStatusEligible) GetClass() string {
	return ClassGiveawayParticipantStatus
}

func (*GiveawayParticipantStatusEligible) GetType() string {
	return TypeGiveawayParticipantStatusEligible
}

func (*GiveawayParticipantStatusEligible) GiveawayParticipantStatusType() string {
	return TypeGiveawayParticipantStatusEligible
}

// The user participates in the giveaway
type GiveawayParticipantStatusParticipating struct {
	meta
}

func (entity *GiveawayParticipantStatusParticipating) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayParticipantStatusParticipating

	return json.Marshal((*stub)(entity))
}

func (*GiveawayParticipantStatusParticipating) GetClass() string {
	return ClassGiveawayParticipantStatus
}

func (*GiveawayParticipantStatusParticipating) GetType() string {
	return TypeGiveawayParticipantStatusParticipating
}

func (*GiveawayParticipantStatusParticipating) GiveawayParticipantStatusType() string {
	return TypeGiveawayParticipantStatusParticipating
}

// The user can't participate in the giveaway, because they have already been member of the chat
type GiveawayParticipantStatusAlreadyWasMember struct {
	meta
	// Point in time (Unix timestamp) when the user joined the chat
	JoinedChatDate int32 `json:"joined_chat_date"`
}

func (entity *GiveawayParticipantStatusAlreadyWasMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayParticipantStatusAlreadyWasMember

	return json.Marshal((*stub)(entity))
}

func (*GiveawayParticipantStatusAlreadyWasMember) GetClass() string {
	return ClassGiveawayParticipantStatus
}

func (*GiveawayParticipantStatusAlreadyWasMember) GetType() string {
	return TypeGiveawayParticipantStatusAlreadyWasMember
}

func (*GiveawayParticipantStatusAlreadyWasMember) GiveawayParticipantStatusType() string {
	return TypeGiveawayParticipantStatusAlreadyWasMember
}

// The user can't participate in the giveaway, because they are an administrator in one of the chats that created the giveaway
type GiveawayParticipantStatusAdministrator struct {
	meta
	// Identifier of the chat administered by the user
	ChatId int64 `json:"chat_id"`
}

func (entity *GiveawayParticipantStatusAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayParticipantStatusAdministrator

	return json.Marshal((*stub)(entity))
}

func (*GiveawayParticipantStatusAdministrator) GetClass() string {
	return ClassGiveawayParticipantStatus
}

func (*GiveawayParticipantStatusAdministrator) GetType() string {
	return TypeGiveawayParticipantStatusAdministrator
}

func (*GiveawayParticipantStatusAdministrator) GiveawayParticipantStatusType() string {
	return TypeGiveawayParticipantStatusAdministrator
}

// The user can't participate in the giveaway, because they phone number is from a disallowed country
type GiveawayParticipantStatusDisallowedCountry struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code of the user's country
	UserCountryCode string `json:"user_country_code"`
}

func (entity *GiveawayParticipantStatusDisallowedCountry) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayParticipantStatusDisallowedCountry

	return json.Marshal((*stub)(entity))
}

func (*GiveawayParticipantStatusDisallowedCountry) GetClass() string {
	return ClassGiveawayParticipantStatus
}

func (*GiveawayParticipantStatusDisallowedCountry) GetType() string {
	return TypeGiveawayParticipantStatusDisallowedCountry
}

func (*GiveawayParticipantStatusDisallowedCountry) GiveawayParticipantStatusType() string {
	return TypeGiveawayParticipantStatusDisallowedCountry
}

// Describes an ongoing giveaway
type GiveawayInfoOngoing struct {
	meta
	// Point in time (Unix timestamp) when the giveaway was created
	CreationDate int32 `json:"creation_date"`
	// Status of the current user in the giveaway
	Status GiveawayParticipantStatus `json:"status"`
	// True, if the giveaway has ended and results are being prepared
	IsEnded bool `json:"is_ended"`
}

func (entity *GiveawayInfoOngoing) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayInfoOngoing

	return json.Marshal((*stub)(entity))
}

func (*GiveawayInfoOngoing) GetClass() string {
	return ClassGiveawayInfo
}

func (*GiveawayInfoOngoing) GetType() string {
	return TypeGiveawayInfoOngoing
}

func (*GiveawayInfoOngoing) GiveawayInfoType() string {
	return TypeGiveawayInfoOngoing
}

func (giveawayInfoOngoing *GiveawayInfoOngoing) UnmarshalJSON(data []byte) error {
	var tmp struct {
		CreationDate int32           `json:"creation_date"`
		Status       json.RawMessage `json:"status"`
		IsEnded      bool            `json:"is_ended"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	giveawayInfoOngoing.CreationDate = tmp.CreationDate
	giveawayInfoOngoing.IsEnded = tmp.IsEnded

	fieldStatus, _ := UnmarshalGiveawayParticipantStatus(tmp.Status)
	giveawayInfoOngoing.Status = fieldStatus

	return nil
}

// Describes a completed giveaway
type GiveawayInfoCompleted struct {
	meta
	// Point in time (Unix timestamp) when the giveaway was created
	CreationDate int32 `json:"creation_date"`
	// Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
	ActualWinnersSelectionDate int32 `json:"actual_winners_selection_date"`
	// True, if the giveaway was canceled and was fully refunded
	WasRefunded bool `json:"was_refunded"`
	// True, if the current user is a winner of the giveaway
	IsWinner bool `json:"is_winner"`
	// Number of winners in the giveaway
	WinnerCount int32 `json:"winner_count"`
	// Number of winners, which activated their gift codes; for Telegram Premium giveaways only
	ActivationCount int32 `json:"activation_count"`
	// Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway
	GiftCode string `json:"gift_code"`
	// The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway
	WonStarCount int64 `json:"won_star_count"`
}

func (entity *GiveawayInfoCompleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayInfoCompleted

	return json.Marshal((*stub)(entity))
}

func (*GiveawayInfoCompleted) GetClass() string {
	return ClassGiveawayInfo
}

func (*GiveawayInfoCompleted) GetType() string {
	return TypeGiveawayInfoCompleted
}

func (*GiveawayInfoCompleted) GiveawayInfoType() string {
	return TypeGiveawayInfoCompleted
}

// The giveaway sends Telegram Premium subscriptions to the winners
type GiveawayPrizePremium struct {
	meta
	// Number of months the Telegram Premium subscription will be active after code activation
	MonthCount int32 `json:"month_count"`
}

func (entity *GiveawayPrizePremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayPrizePremium

	return json.Marshal((*stub)(entity))
}

func (*GiveawayPrizePremium) GetClass() string {
	return ClassGiveawayPrize
}

func (*GiveawayPrizePremium) GetType() string {
	return TypeGiveawayPrizePremium
}

func (*GiveawayPrizePremium) GiveawayPrizeType() string {
	return TypeGiveawayPrizePremium
}

// The giveaway sends Telegram Stars to the winners
type GiveawayPrizeStars struct {
	meta
	// Number of Telegram Stars that will be shared by all winners
	StarCount int64 `json:"star_count"`
}

func (entity *GiveawayPrizeStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayPrizeStars

	return json.Marshal((*stub)(entity))
}

func (*GiveawayPrizeStars) GetClass() string {
	return ClassGiveawayPrize
}

func (*GiveawayPrizeStars) GetType() string {
	return TypeGiveawayPrizeStars
}

func (*GiveawayPrizeStars) GiveawayPrizeType() string {
	return TypeGiveawayPrizeStars
}

// Contains information about supported accent color for user/chat name, background of empty chat photo, replies to messages and link previews
type AccentColor struct {
	meta
	// Accent color identifier
	Id int32 `json:"id"`
	// Identifier of a built-in color to use in places, where only one color is needed; 0-6
	BuiltInAccentColorId int32 `json:"built_in_accent_color_id"`
	// The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
	LightThemeColors []int32 `json:"light_theme_colors"`
	// The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
	DarkThemeColors []int32 `json:"dark_theme_colors"`
	// The minimum chat boost level required to use the color in a channel chat
	MinChannelChatBoostLevel int32 `json:"min_channel_chat_boost_level"`
}

func (entity *AccentColor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AccentColor

	return json.Marshal((*stub)(entity))
}

func (*AccentColor) GetClass() string {
	return ClassAccentColor
}

func (*AccentColor) GetType() string {
	return TypeAccentColor
}

// Contains information about supported accent colors for user profile photo background in RGB format
type ProfileAccentColors struct {
	meta
	// The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
	PaletteColors []int32 `json:"palette_colors"`
	// The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
	BackgroundColors []int32 `json:"background_colors"`
	// The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
	StoryColors []int32 `json:"story_colors"`
}

func (entity *ProfileAccentColors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProfileAccentColors

	return json.Marshal((*stub)(entity))
}

func (*ProfileAccentColors) GetClass() string {
	return ClassProfileAccentColors
}

func (*ProfileAccentColors) GetType() string {
	return TypeProfileAccentColors
}

// Contains information about supported accent color for user profile photo background
type ProfileAccentColor struct {
	meta
	// Profile accent color identifier
	Id int32 `json:"id"`
	// Accent colors expected to be used in light themes
	LightThemeColors *ProfileAccentColors `json:"light_theme_colors"`
	// Accent colors expected to be used in dark themes
	DarkThemeColors *ProfileAccentColors `json:"dark_theme_colors"`
	// The minimum chat boost level required to use the color in a supergroup chat
	MinSupergroupChatBoostLevel int32 `json:"min_supergroup_chat_boost_level"`
	// The minimum chat boost level required to use the color in a channel chat
	MinChannelChatBoostLevel int32 `json:"min_channel_chat_boost_level"`
}

func (entity *ProfileAccentColor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProfileAccentColor

	return json.Marshal((*stub)(entity))
}

func (*ProfileAccentColor) GetClass() string {
	return ClassProfileAccentColor
}

func (*ProfileAccentColor) GetType() string {
	return TypeProfileAccentColor
}

// Describes a custom emoji to be shown instead of the Telegram Premium badge
type EmojiStatus struct {
	meta
	// Identifier of the custom emoji in stickerFormatTgs format
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
	// Point in time (Unix timestamp) when the status will expire; 0 if never
	ExpirationDate int32 `json:"expiration_date"`
}

func (entity *EmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*EmojiStatus) GetClass() string {
	return ClassEmojiStatus
}

func (*EmojiStatus) GetType() string {
	return TypeEmojiStatus
}

// Contains a list of custom emoji identifiers for emoji statuses
type EmojiStatuses struct {
	meta
	// The list of custom emoji identifiers
	CustomEmojiIds []JsonInt64 `json:"custom_emoji_ids"`
}

func (entity *EmojiStatuses) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiStatuses

	return json.Marshal((*stub)(entity))
}

func (*EmojiStatuses) GetClass() string {
	return ClassEmojiStatuses
}

func (*EmojiStatuses) GetType() string {
	return TypeEmojiStatuses
}

// Describes usernames assigned to a user, a supergroup, or a channel
type Usernames struct {
	meta
	// List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
	ActiveUsernames []string `json:"active_usernames"`
	// List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
	DisabledUsernames []string `json:"disabled_usernames"`
	// The active username, which can be changed with setUsername or setSupergroupUsername. Information about other active usernames can be received using getCollectibleItemInfo
	EditableUsername string `json:"editable_username"`
}

func (entity *Usernames) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Usernames

	return json.Marshal((*stub)(entity))
}

func (*Usernames) GetClass() string {
	return ClassUsernames
}

func (*Usernames) GetType() string {
	return TypeUsernames
}

// Represents a user
type User struct {
	meta
	// User identifier
	Id int64 `json:"id"`
	// First name of the user
	FirstName string `json:"first_name"`
	// Last name of the user
	LastName string `json:"last_name"`
	// Usernames of the user; may be null
	Usernames *Usernames `json:"usernames"`
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Current online status of the user
	Status UserStatus `json:"status"`
	// Profile photo of the user; may be null
	ProfilePhoto *ProfilePhoto `json:"profile_photo"`
	// Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview. For Telegram Premium users only
	AccentColorId int32 `json:"accent_color_id"`
	// Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. For Telegram Premium users only
	BackgroundCustomEmojiId JsonInt64 `json:"background_custom_emoji_id"`
	// Identifier of the accent color for the user's profile; -1 if none. For Telegram Premium users only
	ProfileAccentColorId int32 `json:"profile_accent_color_id"`
	// Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none. For Telegram Premium users only
	ProfileBackgroundCustomEmojiId JsonInt64 `json:"profile_background_custom_emoji_id"`
	// Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
	EmojiStatus *EmojiStatus `json:"emoji_status"`
	// The user is a contact of the current user
	IsContact bool `json:"is_contact"`
	// The user is a contact of the current user and the current user is a contact of the user
	IsMutualContact bool `json:"is_mutual_contact"`
	// The user is a close friend of the current user; implies that the user is a contact
	IsCloseFriend bool `json:"is_close_friend"`
	// True, if the user is verified
	IsVerified bool `json:"is_verified"`
	// True, if the user is a Telegram Premium user
	IsPremium bool `json:"is_premium"`
	// True, if the user is Telegram support account
	IsSupport bool `json:"is_support"`
	// If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// True, if many users reported this user as a scam
	IsScam bool `json:"is_scam"`
	// True, if many users reported this user as a fake account
	IsFake bool `json:"is_fake"`
	// True, if the user has non-expired stories available to the current user
	HasActiveStories bool `json:"has_active_stories"`
	// True, if the user has unread non-expired stories available to the current user
	HasUnreadActiveStories bool `json:"has_unread_active_stories"`
	// True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them
	RestrictsNewChats bool `json:"restricts_new_chats"`
	// If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
	HaveAccess bool `json:"have_access"`
	// Type of the user
	Type UserType `json:"type"`
	// IETF language tag of the user's language; only available to bots
	LanguageCode string `json:"language_code"`
	// True, if the user added the current bot to attachment menu; only available to bots
	AddedToAttachmentMenu bool `json:"added_to_attachment_menu"`
}

func (entity *User) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub User

	return json.Marshal((*stub)(entity))
}

func (*User) GetClass() string {
	return ClassUser
}

func (*User) GetType() string {
	return TypeUser
}

func (user *User) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                             int64           `json:"id"`
		FirstName                      string          `json:"first_name"`
		LastName                       string          `json:"last_name"`
		Usernames                      *Usernames      `json:"usernames"`
		PhoneNumber                    string          `json:"phone_number"`
		Status                         json.RawMessage `json:"status"`
		ProfilePhoto                   *ProfilePhoto   `json:"profile_photo"`
		AccentColorId                  int32           `json:"accent_color_id"`
		BackgroundCustomEmojiId        JsonInt64       `json:"background_custom_emoji_id"`
		ProfileAccentColorId           int32           `json:"profile_accent_color_id"`
		ProfileBackgroundCustomEmojiId JsonInt64       `json:"profile_background_custom_emoji_id"`
		EmojiStatus                    *EmojiStatus    `json:"emoji_status"`
		IsContact                      bool            `json:"is_contact"`
		IsMutualContact                bool            `json:"is_mutual_contact"`
		IsCloseFriend                  bool            `json:"is_close_friend"`
		IsVerified                     bool            `json:"is_verified"`
		IsPremium                      bool            `json:"is_premium"`
		IsSupport                      bool            `json:"is_support"`
		RestrictionReason              string          `json:"restriction_reason"`
		IsScam                         bool            `json:"is_scam"`
		IsFake                         bool            `json:"is_fake"`
		HasActiveStories               bool            `json:"has_active_stories"`
		HasUnreadActiveStories         bool            `json:"has_unread_active_stories"`
		RestrictsNewChats              bool            `json:"restricts_new_chats"`
		HaveAccess                     bool            `json:"have_access"`
		Type                           json.RawMessage `json:"type"`
		LanguageCode                   string          `json:"language_code"`
		AddedToAttachmentMenu          bool            `json:"added_to_attachment_menu"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	user.Id = tmp.Id
	user.FirstName = tmp.FirstName
	user.LastName = tmp.LastName
	user.Usernames = tmp.Usernames
	user.PhoneNumber = tmp.PhoneNumber
	user.ProfilePhoto = tmp.ProfilePhoto
	user.AccentColorId = tmp.AccentColorId
	user.BackgroundCustomEmojiId = tmp.BackgroundCustomEmojiId
	user.ProfileAccentColorId = tmp.ProfileAccentColorId
	user.ProfileBackgroundCustomEmojiId = tmp.ProfileBackgroundCustomEmojiId
	user.EmojiStatus = tmp.EmojiStatus
	user.IsContact = tmp.IsContact
	user.IsMutualContact = tmp.IsMutualContact
	user.IsCloseFriend = tmp.IsCloseFriend
	user.IsVerified = tmp.IsVerified
	user.IsPremium = tmp.IsPremium
	user.IsSupport = tmp.IsSupport
	user.RestrictionReason = tmp.RestrictionReason
	user.IsScam = tmp.IsScam
	user.IsFake = tmp.IsFake
	user.HasActiveStories = tmp.HasActiveStories
	user.HasUnreadActiveStories = tmp.HasUnreadActiveStories
	user.RestrictsNewChats = tmp.RestrictsNewChats
	user.HaveAccess = tmp.HaveAccess
	user.LanguageCode = tmp.LanguageCode
	user.AddedToAttachmentMenu = tmp.AddedToAttachmentMenu

	fieldStatus, _ := UnmarshalUserStatus(tmp.Status)
	user.Status = fieldStatus

	fieldType, _ := UnmarshalUserType(tmp.Type)
	user.Type = fieldType

	return nil
}

// Contains information about a bot
type BotInfo struct {
	meta
	// The text that is shown on the bot's profile page and is sent together with the link when users share the bot
	ShortDescription string `json:"short_description"`
	// The text shown in the chat with the bot if the chat is empty
	Description string `json:"description"`
	// Photo shown in the chat with the bot if the chat is empty; may be null
	Photo *Photo `json:"photo"`
	// Animation shown in the chat with the bot if the chat is empty; may be null
	Animation *Animation `json:"animation"`
	// Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
	MenuButton *BotMenuButton `json:"menu_button"`
	// List of the bot commands
	Commands []*BotCommand `json:"commands"`
	// The HTTP link to the privacy policy of the bot. If empty, then /privacy command must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa must be opened
	PrivacyPolicyUrl string `json:"privacy_policy_url"`
	// Default administrator rights for adding the bot to basic group and supergroup chats; may be null
	DefaultGroupAdministratorRights *ChatAdministratorRights `json:"default_group_administrator_rights"`
	// Default administrator rights for adding the bot to channels; may be null
	DefaultChannelAdministratorRights *ChatAdministratorRights `json:"default_channel_administrator_rights"`
	// Default light background color for bot Web Apps; -1 if not specified
	WebAppBackgroundLightColor int32 `json:"web_app_background_light_color"`
	// Default dark background color for bot Web Apps; -1 if not specified
	WebAppBackgroundDarkColor int32 `json:"web_app_background_dark_color"`
	// Default light header color for bot Web Apps; -1 if not specified
	WebAppHeaderLightColor int32 `json:"web_app_header_light_color"`
	// Default dark header color for bot Web Apps; -1 if not specified
	WebAppHeaderDarkColor int32 `json:"web_app_header_dark_color"`
	// True, if the bot's revenue statistics are available to the current user
	CanGetRevenueStatistics bool `json:"can_get_revenue_statistics"`
	// True, if the bot can manage emoji status of the current user
	CanManageEmojiStatus bool `json:"can_manage_emoji_status"`
	// True, if the bot has media previews
	HasMediaPreviews bool `json:"has_media_previews"`
	// The internal link, which can be used to edit bot commands; may be null
	EditCommandsLink InternalLinkType `json:"edit_commands_link"`
	// The internal link, which can be used to edit bot description; may be null
	EditDescriptionLink InternalLinkType `json:"edit_description_link"`
	// The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null
	EditDescriptionMediaLink InternalLinkType `json:"edit_description_media_link"`
	// The internal link, which can be used to edit bot settings; may be null
	EditSettingsLink InternalLinkType `json:"edit_settings_link"`
}

func (entity *BotInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotInfo

	return json.Marshal((*stub)(entity))
}

func (*BotInfo) GetClass() string {
	return ClassBotInfo
}

func (*BotInfo) GetType() string {
	return TypeBotInfo
}

func (botInfo *BotInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ShortDescription                  string                   `json:"short_description"`
		Description                       string                   `json:"description"`
		Photo                             *Photo                   `json:"photo"`
		Animation                         *Animation               `json:"animation"`
		MenuButton                        *BotMenuButton           `json:"menu_button"`
		Commands                          []*BotCommand            `json:"commands"`
		PrivacyPolicyUrl                  string                   `json:"privacy_policy_url"`
		DefaultGroupAdministratorRights   *ChatAdministratorRights `json:"default_group_administrator_rights"`
		DefaultChannelAdministratorRights *ChatAdministratorRights `json:"default_channel_administrator_rights"`
		WebAppBackgroundLightColor        int32                    `json:"web_app_background_light_color"`
		WebAppBackgroundDarkColor         int32                    `json:"web_app_background_dark_color"`
		WebAppHeaderLightColor            int32                    `json:"web_app_header_light_color"`
		WebAppHeaderDarkColor             int32                    `json:"web_app_header_dark_color"`
		CanGetRevenueStatistics           bool                     `json:"can_get_revenue_statistics"`
		CanManageEmojiStatus              bool                     `json:"can_manage_emoji_status"`
		HasMediaPreviews                  bool                     `json:"has_media_previews"`
		EditCommandsLink                  json.RawMessage          `json:"edit_commands_link"`
		EditDescriptionLink               json.RawMessage          `json:"edit_description_link"`
		EditDescriptionMediaLink          json.RawMessage          `json:"edit_description_media_link"`
		EditSettingsLink                  json.RawMessage          `json:"edit_settings_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	botInfo.ShortDescription = tmp.ShortDescription
	botInfo.Description = tmp.Description
	botInfo.Photo = tmp.Photo
	botInfo.Animation = tmp.Animation
	botInfo.MenuButton = tmp.MenuButton
	botInfo.Commands = tmp.Commands
	botInfo.PrivacyPolicyUrl = tmp.PrivacyPolicyUrl
	botInfo.DefaultGroupAdministratorRights = tmp.DefaultGroupAdministratorRights
	botInfo.DefaultChannelAdministratorRights = tmp.DefaultChannelAdministratorRights
	botInfo.WebAppBackgroundLightColor = tmp.WebAppBackgroundLightColor
	botInfo.WebAppBackgroundDarkColor = tmp.WebAppBackgroundDarkColor
	botInfo.WebAppHeaderLightColor = tmp.WebAppHeaderLightColor
	botInfo.WebAppHeaderDarkColor = tmp.WebAppHeaderDarkColor
	botInfo.CanGetRevenueStatistics = tmp.CanGetRevenueStatistics
	botInfo.CanManageEmojiStatus = tmp.CanManageEmojiStatus
	botInfo.HasMediaPreviews = tmp.HasMediaPreviews

	fieldEditCommandsLink, _ := UnmarshalInternalLinkType(tmp.EditCommandsLink)
	botInfo.EditCommandsLink = fieldEditCommandsLink

	fieldEditDescriptionLink, _ := UnmarshalInternalLinkType(tmp.EditDescriptionLink)
	botInfo.EditDescriptionLink = fieldEditDescriptionLink

	fieldEditDescriptionMediaLink, _ := UnmarshalInternalLinkType(tmp.EditDescriptionMediaLink)
	botInfo.EditDescriptionMediaLink = fieldEditDescriptionMediaLink

	fieldEditSettingsLink, _ := UnmarshalInternalLinkType(tmp.EditSettingsLink)
	botInfo.EditSettingsLink = fieldEditSettingsLink

	return nil
}

// Contains full information about a user
type UserFullInfo struct {
	meta
	// User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
	PersonalPhoto *ChatPhoto `json:"personal_photo"`
	// User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
	Photo *ChatPhoto `json:"photo"`
	// User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
	PublicPhoto *ChatPhoto `json:"public_photo"`
	// Block list to which the user is added; may be null if none
	BlockList BlockList `json:"block_list"`
	// True, if the user can be called
	CanBeCalled bool `json:"can_be_called"`
	// True, if a video call can be created with the user
	SupportsVideoCalls bool `json:"supports_video_calls"`
	// True, if the user can't be called due to their privacy settings
	HasPrivateCalls bool `json:"has_private_calls"`
	// True, if the user can't be linked in forwarded messages due to their privacy settings
	HasPrivateForwards bool `json:"has_private_forwards"`
	// True, if voice and video notes can't be sent or forwarded to the user
	HasRestrictedVoiceAndVideoNoteMessages bool `json:"has_restricted_voice_and_video_note_messages"`
	// True, if the user has posted to profile stories
	HasPostedToProfileStories bool `json:"has_posted_to_profile_stories"`
	// True, if the user always enabled sponsored messages; known only for the current user
	HasSponsoredMessagesEnabled bool `json:"has_sponsored_messages_enabled"`
	// True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
	NeedPhoneNumberPrivacyException bool `json:"need_phone_number_privacy_exception"`
	// True, if the user set chat background for both chat users and it wasn't reverted yet
	SetChatBackground bool `json:"set_chat_background"`
	// A short user bio; may be null for bots
	Bio *FormattedText `json:"bio"`
	// Birthdate of the user; may be null if unknown
	Birthdate *Birthdate `json:"birthdate"`
	// Identifier of the personal chat of the user; 0 if none
	PersonalChatId int64 `json:"personal_chat_id"`
	// Number of gifts saved to profile by the user
	GiftCount int32 `json:"gift_count"`
	// Number of group chats where both the other user and the current user are a member; 0 for the current user
	GroupInCommonCount int32 `json:"group_in_common_count"`
	// Information about business settings for Telegram Business accounts; may be null if none
	BusinessInfo *BusinessInfo `json:"business_info"`
	// For bots, information about the bot; may be null if the user isn't a bot
	BotInfo *BotInfo `json:"bot_info"`
}

func (entity *UserFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UserFullInfo) GetClass() string {
	return ClassUserFullInfo
}

func (*UserFullInfo) GetType() string {
	return TypeUserFullInfo
}

func (userFullInfo *UserFullInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PersonalPhoto                          *ChatPhoto      `json:"personal_photo"`
		Photo                                  *ChatPhoto      `json:"photo"`
		PublicPhoto                            *ChatPhoto      `json:"public_photo"`
		BlockList                              json.RawMessage `json:"block_list"`
		CanBeCalled                            bool            `json:"can_be_called"`
		SupportsVideoCalls                     bool            `json:"supports_video_calls"`
		HasPrivateCalls                        bool            `json:"has_private_calls"`
		HasPrivateForwards                     bool            `json:"has_private_forwards"`
		HasRestrictedVoiceAndVideoNoteMessages bool            `json:"has_restricted_voice_and_video_note_messages"`
		HasPostedToProfileStories              bool            `json:"has_posted_to_profile_stories"`
		HasSponsoredMessagesEnabled            bool            `json:"has_sponsored_messages_enabled"`
		NeedPhoneNumberPrivacyException        bool            `json:"need_phone_number_privacy_exception"`
		SetChatBackground                      bool            `json:"set_chat_background"`
		Bio                                    *FormattedText  `json:"bio"`
		Birthdate                              *Birthdate      `json:"birthdate"`
		PersonalChatId                         int64           `json:"personal_chat_id"`
		GiftCount                              int32           `json:"gift_count"`
		GroupInCommonCount                     int32           `json:"group_in_common_count"`
		BusinessInfo                           *BusinessInfo   `json:"business_info"`
		BotInfo                                *BotInfo        `json:"bot_info"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	userFullInfo.PersonalPhoto = tmp.PersonalPhoto
	userFullInfo.Photo = tmp.Photo
	userFullInfo.PublicPhoto = tmp.PublicPhoto
	userFullInfo.CanBeCalled = tmp.CanBeCalled
	userFullInfo.SupportsVideoCalls = tmp.SupportsVideoCalls
	userFullInfo.HasPrivateCalls = tmp.HasPrivateCalls
	userFullInfo.HasPrivateForwards = tmp.HasPrivateForwards
	userFullInfo.HasRestrictedVoiceAndVideoNoteMessages = tmp.HasRestrictedVoiceAndVideoNoteMessages
	userFullInfo.HasPostedToProfileStories = tmp.HasPostedToProfileStories
	userFullInfo.HasSponsoredMessagesEnabled = tmp.HasSponsoredMessagesEnabled
	userFullInfo.NeedPhoneNumberPrivacyException = tmp.NeedPhoneNumberPrivacyException
	userFullInfo.SetChatBackground = tmp.SetChatBackground
	userFullInfo.Bio = tmp.Bio
	userFullInfo.Birthdate = tmp.Birthdate
	userFullInfo.PersonalChatId = tmp.PersonalChatId
	userFullInfo.GiftCount = tmp.GiftCount
	userFullInfo.GroupInCommonCount = tmp.GroupInCommonCount
	userFullInfo.BusinessInfo = tmp.BusinessInfo
	userFullInfo.BotInfo = tmp.BotInfo

	fieldBlockList, _ := UnmarshalBlockList(tmp.BlockList)
	userFullInfo.BlockList = fieldBlockList

	return nil
}

// Represents a list of users
type Users struct {
	meta
	// Approximate total number of users found
	TotalCount int32 `json:"total_count"`
	// A list of user identifiers
	UserIds []int64 `json:"user_ids"`
}

func (entity *Users) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Users

	return json.Marshal((*stub)(entity))
}

func (*Users) GetClass() string {
	return ClassUsers
}

func (*Users) GetType() string {
	return TypeUsers
}

// Represents a list of found users
type FoundUsers struct {
	meta
	// Identifiers of the found users
	UserIds []int64 `json:"user_ids"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundUsers

	return json.Marshal((*stub)(entity))
}

func (*FoundUsers) GetClass() string {
	return ClassFoundUsers
}

func (*FoundUsers) GetType() string {
	return TypeFoundUsers
}

// Contains information about a chat administrator
type ChatAdministrator struct {
	meta
	// User identifier of the administrator
	UserId int64 `json:"user_id"`
	// Custom title of the administrator
	CustomTitle string `json:"custom_title"`
	// True, if the user is the owner of the chat
	IsOwner bool `json:"is_owner"`
}

func (entity *ChatAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministrator) GetClass() string {
	return ClassChatAdministrator
}

func (*ChatAdministrator) GetType() string {
	return TypeChatAdministrator
}

// Represents a list of chat administrators
type ChatAdministrators struct {
	meta
	// A list of chat administrators
	Administrators []*ChatAdministrator `json:"administrators"`
}

func (entity *ChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministrators) GetClass() string {
	return ClassChatAdministrators
}

func (*ChatAdministrators) GetType() string {
	return TypeChatAdministrators
}

// The user is the owner of the chat and has all the administrator privileges
type ChatMemberStatusCreator struct {
	meta
	// A custom title of the owner; 0-16 characters without emoji; applicable to supergroups only
	CustomTitle string `json:"custom_title"`
	// True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
	IsAnonymous bool `json:"is_anonymous"`
	// True, if the user is a member of the chat
	IsMember bool `json:"is_member"`
}

func (entity *ChatMemberStatusCreator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusCreator

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusCreator) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusCreator) GetType() string {
	return TypeChatMemberStatusCreator
}

func (*ChatMemberStatusCreator) ChatMemberStatusType() string {
	return TypeChatMemberStatusCreator
}

// The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats. In supergroups and channels, there are more detailed options for administrator privileges
type ChatMemberStatusAdministrator struct {
	meta
	// A custom title of the administrator; 0-16 characters without emoji; applicable to supergroups only
	CustomTitle string `json:"custom_title"`
	// True, if the current user can edit the administrator privileges for the called user
	CanBeEdited bool `json:"can_be_edited"`
	// Rights of the administrator
	Rights *ChatAdministratorRights `json:"rights"`
}

func (entity *ChatMemberStatusAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusAdministrator) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusAdministrator) GetType() string {
	return TypeChatMemberStatusAdministrator
}

func (*ChatMemberStatusAdministrator) ChatMemberStatusType() string {
	return TypeChatMemberStatusAdministrator
}

// The user is a member of the chat, without any additional privileges or restrictions
type ChatMemberStatusMember struct {
	meta
	// Point in time (Unix timestamp) when the user will be removed from the chat because of the expired subscription; 0 if never. Ignored in setChatMemberStatus
	MemberUntilDate int32 `json:"member_until_date"`
}

func (entity *ChatMemberStatusMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusMember

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusMember) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusMember) GetType() string {
	return TypeChatMemberStatusMember
}

func (*ChatMemberStatusMember) ChatMemberStatusType() string {
	return TypeChatMemberStatusMember
}

// The user is under certain restrictions in the chat. Not supported in basic groups and channels
type ChatMemberStatusRestricted struct {
	meta
	// True, if the user is a member of the chat
	IsMember bool `json:"is_member"`
	// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
	RestrictedUntilDate int32 `json:"restricted_until_date"`
	// User permissions in the chat
	Permissions *ChatPermissions `json:"permissions"`
}

func (entity *ChatMemberStatusRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusRestricted) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusRestricted) GetType() string {
	return TypeChatMemberStatusRestricted
}

func (*ChatMemberStatusRestricted) ChatMemberStatusType() string {
	return TypeChatMemberStatusRestricted
}

// The user or the chat is not a chat member
type ChatMemberStatusLeft struct {
	meta
}

func (entity *ChatMemberStatusLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusLeft

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusLeft) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusLeft) GetType() string {
	return TypeChatMemberStatusLeft
}

func (*ChatMemberStatusLeft) ChatMemberStatusType() string {
	return TypeChatMemberStatusLeft
}

// The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
type ChatMemberStatusBanned struct {
	meta
	// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
	BannedUntilDate int32 `json:"banned_until_date"`
}

func (entity *ChatMemberStatusBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusBanned

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusBanned) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusBanned) GetType() string {
	return TypeChatMemberStatusBanned
}

func (*ChatMemberStatusBanned) ChatMemberStatusType() string {
	return TypeChatMemberStatusBanned
}

// Describes a user or a chat as a member of another chat
type ChatMember struct {
	meta
	// Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
	MemberId MessageSender `json:"member_id"`
	// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
	InviterUserId int64 `json:"inviter_user_id"`
	// Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
	JoinedChatDate int32 `json:"joined_chat_date"`
	// Status of the member in the chat
	Status ChatMemberStatus `json:"status"`
}

func (entity *ChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMember

	return json.Marshal((*stub)(entity))
}

func (*ChatMember) GetClass() string {
	return ClassChatMember
}

func (*ChatMember) GetType() string {
	return TypeChatMember
}

func (chatMember *ChatMember) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MemberId       json.RawMessage `json:"member_id"`
		InviterUserId  int64           `json:"inviter_user_id"`
		JoinedChatDate int32           `json:"joined_chat_date"`
		Status         json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatMember.InviterUserId = tmp.InviterUserId
	chatMember.JoinedChatDate = tmp.JoinedChatDate

	fieldMemberId, _ := UnmarshalMessageSender(tmp.MemberId)
	chatMember.MemberId = fieldMemberId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	chatMember.Status = fieldStatus

	return nil
}

// Contains a list of chat members
type ChatMembers struct {
	meta
	// Approximate total number of chat members found
	TotalCount int32 `json:"total_count"`
	// A list of chat members
	Members []*ChatMember `json:"members"`
}

func (entity *ChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatMembers) GetClass() string {
	return ClassChatMembers
}

func (*ChatMembers) GetType() string {
	return TypeChatMembers
}

// Returns contacts of the user
type ChatMembersFilterContacts struct {
	meta
}

func (entity *ChatMembersFilterContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterContacts

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterContacts) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterContacts) GetType() string {
	return TypeChatMembersFilterContacts
}

func (*ChatMembersFilterContacts) ChatMembersFilterType() string {
	return TypeChatMembersFilterContacts
}

// Returns the owner and administrators
type ChatMembersFilterAdministrators struct {
	meta
}

func (entity *ChatMembersFilterAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterAdministrators

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterAdministrators) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterAdministrators) GetType() string {
	return TypeChatMembersFilterAdministrators
}

func (*ChatMembersFilterAdministrators) ChatMembersFilterType() string {
	return TypeChatMembersFilterAdministrators
}

// Returns all chat members, including restricted chat members
type ChatMembersFilterMembers struct {
	meta
}

func (entity *ChatMembersFilterMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterMembers) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterMembers) GetType() string {
	return TypeChatMembersFilterMembers
}

func (*ChatMembersFilterMembers) ChatMembersFilterType() string {
	return TypeChatMembersFilterMembers
}

// Returns users which can be mentioned in the chat
type ChatMembersFilterMention struct {
	meta
	// If non-zero, the identifier of the current message thread
	MessageThreadId int64 `json:"message_thread_id"`
}

func (entity *ChatMembersFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterMention

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterMention) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterMention) GetType() string {
	return TypeChatMembersFilterMention
}

func (*ChatMembersFilterMention) ChatMembersFilterType() string {
	return TypeChatMembersFilterMention
}

// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
type ChatMembersFilterRestricted struct {
	meta
}

func (entity *ChatMembersFilterRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterRestricted) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterRestricted) GetType() string {
	return TypeChatMembersFilterRestricted
}

func (*ChatMembersFilterRestricted) ChatMembersFilterType() string {
	return TypeChatMembersFilterRestricted
}

// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
type ChatMembersFilterBanned struct {
	meta
}

func (entity *ChatMembersFilterBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterBanned

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterBanned) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterBanned) GetType() string {
	return TypeChatMembersFilterBanned
}

func (*ChatMembersFilterBanned) ChatMembersFilterType() string {
	return TypeChatMembersFilterBanned
}

// Returns bot members of the chat
type ChatMembersFilterBots struct {
	meta
}

func (entity *ChatMembersFilterBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterBots

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterBots) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterBots) GetType() string {
	return TypeChatMembersFilterBots
}

func (*ChatMembersFilterBots) ChatMembersFilterType() string {
	return TypeChatMembersFilterBots
}

// Returns recently active users in reverse chronological order
type SupergroupMembersFilterRecent struct {
	meta
}

func (entity *SupergroupMembersFilterRecent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterRecent

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterRecent) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterRecent) GetType() string {
	return TypeSupergroupMembersFilterRecent
}

func (*SupergroupMembersFilterRecent) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterRecent
}

// Returns contacts of the user, which are members of the supergroup or channel
type SupergroupMembersFilterContacts struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterContacts

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterContacts) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterContacts) GetType() string {
	return TypeSupergroupMembersFilterContacts
}

func (*SupergroupMembersFilterContacts) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterContacts
}

// Returns the owner and administrators
type SupergroupMembersFilterAdministrators struct {
	meta
}

func (entity *SupergroupMembersFilterAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterAdministrators

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterAdministrators) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterAdministrators) GetType() string {
	return TypeSupergroupMembersFilterAdministrators
}

func (*SupergroupMembersFilterAdministrators) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterAdministrators
}

// Used to search for supergroup or channel members via a (string) query
type SupergroupMembersFilterSearch struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterSearch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterSearch

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterSearch) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterSearch) GetType() string {
	return TypeSupergroupMembersFilterSearch
}

func (*SupergroupMembersFilterSearch) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterSearch
}

// Returns restricted supergroup members; can be used only by administrators
type SupergroupMembersFilterRestricted struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterRestricted

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterRestricted) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterRestricted) GetType() string {
	return TypeSupergroupMembersFilterRestricted
}

func (*SupergroupMembersFilterRestricted) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterRestricted
}

// Returns users banned from the supergroup or channel; can be used only by administrators
type SupergroupMembersFilterBanned struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterBanned

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterBanned) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterBanned) GetType() string {
	return TypeSupergroupMembersFilterBanned
}

func (*SupergroupMembersFilterBanned) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterBanned
}

// Returns users which can be mentioned in the supergroup
type SupergroupMembersFilterMention struct {
	meta
	// Query to search for
	Query string `json:"query"`
	// If non-zero, the identifier of the current message thread
	MessageThreadId int64 `json:"message_thread_id"`
}

func (entity *SupergroupMembersFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterMention

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterMention) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterMention) GetType() string {
	return TypeSupergroupMembersFilterMention
}

func (*SupergroupMembersFilterMention) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterMention
}

// Returns bot members of the supergroup or channel
type SupergroupMembersFilterBots struct {
	meta
}

func (entity *SupergroupMembersFilterBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterBots

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterBots) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterBots) GetType() string {
	return TypeSupergroupMembersFilterBots
}

func (*SupergroupMembersFilterBots) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterBots
}

// Contains a chat invite link
type ChatInviteLink struct {
	meta
	// Chat invite link
	InviteLink string `json:"invite_link"`
	// Name of the link
	Name string `json:"name"`
	// User identifier of an administrator created the link
	CreatorUserId int64 `json:"creator_user_id"`
	// Point in time (Unix timestamp) when the link was created
	Date int32 `json:"date"`
	// Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
	EditDate int32 `json:"edit_date"`
	// Point in time (Unix timestamp) when the link will expire; 0 if never
	ExpirationDate int32 `json:"expiration_date"`
	// Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription
	SubscriptionPricing *StarSubscriptionPricing `json:"subscription_pricing"`
	// The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
	MemberLimit int32 `json:"member_limit"`
	// Number of chat members, which joined the chat using the link
	MemberCount int32 `json:"member_count"`
	// Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only
	ExpiredMemberCount int32 `json:"expired_member_count"`
	// Number of pending join requests created using this link
	PendingJoinRequestCount int32 `json:"pending_join_request_count"`
	// True, if the link only creates join request. If true, total number of joining members will be unlimited
	CreatesJoinRequest bool `json:"creates_join_request"`
	// True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
	IsPrimary bool `json:"is_primary"`
	// True, if the link was revoked
	IsRevoked bool `json:"is_revoked"`
}

func (entity *ChatInviteLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLink

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLink) GetClass() string {
	return ClassChatInviteLink
}

func (*ChatInviteLink) GetType() string {
	return TypeChatInviteLink
}

// Contains a list of chat invite links
type ChatInviteLinks struct {
	meta
	// Approximate total number of chat invite links found
	TotalCount int32 `json:"total_count"`
	// List of invite links
	InviteLinks []*ChatInviteLink `json:"invite_links"`
}

func (entity *ChatInviteLinks) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinks

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinks) GetClass() string {
	return ClassChatInviteLinks
}

func (*ChatInviteLinks) GetType() string {
	return TypeChatInviteLinks
}

// Describes a chat administrator with a number of active and revoked chat invite links
type ChatInviteLinkCount struct {
	meta
	// Administrator's user identifier
	UserId int64 `json:"user_id"`
	// Number of active invite links
	InviteLinkCount int32 `json:"invite_link_count"`
	// Number of revoked invite links
	RevokedInviteLinkCount int32 `json:"revoked_invite_link_count"`
}

func (entity *ChatInviteLinkCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkCount

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkCount) GetClass() string {
	return ClassChatInviteLinkCount
}

func (*ChatInviteLinkCount) GetType() string {
	return TypeChatInviteLinkCount
}

// Contains a list of chat invite link counts
type ChatInviteLinkCounts struct {
	meta
	// List of invite link counts
	InviteLinkCounts []*ChatInviteLinkCount `json:"invite_link_counts"`
}

func (entity *ChatInviteLinkCounts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkCounts

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkCounts) GetClass() string {
	return ClassChatInviteLinkCounts
}

func (*ChatInviteLinkCounts) GetType() string {
	return TypeChatInviteLinkCounts
}

// Describes a chat member joined a chat via an invite link
type ChatInviteLinkMember struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Point in time (Unix timestamp) when the user joined the chat
	JoinedChatDate int32 `json:"joined_chat_date"`
	// True, if the user has joined the chat using an invite link for a chat folder
	ViaChatFolderInviteLink bool `json:"via_chat_folder_invite_link"`
	// User identifier of the chat administrator, approved user join request
	ApproverUserId int64 `json:"approver_user_id"`
}

func (entity *ChatInviteLinkMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkMember

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkMember) GetClass() string {
	return ClassChatInviteLinkMember
}

func (*ChatInviteLinkMember) GetType() string {
	return TypeChatInviteLinkMember
}

// Contains a list of chat members joined a chat via an invite link
type ChatInviteLinkMembers struct {
	meta
	// Approximate total number of chat members found
	TotalCount int32 `json:"total_count"`
	// List of chat members, joined a chat via an invite link
	Members []*ChatInviteLinkMember `json:"members"`
}

func (entity *ChatInviteLinkMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkMembers) GetClass() string {
	return ClassChatInviteLinkMembers
}

func (*ChatInviteLinkMembers) GetType() string {
	return TypeChatInviteLinkMembers
}

// The link is an invite link for a basic group
type InviteLinkChatTypeBasicGroup struct {
	meta
}

func (entity *InviteLinkChatTypeBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InviteLinkChatTypeBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*InviteLinkChatTypeBasicGroup) GetClass() string {
	return ClassInviteLinkChatType
}

func (*InviteLinkChatTypeBasicGroup) GetType() string {
	return TypeInviteLinkChatTypeBasicGroup
}

func (*InviteLinkChatTypeBasicGroup) InviteLinkChatTypeType() string {
	return TypeInviteLinkChatTypeBasicGroup
}

// The link is an invite link for a supergroup
type InviteLinkChatTypeSupergroup struct {
	meta
}

func (entity *InviteLinkChatTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InviteLinkChatTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*InviteLinkChatTypeSupergroup) GetClass() string {
	return ClassInviteLinkChatType
}

func (*InviteLinkChatTypeSupergroup) GetType() string {
	return TypeInviteLinkChatTypeSupergroup
}

func (*InviteLinkChatTypeSupergroup) InviteLinkChatTypeType() string {
	return TypeInviteLinkChatTypeSupergroup
}

// The link is an invite link for a channel
type InviteLinkChatTypeChannel struct {
	meta
}

func (entity *InviteLinkChatTypeChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InviteLinkChatTypeChannel

	return json.Marshal((*stub)(entity))
}

func (*InviteLinkChatTypeChannel) GetClass() string {
	return ClassInviteLinkChatType
}

func (*InviteLinkChatTypeChannel) GetType() string {
	return TypeInviteLinkChatTypeChannel
}

func (*InviteLinkChatTypeChannel) InviteLinkChatTypeType() string {
	return TypeInviteLinkChatTypeChannel
}

// Contains information about subscription plan that must be paid by the user to use a chat invite link
type ChatInviteLinkSubscriptionInfo struct {
	meta
	// Information about subscription plan that must be paid by the user to use the link
	Pricing *StarSubscriptionPricing `json:"pricing"`
	// True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again
	CanReuse bool `json:"can_reuse"`
	// Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid
	FormId JsonInt64 `json:"form_id"`
}

func (entity *ChatInviteLinkSubscriptionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkSubscriptionInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkSubscriptionInfo) GetClass() string {
	return ClassChatInviteLinkSubscriptionInfo
}

func (*ChatInviteLinkSubscriptionInfo) GetType() string {
	return TypeChatInviteLinkSubscriptionInfo
}

// Contains information about a chat invite link
type ChatInviteLinkInfo struct {
	meta
	// Chat identifier of the invite link; 0 if the user has no access to the chat before joining
	ChatId int64 `json:"chat_id"`
	// If non-zero, the amount of time for which read access to the chat will remain available, in seconds
	AccessibleFor int32 `json:"accessible_for"`
	// Type of the chat
	Type InviteLinkChatType `json:"type"`
	// Title of the chat
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
	// Identifier of the accent color for chat title and background of chat photo
	AccentColorId int32 `json:"accent_color_id"`
	// Chat description
	Description string `json:"description"`
	// Number of members in the chat
	MemberCount int32 `json:"member_count"`
	// User identifiers of some chat members that may be known to the current user
	MemberUserIds []int64 `json:"member_user_ids"`
	// Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription
	SubscriptionInfo *ChatInviteLinkSubscriptionInfo `json:"subscription_info"`
	// True, if the link only creates join request
	CreatesJoinRequest bool `json:"creates_join_request"`
	// True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
	IsPublic bool `json:"is_public"`
	// True, if the chat is verified
	IsVerified bool `json:"is_verified"`
	// True, if many users reported this chat as a scam
	IsScam bool `json:"is_scam"`
	// True, if many users reported this chat as a fake account
	IsFake bool `json:"is_fake"`
}

func (entity *ChatInviteLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkInfo) GetClass() string {
	return ClassChatInviteLinkInfo
}

func (*ChatInviteLinkInfo) GetType() string {
	return TypeChatInviteLinkInfo
}

func (chatInviteLinkInfo *ChatInviteLinkInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId             int64                           `json:"chat_id"`
		AccessibleFor      int32                           `json:"accessible_for"`
		Type               json.RawMessage                 `json:"type"`
		Title              string                          `json:"title"`
		Photo              *ChatPhotoInfo                  `json:"photo"`
		AccentColorId      int32                           `json:"accent_color_id"`
		Description        string                          `json:"description"`
		MemberCount        int32                           `json:"member_count"`
		MemberUserIds      []int64                         `json:"member_user_ids"`
		SubscriptionInfo   *ChatInviteLinkSubscriptionInfo `json:"subscription_info"`
		CreatesJoinRequest bool                            `json:"creates_join_request"`
		IsPublic           bool                            `json:"is_public"`
		IsVerified         bool                            `json:"is_verified"`
		IsScam             bool                            `json:"is_scam"`
		IsFake             bool                            `json:"is_fake"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatInviteLinkInfo.ChatId = tmp.ChatId
	chatInviteLinkInfo.AccessibleFor = tmp.AccessibleFor
	chatInviteLinkInfo.Title = tmp.Title
	chatInviteLinkInfo.Photo = tmp.Photo
	chatInviteLinkInfo.AccentColorId = tmp.AccentColorId
	chatInviteLinkInfo.Description = tmp.Description
	chatInviteLinkInfo.MemberCount = tmp.MemberCount
	chatInviteLinkInfo.MemberUserIds = tmp.MemberUserIds
	chatInviteLinkInfo.SubscriptionInfo = tmp.SubscriptionInfo
	chatInviteLinkInfo.CreatesJoinRequest = tmp.CreatesJoinRequest
	chatInviteLinkInfo.IsPublic = tmp.IsPublic
	chatInviteLinkInfo.IsVerified = tmp.IsVerified
	chatInviteLinkInfo.IsScam = tmp.IsScam
	chatInviteLinkInfo.IsFake = tmp.IsFake

	fieldType, _ := UnmarshalInviteLinkChatType(tmp.Type)
	chatInviteLinkInfo.Type = fieldType

	return nil
}

// Describes a user that sent a join request and waits for administrator approval
type ChatJoinRequest struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Point in time (Unix timestamp) when the user sent the join request
	Date int32 `json:"date"`
	// A short bio of the user
	Bio string `json:"bio"`
}

func (entity *ChatJoinRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatJoinRequest

	return json.Marshal((*stub)(entity))
}

func (*ChatJoinRequest) GetClass() string {
	return ClassChatJoinRequest
}

func (*ChatJoinRequest) GetType() string {
	return TypeChatJoinRequest
}

// Contains a list of requests to join a chat
type ChatJoinRequests struct {
	meta
	// Approximate total number of requests found
	TotalCount int32 `json:"total_count"`
	// List of the requests
	Requests []*ChatJoinRequest `json:"requests"`
}

func (entity *ChatJoinRequests) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatJoinRequests

	return json.Marshal((*stub)(entity))
}

func (*ChatJoinRequests) GetClass() string {
	return ClassChatJoinRequests
}

func (*ChatJoinRequests) GetType() string {
	return TypeChatJoinRequests
}

// Contains information about pending join requests for a chat
type ChatJoinRequestsInfo struct {
	meta
	// Total number of pending join requests
	TotalCount int32 `json:"total_count"`
	// Identifiers of at most 3 users sent the newest pending join requests
	UserIds []int64 `json:"user_ids"`
}

func (entity *ChatJoinRequestsInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatJoinRequestsInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatJoinRequestsInfo) GetClass() string {
	return ClassChatJoinRequestsInfo
}

func (*ChatJoinRequestsInfo) GetType() string {
	return TypeChatJoinRequestsInfo
}

// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
type BasicGroup struct {
	meta
	// Group identifier
	Id int64 `json:"id"`
	// Number of members in the group
	MemberCount int32 `json:"member_count"`
	// Status of the current user in the group
	Status ChatMemberStatus `json:"status"`
	// True, if the group is active
	IsActive bool `json:"is_active"`
	// Identifier of the supergroup to which this group was upgraded; 0 if none
	UpgradedToSupergroupId int64 `json:"upgraded_to_supergroup_id"`
}

func (entity *BasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BasicGroup

	return json.Marshal((*stub)(entity))
}

func (*BasicGroup) GetClass() string {
	return ClassBasicGroup
}

func (*BasicGroup) GetType() string {
	return TypeBasicGroup
}

func (basicGroup *BasicGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                     int64           `json:"id"`
		MemberCount            int32           `json:"member_count"`
		Status                 json.RawMessage `json:"status"`
		IsActive               bool            `json:"is_active"`
		UpgradedToSupergroupId int64           `json:"upgraded_to_supergroup_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	basicGroup.Id = tmp.Id
	basicGroup.MemberCount = tmp.MemberCount
	basicGroup.IsActive = tmp.IsActive
	basicGroup.UpgradedToSupergroupId = tmp.UpgradedToSupergroupId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	basicGroup.Status = fieldStatus

	return nil
}

// Contains full information about a basic group
type BasicGroupFullInfo struct {
	meta
	// Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
	Photo *ChatPhoto `json:"photo"`
	// Group description. Updated only after the basic group is opened
	Description string `json:"description"`
	// User identifier of the creator of the group; 0 if unknown
	CreatorUserId int64 `json:"creator_user_id"`
	// Group members
	Members []*ChatMember `json:"members"`
	// True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
	CanHideMembers bool `json:"can_hide_members"`
	// True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
	CanToggleAggressiveAntiSpam bool `json:"can_toggle_aggressive_anti_spam"`
	// Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
	InviteLink *ChatInviteLink `json:"invite_link"`
	// List of commands of bots in the group
	BotCommands []*BotCommands `json:"bot_commands"`
}

func (entity *BasicGroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BasicGroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*BasicGroupFullInfo) GetClass() string {
	return ClassBasicGroupFullInfo
}

func (*BasicGroupFullInfo) GetType() string {
	return TypeBasicGroupFullInfo
}

// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
type Supergroup struct {
	meta
	// Supergroup or channel identifier
	Id int64 `json:"id"`
	// Usernames of the supergroup or channel; may be null
	Usernames *Usernames `json:"usernames"`
	// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
	Date int32 `json:"date"`
	// Status of the current user in the supergroup or channel; custom title will always be empty
	Status ChatMemberStatus `json:"status"`
	// Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id, or for chats with messages or stories from publicForwards and foundStories
	MemberCount int32 `json:"member_count"`
	// Approximate boost level for the chat
	BoostLevel int32 `json:"boost_level"`
	// True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
	HasLinkedChat bool `json:"has_linked_chat"`
	// True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
	HasLocation bool `json:"has_location"`
	// True, if messages sent to the channel contains name of the sender. This field is only applicable to channels
	SignMessages bool `json:"sign_messages"`
	// True, if messages sent to the channel have information about the sender user. This field is only applicable to channels
	ShowMessageSender bool `json:"show_message_sender"`
	// True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
	JoinToSendMessages bool `json:"join_to_send_messages"`
	// True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
	JoinByRequest bool `json:"join_by_request"`
	// True, if the slow mode is enabled in the supergroup
	IsSlowModeEnabled bool `json:"is_slow_mode_enabled"`
	// True, if the supergroup is a channel
	IsChannel bool `json:"is_channel"`
	// True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
	IsBroadcastGroup bool `json:"is_broadcast_group"`
	// True, if the supergroup is a forum with topics
	IsForum bool `json:"is_forum"`
	// True, if the supergroup or channel is verified
	IsVerified bool `json:"is_verified"`
	// True, if content of media messages in the supergroup or channel chat must be hidden with 18+ spoiler
	HasSensitiveContent bool `json:"has_sensitive_content"`
	// If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// True, if many users reported this supergroup or channel as a scam
	IsScam bool `json:"is_scam"`
	// True, if many users reported this supergroup or channel as a fake account
	IsFake bool `json:"is_fake"`
	// True, if the supergroup or channel has non-expired stories available to the current user
	HasActiveStories bool `json:"has_active_stories"`
	// True, if the supergroup or channel has unread non-expired stories available to the current user
	HasUnreadActiveStories bool `json:"has_unread_active_stories"`
}

func (entity *Supergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Supergroup

	return json.Marshal((*stub)(entity))
}

func (*Supergroup) GetClass() string {
	return ClassSupergroup
}

func (*Supergroup) GetType() string {
	return TypeSupergroup
}

func (supergroup *Supergroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                     int64           `json:"id"`
		Usernames              *Usernames      `json:"usernames"`
		Date                   int32           `json:"date"`
		Status                 json.RawMessage `json:"status"`
		MemberCount            int32           `json:"member_count"`
		BoostLevel             int32           `json:"boost_level"`
		HasLinkedChat          bool            `json:"has_linked_chat"`
		HasLocation            bool            `json:"has_location"`
		SignMessages           bool            `json:"sign_messages"`
		ShowMessageSender      bool            `json:"show_message_sender"`
		JoinToSendMessages     bool            `json:"join_to_send_messages"`
		JoinByRequest          bool            `json:"join_by_request"`
		IsSlowModeEnabled      bool            `json:"is_slow_mode_enabled"`
		IsChannel              bool            `json:"is_channel"`
		IsBroadcastGroup       bool            `json:"is_broadcast_group"`
		IsForum                bool            `json:"is_forum"`
		IsVerified             bool            `json:"is_verified"`
		HasSensitiveContent    bool            `json:"has_sensitive_content"`
		RestrictionReason      string          `json:"restriction_reason"`
		IsScam                 bool            `json:"is_scam"`
		IsFake                 bool            `json:"is_fake"`
		HasActiveStories       bool            `json:"has_active_stories"`
		HasUnreadActiveStories bool            `json:"has_unread_active_stories"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	supergroup.Id = tmp.Id
	supergroup.Usernames = tmp.Usernames
	supergroup.Date = tmp.Date
	supergroup.MemberCount = tmp.MemberCount
	supergroup.BoostLevel = tmp.BoostLevel
	supergroup.HasLinkedChat = tmp.HasLinkedChat
	supergroup.HasLocation = tmp.HasLocation
	supergroup.SignMessages = tmp.SignMessages
	supergroup.ShowMessageSender = tmp.ShowMessageSender
	supergroup.JoinToSendMessages = tmp.JoinToSendMessages
	supergroup.JoinByRequest = tmp.JoinByRequest
	supergroup.IsSlowModeEnabled = tmp.IsSlowModeEnabled
	supergroup.IsChannel = tmp.IsChannel
	supergroup.IsBroadcastGroup = tmp.IsBroadcastGroup
	supergroup.IsForum = tmp.IsForum
	supergroup.IsVerified = tmp.IsVerified
	supergroup.HasSensitiveContent = tmp.HasSensitiveContent
	supergroup.RestrictionReason = tmp.RestrictionReason
	supergroup.IsScam = tmp.IsScam
	supergroup.IsFake = tmp.IsFake
	supergroup.HasActiveStories = tmp.HasActiveStories
	supergroup.HasUnreadActiveStories = tmp.HasUnreadActiveStories

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	supergroup.Status = fieldStatus

	return nil
}

// Contains full information about a supergroup or channel
type SupergroupFullInfo struct {
	meta
	// Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
	Photo *ChatPhoto `json:"photo"`
	// Supergroup or channel description
	Description string `json:"description"`
	// Number of members in the supergroup or channel; 0 if unknown
	MemberCount int32 `json:"member_count"`
	// Number of privileged users in the supergroup or channel; 0 if unknown
	AdministratorCount int32 `json:"administrator_count"`
	// Number of restricted users in the supergroup; 0 if unknown
	RestrictedCount int32 `json:"restricted_count"`
	// Number of users banned from chat; 0 if unknown
	BannedCount int32 `json:"banned_count"`
	// Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
	LinkedChatId int64 `json:"linked_chat_id"`
	// Delay between consecutive sent messages for non-administrator supergroup members, in seconds
	SlowModeDelay int32 `json:"slow_mode_delay"`
	// Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
	SlowModeDelayExpiresIn float64 `json:"slow_mode_delay_expires_in"`
	// True, if paid reaction can be enabled in the channel chat; for channels only
	CanEnablePaidReaction bool `json:"can_enable_paid_reaction"`
	// True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
	CanGetMembers bool `json:"can_get_members"`
	// True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
	HasHiddenMembers bool `json:"has_hidden_members"`
	// True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
	CanHideMembers bool `json:"can_hide_members"`
	// True, if the supergroup sticker set can be changed
	CanSetStickerSet bool `json:"can_set_sticker_set"`
	// True, if the supergroup location can be changed
	CanSetLocation bool `json:"can_set_location"`
	// True, if the supergroup or channel statistics are available
	CanGetStatistics bool `json:"can_get_statistics"`
	// True, if the supergroup or channel revenue statistics are available
	CanGetRevenueStatistics bool `json:"can_get_revenue_statistics"`
	// True, if the supergroup or channel Telegram Star revenue statistics are available
	CanGetStarRevenueStatistics bool `json:"can_get_star_revenue_statistics"`
	// True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
	CanToggleAggressiveAntiSpam bool `json:"can_toggle_aggressive_anti_spam"`
	// True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
	IsAllHistoryAvailable bool `json:"is_all_history_available"`
	// True, if the chat can have sponsored messages. The value of this field is only available to the owner of the chat
	CanHaveSponsoredMessages bool `json:"can_have_sponsored_messages"`
	// True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
	HasAggressiveAntiSpamEnabled bool `json:"has_aggressive_anti_spam_enabled"`
	// True, if paid media can be sent and forwarded to the channel chat; for channels only
	HasPaidMediaAllowed bool `json:"has_paid_media_allowed"`
	// True, if the supergroup or channel has pinned stories
	HasPinnedStories bool `json:"has_pinned_stories"`
	// Number of times the current user boosted the supergroup or channel
	MyBoostCount int32 `json:"my_boost_count"`
	// Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified
	UnrestrictBoostCount int32 `json:"unrestrict_boost_count"`
	// Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none
	StickerSetId JsonInt64 `json:"sticker_set_id"`
	// Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none
	CustomEmojiStickerSetId JsonInt64 `json:"custom_emoji_sticker_set_id"`
	// Location to which the supergroup is connected; may be null if none
	Location *ChatLocation `json:"location"`
	// Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
	InviteLink *ChatInviteLink `json:"invite_link"`
	// List of commands of bots in the group
	BotCommands []*BotCommands `json:"bot_commands"`
	// Identifier of the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromBasicGroupId int64 `json:"upgraded_from_basic_group_id"`
	// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromMaxMessageId int64 `json:"upgraded_from_max_message_id"`
}

func (entity *SupergroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*SupergroupFullInfo) GetClass() string {
	return ClassSupergroupFullInfo
}

func (*SupergroupFullInfo) GetType() string {
	return TypeSupergroupFullInfo
}

// The secret chat is not yet created; waiting for the other user to get online
type SecretChatStatePending struct {
	meta
}

func (entity *SecretChatStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStatePending

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStatePending) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStatePending) GetType() string {
	return TypeSecretChatStatePending
}

func (*SecretChatStatePending) SecretChatStateType() string {
	return TypeSecretChatStatePending
}

// The secret chat is ready to use
type SecretChatStateReady struct {
	meta
}

func (entity *SecretChatStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStateReady

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStateReady) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStateReady) GetType() string {
	return TypeSecretChatStateReady
}

func (*SecretChatStateReady) SecretChatStateType() string {
	return TypeSecretChatStateReady
}

// The secret chat is closed
type SecretChatStateClosed struct {
	meta
}

func (entity *SecretChatStateClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStateClosed

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStateClosed) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStateClosed) GetType() string {
	return TypeSecretChatStateClosed
}

func (*SecretChatStateClosed) SecretChatStateType() string {
	return TypeSecretChatStateClosed
}

// Represents a secret chat
type SecretChat struct {
	meta
	// Secret chat identifier
	Id int32 `json:"id"`
	// Identifier of the chat partner
	UserId int64 `json:"user_id"`
	// State of the secret chat
	State SecretChatState `json:"state"`
	// True, if the chat was created by the current user; false otherwise
	IsOutbound bool `json:"is_outbound"`
	// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
	KeyHash []byte `json:"key_hash"`
	// Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
	Layer int32 `json:"layer"`
}

func (entity *SecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChat

	return json.Marshal((*stub)(entity))
}

func (*SecretChat) GetClass() string {
	return ClassSecretChat
}

func (*SecretChat) GetType() string {
	return TypeSecretChat
}

func (secretChat *SecretChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         int32           `json:"id"`
		UserId     int64           `json:"user_id"`
		State      json.RawMessage `json:"state"`
		IsOutbound bool            `json:"is_outbound"`
		KeyHash    []byte          `json:"key_hash"`
		Layer      int32           `json:"layer"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	secretChat.Id = tmp.Id
	secretChat.UserId = tmp.UserId
	secretChat.IsOutbound = tmp.IsOutbound
	secretChat.KeyHash = tmp.KeyHash
	secretChat.Layer = tmp.Layer

	fieldState, _ := UnmarshalSecretChatState(tmp.State)
	secretChat.State = fieldState

	return nil
}

// The message was sent by a known user
type MessageSenderUser struct {
	meta
	// Identifier of the user that sent the message
	UserId int64 `json:"user_id"`
}

func (entity *MessageSenderUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSenderUser

	return json.Marshal((*stub)(entity))
}

func (*MessageSenderUser) GetClass() string {
	return ClassMessageSender
}

func (*MessageSenderUser) GetType() string {
	return TypeMessageSenderUser
}

func (*MessageSenderUser) MessageSenderType() string {
	return TypeMessageSenderUser
}

// The message was sent on behalf of a chat
type MessageSenderChat struct {
	meta
	// Identifier of the chat that sent the message
	ChatId int64 `json:"chat_id"`
}

func (entity *MessageSenderChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSenderChat

	return json.Marshal((*stub)(entity))
}

func (*MessageSenderChat) GetClass() string {
	return ClassMessageSender
}

func (*MessageSenderChat) GetType() string {
	return TypeMessageSenderChat
}

func (*MessageSenderChat) MessageSenderType() string {
	return TypeMessageSenderChat
}

// Represents a list of message senders
type MessageSenders struct {
	meta
	// Approximate total number of messages senders found
	TotalCount int32 `json:"total_count"`
	// List of message senders
	Senders []MessageSender `json:"senders"`
}

func (entity *MessageSenders) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSenders

	return json.Marshal((*stub)(entity))
}

func (*MessageSenders) GetClass() string {
	return ClassMessageSenders
}

func (*MessageSenders) GetType() string {
	return TypeMessageSenders
}

func (messageSenders *MessageSenders) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TotalCount int32             `json:"total_count"`
		Senders    []json.RawMessage `json:"senders"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageSenders.TotalCount = tmp.TotalCount

	fieldSenders, _ := UnmarshalListOfMessageSender(tmp.Senders)
	messageSenders.Senders = fieldSenders

	return nil
}

// Represents a message sender, which can be used to send messages in a chat
type ChatMessageSender struct {
	meta
	// The message sender
	Sender MessageSender `json:"sender"`
	// True, if Telegram Premium is needed to use the message sender
	NeedsPremium bool `json:"needs_premium"`
}

func (entity *ChatMessageSender) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMessageSender

	return json.Marshal((*stub)(entity))
}

func (*ChatMessageSender) GetClass() string {
	return ClassChatMessageSender
}

func (*ChatMessageSender) GetType() string {
	return TypeChatMessageSender
}

func (chatMessageSender *ChatMessageSender) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sender       json.RawMessage `json:"sender"`
		NeedsPremium bool            `json:"needs_premium"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatMessageSender.NeedsPremium = tmp.NeedsPremium

	fieldSender, _ := UnmarshalMessageSender(tmp.Sender)
	chatMessageSender.Sender = fieldSender

	return nil
}

// Represents a list of message senders, which can be used to send messages in a chat
type ChatMessageSenders struct {
	meta
	// List of available message senders
	Senders []*ChatMessageSender `json:"senders"`
}

func (entity *ChatMessageSenders) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMessageSenders

	return json.Marshal((*stub)(entity))
}

func (*ChatMessageSenders) GetClass() string {
	return ClassChatMessageSenders
}

func (*ChatMessageSenders) GetType() string {
	return TypeChatMessageSenders
}

// Contains read date of the message
type MessageReadDateRead struct {
	meta
	// Point in time (Unix timestamp) when the message was read by the other user
	ReadDate int32 `json:"read_date"`
}

func (entity *MessageReadDateRead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReadDateRead

	return json.Marshal((*stub)(entity))
}

func (*MessageReadDateRead) GetClass() string {
	return ClassMessageReadDate
}

func (*MessageReadDateRead) GetType() string {
	return TypeMessageReadDateRead
}

func (*MessageReadDateRead) MessageReadDateType() string {
	return TypeMessageReadDateRead
}

// The message is unread yet
type MessageReadDateUnread struct {
	meta
}

func (entity *MessageReadDateUnread) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReadDateUnread

	return json.Marshal((*stub)(entity))
}

func (*MessageReadDateUnread) GetClass() string {
	return ClassMessageReadDate
}

func (*MessageReadDateUnread) GetType() string {
	return TypeMessageReadDateUnread
}

func (*MessageReadDateUnread) MessageReadDateType() string {
	return TypeMessageReadDateUnread
}

// The message is too old to get read date
type MessageReadDateTooOld struct {
	meta
}

func (entity *MessageReadDateTooOld) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReadDateTooOld

	return json.Marshal((*stub)(entity))
}

func (*MessageReadDateTooOld) GetClass() string {
	return ClassMessageReadDate
}

func (*MessageReadDateTooOld) GetType() string {
	return TypeMessageReadDateTooOld
}

func (*MessageReadDateTooOld) MessageReadDateType() string {
	return TypeMessageReadDateTooOld
}

// The read date is unknown due to privacy settings of the other user
type MessageReadDateUserPrivacyRestricted struct {
	meta
}

func (entity *MessageReadDateUserPrivacyRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReadDateUserPrivacyRestricted

	return json.Marshal((*stub)(entity))
}

func (*MessageReadDateUserPrivacyRestricted) GetClass() string {
	return ClassMessageReadDate
}

func (*MessageReadDateUserPrivacyRestricted) GetType() string {
	return TypeMessageReadDateUserPrivacyRestricted
}

func (*MessageReadDateUserPrivacyRestricted) MessageReadDateType() string {
	return TypeMessageReadDateUserPrivacyRestricted
}

// The read date is unknown due to privacy settings of the current user, but will be known if the user subscribes to Telegram Premium
type MessageReadDateMyPrivacyRestricted struct {
	meta
}

func (entity *MessageReadDateMyPrivacyRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReadDateMyPrivacyRestricted

	return json.Marshal((*stub)(entity))
}

func (*MessageReadDateMyPrivacyRestricted) GetClass() string {
	return ClassMessageReadDate
}

func (*MessageReadDateMyPrivacyRestricted) GetType() string {
	return TypeMessageReadDateMyPrivacyRestricted
}

func (*MessageReadDateMyPrivacyRestricted) MessageReadDateType() string {
	return TypeMessageReadDateMyPrivacyRestricted
}

// Represents a viewer of a message
type MessageViewer struct {
	meta
	// User identifier of the viewer
	UserId int64 `json:"user_id"`
	// Approximate point in time (Unix timestamp) when the message was viewed
	ViewDate int32 `json:"view_date"`
}

func (entity *MessageViewer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageViewer

	return json.Marshal((*stub)(entity))
}

func (*MessageViewer) GetClass() string {
	return ClassMessageViewer
}

func (*MessageViewer) GetType() string {
	return TypeMessageViewer
}

// Represents a list of message viewers
type MessageViewers struct {
	meta
	// List of message viewers
	Viewers []*MessageViewer `json:"viewers"`
}

func (entity *MessageViewers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageViewers

	return json.Marshal((*stub)(entity))
}

func (*MessageViewers) GetClass() string {
	return ClassMessageViewers
}

func (*MessageViewers) GetType() string {
	return TypeMessageViewers
}

// The message was originally sent by a known user
type MessageOriginUser struct {
	meta
	// Identifier of the user that originally sent the message
	SenderUserId int64 `json:"sender_user_id"`
}

func (entity *MessageOriginUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageOriginUser

	return json.Marshal((*stub)(entity))
}

func (*MessageOriginUser) GetClass() string {
	return ClassMessageOrigin
}

func (*MessageOriginUser) GetType() string {
	return TypeMessageOriginUser
}

func (*MessageOriginUser) MessageOriginType() string {
	return TypeMessageOriginUser
}

// The message was originally sent by a user, which is hidden by their privacy settings
type MessageOriginHiddenUser struct {
	meta
	// Name of the sender
	SenderName string `json:"sender_name"`
}

func (entity *MessageOriginHiddenUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageOriginHiddenUser

	return json.Marshal((*stub)(entity))
}

func (*MessageOriginHiddenUser) GetClass() string {
	return ClassMessageOrigin
}

func (*MessageOriginHiddenUser) GetType() string {
	return TypeMessageOriginHiddenUser
}

func (*MessageOriginHiddenUser) MessageOriginType() string {
	return TypeMessageOriginHiddenUser
}

// The message was originally sent on behalf of a chat
type MessageOriginChat struct {
	meta
	// Identifier of the chat that originally sent the message
	SenderChatId int64 `json:"sender_chat_id"`
	// For messages originally sent by an anonymous chat administrator, original message author signature
	AuthorSignature string `json:"author_signature"`
}

func (entity *MessageOriginChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageOriginChat

	return json.Marshal((*stub)(entity))
}

func (*MessageOriginChat) GetClass() string {
	return ClassMessageOrigin
}

func (*MessageOriginChat) GetType() string {
	return TypeMessageOriginChat
}

func (*MessageOriginChat) MessageOriginType() string {
	return TypeMessageOriginChat
}

// The message was originally a post in a channel
type MessageOriginChannel struct {
	meta
	// Identifier of the channel chat to which the message was originally sent
	ChatId int64 `json:"chat_id"`
	// Message identifier of the original message
	MessageId int64 `json:"message_id"`
	// Original post author signature
	AuthorSignature string `json:"author_signature"`
}

func (entity *MessageOriginChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageOriginChannel

	return json.Marshal((*stub)(entity))
}

func (*MessageOriginChannel) GetClass() string {
	return ClassMessageOrigin
}

func (*MessageOriginChannel) GetType() string {
	return TypeMessageOriginChannel
}

func (*MessageOriginChannel) MessageOriginType() string {
	return TypeMessageOriginChannel
}

// Contains information about the last message from which a new message was forwarded last time
type ForwardSource struct {
	meta
	// Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown
	ChatId int64 `json:"chat_id"`
	// Identifier of the message; may be 0 if unknown
	MessageId int64 `json:"message_id"`
	// Identifier of the sender of the message; may be null if unknown or the new message was forwarded not to Saved Messages
	SenderId MessageSender `json:"sender_id"`
	// Name of the sender of the message if the sender is hidden by their privacy settings
	SenderName string `json:"sender_name"`
	// Point in time (Unix timestamp) when the message is sent; 0 if unknown
	Date int32 `json:"date"`
	// True, if the message that was forwarded is outgoing; always false if sender is unknown
	IsOutgoing bool `json:"is_outgoing"`
}

func (entity *ForwardSource) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForwardSource

	return json.Marshal((*stub)(entity))
}

func (*ForwardSource) GetClass() string {
	return ClassForwardSource
}

func (*ForwardSource) GetType() string {
	return TypeForwardSource
}

func (forwardSource *ForwardSource) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId     int64           `json:"chat_id"`
		MessageId  int64           `json:"message_id"`
		SenderId   json.RawMessage `json:"sender_id"`
		SenderName string          `json:"sender_name"`
		Date       int32           `json:"date"`
		IsOutgoing bool            `json:"is_outgoing"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	forwardSource.ChatId = tmp.ChatId
	forwardSource.MessageId = tmp.MessageId
	forwardSource.SenderName = tmp.SenderName
	forwardSource.Date = tmp.Date
	forwardSource.IsOutgoing = tmp.IsOutgoing

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	forwardSource.SenderId = fieldSenderId

	return nil
}

// A reaction with an emoji
type ReactionTypeEmoji struct {
	meta
	// Text representation of the reaction
	Emoji string `json:"emoji"`
}

func (entity *ReactionTypeEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionTypeEmoji

	return json.Marshal((*stub)(entity))
}

func (*ReactionTypeEmoji) GetClass() string {
	return ClassReactionType
}

func (*ReactionTypeEmoji) GetType() string {
	return TypeReactionTypeEmoji
}

func (*ReactionTypeEmoji) ReactionTypeType() string {
	return TypeReactionTypeEmoji
}

// A reaction with a custom emoji
type ReactionTypeCustomEmoji struct {
	meta
	// Unique identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *ReactionTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*ReactionTypeCustomEmoji) GetClass() string {
	return ClassReactionType
}

func (*ReactionTypeCustomEmoji) GetType() string {
	return TypeReactionTypeCustomEmoji
}

func (*ReactionTypeCustomEmoji) ReactionTypeType() string {
	return TypeReactionTypeCustomEmoji
}

// The paid reaction in a channel chat
type ReactionTypePaid struct {
	meta
}

func (entity *ReactionTypePaid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionTypePaid

	return json.Marshal((*stub)(entity))
}

func (*ReactionTypePaid) GetClass() string {
	return ClassReactionType
}

func (*ReactionTypePaid) GetType() string {
	return TypeReactionTypePaid
}

func (*ReactionTypePaid) ReactionTypeType() string {
	return TypeReactionTypePaid
}

// Contains information about a user that added paid reactions
type PaidReactor struct {
	meta
	// Identifier of the user or chat that added the reactions; may be null for anonymous reactors that aren't the current user
	SenderId MessageSender `json:"sender_id"`
	// Number of Telegram Stars added
	StarCount int32 `json:"star_count"`
	// True, if the reactor is one of the most active reactors; may be false if the reactor is the current user
	IsTop bool `json:"is_top"`
	// True, if the paid reaction was added by the current user
	IsMe bool `json:"is_me"`
	// True, if the reactor is anonymous
	IsAnonymous bool `json:"is_anonymous"`
}

func (entity *PaidReactor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaidReactor

	return json.Marshal((*stub)(entity))
}

func (*PaidReactor) GetClass() string {
	return ClassPaidReactor
}

func (*PaidReactor) GetType() string {
	return TypePaidReactor
}

func (paidReactor *PaidReactor) UnmarshalJSON(data []byte) error {
	var tmp struct {
		SenderId    json.RawMessage `json:"sender_id"`
		StarCount   int32           `json:"star_count"`
		IsTop       bool            `json:"is_top"`
		IsMe        bool            `json:"is_me"`
		IsAnonymous bool            `json:"is_anonymous"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	paidReactor.StarCount = tmp.StarCount
	paidReactor.IsTop = tmp.IsTop
	paidReactor.IsMe = tmp.IsMe
	paidReactor.IsAnonymous = tmp.IsAnonymous

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	paidReactor.SenderId = fieldSenderId

	return nil
}

// Contains information about a forwarded message
type MessageForwardInfo struct {
	meta
	// Origin of the forwarded message
	Origin MessageOrigin `json:"origin"`
	// Point in time (Unix timestamp) when the message was originally sent
	Date int32 `json:"date"`
	// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, information about the source message from which the message was forwarded last time; may be null for other forwards or if unknown
	Source *ForwardSource `json:"source"`
	// The type of public service announcement for the forwarded message
	PublicServiceAnnouncementType string `json:"public_service_announcement_type"`
}

func (entity *MessageForwardInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardInfo) GetClass() string {
	return ClassMessageForwardInfo
}

func (*MessageForwardInfo) GetType() string {
	return TypeMessageForwardInfo
}

func (messageForwardInfo *MessageForwardInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Origin                        json.RawMessage `json:"origin"`
		Date                          int32           `json:"date"`
		Source                        *ForwardSource  `json:"source"`
		PublicServiceAnnouncementType string          `json:"public_service_announcement_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageForwardInfo.Date = tmp.Date
	messageForwardInfo.Source = tmp.Source
	messageForwardInfo.PublicServiceAnnouncementType = tmp.PublicServiceAnnouncementType

	fieldOrigin, _ := UnmarshalMessageOrigin(tmp.Origin)
	messageForwardInfo.Origin = fieldOrigin

	return nil
}

// Contains information about a message created with importMessages
type MessageImportInfo struct {
	meta
	// Name of the original sender
	SenderName string `json:"sender_name"`
	// Point in time (Unix timestamp) when the message was originally sent
	Date int32 `json:"date"`
}

func (entity *MessageImportInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageImportInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageImportInfo) GetClass() string {
	return ClassMessageImportInfo
}

func (*MessageImportInfo) GetType() string {
	return TypeMessageImportInfo
}

// Contains information about replies to a message
type MessageReplyInfo struct {
	meta
	// Number of times the message was directly or indirectly replied
	ReplyCount int32 `json:"reply_count"`
	// Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
	RecentReplierIds []MessageSender `json:"recent_replier_ids"`
	// Identifier of the last read incoming reply to the message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing reply to the message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Identifier of the last reply to the message
	LastMessageId int64 `json:"last_message_id"`
}

func (entity *MessageReplyInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReplyInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageReplyInfo) GetClass() string {
	return ClassMessageReplyInfo
}

func (*MessageReplyInfo) GetType() string {
	return TypeMessageReplyInfo
}

func (messageReplyInfo *MessageReplyInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReplyCount              int32             `json:"reply_count"`
		RecentReplierIds        []json.RawMessage `json:"recent_replier_ids"`
		LastReadInboxMessageId  int64             `json:"last_read_inbox_message_id"`
		LastReadOutboxMessageId int64             `json:"last_read_outbox_message_id"`
		LastMessageId           int64             `json:"last_message_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageReplyInfo.ReplyCount = tmp.ReplyCount
	messageReplyInfo.LastReadInboxMessageId = tmp.LastReadInboxMessageId
	messageReplyInfo.LastReadOutboxMessageId = tmp.LastReadOutboxMessageId
	messageReplyInfo.LastMessageId = tmp.LastMessageId

	fieldRecentReplierIds, _ := UnmarshalListOfMessageSender(tmp.RecentReplierIds)
	messageReplyInfo.RecentReplierIds = fieldRecentReplierIds

	return nil
}

// Contains information about a reaction to a message
type MessageReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// Number of times the reaction was added
	TotalCount int32 `json:"total_count"`
	// True, if the reaction is chosen by the current user
	IsChosen bool `json:"is_chosen"`
	// Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen
	UsedSenderId MessageSender `json:"used_sender_id"`
	// Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
	RecentSenderIds []MessageSender `json:"recent_sender_ids"`
}

func (entity *MessageReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReaction

	return json.Marshal((*stub)(entity))
}

func (*MessageReaction) GetClass() string {
	return ClassMessageReaction
}

func (*MessageReaction) GetType() string {
	return TypeMessageReaction
}

func (messageReaction *MessageReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type            json.RawMessage   `json:"type"`
		TotalCount      int32             `json:"total_count"`
		IsChosen        bool              `json:"is_chosen"`
		UsedSenderId    json.RawMessage   `json:"used_sender_id"`
		RecentSenderIds []json.RawMessage `json:"recent_sender_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageReaction.TotalCount = tmp.TotalCount
	messageReaction.IsChosen = tmp.IsChosen

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	messageReaction.Type = fieldType

	fieldUsedSenderId, _ := UnmarshalMessageSender(tmp.UsedSenderId)
	messageReaction.UsedSenderId = fieldUsedSenderId

	fieldRecentSenderIds, _ := UnmarshalListOfMessageSender(tmp.RecentSenderIds)
	messageReaction.RecentSenderIds = fieldRecentSenderIds

	return nil
}

// Contains a list of reactions added to a message
type MessageReactions struct {
	meta
	// List of added reactions
	Reactions []*MessageReaction `json:"reactions"`
	// True, if the reactions are tags and Telegram Premium users can filter messages by them
	AreTags bool `json:"are_tags"`
	// Information about top users that added the paid reaction
	PaidReactors []*PaidReactor `json:"paid_reactors"`
	// True, if the list of added reactions is available using getMessageAddedReactions
	CanGetAddedReactions bool `json:"can_get_added_reactions"`
}

func (entity *MessageReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReactions

	return json.Marshal((*stub)(entity))
}

func (*MessageReactions) GetClass() string {
	return ClassMessageReactions
}

func (*MessageReactions) GetType() string {
	return TypeMessageReactions
}

// Contains information about interactions with a message
type MessageInteractionInfo struct {
	meta
	// Number of times the message was viewed
	ViewCount int32 `json:"view_count"`
	// Number of times the message was forwarded
	ForwardCount int32 `json:"forward_count"`
	// Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
	ReplyInfo *MessageReplyInfo `json:"reply_info"`
	// The list of reactions or tags added to the message; may be null
	Reactions *MessageReactions `json:"reactions"`
}

func (entity *MessageInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageInteractionInfo) GetClass() string {
	return ClassMessageInteractionInfo
}

func (*MessageInteractionInfo) GetType() string {
	return TypeMessageInteractionInfo
}

// Contains information about an unread reaction to a message
type UnreadReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// Identifier of the sender, added the reaction
	SenderId MessageSender `json:"sender_id"`
	// True, if the reaction was added with a big animation
	IsBig bool `json:"is_big"`
}

func (entity *UnreadReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UnreadReaction

	return json.Marshal((*stub)(entity))
}

func (*UnreadReaction) GetClass() string {
	return ClassUnreadReaction
}

func (*UnreadReaction) GetType() string {
	return TypeUnreadReaction
}

func (unreadReaction *UnreadReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type     json.RawMessage `json:"type"`
		SenderId json.RawMessage `json:"sender_id"`
		IsBig    bool            `json:"is_big"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	unreadReaction.IsBig = tmp.IsBig

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	unreadReaction.Type = fieldType

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	unreadReaction.SenderId = fieldSenderId

	return nil
}

// An effect from an emoji reaction
type MessageEffectTypeEmojiReaction struct {
	meta
	// Select animation for the effect in TGS format
	SelectAnimation *Sticker `json:"select_animation"`
	// Effect animation for the effect in TGS format
	EffectAnimation *Sticker `json:"effect_animation"`
}

func (entity *MessageEffectTypeEmojiReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageEffectTypeEmojiReaction

	return json.Marshal((*stub)(entity))
}

func (*MessageEffectTypeEmojiReaction) GetClass() string {
	return ClassMessageEffectType
}

func (*MessageEffectTypeEmojiReaction) GetType() string {
	return TypeMessageEffectTypeEmojiReaction
}

func (*MessageEffectTypeEmojiReaction) MessageEffectTypeType() string {
	return TypeMessageEffectTypeEmojiReaction
}

// An effect from a premium sticker
type MessageEffectTypePremiumSticker struct {
	meta
	// The premium sticker. The effect can be found at sticker.full_type.premium_animation
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageEffectTypePremiumSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageEffectTypePremiumSticker

	return json.Marshal((*stub)(entity))
}

func (*MessageEffectTypePremiumSticker) GetClass() string {
	return ClassMessageEffectType
}

func (*MessageEffectTypePremiumSticker) GetType() string {
	return TypeMessageEffectTypePremiumSticker
}

func (*MessageEffectTypePremiumSticker) MessageEffectTypeType() string {
	return TypeMessageEffectTypePremiumSticker
}

// Contains information about an effect added to a message
type MessageEffect struct {
	meta
	// Unique identifier of the effect
	Id JsonInt64 `json:"id"`
	// Static icon for the effect in WEBP format; may be null if none
	StaticIcon *Sticker `json:"static_icon"`
	// Emoji corresponding to the effect that can be used if static icon isn't available
	Emoji string `json:"emoji"`
	// True, if Telegram Premium subscription is required to use the effect
	IsPremium bool `json:"is_premium"`
	// Type of the effect
	Type MessageEffectType `json:"type"`
}

func (entity *MessageEffect) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageEffect

	return json.Marshal((*stub)(entity))
}

func (*MessageEffect) GetClass() string {
	return ClassMessageEffect
}

func (*MessageEffect) GetType() string {
	return TypeMessageEffect
}

func (messageEffect *MessageEffect) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         JsonInt64       `json:"id"`
		StaticIcon *Sticker        `json:"static_icon"`
		Emoji      string          `json:"emoji"`
		IsPremium  bool            `json:"is_premium"`
		Type       json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageEffect.Id = tmp.Id
	messageEffect.StaticIcon = tmp.StaticIcon
	messageEffect.Emoji = tmp.Emoji
	messageEffect.IsPremium = tmp.IsPremium

	fieldType, _ := UnmarshalMessageEffectType(tmp.Type)
	messageEffect.Type = fieldType

	return nil
}

// The message is being sent now, but has not yet been delivered to the server
type MessageSendingStatePending struct {
	meta
	// Non-persistent message sending identifier, specified by the application
	SendingId int32 `json:"sending_id"`
}

func (entity *MessageSendingStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendingStatePending

	return json.Marshal((*stub)(entity))
}

func (*MessageSendingStatePending) GetClass() string {
	return ClassMessageSendingState
}

func (*MessageSendingStatePending) GetType() string {
	return TypeMessageSendingStatePending
}

func (*MessageSendingStatePending) MessageSendingStateType() string {
	return TypeMessageSendingStatePending
}

// The message failed to be sent
type MessageSendingStateFailed struct {
	meta
	// The cause of the message sending failure
	Error *Error `json:"error"`
	// True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages
	CanRetry bool `json:"can_retry"`
	// True, if the message can be re-sent only on behalf of a different sender
	NeedAnotherSender bool `json:"need_another_sender"`
	// True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
	NeedAnotherReplyQuote bool `json:"need_another_reply_quote"`
	// True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
	NeedDropReply bool `json:"need_drop_reply"`
	// Time left before the message can be re-sent, in seconds. No update is sent when this field changes
	RetryAfter float64 `json:"retry_after"`
}

func (entity *MessageSendingStateFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendingStateFailed

	return json.Marshal((*stub)(entity))
}

func (*MessageSendingStateFailed) GetClass() string {
	return ClassMessageSendingState
}

func (*MessageSendingStateFailed) GetType() string {
	return TypeMessageSendingStateFailed
}

func (*MessageSendingStateFailed) MessageSendingStateType() string {
	return TypeMessageSendingStateFailed
}

// Describes manually or automatically chosen quote from another message
type TextQuote struct {
	meta
	// Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
	Text *FormattedText `json:"text"`
	// Approximate quote position in the original message in UTF-16 code units as specified by the message sender
	Position int32 `json:"position"`
	// True, if the quote was manually chosen by the message sender
	IsManual bool `json:"is_manual"`
}

func (entity *TextQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextQuote

	return json.Marshal((*stub)(entity))
}

func (*TextQuote) GetClass() string {
	return ClassTextQuote
}

func (*TextQuote) GetType() string {
	return TypeTextQuote
}

// Describes manually chosen quote from another message
type InputTextQuote struct {
	meta
	// Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
	Text *FormattedText `json:"text"`
	// Quote position in the original message in UTF-16 code units
	Position int32 `json:"position"`
}

func (entity *InputTextQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputTextQuote

	return json.Marshal((*stub)(entity))
}

func (*InputTextQuote) GetClass() string {
	return ClassInputTextQuote
}

func (*InputTextQuote) GetType() string {
	return TypeInputTextQuote
}

// Describes a message replied by a given message
type MessageReplyToMessage struct {
	meta
	// The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
	ChatId int64 `json:"chat_id"`
	// The identifier of the message; may be 0 if the replied message is in unknown chat
	MessageId int64 `json:"message_id"`
	// Chosen quote from the replied message; may be null if none
	Quote *TextQuote `json:"quote"`
	// Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat
	Origin MessageOrigin `json:"origin"`
	// Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat
	OriginSendDate int32 `json:"origin_send_date"`
	// Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media. Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll, messageSticker, messageStory, messageText (for link preview), messageVenue, messageVideo, messageVideoNote, or messageVoiceNote
	Content MessageContent `json:"content"`
}

func (entity *MessageReplyToMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReplyToMessage

	return json.Marshal((*stub)(entity))
}

func (*MessageReplyToMessage) GetClass() string {
	return ClassMessageReplyTo
}

func (*MessageReplyToMessage) GetType() string {
	return TypeMessageReplyToMessage
}

func (*MessageReplyToMessage) MessageReplyToType() string {
	return TypeMessageReplyToMessage
}

func (messageReplyToMessage *MessageReplyToMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId         int64           `json:"chat_id"`
		MessageId      int64           `json:"message_id"`
		Quote          *TextQuote      `json:"quote"`
		Origin         json.RawMessage `json:"origin"`
		OriginSendDate int32           `json:"origin_send_date"`
		Content        json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageReplyToMessage.ChatId = tmp.ChatId
	messageReplyToMessage.MessageId = tmp.MessageId
	messageReplyToMessage.Quote = tmp.Quote
	messageReplyToMessage.OriginSendDate = tmp.OriginSendDate

	fieldOrigin, _ := UnmarshalMessageOrigin(tmp.Origin)
	messageReplyToMessage.Origin = fieldOrigin

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	messageReplyToMessage.Content = fieldContent

	return nil
}

// Describes a story replied by a given message
type MessageReplyToStory struct {
	meta
	// The identifier of the sender of the story
	StorySenderChatId int64 `json:"story_sender_chat_id"`
	// The identifier of the story
	StoryId int32 `json:"story_id"`
}

func (entity *MessageReplyToStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageReplyToStory

	return json.Marshal((*stub)(entity))
}

func (*MessageReplyToStory) GetClass() string {
	return ClassMessageReplyTo
}

func (*MessageReplyToStory) GetType() string {
	return TypeMessageReplyToStory
}

func (*MessageReplyToStory) MessageReplyToType() string {
	return TypeMessageReplyToStory
}

// Describes a message to be replied in the same chat and forum topic
type InputMessageReplyToMessage struct {
	meta
	// The identifier of the message to be replied in the same chat and forum topic. A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
	MessageId int64 `json:"message_id"`
	// Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats
	Quote *InputTextQuote `json:"quote"`
}

func (entity *InputMessageReplyToMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageReplyToMessage

	return json.Marshal((*stub)(entity))
}

func (*InputMessageReplyToMessage) GetClass() string {
	return ClassInputMessageReplyTo
}

func (*InputMessageReplyToMessage) GetType() string {
	return TypeInputMessageReplyToMessage
}

func (*InputMessageReplyToMessage) InputMessageReplyToType() string {
	return TypeInputMessageReplyToMessage
}

// Describes a message to be replied that is from a different chat or a forum topic; not supported in secret chats
type InputMessageReplyToExternalMessage struct {
	meta
	// The identifier of the chat to which the message to be replied belongs
	ChatId int64 `json:"chat_id"`
	// The identifier of the message to be replied in the specified chat. A message can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
	MessageId int64 `json:"message_id"`
	// Quote from the message to be replied; pass null if none
	Quote *InputTextQuote `json:"quote"`
}

func (entity *InputMessageReplyToExternalMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageReplyToExternalMessage

	return json.Marshal((*stub)(entity))
}

func (*InputMessageReplyToExternalMessage) GetClass() string {
	return ClassInputMessageReplyTo
}

func (*InputMessageReplyToExternalMessage) GetType() string {
	return TypeInputMessageReplyToExternalMessage
}

func (*InputMessageReplyToExternalMessage) InputMessageReplyToType() string {
	return TypeInputMessageReplyToExternalMessage
}

// Describes a story to be replied
type InputMessageReplyToStory struct {
	meta
	// The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat and channel stories can't be replied
	StorySenderChatId int64 `json:"story_sender_chat_id"`
	// The identifier of the story
	StoryId int32 `json:"story_id"`
}

func (entity *InputMessageReplyToStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageReplyToStory

	return json.Marshal((*stub)(entity))
}

func (*InputMessageReplyToStory) GetClass() string {
	return ClassInputMessageReplyTo
}

func (*InputMessageReplyToStory) GetType() string {
	return TypeInputMessageReplyToStory
}

func (*InputMessageReplyToStory) InputMessageReplyToType() string {
	return TypeInputMessageReplyToStory
}

// Describes a fact-check added to the message by an independent checker
type FactCheck struct {
	meta
	// Text of the fact-check
	Text *FormattedText `json:"text"`
	// A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check is shown
	CountryCode string `json:"country_code"`
}

func (entity *FactCheck) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FactCheck

	return json.Marshal((*stub)(entity))
}

func (*FactCheck) GetClass() string {
	return ClassFactCheck
}

func (*FactCheck) GetType() string {
	return TypeFactCheck
}

// Describes a message
type Message struct {
	meta
	// Message identifier; unique for the chat to which the message belongs
	Id int64 `json:"id"`
	// Identifier of the sender of the message
	SenderId MessageSender `json:"sender_id"`
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
	SendingState MessageSendingState `json:"sending_state"`
	// The scheduling state of the message; may be null if the message isn't scheduled
	SchedulingState MessageSchedulingState `json:"scheduling_state"`
	// True, if the message is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the message is pinned
	IsPinned bool `json:"is_pinned"`
	// True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message
	IsFromOffline bool `json:"is_from_offline"`
	// True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
	CanBeSaved bool `json:"can_be_saved"`
	// True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
	HasTimestampedMedia bool `json:"has_timestamped_media"`
	// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
	IsChannelPost bool `json:"is_channel_post"`
	// True, if the message is a forum topic message
	IsTopicMessage bool `json:"is_topic_message"`
	// True, if the message contains an unread mention for the current user
	ContainsUnreadMention bool `json:"contains_unread_mention"`
	// Point in time (Unix timestamp) when the message was sent; 0 for scheduled messages
	Date int32 `json:"date"`
	// Point in time (Unix timestamp) when the message was last edited; 0 for scheduled messages
	EditDate int32 `json:"edit_date"`
	// Information about the initial message sender; may be null if none or unknown
	ForwardInfo *MessageForwardInfo `json:"forward_info"`
	// Information about the initial message for messages created with importMessages; may be null if the message isn't imported
	ImportInfo *MessageImportInfo `json:"import_info"`
	// Information about interactions with the message; may be null if none
	InteractionInfo *MessageInteractionInfo `json:"interaction_info"`
	// Information about unread reactions added to the message
	UnreadReactions []*UnreadReaction `json:"unread_reactions"`
	// Information about fact-check added to the message; may be null if none
	FactCheck *FactCheck `json:"fact_check"`
	// Information about the message or the story this message is replying to; may be null if none
	ReplyTo MessageReplyTo `json:"reply_to"`
	// If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
	MessageThreadId int64 `json:"message_thread_id"`
	// Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages
	SavedMessagesTopicId int64 `json:"saved_messages_topic_id"`
	// The message's self-destruct type; may be null if none
	SelfDestructType MessageSelfDestructType `json:"self_destruct_type"`
	// Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
	SelfDestructIn float64 `json:"self_destruct_in"`
	// Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
	AutoDeleteIn float64 `json:"auto_delete_in"`
	// If non-zero, the user identifier of the inline bot through which this message was sent
	ViaBotUserId int64 `json:"via_bot_user_id"`
	// If non-zero, the user identifier of the business bot that sent this message
	SenderBusinessBotUserId int64 `json:"sender_business_bot_user_id"`
	// Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown. For messages sent by the current user, supergroupFullInfo.my_boost_count must be used instead
	SenderBoostCount int32 `json:"sender_boost_count"`
	// For channel posts and anonymous group messages, optional author signature
	AuthorSignature string `json:"author_signature"`
	// Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
	MediaAlbumId JsonInt64 `json:"media_album_id"`
	// Unique identifier of the effect added to the message; 0 if none
	EffectId JsonInt64 `json:"effect_id"`
	// True, if media content of the message must be hidden with 18+ spoiler
	HasSensitiveContent bool `json:"has_sensitive_content"`
	// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// Content of the message
	Content MessageContent `json:"content"`
	// Reply markup for the message; may be null if none
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *Message) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Message

	return json.Marshal((*stub)(entity))
}

func (*Message) GetClass() string {
	return ClassMessage
}

func (*Message) GetType() string {
	return TypeMessage
}

func (message *Message) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                      int64                   `json:"id"`
		SenderId                json.RawMessage         `json:"sender_id"`
		ChatId                  int64                   `json:"chat_id"`
		SendingState            json.RawMessage         `json:"sending_state"`
		SchedulingState         json.RawMessage         `json:"scheduling_state"`
		IsOutgoing              bool                    `json:"is_outgoing"`
		IsPinned                bool                    `json:"is_pinned"`
		IsFromOffline           bool                    `json:"is_from_offline"`
		CanBeSaved              bool                    `json:"can_be_saved"`
		HasTimestampedMedia     bool                    `json:"has_timestamped_media"`
		IsChannelPost           bool                    `json:"is_channel_post"`
		IsTopicMessage          bool                    `json:"is_topic_message"`
		ContainsUnreadMention   bool                    `json:"contains_unread_mention"`
		Date                    int32                   `json:"date"`
		EditDate                int32                   `json:"edit_date"`
		ForwardInfo             *MessageForwardInfo     `json:"forward_info"`
		ImportInfo              *MessageImportInfo      `json:"import_info"`
		InteractionInfo         *MessageInteractionInfo `json:"interaction_info"`
		UnreadReactions         []*UnreadReaction       `json:"unread_reactions"`
		FactCheck               *FactCheck              `json:"fact_check"`
		ReplyTo                 json.RawMessage         `json:"reply_to"`
		MessageThreadId         int64                   `json:"message_thread_id"`
		SavedMessagesTopicId    int64                   `json:"saved_messages_topic_id"`
		SelfDestructType        json.RawMessage         `json:"self_destruct_type"`
		SelfDestructIn          float64                 `json:"self_destruct_in"`
		AutoDeleteIn            float64                 `json:"auto_delete_in"`
		ViaBotUserId            int64                   `json:"via_bot_user_id"`
		SenderBusinessBotUserId int64                   `json:"sender_business_bot_user_id"`
		SenderBoostCount        int32                   `json:"sender_boost_count"`
		AuthorSignature         string                  `json:"author_signature"`
		MediaAlbumId            JsonInt64               `json:"media_album_id"`
		EffectId                JsonInt64               `json:"effect_id"`
		HasSensitiveContent     bool                    `json:"has_sensitive_content"`
		RestrictionReason       string                  `json:"restriction_reason"`
		Content                 json.RawMessage         `json:"content"`
		ReplyMarkup             json.RawMessage         `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	message.Id = tmp.Id
	message.ChatId = tmp.ChatId
	message.IsOutgoing = tmp.IsOutgoing
	message.IsPinned = tmp.IsPinned
	message.IsFromOffline = tmp.IsFromOffline
	message.CanBeSaved = tmp.CanBeSaved
	message.HasTimestampedMedia = tmp.HasTimestampedMedia
	message.IsChannelPost = tmp.IsChannelPost
	message.IsTopicMessage = tmp.IsTopicMessage
	message.ContainsUnreadMention = tmp.ContainsUnreadMention
	message.Date = tmp.Date
	message.EditDate = tmp.EditDate
	message.ForwardInfo = tmp.ForwardInfo
	message.ImportInfo = tmp.ImportInfo
	message.InteractionInfo = tmp.InteractionInfo
	message.UnreadReactions = tmp.UnreadReactions
	message.FactCheck = tmp.FactCheck
	message.MessageThreadId = tmp.MessageThreadId
	message.SavedMessagesTopicId = tmp.SavedMessagesTopicId
	message.SelfDestructIn = tmp.SelfDestructIn
	message.AutoDeleteIn = tmp.AutoDeleteIn
	message.ViaBotUserId = tmp.ViaBotUserId
	message.SenderBusinessBotUserId = tmp.SenderBusinessBotUserId
	message.SenderBoostCount = tmp.SenderBoostCount
	message.AuthorSignature = tmp.AuthorSignature
	message.MediaAlbumId = tmp.MediaAlbumId
	message.EffectId = tmp.EffectId
	message.HasSensitiveContent = tmp.HasSensitiveContent
	message.RestrictionReason = tmp.RestrictionReason

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	message.SenderId = fieldSenderId

	fieldSendingState, _ := UnmarshalMessageSendingState(tmp.SendingState)
	message.SendingState = fieldSendingState

	fieldSchedulingState, _ := UnmarshalMessageSchedulingState(tmp.SchedulingState)
	message.SchedulingState = fieldSchedulingState

	fieldReplyTo, _ := UnmarshalMessageReplyTo(tmp.ReplyTo)
	message.ReplyTo = fieldReplyTo

	fieldSelfDestructType, _ := UnmarshalMessageSelfDestructType(tmp.SelfDestructType)
	message.SelfDestructType = fieldSelfDestructType

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	message.Content = fieldContent

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	message.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Contains a list of messages
type Messages struct {
	meta
	// Approximate total number of messages found
	TotalCount int32 `json:"total_count"`
	// List of messages; messages may be null
	Messages []*Message `json:"messages"`
}

func (entity *Messages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Messages

	return json.Marshal((*stub)(entity))
}

func (*Messages) GetClass() string {
	return ClassMessages
}

func (*Messages) GetType() string {
	return TypeMessages
}

// Contains a list of messages found by a search
type FoundMessages struct {
	meta
	// Approximate total number of messages found; -1 if unknown
	TotalCount int32 `json:"total_count"`
	// List of messages
	Messages []*Message `json:"messages"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundMessages

	return json.Marshal((*stub)(entity))
}

func (*FoundMessages) GetClass() string {
	return ClassFoundMessages
}

func (*FoundMessages) GetType() string {
	return TypeFoundMessages
}

// Contains a list of messages found by a search in a given chat
type FoundChatMessages struct {
	meta
	// Approximate total number of messages found; -1 if unknown
	TotalCount int32 `json:"total_count"`
	// List of messages
	Messages []*Message `json:"messages"`
	// The offset for the next request. If 0, there are no more results
	NextFromMessageId int64 `json:"next_from_message_id"`
}

func (entity *FoundChatMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundChatMessages

	return json.Marshal((*stub)(entity))
}

func (*FoundChatMessages) GetClass() string {
	return ClassFoundChatMessages
}

func (*FoundChatMessages) GetType() string {
	return TypeFoundChatMessages
}

// Contains information about a message in a specific position
type MessagePosition struct {
	meta
	// 0-based message position in the full list of suitable messages
	Position int32 `json:"position"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Point in time (Unix timestamp) when the message was sent
	Date int32 `json:"date"`
}

func (entity *MessagePosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePosition

	return json.Marshal((*stub)(entity))
}

func (*MessagePosition) GetClass() string {
	return ClassMessagePosition
}

func (*MessagePosition) GetType() string {
	return TypeMessagePosition
}

// Contains a list of message positions
type MessagePositions struct {
	meta
	// Total number of messages found
	TotalCount int32 `json:"total_count"`
	// List of message positions
	Positions []*MessagePosition `json:"positions"`
}

func (entity *MessagePositions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePositions

	return json.Marshal((*stub)(entity))
}

func (*MessagePositions) GetClass() string {
	return ClassMessagePositions
}

func (*MessagePositions) GetType() string {
	return TypeMessagePositions
}

// Contains information about found messages sent on a specific day
type MessageCalendarDay struct {
	meta
	// Total number of found messages sent on the day
	TotalCount int32 `json:"total_count"`
	// First message sent on the day
	Message *Message `json:"message"`
}

func (entity *MessageCalendarDay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCalendarDay

	return json.Marshal((*stub)(entity))
}

func (*MessageCalendarDay) GetClass() string {
	return ClassMessageCalendarDay
}

func (*MessageCalendarDay) GetType() string {
	return TypeMessageCalendarDay
}

// Contains information about found messages, split by days according to the option "utc_time_offset"
type MessageCalendar struct {
	meta
	// Total number of found messages
	TotalCount int32 `json:"total_count"`
	// Information about messages sent
	Days []*MessageCalendarDay `json:"days"`
}

func (entity *MessageCalendar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCalendar

	return json.Marshal((*stub)(entity))
}

func (*MessageCalendar) GetClass() string {
	return ClassMessageCalendar
}

func (*MessageCalendar) GetType() string {
	return TypeMessageCalendar
}

// Describes a message from a business account as received by a bot
type BusinessMessage struct {
	meta
	// The message
	Message *Message `json:"message"`
	// Message that is replied by the message in the same chat; may be null if none
	ReplyToMessage *Message `json:"reply_to_message"`
}

func (entity *BusinessMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessMessage

	return json.Marshal((*stub)(entity))
}

func (*BusinessMessage) GetClass() string {
	return ClassBusinessMessage
}

func (*BusinessMessage) GetType() string {
	return TypeBusinessMessage
}

// Contains a list of messages from a business account as received by a bot
type BusinessMessages struct {
	meta
	// List of business messages
	Messages []*BusinessMessage `json:"messages"`
}

func (entity *BusinessMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessMessages

	return json.Marshal((*stub)(entity))
}

func (*BusinessMessages) GetClass() string {
	return ClassBusinessMessages
}

func (*BusinessMessages) GetType() string {
	return TypeBusinessMessages
}

// The message is from a chat history
type MessageSourceChatHistory struct {
	meta
}

func (entity *MessageSourceChatHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceChatHistory

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceChatHistory) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceChatHistory) GetType() string {
	return TypeMessageSourceChatHistory
}

func (*MessageSourceChatHistory) MessageSourceType() string {
	return TypeMessageSourceChatHistory
}

// The message is from a message thread history
type MessageSourceMessageThreadHistory struct {
	meta
}

func (entity *MessageSourceMessageThreadHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceMessageThreadHistory

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceMessageThreadHistory) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceMessageThreadHistory) GetType() string {
	return TypeMessageSourceMessageThreadHistory
}

func (*MessageSourceMessageThreadHistory) MessageSourceType() string {
	return TypeMessageSourceMessageThreadHistory
}

// The message is from a forum topic history
type MessageSourceForumTopicHistory struct {
	meta
}

func (entity *MessageSourceForumTopicHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceForumTopicHistory

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceForumTopicHistory) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceForumTopicHistory) GetType() string {
	return TypeMessageSourceForumTopicHistory
}

func (*MessageSourceForumTopicHistory) MessageSourceType() string {
	return TypeMessageSourceForumTopicHistory
}

// The message is from chat, message thread or forum topic history preview
type MessageSourceHistoryPreview struct {
	meta
}

func (entity *MessageSourceHistoryPreview) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceHistoryPreview

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceHistoryPreview) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceHistoryPreview) GetType() string {
	return TypeMessageSourceHistoryPreview
}

func (*MessageSourceHistoryPreview) MessageSourceType() string {
	return TypeMessageSourceHistoryPreview
}

// The message is from a chat list or a forum topic list
type MessageSourceChatList struct {
	meta
}

func (entity *MessageSourceChatList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceChatList

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceChatList) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceChatList) GetType() string {
	return TypeMessageSourceChatList
}

func (*MessageSourceChatList) MessageSourceType() string {
	return TypeMessageSourceChatList
}

// The message is from search results, including file downloads, local file list, outgoing document messages, calendar
type MessageSourceSearch struct {
	meta
}

func (entity *MessageSourceSearch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceSearch

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceSearch) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceSearch) GetType() string {
	return TypeMessageSourceSearch
}

func (*MessageSourceSearch) MessageSourceType() string {
	return TypeMessageSourceSearch
}

// The message is from a chat event log
type MessageSourceChatEventLog struct {
	meta
}

func (entity *MessageSourceChatEventLog) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceChatEventLog

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceChatEventLog) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceChatEventLog) GetType() string {
	return TypeMessageSourceChatEventLog
}

func (*MessageSourceChatEventLog) MessageSourceType() string {
	return TypeMessageSourceChatEventLog
}

// The message is from a notification
type MessageSourceNotification struct {
	meta
}

func (entity *MessageSourceNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceNotification

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceNotification) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceNotification) GetType() string {
	return TypeMessageSourceNotification
}

func (*MessageSourceNotification) MessageSourceType() string {
	return TypeMessageSourceNotification
}

// The message was screenshotted; the source must be used only if the message content was visible during the screenshot
type MessageSourceScreenshot struct {
	meta
}

func (entity *MessageSourceScreenshot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceScreenshot

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceScreenshot) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceScreenshot) GetType() string {
	return TypeMessageSourceScreenshot
}

func (*MessageSourceScreenshot) MessageSourceType() string {
	return TypeMessageSourceScreenshot
}

// The message is from some other source
type MessageSourceOther struct {
	meta
}

func (entity *MessageSourceOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSourceOther

	return json.Marshal((*stub)(entity))
}

func (*MessageSourceOther) GetClass() string {
	return ClassMessageSource
}

func (*MessageSourceOther) GetType() string {
	return TypeMessageSourceOther
}

func (*MessageSourceOther) MessageSourceType() string {
	return TypeMessageSourceOther
}

// Information about the sponsor of a message
type MessageSponsor struct {
	meta
	// URL of the sponsor to be opened when the message is clicked
	Url string `json:"url"`
	// Photo of the sponsor; may be null if must not be shown
	Photo *Photo `json:"photo"`
	// Additional optional information about the sponsor to be shown along with the message
	Info string `json:"info"`
}

func (entity *MessageSponsor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSponsor

	return json.Marshal((*stub)(entity))
}

func (*MessageSponsor) GetClass() string {
	return ClassMessageSponsor
}

func (*MessageSponsor) GetType() string {
	return TypeMessageSponsor
}

// Describes a sponsored message
type SponsoredMessage struct {
	meta
	// Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
	MessageId int64 `json:"message_id"`
	// True, if the message needs to be labeled as "recommended" instead of "sponsored"
	IsRecommended bool `json:"is_recommended"`
	// True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage
	CanBeReported bool `json:"can_be_reported"`
	// Content of the message. Currently, can be only of the types messageText, messageAnimation, messagePhoto, or messageVideo. Video messages can be viewed fullscreen
	Content MessageContent `json:"content"`
	// Information about the sponsor of the message
	Sponsor *MessageSponsor `json:"sponsor"`
	// Title of the sponsored message
	Title string `json:"title"`
	// Text for the message action button
	ButtonText string `json:"button_text"`
	// Identifier of the accent color for title, button text and message background
	AccentColorId int32 `json:"accent_color_id"`
	// Identifier of a custom emoji to be shown on the message background; 0 if none
	BackgroundCustomEmojiId JsonInt64 `json:"background_custom_emoji_id"`
	// If non-empty, additional information about the sponsored message to be shown along with the message
	AdditionalInfo string `json:"additional_info"`
}

func (entity *SponsoredMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SponsoredMessage

	return json.Marshal((*stub)(entity))
}

func (*SponsoredMessage) GetClass() string {
	return ClassSponsoredMessage
}

func (*SponsoredMessage) GetType() string {
	return TypeSponsoredMessage
}

func (sponsoredMessage *SponsoredMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageId               int64           `json:"message_id"`
		IsRecommended           bool            `json:"is_recommended"`
		CanBeReported           bool            `json:"can_be_reported"`
		Content                 json.RawMessage `json:"content"`
		Sponsor                 *MessageSponsor `json:"sponsor"`
		Title                   string          `json:"title"`
		ButtonText              string          `json:"button_text"`
		AccentColorId           int32           `json:"accent_color_id"`
		BackgroundCustomEmojiId JsonInt64       `json:"background_custom_emoji_id"`
		AdditionalInfo          string          `json:"additional_info"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	sponsoredMessage.MessageId = tmp.MessageId
	sponsoredMessage.IsRecommended = tmp.IsRecommended
	sponsoredMessage.CanBeReported = tmp.CanBeReported
	sponsoredMessage.Sponsor = tmp.Sponsor
	sponsoredMessage.Title = tmp.Title
	sponsoredMessage.ButtonText = tmp.ButtonText
	sponsoredMessage.AccentColorId = tmp.AccentColorId
	sponsoredMessage.BackgroundCustomEmojiId = tmp.BackgroundCustomEmojiId
	sponsoredMessage.AdditionalInfo = tmp.AdditionalInfo

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	sponsoredMessage.Content = fieldContent

	return nil
}

// Contains a list of sponsored messages
type SponsoredMessages struct {
	meta
	// List of sponsored messages
	Messages []*SponsoredMessage `json:"messages"`
	// The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
	MessagesBetween int32 `json:"messages_between"`
}

func (entity *SponsoredMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SponsoredMessages

	return json.Marshal((*stub)(entity))
}

func (*SponsoredMessages) GetClass() string {
	return ClassSponsoredMessages
}

func (*SponsoredMessages) GetType() string {
	return TypeSponsoredMessages
}

// Describes an option to report an entity to Telegram
type ReportOption struct {
	meta
	// Unique identifier of the option
	Id []byte `json:"id"`
	// Text of the option
	Text string `json:"text"`
}

func (entity *ReportOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportOption

	return json.Marshal((*stub)(entity))
}

func (*ReportOption) GetClass() string {
	return ClassReportOption
}

func (*ReportOption) GetType() string {
	return TypeReportOption
}

// The message was reported successfully
type ReportChatSponsoredMessageResultOk struct {
	meta
}

func (entity *ReportChatSponsoredMessageResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatSponsoredMessageResultOk

	return json.Marshal((*stub)(entity))
}

func (*ReportChatSponsoredMessageResultOk) GetClass() string {
	return ClassReportChatSponsoredMessageResult
}

func (*ReportChatSponsoredMessageResultOk) GetType() string {
	return TypeReportChatSponsoredMessageResultOk
}

func (*ReportChatSponsoredMessageResultOk) ReportChatSponsoredMessageResultType() string {
	return TypeReportChatSponsoredMessageResultOk
}

// The sponsored message is too old or not found
type ReportChatSponsoredMessageResultFailed struct {
	meta
}

func (entity *ReportChatSponsoredMessageResultFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatSponsoredMessageResultFailed

	return json.Marshal((*stub)(entity))
}

func (*ReportChatSponsoredMessageResultFailed) GetClass() string {
	return ClassReportChatSponsoredMessageResult
}

func (*ReportChatSponsoredMessageResultFailed) GetType() string {
	return TypeReportChatSponsoredMessageResultFailed
}

func (*ReportChatSponsoredMessageResultFailed) ReportChatSponsoredMessageResultType() string {
	return TypeReportChatSponsoredMessageResultFailed
}

// The user must choose an option to report the message and repeat request with the chosen option
type ReportChatSponsoredMessageResultOptionRequired struct {
	meta
	// Title for the option choice
	Title string `json:"title"`
	// List of available options
	Options []*ReportOption `json:"options"`
}

func (entity *ReportChatSponsoredMessageResultOptionRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatSponsoredMessageResultOptionRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportChatSponsoredMessageResultOptionRequired) GetClass() string {
	return ClassReportChatSponsoredMessageResult
}

func (*ReportChatSponsoredMessageResultOptionRequired) GetType() string {
	return TypeReportChatSponsoredMessageResultOptionRequired
}

func (*ReportChatSponsoredMessageResultOptionRequired) ReportChatSponsoredMessageResultType() string {
	return TypeReportChatSponsoredMessageResultOptionRequired
}

// Sponsored messages were hidden for the user in all chats
type ReportChatSponsoredMessageResultAdsHidden struct {
	meta
}

func (entity *ReportChatSponsoredMessageResultAdsHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatSponsoredMessageResultAdsHidden

	return json.Marshal((*stub)(entity))
}

func (*ReportChatSponsoredMessageResultAdsHidden) GetClass() string {
	return ClassReportChatSponsoredMessageResult
}

func (*ReportChatSponsoredMessageResultAdsHidden) GetType() string {
	return TypeReportChatSponsoredMessageResultAdsHidden
}

func (*ReportChatSponsoredMessageResultAdsHidden) ReportChatSponsoredMessageResultType() string {
	return TypeReportChatSponsoredMessageResultAdsHidden
}

// The user asked to hide sponsored messages, but Telegram Premium is required for this
type ReportChatSponsoredMessageResultPremiumRequired struct {
	meta
}

func (entity *ReportChatSponsoredMessageResultPremiumRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatSponsoredMessageResultPremiumRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportChatSponsoredMessageResultPremiumRequired) GetClass() string {
	return ClassReportChatSponsoredMessageResult
}

func (*ReportChatSponsoredMessageResultPremiumRequired) GetType() string {
	return TypeReportChatSponsoredMessageResultPremiumRequired
}

func (*ReportChatSponsoredMessageResultPremiumRequired) ReportChatSponsoredMessageResultType() string {
	return TypeReportChatSponsoredMessageResultPremiumRequired
}

// Describes a file added to file download list
type FileDownload struct {
	meta
	// File identifier
	FileId int32 `json:"file_id"`
	// The message with the file
	Message *Message `json:"message"`
	// Point in time (Unix timestamp) when the file was added to the download list
	AddDate int32 `json:"add_date"`
	// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
	CompleteDate int32 `json:"complete_date"`
	// True, if downloading of the file is paused
	IsPaused bool `json:"is_paused"`
}

func (entity *FileDownload) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileDownload

	return json.Marshal((*stub)(entity))
}

func (*FileDownload) GetClass() string {
	return ClassFileDownload
}

func (*FileDownload) GetType() string {
	return TypeFileDownload
}

// Contains number of being downloaded and recently downloaded files found
type DownloadedFileCounts struct {
	meta
	// Number of active file downloads found, including paused
	ActiveCount int32 `json:"active_count"`
	// Number of paused file downloads found
	PausedCount int32 `json:"paused_count"`
	// Number of completed file downloads found
	CompletedCount int32 `json:"completed_count"`
}

func (entity *DownloadedFileCounts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DownloadedFileCounts

	return json.Marshal((*stub)(entity))
}

func (*DownloadedFileCounts) GetClass() string {
	return ClassDownloadedFileCounts
}

func (*DownloadedFileCounts) GetType() string {
	return TypeDownloadedFileCounts
}

// Contains a list of downloaded files, found by a search
type FoundFileDownloads struct {
	meta
	// Total number of suitable files, ignoring offset
	TotalCounts *DownloadedFileCounts `json:"total_counts"`
	// The list of files
	Files []*FileDownload `json:"files"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundFileDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundFileDownloads

	return json.Marshal((*stub)(entity))
}

func (*FoundFileDownloads) GetClass() string {
	return ClassFoundFileDownloads
}

func (*FoundFileDownloads) GetType() string {
	return TypeFoundFileDownloads
}

// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
type NotificationSettingsScopePrivateChats struct {
	meta
}

func (entity *NotificationSettingsScopePrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopePrivateChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopePrivateChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopePrivateChats) GetType() string {
	return TypeNotificationSettingsScopePrivateChats
}

func (*NotificationSettingsScopePrivateChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopePrivateChats
}

// Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
type NotificationSettingsScopeGroupChats struct {
	meta
}

func (entity *NotificationSettingsScopeGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopeGroupChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopeGroupChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopeGroupChats) GetType() string {
	return TypeNotificationSettingsScopeGroupChats
}

func (*NotificationSettingsScopeGroupChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopeGroupChats
}

// Notification settings applied to all channel chats when the corresponding chat setting has a default value
type NotificationSettingsScopeChannelChats struct {
	meta
}

func (entity *NotificationSettingsScopeChannelChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopeChannelChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopeChannelChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopeChannelChats) GetType() string {
	return TypeNotificationSettingsScopeChannelChats
}

func (*NotificationSettingsScopeChannelChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopeChannelChats
}

// Contains information about notification settings for a chat or a forum topic
type ChatNotificationSettings struct {
	meta
	// If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
	UseDefaultMuteFor bool `json:"use_default_mute_for"`
	// Time left before notifications will be unmuted, in seconds
	MuteFor int32 `json:"mute_for"`
	// If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
	UseDefaultSound bool `json:"use_default_sound"`
	// Identifier of the notification sound to be played for messages; 0 if sound is disabled
	SoundId JsonInt64 `json:"sound_id"`
	// If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
	UseDefaultShowPreview bool `json:"use_default_show_preview"`
	// True, if message content must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
	// If true, the value for the relevant type of chat is used instead of mute_stories
	UseDefaultMuteStories bool `json:"use_default_mute_stories"`
	// True, if story notifications are disabled for the chat
	MuteStories bool `json:"mute_stories"`
	// If true, the value for the relevant type of chat is used instead of story_sound_id
	UseDefaultStorySound bool `json:"use_default_story_sound"`
	// Identifier of the notification sound to be played for stories; 0 if sound is disabled
	StorySoundId JsonInt64 `json:"story_sound_id"`
	// If true, the value for the relevant type of chat is used instead of show_story_sender
	UseDefaultShowStorySender bool `json:"use_default_show_story_sender"`
	// True, if the sender of stories must be displayed in notifications
	ShowStorySender bool `json:"show_story_sender"`
	// If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
	UseDefaultDisablePinnedMessageNotifications bool `json:"use_default_disable_pinned_message_notifications"`
	// If true, notifications for incoming pinned messages will be created as for an ordinary unread message
	DisablePinnedMessageNotifications bool `json:"disable_pinned_message_notifications"`
	// If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
	UseDefaultDisableMentionNotifications bool `json:"use_default_disable_mention_notifications"`
	// If true, notifications for messages with mentions will be created as for an ordinary unread message
	DisableMentionNotifications bool `json:"disable_mention_notifications"`
}

func (entity *ChatNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ChatNotificationSettings) GetClass() string {
	return ClassChatNotificationSettings
}

func (*ChatNotificationSettings) GetType() string {
	return TypeChatNotificationSettings
}

// Contains information about notification settings for several chats
type ScopeNotificationSettings struct {
	meta
	// Time left before notifications will be unmuted, in seconds
	MuteFor int32 `json:"mute_for"`
	// Identifier of the notification sound to be played; 0 if sound is disabled
	SoundId JsonInt64 `json:"sound_id"`
	// True, if message content must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
	// If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
	UseDefaultMuteStories bool `json:"use_default_mute_stories"`
	// True, if story notifications are disabled
	MuteStories bool `json:"mute_stories"`
	// Identifier of the notification sound to be played for stories; 0 if sound is disabled
	StorySoundId JsonInt64 `json:"story_sound_id"`
	// True, if the sender of stories must be displayed in notifications
	ShowStorySender bool `json:"show_story_sender"`
	// True, if notifications for incoming pinned messages will be created as for an ordinary unread message
	DisablePinnedMessageNotifications bool `json:"disable_pinned_message_notifications"`
	// True, if notifications for messages with mentions will be created as for an ordinary unread message
	DisableMentionNotifications bool `json:"disable_mention_notifications"`
}

func (entity *ScopeNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ScopeNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ScopeNotificationSettings) GetClass() string {
	return ClassScopeNotificationSettings
}

func (*ScopeNotificationSettings) GetType() string {
	return TypeScopeNotificationSettings
}

// Notifications for reactions are disabled
type ReactionNotificationSourceNone struct {
	meta
}

func (entity *ReactionNotificationSourceNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionNotificationSourceNone

	return json.Marshal((*stub)(entity))
}

func (*ReactionNotificationSourceNone) GetClass() string {
	return ClassReactionNotificationSource
}

func (*ReactionNotificationSourceNone) GetType() string {
	return TypeReactionNotificationSourceNone
}

func (*ReactionNotificationSourceNone) ReactionNotificationSourceType() string {
	return TypeReactionNotificationSourceNone
}

// Notifications for reactions are shown only for reactions from contacts
type ReactionNotificationSourceContacts struct {
	meta
}

func (entity *ReactionNotificationSourceContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionNotificationSourceContacts

	return json.Marshal((*stub)(entity))
}

func (*ReactionNotificationSourceContacts) GetClass() string {
	return ClassReactionNotificationSource
}

func (*ReactionNotificationSourceContacts) GetType() string {
	return TypeReactionNotificationSourceContacts
}

func (*ReactionNotificationSourceContacts) ReactionNotificationSourceType() string {
	return TypeReactionNotificationSourceContacts
}

// Notifications for reactions are shown for all reactions
type ReactionNotificationSourceAll struct {
	meta
}

func (entity *ReactionNotificationSourceAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionNotificationSourceAll

	return json.Marshal((*stub)(entity))
}

func (*ReactionNotificationSourceAll) GetClass() string {
	return ClassReactionNotificationSource
}

func (*ReactionNotificationSourceAll) GetType() string {
	return TypeReactionNotificationSourceAll
}

func (*ReactionNotificationSourceAll) ReactionNotificationSourceType() string {
	return TypeReactionNotificationSourceAll
}

// Contains information about notification settings for reactions
type ReactionNotificationSettings struct {
	meta
	// Source of message reactions for which notifications are shown
	MessageReactionSource ReactionNotificationSource `json:"message_reaction_source"`
	// Source of story reactions for which notifications are shown
	StoryReactionSource ReactionNotificationSource `json:"story_reaction_source"`
	// Identifier of the notification sound to be played; 0 if sound is disabled
	SoundId JsonInt64 `json:"sound_id"`
	// True, if reaction sender and emoji must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
}

func (entity *ReactionNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ReactionNotificationSettings) GetClass() string {
	return ClassReactionNotificationSettings
}

func (*ReactionNotificationSettings) GetType() string {
	return TypeReactionNotificationSettings
}

func (reactionNotificationSettings *ReactionNotificationSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageReactionSource json.RawMessage `json:"message_reaction_source"`
		StoryReactionSource   json.RawMessage `json:"story_reaction_source"`
		SoundId               JsonInt64       `json:"sound_id"`
		ShowPreview           bool            `json:"show_preview"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	reactionNotificationSettings.SoundId = tmp.SoundId
	reactionNotificationSettings.ShowPreview = tmp.ShowPreview

	fieldMessageReactionSource, _ := UnmarshalReactionNotificationSource(tmp.MessageReactionSource)
	reactionNotificationSettings.MessageReactionSource = fieldMessageReactionSource

	fieldStoryReactionSource, _ := UnmarshalReactionNotificationSource(tmp.StoryReactionSource)
	reactionNotificationSettings.StoryReactionSource = fieldStoryReactionSource

	return nil
}

// Contains information about a message draft
type DraftMessage struct {
	meta
	// Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none
	ReplyTo InputMessageReplyTo `json:"reply_to"`
	// Point in time (Unix timestamp) when the draft was created
	Date int32 `json:"date"`
	// Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote, or inputMessageVoiceNote
	InputMessageText InputMessageContent `json:"input_message_text"`
	// Identifier of the effect to apply to the message when it is sent; 0 if none
	EffectId JsonInt64 `json:"effect_id"`
}

func (entity *DraftMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DraftMessage

	return json.Marshal((*stub)(entity))
}

func (*DraftMessage) GetClass() string {
	return ClassDraftMessage
}

func (*DraftMessage) GetType() string {
	return TypeDraftMessage
}

func (draftMessage *DraftMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReplyTo          json.RawMessage `json:"reply_to"`
		Date             int32           `json:"date"`
		InputMessageText json.RawMessage `json:"input_message_text"`
		EffectId         JsonInt64       `json:"effect_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	draftMessage.Date = tmp.Date
	draftMessage.EffectId = tmp.EffectId

	fieldReplyTo, _ := UnmarshalInputMessageReplyTo(tmp.ReplyTo)
	draftMessage.ReplyTo = fieldReplyTo

	fieldInputMessageText, _ := UnmarshalInputMessageContent(tmp.InputMessageText)
	draftMessage.InputMessageText = fieldInputMessageText

	return nil
}

// An ordinary chat with a user
type ChatTypePrivate struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
}

func (entity *ChatTypePrivate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypePrivate

	return json.Marshal((*stub)(entity))
}

func (*ChatTypePrivate) GetClass() string {
	return ClassChatType
}

func (*ChatTypePrivate) GetType() string {
	return TypeChatTypePrivate
}

func (*ChatTypePrivate) ChatTypeType() string {
	return TypeChatTypePrivate
}

// A basic group (a chat with 0-200 other users)
type ChatTypeBasicGroup struct {
	meta
	// Basic group identifier
	BasicGroupId int64 `json:"basic_group_id"`
}

func (entity *ChatTypeBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeBasicGroup) GetClass() string {
	return ClassChatType
}

func (*ChatTypeBasicGroup) GetType() string {
	return TypeChatTypeBasicGroup
}

func (*ChatTypeBasicGroup) ChatTypeType() string {
	return TypeChatTypeBasicGroup
}

// A supergroup or channel (with unlimited members)
type ChatTypeSupergroup struct {
	meta
	// Supergroup or channel identifier
	SupergroupId int64 `json:"supergroup_id"`
	// True, if the supergroup is a channel
	IsChannel bool `json:"is_channel"`
}

func (entity *ChatTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeSupergroup) GetClass() string {
	return ClassChatType
}

func (*ChatTypeSupergroup) GetType() string {
	return TypeChatTypeSupergroup
}

func (*ChatTypeSupergroup) ChatTypeType() string {
	return TypeChatTypeSupergroup
}

// A secret chat with a user
type ChatTypeSecret struct {
	meta
	// Secret chat identifier
	SecretChatId int32 `json:"secret_chat_id"`
	// User identifier of the other user in the secret chat
	UserId int64 `json:"user_id"`
}

func (entity *ChatTypeSecret) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeSecret

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeSecret) GetClass() string {
	return ClassChatType
}

func (*ChatTypeSecret) GetType() string {
	return TypeChatTypeSecret
}

func (*ChatTypeSecret) ChatTypeType() string {
	return TypeChatTypeSecret
}

// Represents an icon for a chat folder
type ChatFolderIcon struct {
	meta
	// The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
	Name string `json:"name"`
}

func (entity *ChatFolderIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFolderIcon

	return json.Marshal((*stub)(entity))
}

func (*ChatFolderIcon) GetClass() string {
	return ClassChatFolderIcon
}

func (*ChatFolderIcon) GetType() string {
	return TypeChatFolderIcon
}

// Represents a folder for user chats
type ChatFolder struct {
	meta
	// The title of the folder; 1-12 characters without line feeds
	Title string `json:"title"`
	// The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder
	Icon *ChatFolderIcon `json:"icon"`
	// The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription
	ColorId int32 `json:"color_id"`
	// True, if at least one link has been created for the folder
	IsShareable bool `json:"is_shareable"`
	// The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	PinnedChatIds []int64 `json:"pinned_chat_ids"`
	// The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	IncludedChatIds []int64 `json:"included_chat_ids"`
	// The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	ExcludedChatIds []int64 `json:"excluded_chat_ids"`
	// True, if muted chats need to be excluded
	ExcludeMuted bool `json:"exclude_muted"`
	// True, if read chats need to be excluded
	ExcludeRead bool `json:"exclude_read"`
	// True, if archived chats need to be excluded
	ExcludeArchived bool `json:"exclude_archived"`
	// True, if contacts need to be included
	IncludeContacts bool `json:"include_contacts"`
	// True, if non-contact users need to be included
	IncludeNonContacts bool `json:"include_non_contacts"`
	// True, if bots need to be included
	IncludeBots bool `json:"include_bots"`
	// True, if basic groups and supergroups need to be included
	IncludeGroups bool `json:"include_groups"`
	// True, if channels need to be included
	IncludeChannels bool `json:"include_channels"`
}

func (entity *ChatFolder) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFolder

	return json.Marshal((*stub)(entity))
}

func (*ChatFolder) GetClass() string {
	return ClassChatFolder
}

func (*ChatFolder) GetType() string {
	return TypeChatFolder
}

// Contains basic information about a chat folder
type ChatFolderInfo struct {
	meta
	// Unique chat folder identifier
	Id int32 `json:"id"`
	// The title of the folder; 1-12 characters without line feeds
	Title string `json:"title"`
	// The chosen or default icon for the chat folder
	Icon *ChatFolderIcon `json:"icon"`
	// The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled
	ColorId int32 `json:"color_id"`
	// True, if at least one link has been created for the folder
	IsShareable bool `json:"is_shareable"`
	// True, if the chat folder has invite links created by the current user
	HasMyInviteLinks bool `json:"has_my_invite_links"`
}

func (entity *ChatFolderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFolderInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatFolderInfo) GetClass() string {
	return ClassChatFolderInfo
}

func (*ChatFolderInfo) GetType() string {
	return TypeChatFolderInfo
}

// Contains a chat folder invite link
type ChatFolderInviteLink struct {
	meta
	// The chat folder invite link
	InviteLink string `json:"invite_link"`
	// Name of the link
	Name string `json:"name"`
	// Identifiers of chats, included in the link
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *ChatFolderInviteLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFolderInviteLink

	return json.Marshal((*stub)(entity))
}

func (*ChatFolderInviteLink) GetClass() string {
	return ClassChatFolderInviteLink
}

func (*ChatFolderInviteLink) GetType() string {
	return TypeChatFolderInviteLink
}

// Represents a list of chat folder invite links
type ChatFolderInviteLinks struct {
	meta
	// List of the invite links
	InviteLinks []*ChatFolderInviteLink `json:"invite_links"`
}

func (entity *ChatFolderInviteLinks) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFolderInviteLinks

	return json.Marshal((*stub)(entity))
}

func (*ChatFolderInviteLinks) GetClass() string {
	return ClassChatFolderInviteLinks
}

func (*ChatFolderInviteLinks) GetType() string {
	return TypeChatFolderInviteLinks
}

// Contains information about an invite link to a chat folder
type ChatFolderInviteLinkInfo struct {
	meta
	// Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
	ChatFolderInfo *ChatFolderInfo `json:"chat_folder_info"`
	// Identifiers of the chats from the link, which aren't added to the folder yet
	MissingChatIds []int64 `json:"missing_chat_ids"`
	// Identifiers of the chats from the link, which are added to the folder already
	AddedChatIds []int64 `json:"added_chat_ids"`
}

func (entity *ChatFolderInviteLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatFolderInviteLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatFolderInviteLinkInfo) GetClass() string {
	return ClassChatFolderInviteLinkInfo
}

func (*ChatFolderInviteLinkInfo) GetType() string {
	return TypeChatFolderInviteLinkInfo
}

// Describes a recommended chat folder
type RecommendedChatFolder struct {
	meta
	// The chat folder
	Folder *ChatFolder `json:"folder"`
	// Chat folder description
	Description string `json:"description"`
}

func (entity *RecommendedChatFolder) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecommendedChatFolder

	return json.Marshal((*stub)(entity))
}

func (*RecommendedChatFolder) GetClass() string {
	return ClassRecommendedChatFolder
}

func (*RecommendedChatFolder) GetType() string {
	return TypeRecommendedChatFolder
}

// Contains a list of recommended chat folders
type RecommendedChatFolders struct {
	meta
	// List of recommended chat folders
	ChatFolders []*RecommendedChatFolder `json:"chat_folders"`
}

func (entity *RecommendedChatFolders) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecommendedChatFolders

	return json.Marshal((*stub)(entity))
}

func (*RecommendedChatFolders) GetClass() string {
	return ClassRecommendedChatFolders
}

func (*RecommendedChatFolders) GetType() string {
	return TypeRecommendedChatFolders
}

// Contains settings for automatic moving of chats to and from the Archive chat lists
type ArchiveChatListSettings struct {
	meta
	// True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
	ArchiveAndMuteNewChatsFromUnknownUsers bool `json:"archive_and_mute_new_chats_from_unknown_users"`
	// True, if unmuted chats will be kept in the Archive chat list when they get a new message
	KeepUnmutedChatsArchived bool `json:"keep_unmuted_chats_archived"`
	// True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
	KeepChatsFromFoldersArchived bool `json:"keep_chats_from_folders_archived"`
}

func (entity *ArchiveChatListSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ArchiveChatListSettings

	return json.Marshal((*stub)(entity))
}

func (*ArchiveChatListSettings) GetClass() string {
	return ClassArchiveChatListSettings
}

func (*ArchiveChatListSettings) GetType() string {
	return TypeArchiveChatListSettings
}

// A main list of chats
type ChatListMain struct {
	meta
}

func (entity *ChatListMain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListMain

	return json.Marshal((*stub)(entity))
}

func (*ChatListMain) GetClass() string {
	return ClassChatList
}

func (*ChatListMain) GetType() string {
	return TypeChatListMain
}

func (*ChatListMain) ChatListType() string {
	return TypeChatListMain
}

// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
type ChatListArchive struct {
	meta
}

func (entity *ChatListArchive) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListArchive

	return json.Marshal((*stub)(entity))
}

func (*ChatListArchive) GetClass() string {
	return ClassChatList
}

func (*ChatListArchive) GetType() string {
	return TypeChatListArchive
}

func (*ChatListArchive) ChatListType() string {
	return TypeChatListArchive
}

// A list of chats added to a chat folder
type ChatListFolder struct {
	meta
	// Chat folder identifier
	ChatFolderId int32 `json:"chat_folder_id"`
}

func (entity *ChatListFolder) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListFolder

	return json.Marshal((*stub)(entity))
}

func (*ChatListFolder) GetClass() string {
	return ClassChatList
}

func (*ChatListFolder) GetType() string {
	return TypeChatListFolder
}

func (*ChatListFolder) ChatListType() string {
	return TypeChatListFolder
}

// Contains a list of chat lists
type ChatLists struct {
	meta
	// List of chat lists
	ChatLists []ChatList `json:"chat_lists"`
}

func (entity *ChatLists) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatLists

	return json.Marshal((*stub)(entity))
}

func (*ChatLists) GetClass() string {
	return ClassChatLists
}

func (*ChatLists) GetType() string {
	return TypeChatLists
}

func (chatLists *ChatLists) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatLists []json.RawMessage `json:"chat_lists"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldChatLists, _ := UnmarshalListOfChatList(tmp.ChatLists)
	chatLists.ChatLists = fieldChatLists

	return nil
}

// The chat is sponsored by the user's MTProxy server
type ChatSourceMtprotoProxy struct {
	meta
}

func (entity *ChatSourceMtprotoProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatSourceMtprotoProxy

	return json.Marshal((*stub)(entity))
}

func (*ChatSourceMtprotoProxy) GetClass() string {
	return ClassChatSource
}

func (*ChatSourceMtprotoProxy) GetType() string {
	return TypeChatSourceMtprotoProxy
}

func (*ChatSourceMtprotoProxy) ChatSourceType() string {
	return TypeChatSourceMtprotoProxy
}

// The chat contains a public service announcement
type ChatSourcePublicServiceAnnouncement struct {
	meta
	// The type of the announcement
	Type string `json:"type"`
	// The text of the announcement
	Text string `json:"text"`
}

func (entity *ChatSourcePublicServiceAnnouncement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatSourcePublicServiceAnnouncement

	return json.Marshal((*stub)(entity))
}

func (*ChatSourcePublicServiceAnnouncement) GetClass() string {
	return ClassChatSource
}

func (*ChatSourcePublicServiceAnnouncement) GetType() string {
	return TypeChatSourcePublicServiceAnnouncement
}

func (*ChatSourcePublicServiceAnnouncement) ChatSourceType() string {
	return TypeChatSourcePublicServiceAnnouncement
}

// Describes a position of a chat in a chat list
type ChatPosition struct {
	meta
	// The chat list
	List ChatList `json:"list"`
	// A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
	Order JsonInt64 `json:"order"`
	// True, if the chat is pinned in the chat list
	IsPinned bool `json:"is_pinned"`
	// Source of the chat in the chat list; may be null
	Source ChatSource `json:"source"`
}

func (entity *ChatPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPosition

	return json.Marshal((*stub)(entity))
}

func (*ChatPosition) GetClass() string {
	return ClassChatPosition
}

func (*ChatPosition) GetType() string {
	return TypeChatPosition
}

func (chatPosition *ChatPosition) UnmarshalJSON(data []byte) error {
	var tmp struct {
		List     json.RawMessage `json:"list"`
		Order    JsonInt64       `json:"order"`
		IsPinned bool            `json:"is_pinned"`
		Source   json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatPosition.Order = tmp.Order
	chatPosition.IsPinned = tmp.IsPinned

	fieldList, _ := UnmarshalChatList(tmp.List)
	chatPosition.List = fieldList

	fieldSource, _ := UnmarshalChatSource(tmp.Source)
	chatPosition.Source = fieldSource

	return nil
}

// All reactions are available in the chat, excluding the paid reaction and custom reactions in channel chats
type ChatAvailableReactionsAll struct {
	meta
	// The maximum allowed number of reactions per message; 1-11
	MaxReactionCount int32 `json:"max_reaction_count"`
}

func (entity *ChatAvailableReactionsAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAvailableReactionsAll

	return json.Marshal((*stub)(entity))
}

func (*ChatAvailableReactionsAll) GetClass() string {
	return ClassChatAvailableReactions
}

func (*ChatAvailableReactionsAll) GetType() string {
	return TypeChatAvailableReactionsAll
}

func (*ChatAvailableReactionsAll) ChatAvailableReactionsType() string {
	return TypeChatAvailableReactionsAll
}

// Only specific reactions are available in the chat
type ChatAvailableReactionsSome struct {
	meta
	// The list of reactions
	Reactions []ReactionType `json:"reactions"`
	// The maximum allowed number of reactions per message; 1-11
	MaxReactionCount int32 `json:"max_reaction_count"`
}

func (entity *ChatAvailableReactionsSome) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAvailableReactionsSome

	return json.Marshal((*stub)(entity))
}

func (*ChatAvailableReactionsSome) GetClass() string {
	return ClassChatAvailableReactions
}

func (*ChatAvailableReactionsSome) GetType() string {
	return TypeChatAvailableReactionsSome
}

func (*ChatAvailableReactionsSome) ChatAvailableReactionsType() string {
	return TypeChatAvailableReactionsSome
}

func (chatAvailableReactionsSome *ChatAvailableReactionsSome) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Reactions        []json.RawMessage `json:"reactions"`
		MaxReactionCount int32             `json:"max_reaction_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatAvailableReactionsSome.MaxReactionCount = tmp.MaxReactionCount

	fieldReactions, _ := UnmarshalListOfReactionType(tmp.Reactions)
	chatAvailableReactionsSome.Reactions = fieldReactions

	return nil
}

// Represents a tag used in Saved Messages or a Saved Messages topic
type SavedMessagesTag struct {
	meta
	// The tag
	Tag ReactionType `json:"tag"`
	// Label of the tag; 0-12 characters. Always empty if the tag is returned for a Saved Messages topic
	Label string `json:"label"`
	// Number of times the tag was used; may be 0 if the tag has non-empty label
	Count int32 `json:"count"`
}

func (entity *SavedMessagesTag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedMessagesTag

	return json.Marshal((*stub)(entity))
}

func (*SavedMessagesTag) GetClass() string {
	return ClassSavedMessagesTag
}

func (*SavedMessagesTag) GetType() string {
	return TypeSavedMessagesTag
}

func (savedMessagesTag *SavedMessagesTag) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Tag   json.RawMessage `json:"tag"`
		Label string          `json:"label"`
		Count int32           `json:"count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	savedMessagesTag.Label = tmp.Label
	savedMessagesTag.Count = tmp.Count

	fieldTag, _ := UnmarshalReactionType(tmp.Tag)
	savedMessagesTag.Tag = fieldTag

	return nil
}

// Contains a list of tags used in Saved Messages
type SavedMessagesTags struct {
	meta
	// List of tags
	Tags []*SavedMessagesTag `json:"tags"`
}

func (entity *SavedMessagesTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedMessagesTags

	return json.Marshal((*stub)(entity))
}

func (*SavedMessagesTags) GetClass() string {
	return ClassSavedMessagesTags
}

func (*SavedMessagesTags) GetType() string {
	return TypeSavedMessagesTags
}

// Contains information about a business bot that manages the chat
type BusinessBotManageBar struct {
	meta
	// User identifier of the bot
	BotUserId int64 `json:"bot_user_id"`
	// URL to be opened to manage the bot
	ManageUrl string `json:"manage_url"`
	// True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field
	IsBotPaused bool `json:"is_bot_paused"`
	// True, if the bot can reply
	CanBotReply bool `json:"can_bot_reply"`
}

func (entity *BusinessBotManageBar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessBotManageBar

	return json.Marshal((*stub)(entity))
}

func (*BusinessBotManageBar) GetClass() string {
	return ClassBusinessBotManageBar
}

func (*BusinessBotManageBar) GetType() string {
	return TypeBusinessBotManageBar
}

// Describes a video chat
type VideoChat struct {
	meta
	// Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
	// True, if the video chat has participants
	HasParticipants bool `json:"has_participants"`
	// Default group call participant identifier to join the video chat; may be null
	DefaultParticipantId MessageSender `json:"default_participant_id"`
}

func (entity *VideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VideoChat

	return json.Marshal((*stub)(entity))
}

func (*VideoChat) GetClass() string {
	return ClassVideoChat
}

func (*VideoChat) GetType() string {
	return TypeVideoChat
}

func (videoChat *VideoChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		GroupCallId          int32           `json:"group_call_id"`
		HasParticipants      bool            `json:"has_participants"`
		DefaultParticipantId json.RawMessage `json:"default_participant_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	videoChat.GroupCallId = tmp.GroupCallId
	videoChat.HasParticipants = tmp.HasParticipants

	fieldDefaultParticipantId, _ := UnmarshalMessageSender(tmp.DefaultParticipantId)
	videoChat.DefaultParticipantId = fieldDefaultParticipantId

	return nil
}

// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
type Chat struct {
	meta
	// Chat unique identifier
	Id int64 `json:"id"`
	// Type of the chat
	Type ChatType `json:"type"`
	// Chat title
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
	// Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
	AccentColorId int32 `json:"accent_color_id"`
	// Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none
	BackgroundCustomEmojiId JsonInt64 `json:"background_custom_emoji_id"`
	// Identifier of the profile accent color for the chat's profile; -1 if none
	ProfileAccentColorId int32 `json:"profile_accent_color_id"`
	// Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none
	ProfileBackgroundCustomEmojiId JsonInt64 `json:"profile_background_custom_emoji_id"`
	// Actions that non-administrator chat members are allowed to take in the chat
	Permissions *ChatPermissions `json:"permissions"`
	// Last message in the chat; may be null if none or unknown
	LastMessage *Message `json:"last_message"`
	// Positions of the chat in chat lists
	Positions []*ChatPosition `json:"positions"`
	// Chat lists to which the chat belongs. A chat can have a non-zero position in a chat list even it doesn't belong to the chat list and have no position in a chat list even it belongs to the chat list
	ChatLists []ChatList `json:"chat_lists"`
	// Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
	MessageSenderId MessageSender `json:"message_sender_id"`
	// Block list to which the chat is added; may be null if none
	BlockList BlockList `json:"block_list"`
	// True, if chat content can't be saved locally, forwarded, or copied
	HasProtectedContent bool `json:"has_protected_content"`
	// True, if translation of all messages in the chat must be suggested to the user
	IsTranslatable bool `json:"is_translatable"`
	// True, if the chat is marked as unread
	IsMarkedAsUnread bool `json:"is_marked_as_unread"`
	// True, if the chat is a forum supergroup that must be shown in the "View as topics" mode, or Saved Messages chat that must be shown in the "View as chats"
	ViewAsTopics bool `json:"view_as_topics"`
	// True, if the chat has scheduled messages
	HasScheduledMessages bool `json:"has_scheduled_messages"`
	// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
	CanBeDeletedOnlyForSelf bool `json:"can_be_deleted_only_for_self"`
	// True, if the chat messages can be deleted for all users
	CanBeDeletedForAllUsers bool `json:"can_be_deleted_for_all_users"`
	// True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
	CanBeReported bool `json:"can_be_reported"`
	// Default value of the disable_notification parameter, used when a message is sent to the chat
	DefaultDisableNotification bool `json:"default_disable_notification"`
	// Number of unread messages in the chat
	UnreadCount int32 `json:"unread_count"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Number of unread messages with a mention/reply in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
	// Number of messages with unread reactions in the chat
	UnreadReactionCount int32 `json:"unread_reaction_count"`
	// Notification settings for the chat
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
	// Types of reaction, available in the chat
	AvailableReactions ChatAvailableReactions `json:"available_reactions"`
	// Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"`
	// Emoji status to be shown along with chat title; may be null
	EmojiStatus *EmojiStatus `json:"emoji_status"`
	// Background set for the chat; may be null if none
	Background *ChatBackground `json:"background"`
	// If non-empty, name of a theme, set for the chat
	ThemeName string `json:"theme_name"`
	// Information about actions which must be possible to do through the chat action bar; may be null if none
	ActionBar ChatActionBar `json:"action_bar"`
	// Information about bar for managing a business bot in the chat; may be null if none
	BusinessBotManageBar *BusinessBotManageBar `json:"business_bot_manage_bar"`
	// Information about video chat of the chat
	VideoChat *VideoChat `json:"video_chat"`
	// Information about pending join requests; may be null if none
	PendingJoinRequests *ChatJoinRequestsInfo `json:"pending_join_requests"`
	// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	ReplyMarkupMessageId int64 `json:"reply_markup_message_id"`
	// A draft of a message in the chat; may be null if none
	DraftMessage *DraftMessage `json:"draft_message"`
	// Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
	ClientData string `json:"client_data"`
}

func (entity *Chat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Chat

	return json.Marshal((*stub)(entity))
}

func (*Chat) GetClass() string {
	return ClassChat
}

func (*Chat) GetType() string {
	return TypeChat
}

func (chat *Chat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                             int64                     `json:"id"`
		Type                           json.RawMessage           `json:"type"`
		Title                          string                    `json:"title"`
		Photo                          *ChatPhotoInfo            `json:"photo"`
		AccentColorId                  int32                     `json:"accent_color_id"`
		BackgroundCustomEmojiId        JsonInt64                 `json:"background_custom_emoji_id"`
		ProfileAccentColorId           int32                     `json:"profile_accent_color_id"`
		ProfileBackgroundCustomEmojiId JsonInt64                 `json:"profile_background_custom_emoji_id"`
		Permissions                    *ChatPermissions          `json:"permissions"`
		LastMessage                    *Message                  `json:"last_message"`
		Positions                      []*ChatPosition           `json:"positions"`
		ChatLists                      []json.RawMessage         `json:"chat_lists"`
		MessageSenderId                json.RawMessage           `json:"message_sender_id"`
		BlockList                      json.RawMessage           `json:"block_list"`
		HasProtectedContent            bool                      `json:"has_protected_content"`
		IsTranslatable                 bool                      `json:"is_translatable"`
		IsMarkedAsUnread               bool                      `json:"is_marked_as_unread"`
		ViewAsTopics                   bool                      `json:"view_as_topics"`
		HasScheduledMessages           bool                      `json:"has_scheduled_messages"`
		CanBeDeletedOnlyForSelf        bool                      `json:"can_be_deleted_only_for_self"`
		CanBeDeletedForAllUsers        bool                      `json:"can_be_deleted_for_all_users"`
		CanBeReported                  bool                      `json:"can_be_reported"`
		DefaultDisableNotification     bool                      `json:"default_disable_notification"`
		UnreadCount                    int32                     `json:"unread_count"`
		LastReadInboxMessageId         int64                     `json:"last_read_inbox_message_id"`
		LastReadOutboxMessageId        int64                     `json:"last_read_outbox_message_id"`
		UnreadMentionCount             int32                     `json:"unread_mention_count"`
		UnreadReactionCount            int32                     `json:"unread_reaction_count"`
		NotificationSettings           *ChatNotificationSettings `json:"notification_settings"`
		AvailableReactions             json.RawMessage           `json:"available_reactions"`
		MessageAutoDeleteTime          int32                     `json:"message_auto_delete_time"`
		EmojiStatus                    *EmojiStatus              `json:"emoji_status"`
		Background                     *ChatBackground           `json:"background"`
		ThemeName                      string                    `json:"theme_name"`
		ActionBar                      json.RawMessage           `json:"action_bar"`
		BusinessBotManageBar           *BusinessBotManageBar     `json:"business_bot_manage_bar"`
		VideoChat                      *VideoChat                `json:"video_chat"`
		PendingJoinRequests            *ChatJoinRequestsInfo     `json:"pending_join_requests"`
		ReplyMarkupMessageId           int64                     `json:"reply_markup_message_id"`
		DraftMessage                   *DraftMessage             `json:"draft_message"`
		ClientData                     string                    `json:"client_data"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chat.Id = tmp.Id
	chat.Title = tmp.Title
	chat.Photo = tmp.Photo
	chat.AccentColorId = tmp.AccentColorId
	chat.BackgroundCustomEmojiId = tmp.BackgroundCustomEmojiId
	chat.ProfileAccentColorId = tmp.ProfileAccentColorId
	chat.ProfileBackgroundCustomEmojiId = tmp.ProfileBackgroundCustomEmojiId
	chat.Permissions = tmp.Permissions
	chat.LastMessage = tmp.LastMessage
	chat.Positions = tmp.Positions
	chat.HasProtectedContent = tmp.HasProtectedContent
	chat.IsTranslatable = tmp.IsTranslatable
	chat.IsMarkedAsUnread = tmp.IsMarkedAsUnread
	chat.ViewAsTopics = tmp.ViewAsTopics
	chat.HasScheduledMessages = tmp.HasScheduledMessages
	chat.CanBeDeletedOnlyForSelf = tmp.CanBeDeletedOnlyForSelf
	chat.CanBeDeletedForAllUsers = tmp.CanBeDeletedForAllUsers
	chat.CanBeReported = tmp.CanBeReported
	chat.DefaultDisableNotification = tmp.DefaultDisableNotification
	chat.UnreadCount = tmp.UnreadCount
	chat.LastReadInboxMessageId = tmp.LastReadInboxMessageId
	chat.LastReadOutboxMessageId = tmp.LastReadOutboxMessageId
	chat.UnreadMentionCount = tmp.UnreadMentionCount
	chat.UnreadReactionCount = tmp.UnreadReactionCount
	chat.NotificationSettings = tmp.NotificationSettings
	chat.MessageAutoDeleteTime = tmp.MessageAutoDeleteTime
	chat.EmojiStatus = tmp.EmojiStatus
	chat.Background = tmp.Background
	chat.ThemeName = tmp.ThemeName
	chat.BusinessBotManageBar = tmp.BusinessBotManageBar
	chat.VideoChat = tmp.VideoChat
	chat.PendingJoinRequests = tmp.PendingJoinRequests
	chat.ReplyMarkupMessageId = tmp.ReplyMarkupMessageId
	chat.DraftMessage = tmp.DraftMessage
	chat.ClientData = tmp.ClientData

	fieldType, _ := UnmarshalChatType(tmp.Type)
	chat.Type = fieldType

	fieldChatLists, _ := UnmarshalListOfChatList(tmp.ChatLists)
	chat.ChatLists = fieldChatLists

	fieldMessageSenderId, _ := UnmarshalMessageSender(tmp.MessageSenderId)
	chat.MessageSenderId = fieldMessageSenderId

	fieldBlockList, _ := UnmarshalBlockList(tmp.BlockList)
	chat.BlockList = fieldBlockList

	fieldAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.AvailableReactions)
	chat.AvailableReactions = fieldAvailableReactions

	fieldActionBar, _ := UnmarshalChatActionBar(tmp.ActionBar)
	chat.ActionBar = fieldActionBar

	return nil
}

// Represents a list of chats
type Chats struct {
	meta
	// Approximate total number of chats found
	TotalCount int32 `json:"total_count"`
	// List of chat identifiers
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *Chats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Chats

	return json.Marshal((*stub)(entity))
}

func (*Chats) GetClass() string {
	return ClassChats
}

func (*Chats) GetType() string {
	return TypeChats
}

// Contains information about a user that has failed to be added to a chat
type FailedToAddMember struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// True, if subscription to Telegram Premium would have allowed to add the user to the chat
	PremiumWouldAllowInvite bool `json:"premium_would_allow_invite"`
	// True, if subscription to Telegram Premium is required to send the user chat invite link
	PremiumRequiredToSendMessages bool `json:"premium_required_to_send_messages"`
}

func (entity *FailedToAddMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FailedToAddMember

	return json.Marshal((*stub)(entity))
}

func (*FailedToAddMember) GetClass() string {
	return ClassFailedToAddMember
}

func (*FailedToAddMember) GetType() string {
	return TypeFailedToAddMember
}

// Represents a list of users that has failed to be added to a chat
type FailedToAddMembers struct {
	meta
	// Information about users that weren't added to the chat
	FailedToAddMembers []*FailedToAddMember `json:"failed_to_add_members"`
}

func (entity *FailedToAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FailedToAddMembers

	return json.Marshal((*stub)(entity))
}

func (*FailedToAddMembers) GetClass() string {
	return ClassFailedToAddMembers
}

func (*FailedToAddMembers) GetType() string {
	return TypeFailedToAddMembers
}

// Contains information about a newly created basic group chat
type CreatedBasicGroupChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Information about failed to add members
	FailedToAddMembers *FailedToAddMembers `json:"failed_to_add_members"`
}

func (entity *CreatedBasicGroupChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CreatedBasicGroupChat

	return json.Marshal((*stub)(entity))
}

func (*CreatedBasicGroupChat) GetClass() string {
	return ClassCreatedBasicGroupChat
}

func (*CreatedBasicGroupChat) GetType() string {
	return TypeCreatedBasicGroupChat
}

// The chat is public, because it has an active username
type PublicChatTypeHasUsername struct {
	meta
}

func (entity *PublicChatTypeHasUsername) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicChatTypeHasUsername

	return json.Marshal((*stub)(entity))
}

func (*PublicChatTypeHasUsername) GetClass() string {
	return ClassPublicChatType
}

func (*PublicChatTypeHasUsername) GetType() string {
	return TypePublicChatTypeHasUsername
}

func (*PublicChatTypeHasUsername) PublicChatTypeType() string {
	return TypePublicChatTypeHasUsername
}

// The chat is public, because it is a location-based supergroup
type PublicChatTypeIsLocationBased struct {
	meta
}

func (entity *PublicChatTypeIsLocationBased) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicChatTypeIsLocationBased

	return json.Marshal((*stub)(entity))
}

func (*PublicChatTypeIsLocationBased) GetClass() string {
	return ClassPublicChatType
}

func (*PublicChatTypeIsLocationBased) GetType() string {
	return TypePublicChatTypeIsLocationBased
}

func (*PublicChatTypeIsLocationBased) PublicChatTypeType() string {
	return TypePublicChatTypeIsLocationBased
}

// The chat can be reported as spam using the method reportChat with an empty option_id and message_ids. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
type ChatActionBarReportSpam struct {
	meta
	// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
	CanUnarchive bool `json:"can_unarchive"`
}

func (entity *ChatActionBarReportSpam) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportSpam

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportSpam) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportSpam) GetType() string {
	return TypeChatActionBarReportSpam
}

func (*ChatActionBarReportSpam) ChatActionBarType() string {
	return TypeChatActionBarReportSpam
}

// The chat is a recently created group chat to which new members can be invited
type ChatActionBarInviteMembers struct {
	meta
}

func (entity *ChatActionBarInviteMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarInviteMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarInviteMembers) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarInviteMembers) GetType() string {
	return TypeChatActionBarInviteMembers
}

func (*ChatActionBarInviteMembers) ChatActionBarType() string {
	return TypeChatActionBarInviteMembers
}

// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList, or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
type ChatActionBarReportAddBlock struct {
	meta
	// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
	CanUnarchive bool `json:"can_unarchive"`
}

func (entity *ChatActionBarReportAddBlock) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportAddBlock

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportAddBlock) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportAddBlock) GetType() string {
	return TypeChatActionBarReportAddBlock
}

func (*ChatActionBarReportAddBlock) ChatActionBarType() string {
	return TypeChatActionBarReportAddBlock
}

// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
type ChatActionBarAddContact struct {
	meta
}

func (entity *ChatActionBarAddContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarAddContact

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarAddContact) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarAddContact) GetType() string {
	return TypeChatActionBarAddContact
}

func (*ChatActionBarAddContact) ChatActionBarType() string {
	return TypeChatActionBarAddContact
}

// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
type ChatActionBarSharePhoneNumber struct {
	meta
}

func (entity *ChatActionBarSharePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarSharePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarSharePhoneNumber) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarSharePhoneNumber) GetType() string {
	return TypeChatActionBarSharePhoneNumber
}

func (*ChatActionBarSharePhoneNumber) ChatActionBarType() string {
	return TypeChatActionBarSharePhoneNumber
}

// The chat is a private chat with an administrator of a chat to which the user sent join request
type ChatActionBarJoinRequest struct {
	meta
	// Title of the chat to which the join request was sent
	Title string `json:"title"`
	// True, if the join request was sent to a channel chat
	IsChannel bool `json:"is_channel"`
	// Point in time (Unix timestamp) when the join request was sent
	RequestDate int32 `json:"request_date"`
}

func (entity *ChatActionBarJoinRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarJoinRequest

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarJoinRequest) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarJoinRequest) GetType() string {
	return TypeChatActionBarJoinRequest
}

func (*ChatActionBarJoinRequest) ChatActionBarType() string {
	return TypeChatActionBarJoinRequest
}

// A simple button, with text that must be sent when the button is pressed
type KeyboardButtonTypeText struct {
	meta
}

func (entity *KeyboardButtonTypeText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeText

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeText) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeText) GetType() string {
	return TypeKeyboardButtonTypeText
}

func (*KeyboardButtonTypeText) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeText
}

// A button that sends the user's phone number when pressed; available only in private chats
type KeyboardButtonTypeRequestPhoneNumber struct {
	meta
}

func (entity *KeyboardButtonTypeRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestPhoneNumber) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestPhoneNumber) GetType() string {
	return TypeKeyboardButtonTypeRequestPhoneNumber
}

func (*KeyboardButtonTypeRequestPhoneNumber) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestPhoneNumber
}

// A button that sends the user's location when pressed; available only in private chats
type KeyboardButtonTypeRequestLocation struct {
	meta
}

func (entity *KeyboardButtonTypeRequestLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestLocation

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestLocation) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestLocation) GetType() string {
	return TypeKeyboardButtonTypeRequestLocation
}

func (*KeyboardButtonTypeRequestLocation) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestLocation
}

// A button that allows the user to create and send a poll when pressed; available only in private chats
type KeyboardButtonTypeRequestPoll struct {
	meta
	// If true, only regular polls must be allowed to create
	ForceRegular bool `json:"force_regular"`
	// If true, only polls in quiz mode must be allowed to create
	ForceQuiz bool `json:"force_quiz"`
}

func (entity *KeyboardButtonTypeRequestPoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestPoll

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestPoll) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestPoll) GetType() string {
	return TypeKeyboardButtonTypeRequestPoll
}

func (*KeyboardButtonTypeRequestPoll) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestPoll
}

// A button that requests users to be shared by the current user; available only in private chats. Use the method shareUsersWithBot to complete the request
type KeyboardButtonTypeRequestUsers struct {
	meta
	// Unique button identifier
	Id int32 `json:"id"`
	// True, if the shared users must or must not be bots
	RestrictUserIsBot bool `json:"restrict_user_is_bot"`
	// True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
	UserIsBot bool `json:"user_is_bot"`
	// True, if the shared users must or must not be Telegram Premium users
	RestrictUserIsPremium bool `json:"restrict_user_is_premium"`
	// True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
	UserIsPremium bool `json:"user_is_premium"`
	// The maximum number of users to share
	MaxQuantity int32 `json:"max_quantity"`
	// Pass true to request name of the users; bots only
	RequestName bool `json:"request_name"`
	// Pass true to request username of the users; bots only
	RequestUsername bool `json:"request_username"`
	// Pass true to request photo of the users; bots only
	RequestPhoto bool `json:"request_photo"`
}

func (entity *KeyboardButtonTypeRequestUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestUsers

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestUsers) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestUsers) GetType() string {
	return TypeKeyboardButtonTypeRequestUsers
}

func (*KeyboardButtonTypeRequestUsers) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestUsers
}

// A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request
type KeyboardButtonTypeRequestChat struct {
	meta
	// Unique button identifier
	Id int32 `json:"id"`
	// True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
	ChatIsChannel bool `json:"chat_is_channel"`
	// True, if the chat must or must not be a forum supergroup
	RestrictChatIsForum bool `json:"restrict_chat_is_forum"`
	// True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
	ChatIsForum bool `json:"chat_is_forum"`
	// True, if the chat must or must not have a username
	RestrictChatHasUsername bool `json:"restrict_chat_has_username"`
	// True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
	ChatHasUsername bool `json:"chat_has_username"`
	// True, if the chat must be created by the current user
	ChatIsCreated bool `json:"chat_is_created"`
	// Expected user administrator rights in the chat; may be null if they aren't restricted
	UserAdministratorRights *ChatAdministratorRights `json:"user_administrator_rights"`
	// Expected bot administrator rights in the chat; may be null if they aren't restricted
	BotAdministratorRights *ChatAdministratorRights `json:"bot_administrator_rights"`
	// True, if the bot must be a member of the chat; for basic group and supergroup chats only
	BotIsMember bool `json:"bot_is_member"`
	// Pass true to request title of the chat; bots only
	RequestTitle bool `json:"request_title"`
	// Pass true to request username of the chat; bots only
	RequestUsername bool `json:"request_username"`
	// Pass true to request photo of the chat; bots only
	RequestPhoto bool `json:"request_photo"`
}

func (entity *KeyboardButtonTypeRequestChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestChat

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestChat) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestChat) GetType() string {
	return TypeKeyboardButtonTypeRequestChat
}

func (*KeyboardButtonTypeRequestChat) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestChat
}

// A button that opens a Web App by calling getWebAppUrl
type KeyboardButtonTypeWebApp struct {
	meta
	// An HTTP URL to pass to getWebAppUrl
	Url string `json:"url"`
}

func (entity *KeyboardButtonTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeWebApp) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeWebApp) GetType() string {
	return TypeKeyboardButtonTypeWebApp
}

func (*KeyboardButtonTypeWebApp) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeWebApp
}

// Represents a single button in a bot keyboard
type KeyboardButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// Type of the button
	Type KeyboardButtonType `json:"type"`
}

func (entity *KeyboardButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButton

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButton) GetClass() string {
	return ClassKeyboardButton
}

func (*KeyboardButton) GetType() string {
	return TypeKeyboardButton
}

func (keyboardButton *KeyboardButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	keyboardButton.Text = tmp.Text

	fieldType, _ := UnmarshalKeyboardButtonType(tmp.Type)
	keyboardButton.Type = fieldType

	return nil
}

// A button that opens a specified URL
type InlineKeyboardButtonTypeUrl struct {
	meta
	// HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button
	Url string `json:"url"`
}

func (entity *InlineKeyboardButtonTypeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeUrl

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeUrl) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeUrl) GetType() string {
	return TypeInlineKeyboardButtonTypeUrl
}

func (*InlineKeyboardButtonTypeUrl) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeUrl
}

// A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo
type InlineKeyboardButtonTypeLoginUrl struct {
	meta
	// An HTTP URL to pass to getLoginUrlInfo
	Url string `json:"url"`
	// Unique button identifier
	Id int64 `json:"id"`
	// If non-empty, new text of the button in forwarded messages
	ForwardText string `json:"forward_text"`
}

func (entity *InlineKeyboardButtonTypeLoginUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeLoginUrl

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeLoginUrl) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeLoginUrl) GetType() string {
	return TypeInlineKeyboardButtonTypeLoginUrl
}

func (*InlineKeyboardButtonTypeLoginUrl) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeLoginUrl
}

// A button that opens a Web App by calling openWebApp
type InlineKeyboardButtonTypeWebApp struct {
	meta
	// An HTTP URL to pass to openWebApp
	Url string `json:"url"`
}

func (entity *InlineKeyboardButtonTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeWebApp) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeWebApp) GetType() string {
	return TypeInlineKeyboardButtonTypeWebApp
}

func (*InlineKeyboardButtonTypeWebApp) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeWebApp
}

// A button that sends a callback query to a bot
type InlineKeyboardButtonTypeCallback struct {
	meta
	// Data to be sent to the bot via a callback query
	Data []byte `json:"data"`
}

func (entity *InlineKeyboardButtonTypeCallback) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallback

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallback) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallback) GetType() string {
	return TypeInlineKeyboardButtonTypeCallback
}

func (*InlineKeyboardButtonTypeCallback) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallback
}

// A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot
type InlineKeyboardButtonTypeCallbackWithPassword struct {
	meta
	// Data to be sent to the bot via a callback query
	Data []byte `json:"data"`
}

func (entity *InlineKeyboardButtonTypeCallbackWithPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallbackWithPassword

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallbackWithPassword) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallbackWithPassword) GetType() string {
	return TypeInlineKeyboardButtonTypeCallbackWithPassword
}

func (*InlineKeyboardButtonTypeCallbackWithPassword) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallbackWithPassword
}

// A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
type InlineKeyboardButtonTypeCallbackGame struct {
	meta
}

func (entity *InlineKeyboardButtonTypeCallbackGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallbackGame

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallbackGame) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallbackGame) GetType() string {
	return TypeInlineKeyboardButtonTypeCallbackGame
}

func (*InlineKeyboardButtonTypeCallbackGame) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallbackGame
}

// A button that forces an inline query to the bot to be inserted in the input field
type InlineKeyboardButtonTypeSwitchInline struct {
	meta
	// Inline query to be sent to the bot
	Query string `json:"query"`
	// Target chat from which to send the inline query
	TargetChat TargetChat `json:"target_chat"`
}

func (entity *InlineKeyboardButtonTypeSwitchInline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeSwitchInline

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeSwitchInline) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeSwitchInline) GetType() string {
	return TypeInlineKeyboardButtonTypeSwitchInline
}

func (*InlineKeyboardButtonTypeSwitchInline) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeSwitchInline
}

func (inlineKeyboardButtonTypeSwitchInline *InlineKeyboardButtonTypeSwitchInline) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Query      string          `json:"query"`
		TargetChat json.RawMessage `json:"target_chat"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeSwitchInline.Query = tmp.Query

	fieldTargetChat, _ := UnmarshalTargetChat(tmp.TargetChat)
	inlineKeyboardButtonTypeSwitchInline.TargetChat = fieldTargetChat

	return nil
}

// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
type InlineKeyboardButtonTypeBuy struct {
	meta
}

func (entity *InlineKeyboardButtonTypeBuy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeBuy

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeBuy) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeBuy) GetType() string {
	return TypeInlineKeyboardButtonTypeBuy
}

func (*InlineKeyboardButtonTypeBuy) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeBuy
}

// A button with a user reference to be handled in the same way as textEntityTypeMentionName entities
type InlineKeyboardButtonTypeUser struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
}

func (entity *InlineKeyboardButtonTypeUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeUser

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeUser) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeUser) GetType() string {
	return TypeInlineKeyboardButtonTypeUser
}

func (*InlineKeyboardButtonTypeUser) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeUser
}

// A button that copies specified text to clipboard
type InlineKeyboardButtonTypeCopyText struct {
	meta
	// The text to copy to clipboard
	Text string `json:"text"`
}

func (entity *InlineKeyboardButtonTypeCopyText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCopyText

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCopyText) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCopyText) GetType() string {
	return TypeInlineKeyboardButtonTypeCopyText
}

func (*InlineKeyboardButtonTypeCopyText) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCopyText
}

// Represents a single button in an inline keyboard
type InlineKeyboardButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// Type of the button
	Type InlineKeyboardButtonType `json:"type"`
}

func (entity *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButton

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButton) GetClass() string {
	return ClassInlineKeyboardButton
}

func (*InlineKeyboardButton) GetType() string {
	return TypeInlineKeyboardButton
}

func (inlineKeyboardButton *InlineKeyboardButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineKeyboardButton.Text = tmp.Text

	fieldType, _ := UnmarshalInlineKeyboardButtonType(tmp.Type)
	inlineKeyboardButton.Type = fieldType

	return nil
}

// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent
type ReplyMarkupRemoveKeyboard struct {
	meta
	// True, if the keyboard is removed only for the mentioned users or the target user of a reply
	IsPersonal bool `json:"is_personal"`
}

func (entity *ReplyMarkupRemoveKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupRemoveKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupRemoveKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupRemoveKeyboard) GetType() string {
	return TypeReplyMarkupRemoveKeyboard
}

func (*ReplyMarkupRemoveKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupRemoveKeyboard
}

// Instructs application to force a reply to this message
type ReplyMarkupForceReply struct {
	meta
	// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
	IsPersonal bool `json:"is_personal"`
	// If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
	InputFieldPlaceholder string `json:"input_field_placeholder"`
}

func (entity *ReplyMarkupForceReply) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupForceReply

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupForceReply) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupForceReply) GetType() string {
	return TypeReplyMarkupForceReply
}

func (*ReplyMarkupForceReply) ReplyMarkupType() string {
	return TypeReplyMarkupForceReply
}

// Contains a custom keyboard layout to quickly reply to bots
type ReplyMarkupShowKeyboard struct {
	meta
	// A list of rows of bot keyboard buttons
	Rows [][]*KeyboardButton `json:"rows"`
	// True, if the keyboard is expected to always be shown when the ordinary keyboard is hidden
	IsPersistent bool `json:"is_persistent"`
	// True, if the application needs to resize the keyboard vertically
	ResizeKeyboard bool `json:"resize_keyboard"`
	// True, if the application needs to hide the keyboard after use
	OneTime bool `json:"one_time"`
	// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
	IsPersonal bool `json:"is_personal"`
	// If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
	InputFieldPlaceholder string `json:"input_field_placeholder"`
}

func (entity *ReplyMarkupShowKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupShowKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupShowKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupShowKeyboard) GetType() string {
	return TypeReplyMarkupShowKeyboard
}

func (*ReplyMarkupShowKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupShowKeyboard
}

// Contains an inline keyboard layout
type ReplyMarkupInlineKeyboard struct {
	meta
	// A list of rows of inline keyboard buttons
	Rows [][]*InlineKeyboardButton `json:"rows"`
}

func (entity *ReplyMarkupInlineKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupInlineKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupInlineKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupInlineKeyboard) GetType() string {
	return TypeReplyMarkupInlineKeyboard
}

func (*ReplyMarkupInlineKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupInlineKeyboard
}

// An HTTP URL needs to be open
type LoginUrlInfoOpen struct {
	meta
	// The URL to open
	Url string `json:"url"`
	// True, if there is no need to show an ordinary open URL confirmation
	SkipConfirmation bool `json:"skip_confirmation"`
}

func (entity *LoginUrlInfoOpen) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LoginUrlInfoOpen

	return json.Marshal((*stub)(entity))
}

func (*LoginUrlInfoOpen) GetClass() string {
	return ClassLoginUrlInfo
}

func (*LoginUrlInfoOpen) GetType() string {
	return TypeLoginUrlInfoOpen
}

func (*LoginUrlInfoOpen) LoginUrlInfoType() string {
	return TypeLoginUrlInfoOpen
}

// An authorization confirmation dialog needs to be shown to the user
type LoginUrlInfoRequestConfirmation struct {
	meta
	// An HTTP URL to be opened
	Url string `json:"url"`
	// A domain of the URL
	Domain string `json:"domain"`
	// User identifier of a bot linked with the website
	BotUserId int64 `json:"bot_user_id"`
	// True, if the user must be asked for the permission to the bot to send them messages
	RequestWriteAccess bool `json:"request_write_access"`
}

func (entity *LoginUrlInfoRequestConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LoginUrlInfoRequestConfirmation

	return json.Marshal((*stub)(entity))
}

func (*LoginUrlInfoRequestConfirmation) GetClass() string {
	return ClassLoginUrlInfo
}

func (*LoginUrlInfoRequestConfirmation) GetType() string {
	return TypeLoginUrlInfoRequestConfirmation
}

func (*LoginUrlInfoRequestConfirmation) LoginUrlInfoType() string {
	return TypeLoginUrlInfoRequestConfirmation
}

// Contains parameters of the application theme
type ThemeParameters struct {
	meta
	// A color of the background in the RGB format
	BackgroundColor int32 `json:"background_color"`
	// A secondary color for the background in the RGB format
	SecondaryBackgroundColor int32 `json:"secondary_background_color"`
	// A color of the header background in the RGB format
	HeaderBackgroundColor int32 `json:"header_background_color"`
	// A color of the bottom bar background in the RGB format
	BottomBarBackgroundColor int32 `json:"bottom_bar_background_color"`
	// A color of the section background in the RGB format
	SectionBackgroundColor int32 `json:"section_background_color"`
	// A color of the section separator in the RGB format
	SectionSeparatorColor int32 `json:"section_separator_color"`
	// A color of text in the RGB format
	TextColor int32 `json:"text_color"`
	// An accent color of the text in the RGB format
	AccentTextColor int32 `json:"accent_text_color"`
	// A color of text on the section headers in the RGB format
	SectionHeaderTextColor int32 `json:"section_header_text_color"`
	// A color of the subtitle text in the RGB format
	SubtitleTextColor int32 `json:"subtitle_text_color"`
	// A color of the text for destructive actions in the RGB format
	DestructiveTextColor int32 `json:"destructive_text_color"`
	// A color of hints in the RGB format
	HintColor int32 `json:"hint_color"`
	// A color of links in the RGB format
	LinkColor int32 `json:"link_color"`
	// A color of the buttons in the RGB format
	ButtonColor int32 `json:"button_color"`
	// A color of text on the buttons in the RGB format
	ButtonTextColor int32 `json:"button_text_color"`
}

func (entity *ThemeParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThemeParameters

	return json.Marshal((*stub)(entity))
}

func (*ThemeParameters) GetClass() string {
	return ClassThemeParameters
}

func (*ThemeParameters) GetType() string {
	return TypeThemeParameters
}

// The Web App is opened in the compact mode
type WebAppOpenModeCompact struct {
	meta
}

func (entity *WebAppOpenModeCompact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebAppOpenModeCompact

	return json.Marshal((*stub)(entity))
}

func (*WebAppOpenModeCompact) GetClass() string {
	return ClassWebAppOpenMode
}

func (*WebAppOpenModeCompact) GetType() string {
	return TypeWebAppOpenModeCompact
}

func (*WebAppOpenModeCompact) WebAppOpenModeType() string {
	return TypeWebAppOpenModeCompact
}

// The Web App is opened in the full-size mode
type WebAppOpenModeFullSize struct {
	meta
}

func (entity *WebAppOpenModeFullSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebAppOpenModeFullSize

	return json.Marshal((*stub)(entity))
}

func (*WebAppOpenModeFullSize) GetClass() string {
	return ClassWebAppOpenMode
}

func (*WebAppOpenModeFullSize) GetType() string {
	return TypeWebAppOpenModeFullSize
}

func (*WebAppOpenModeFullSize) WebAppOpenModeType() string {
	return TypeWebAppOpenModeFullSize
}

// The Web App is opened in the full-screen mode
type WebAppOpenModeFullScreen struct {
	meta
}

func (entity *WebAppOpenModeFullScreen) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebAppOpenModeFullScreen

	return json.Marshal((*stub)(entity))
}

func (*WebAppOpenModeFullScreen) GetClass() string {
	return ClassWebAppOpenMode
}

func (*WebAppOpenModeFullScreen) GetType() string {
	return TypeWebAppOpenModeFullScreen
}

func (*WebAppOpenModeFullScreen) WebAppOpenModeType() string {
	return TypeWebAppOpenModeFullScreen
}

// Contains information about a Web App found by its short name
type FoundWebApp struct {
	meta
	// The Web App
	WebApp *WebApp `json:"web_app"`
	// True, if the user must be asked for the permission to the bot to send them messages
	RequestWriteAccess bool `json:"request_write_access"`
	// True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
	SkipConfirmation bool `json:"skip_confirmation"`
}

func (entity *FoundWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundWebApp

	return json.Marshal((*stub)(entity))
}

func (*FoundWebApp) GetClass() string {
	return ClassFoundWebApp
}

func (*FoundWebApp) GetType() string {
	return TypeFoundWebApp
}

// Contains information about a Web App
type WebAppInfo struct {
	meta
	// Unique identifier for the Web App launch
	LaunchId JsonInt64 `json:"launch_id"`
	// A Web App URL to open in a web view
	Url string `json:"url"`
}

func (entity *WebAppInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebAppInfo

	return json.Marshal((*stub)(entity))
}

func (*WebAppInfo) GetClass() string {
	return ClassWebAppInfo
}

func (*WebAppInfo) GetType() string {
	return TypeWebAppInfo
}

// Contains information about the main Web App of a bot
type MainWebApp struct {
	meta
	// URL of the Web App to open
	Url string `json:"url"`
	// The mode in which the Web App must be opened
	Mode WebAppOpenMode `json:"mode"`
}

func (entity *MainWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MainWebApp

	return json.Marshal((*stub)(entity))
}

func (*MainWebApp) GetClass() string {
	return ClassMainWebApp
}

func (*MainWebApp) GetType() string {
	return TypeMainWebApp
}

func (mainWebApp *MainWebApp) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url  string          `json:"url"`
		Mode json.RawMessage `json:"mode"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	mainWebApp.Url = tmp.Url

	fieldMode, _ := UnmarshalWebAppOpenMode(tmp.Mode)
	mainWebApp.Mode = fieldMode

	return nil
}

// Options to be used when a Web App is opened
type WebAppOpenParameters struct {
	meta
	// Preferred Web App theme; pass null to use the default theme
	Theme *ThemeParameters `json:"theme"`
	// Short name of the current application; 0-64 English letters, digits, and underscores
	ApplicationName string `json:"application_name"`
	// The mode in which the Web App is opened; pass null to open in webAppOpenModeFullSize
	Mode WebAppOpenMode `json:"mode"`
}

func (entity *WebAppOpenParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebAppOpenParameters

	return json.Marshal((*stub)(entity))
}

func (*WebAppOpenParameters) GetClass() string {
	return ClassWebAppOpenParameters
}

func (*WebAppOpenParameters) GetType() string {
	return TypeWebAppOpenParameters
}

func (webAppOpenParameters *WebAppOpenParameters) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Theme           *ThemeParameters `json:"theme"`
		ApplicationName string           `json:"application_name"`
		Mode            json.RawMessage  `json:"mode"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	webAppOpenParameters.Theme = tmp.Theme
	webAppOpenParameters.ApplicationName = tmp.ApplicationName

	fieldMode, _ := UnmarshalWebAppOpenMode(tmp.Mode)
	webAppOpenParameters.Mode = fieldMode

	return nil
}

// Contains information about a message thread
type MessageThreadInfo struct {
	meta
	// Identifier of the chat to which the message thread belongs
	ChatId int64 `json:"chat_id"`
	// Message thread identifier, unique within the chat
	MessageThreadId int64 `json:"message_thread_id"`
	// Information about the message thread; may be null for forum topic threads
	ReplyInfo *MessageReplyInfo `json:"reply_info"`
	// Approximate number of unread messages in the message thread
	UnreadMessageCount int32 `json:"unread_message_count"`
	// The messages from which the thread starts. The messages are returned in reverse chronological order (i.e., in order of decreasing message_id)
	Messages []*Message `json:"messages"`
	// A draft of a message in the message thread; may be null if none
	DraftMessage *DraftMessage `json:"draft_message"`
}

func (entity *MessageThreadInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageThreadInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageThreadInfo) GetClass() string {
	return ClassMessageThreadInfo
}

func (*MessageThreadInfo) GetType() string {
	return TypeMessageThreadInfo
}

// Topic containing messages sent by the current user of forwarded from an unknown chat
type SavedMessagesTopicTypeMyNotes struct {
	meta
}

func (entity *SavedMessagesTopicTypeMyNotes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedMessagesTopicTypeMyNotes

	return json.Marshal((*stub)(entity))
}

func (*SavedMessagesTopicTypeMyNotes) GetClass() string {
	return ClassSavedMessagesTopicType
}

func (*SavedMessagesTopicTypeMyNotes) GetType() string {
	return TypeSavedMessagesTopicTypeMyNotes
}

func (*SavedMessagesTopicTypeMyNotes) SavedMessagesTopicTypeType() string {
	return TypeSavedMessagesTopicTypeMyNotes
}

// Topic containing messages forwarded from a user with hidden privacy
type SavedMessagesTopicTypeAuthorHidden struct {
	meta
}

func (entity *SavedMessagesTopicTypeAuthorHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedMessagesTopicTypeAuthorHidden

	return json.Marshal((*stub)(entity))
}

func (*SavedMessagesTopicTypeAuthorHidden) GetClass() string {
	return ClassSavedMessagesTopicType
}

func (*SavedMessagesTopicTypeAuthorHidden) GetType() string {
	return TypeSavedMessagesTopicTypeAuthorHidden
}

func (*SavedMessagesTopicTypeAuthorHidden) SavedMessagesTopicTypeType() string {
	return TypeSavedMessagesTopicTypeAuthorHidden
}

// Topic containing messages forwarded from a specific chat
type SavedMessagesTopicTypeSavedFromChat struct {
	meta
	// Identifier of the chat
	ChatId int64 `json:"chat_id"`
}

func (entity *SavedMessagesTopicTypeSavedFromChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedMessagesTopicTypeSavedFromChat

	return json.Marshal((*stub)(entity))
}

func (*SavedMessagesTopicTypeSavedFromChat) GetClass() string {
	return ClassSavedMessagesTopicType
}

func (*SavedMessagesTopicTypeSavedFromChat) GetType() string {
	return TypeSavedMessagesTopicTypeSavedFromChat
}

func (*SavedMessagesTopicTypeSavedFromChat) SavedMessagesTopicTypeType() string {
	return TypeSavedMessagesTopicTypeSavedFromChat
}

// Contains information about a Saved Messages topic
type SavedMessagesTopic struct {
	meta
	// Unique topic identifier
	Id int64 `json:"id"`
	// Type of the topic
	Type SavedMessagesTopicType `json:"type"`
	// True, if the topic is pinned
	IsPinned bool `json:"is_pinned"`
	// A parameter used to determine order of the topic in the topic list. Topics must be sorted by the order in descending order
	Order JsonInt64 `json:"order"`
	// Last message in the topic; may be null if none or unknown
	LastMessage *Message `json:"last_message"`
	// A draft of a message in the topic; may be null if none
	DraftMessage *DraftMessage `json:"draft_message"`
}

func (entity *SavedMessagesTopic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedMessagesTopic

	return json.Marshal((*stub)(entity))
}

func (*SavedMessagesTopic) GetClass() string {
	return ClassSavedMessagesTopic
}

func (*SavedMessagesTopic) GetType() string {
	return TypeSavedMessagesTopic
}

func (savedMessagesTopic *SavedMessagesTopic) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           int64           `json:"id"`
		Type         json.RawMessage `json:"type"`
		IsPinned     bool            `json:"is_pinned"`
		Order        JsonInt64       `json:"order"`
		LastMessage  *Message        `json:"last_message"`
		DraftMessage *DraftMessage   `json:"draft_message"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	savedMessagesTopic.Id = tmp.Id
	savedMessagesTopic.IsPinned = tmp.IsPinned
	savedMessagesTopic.Order = tmp.Order
	savedMessagesTopic.LastMessage = tmp.LastMessage
	savedMessagesTopic.DraftMessage = tmp.DraftMessage

	fieldType, _ := UnmarshalSavedMessagesTopicType(tmp.Type)
	savedMessagesTopic.Type = fieldType

	return nil
}

// Describes a forum topic icon
type ForumTopicIcon struct {
	meta
	// Color of the topic icon in RGB format
	Color int32 `json:"color"`
	// Unique identifier of the custom emoji shown on the topic icon; 0 if none
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *ForumTopicIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopicIcon

	return json.Marshal((*stub)(entity))
}

func (*ForumTopicIcon) GetClass() string {
	return ClassForumTopicIcon
}

func (*ForumTopicIcon) GetType() string {
	return TypeForumTopicIcon
}

// Contains basic information about a forum topic
type ForumTopicInfo struct {
	meta
	// Message thread identifier of the topic
	MessageThreadId int64 `json:"message_thread_id"`
	// Name of the topic
	Name string `json:"name"`
	// Icon of the topic
	Icon *ForumTopicIcon `json:"icon"`
	// Point in time (Unix timestamp) when the topic was created
	CreationDate int32 `json:"creation_date"`
	// Identifier of the creator of the topic
	CreatorId MessageSender `json:"creator_id"`
	// True, if the topic is the General topic list
	IsGeneral bool `json:"is_general"`
	// True, if the topic was created by the current user
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the topic is closed
	IsClosed bool `json:"is_closed"`
	// True, if the topic is hidden above the topic list and closed; for General topic only
	IsHidden bool `json:"is_hidden"`
}

func (entity *ForumTopicInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopicInfo

	return json.Marshal((*stub)(entity))
}

func (*ForumTopicInfo) GetClass() string {
	return ClassForumTopicInfo
}

func (*ForumTopicInfo) GetType() string {
	return TypeForumTopicInfo
}

func (forumTopicInfo *ForumTopicInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageThreadId int64           `json:"message_thread_id"`
		Name            string          `json:"name"`
		Icon            *ForumTopicIcon `json:"icon"`
		CreationDate    int32           `json:"creation_date"`
		CreatorId       json.RawMessage `json:"creator_id"`
		IsGeneral       bool            `json:"is_general"`
		IsOutgoing      bool            `json:"is_outgoing"`
		IsClosed        bool            `json:"is_closed"`
		IsHidden        bool            `json:"is_hidden"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	forumTopicInfo.MessageThreadId = tmp.MessageThreadId
	forumTopicInfo.Name = tmp.Name
	forumTopicInfo.Icon = tmp.Icon
	forumTopicInfo.CreationDate = tmp.CreationDate
	forumTopicInfo.IsGeneral = tmp.IsGeneral
	forumTopicInfo.IsOutgoing = tmp.IsOutgoing
	forumTopicInfo.IsClosed = tmp.IsClosed
	forumTopicInfo.IsHidden = tmp.IsHidden

	fieldCreatorId, _ := UnmarshalMessageSender(tmp.CreatorId)
	forumTopicInfo.CreatorId = fieldCreatorId

	return nil
}

// Describes a forum topic
type ForumTopic struct {
	meta
	// Basic information about the topic
	Info *ForumTopicInfo `json:"info"`
	// Last message in the topic; may be null if unknown
	LastMessage *Message `json:"last_message"`
	// True, if the topic is pinned in the topic list
	IsPinned bool `json:"is_pinned"`
	// Number of unread messages in the topic
	UnreadCount int32 `json:"unread_count"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Number of unread messages with a mention/reply in the topic
	UnreadMentionCount int32 `json:"unread_mention_count"`
	// Number of messages with unread reactions in the topic
	UnreadReactionCount int32 `json:"unread_reaction_count"`
	// Notification settings for the topic
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
	// A draft of a message in the topic; may be null if none
	DraftMessage *DraftMessage `json:"draft_message"`
}

func (entity *ForumTopic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopic

	return json.Marshal((*stub)(entity))
}

func (*ForumTopic) GetClass() string {
	return ClassForumTopic
}

func (*ForumTopic) GetType() string {
	return TypeForumTopic
}

// Describes a list of forum topics
type ForumTopics struct {
	meta
	// Approximate total number of forum topics found
	TotalCount int32 `json:"total_count"`
	// List of forum topics
	Topics []*ForumTopic `json:"topics"`
	// Offset date for the next getForumTopics request
	NextOffsetDate int32 `json:"next_offset_date"`
	// Offset message identifier for the next getForumTopics request
	NextOffsetMessageId int64 `json:"next_offset_message_id"`
	// Offset message thread identifier for the next getForumTopics request
	NextOffsetMessageThreadId int64 `json:"next_offset_message_thread_id"`
}

func (entity *ForumTopics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ForumTopics

	return json.Marshal((*stub)(entity))
}

func (*ForumTopics) GetClass() string {
	return ClassForumTopics
}

func (*ForumTopics) GetType() string {
	return TypeForumTopics
}

// Options to be used for generation of a link preview
type LinkPreviewOptions struct {
	meta
	// True, if link preview must be disabled
	IsDisabled bool `json:"is_disabled"`
	// URL to use for link preview. If empty, then the first URL found in the message text will be used
	Url string `json:"url"`
	// True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
	ForceSmallMedia bool `json:"force_small_media"`
	// True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
	ForceLargeMedia bool `json:"force_large_media"`
	// True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
	ShowAboveText bool `json:"show_above_text"`
}

func (entity *LinkPreviewOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewOptions

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewOptions) GetClass() string {
	return ClassLinkPreviewOptions
}

func (*LinkPreviewOptions) GetType() string {
	return TypeLinkPreviewOptions
}

// Contains information about a user shared with a bot
type SharedUser struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// First name of the user; for bots only
	FirstName string `json:"first_name"`
	// Last name of the user; for bots only
	LastName string `json:"last_name"`
	// Username of the user; for bots only
	Username string `json:"username"`
	// Profile photo of the user; for bots only; may be null
	Photo *Photo `json:"photo"`
}

func (entity *SharedUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SharedUser

	return json.Marshal((*stub)(entity))
}

func (*SharedUser) GetClass() string {
	return ClassSharedUser
}

func (*SharedUser) GetType() string {
	return TypeSharedUser
}

// Contains information about a chat shared with a bot
type SharedChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Title of the chat; for bots only
	Title string `json:"title"`
	// Username of the chat; for bots only
	Username string `json:"username"`
	// Photo of the chat; for bots only; may be null
	Photo *Photo `json:"photo"`
}

func (entity *SharedChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SharedChat

	return json.Marshal((*stub)(entity))
}

func (*SharedChat) GetClass() string {
	return ClassSharedChat
}

func (*SharedChat) GetType() string {
	return TypeSharedChat
}

// Describes theme settings
type ThemeSettings struct {
	meta
	// Theme accent color in ARGB format
	AccentColor int32 `json:"accent_color"`
	// The background to be used in chats; may be null
	Background *Background `json:"background"`
	// The fill to be used as a background for outgoing messages
	OutgoingMessageFill BackgroundFill `json:"outgoing_message_fill"`
	// If true, the freeform gradient fill needs to be animated on every sent message
	AnimateOutgoingMessageFill bool `json:"animate_outgoing_message_fill"`
	// Accent color of outgoing messages in ARGB format
	OutgoingMessageAccentColor int32 `json:"outgoing_message_accent_color"`
}

func (entity *ThemeSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ThemeSettings

	return json.Marshal((*stub)(entity))
}

func (*ThemeSettings) GetClass() string {
	return ClassThemeSettings
}

func (*ThemeSettings) GetType() string {
	return TypeThemeSettings
}

func (themeSettings *ThemeSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AccentColor                int32           `json:"accent_color"`
		Background                 *Background     `json:"background"`
		OutgoingMessageFill        json.RawMessage `json:"outgoing_message_fill"`
		AnimateOutgoingMessageFill bool            `json:"animate_outgoing_message_fill"`
		OutgoingMessageAccentColor int32           `json:"outgoing_message_accent_color"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	themeSettings.AccentColor = tmp.AccentColor
	themeSettings.Background = tmp.Background
	themeSettings.AnimateOutgoingMessageFill = tmp.AnimateOutgoingMessageFill
	themeSettings.OutgoingMessageAccentColor = tmp.OutgoingMessageAccentColor

	fieldOutgoingMessageFill, _ := UnmarshalBackgroundFill(tmp.OutgoingMessageFill)
	themeSettings.OutgoingMessageFill = fieldOutgoingMessageFill

	return nil
}

// A plain text
type RichTextPlain struct {
	meta
	// Text
	Text string `json:"text"`
}

func (entity *RichTextPlain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextPlain

	return json.Marshal((*stub)(entity))
}

func (*RichTextPlain) GetClass() string {
	return ClassRichText
}

func (*RichTextPlain) GetType() string {
	return TypeRichTextPlain
}

func (*RichTextPlain) RichTextType() string {
	return TypeRichTextPlain
}

// A bold rich text
type RichTextBold struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextBold) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextBold

	return json.Marshal((*stub)(entity))
}

func (*RichTextBold) GetClass() string {
	return ClassRichText
}

func (*RichTextBold) GetType() string {
	return TypeRichTextBold
}

func (*RichTextBold) RichTextType() string {
	return TypeRichTextBold
}

func (richTextBold *RichTextBold) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextBold.Text = fieldText

	return nil
}

// An italicized rich text
type RichTextItalic struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextItalic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextItalic

	return json.Marshal((*stub)(entity))
}

func (*RichTextItalic) GetClass() string {
	return ClassRichText
}

func (*RichTextItalic) GetType() string {
	return TypeRichTextItalic
}

func (*RichTextItalic) RichTextType() string {
	return TypeRichTextItalic
}

func (richTextItalic *RichTextItalic) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextItalic.Text = fieldText

	return nil
}

// An underlined rich text
type RichTextUnderline struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextUnderline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextUnderline

	return json.Marshal((*stub)(entity))
}

func (*RichTextUnderline) GetClass() string {
	return ClassRichText
}

func (*RichTextUnderline) GetType() string {
	return TypeRichTextUnderline
}

func (*RichTextUnderline) RichTextType() string {
	return TypeRichTextUnderline
}

func (richTextUnderline *RichTextUnderline) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextUnderline.Text = fieldText

	return nil
}

// A strikethrough rich text
type RichTextStrikethrough struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextStrikethrough) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextStrikethrough

	return json.Marshal((*stub)(entity))
}

func (*RichTextStrikethrough) GetClass() string {
	return ClassRichText
}

func (*RichTextStrikethrough) GetType() string {
	return TypeRichTextStrikethrough
}

func (*RichTextStrikethrough) RichTextType() string {
	return TypeRichTextStrikethrough
}

func (richTextStrikethrough *RichTextStrikethrough) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextStrikethrough.Text = fieldText

	return nil
}

// A fixed-width rich text
type RichTextFixed struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextFixed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextFixed

	return json.Marshal((*stub)(entity))
}

func (*RichTextFixed) GetClass() string {
	return ClassRichText
}

func (*RichTextFixed) GetType() string {
	return TypeRichTextFixed
}

func (*RichTextFixed) RichTextType() string {
	return TypeRichTextFixed
}

func (richTextFixed *RichTextFixed) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextFixed.Text = fieldText

	return nil
}

// A rich text URL link
type RichTextUrl struct {
	meta
	// Text
	Text RichText `json:"text"`
	// URL
	Url string `json:"url"`
	// True, if the URL has cached instant view server-side
	IsCached bool `json:"is_cached"`
}

func (entity *RichTextUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextUrl

	return json.Marshal((*stub)(entity))
}

func (*RichTextUrl) GetClass() string {
	return ClassRichText
}

func (*RichTextUrl) GetType() string {
	return TypeRichTextUrl
}

func (*RichTextUrl) RichTextType() string {
	return TypeRichTextUrl
}

func (richTextUrl *RichTextUrl) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		Url      string          `json:"url"`
		IsCached bool            `json:"is_cached"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextUrl.Url = tmp.Url
	richTextUrl.IsCached = tmp.IsCached

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextUrl.Text = fieldText

	return nil
}

// A rich text email link
type RichTextEmailAddress struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Email address
	EmailAddress string `json:"email_address"`
}

func (entity *RichTextEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*RichTextEmailAddress) GetClass() string {
	return ClassRichText
}

func (*RichTextEmailAddress) GetType() string {
	return TypeRichTextEmailAddress
}

func (*RichTextEmailAddress) RichTextType() string {
	return TypeRichTextEmailAddress
}

func (richTextEmailAddress *RichTextEmailAddress) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text         json.RawMessage `json:"text"`
		EmailAddress string          `json:"email_address"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextEmailAddress.EmailAddress = tmp.EmailAddress

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextEmailAddress.Text = fieldText

	return nil
}

// A subscript rich text
type RichTextSubscript struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextSubscript) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextSubscript

	return json.Marshal((*stub)(entity))
}

func (*RichTextSubscript) GetClass() string {
	return ClassRichText
}

func (*RichTextSubscript) GetType() string {
	return TypeRichTextSubscript
}

func (*RichTextSubscript) RichTextType() string {
	return TypeRichTextSubscript
}

func (richTextSubscript *RichTextSubscript) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextSubscript.Text = fieldText

	return nil
}

// A superscript rich text
type RichTextSuperscript struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextSuperscript) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextSuperscript

	return json.Marshal((*stub)(entity))
}

func (*RichTextSuperscript) GetClass() string {
	return ClassRichText
}

func (*RichTextSuperscript) GetType() string {
	return TypeRichTextSuperscript
}

func (*RichTextSuperscript) RichTextType() string {
	return TypeRichTextSuperscript
}

func (richTextSuperscript *RichTextSuperscript) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextSuperscript.Text = fieldText

	return nil
}

// A marked rich text
type RichTextMarked struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextMarked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextMarked

	return json.Marshal((*stub)(entity))
}

func (*RichTextMarked) GetClass() string {
	return ClassRichText
}

func (*RichTextMarked) GetType() string {
	return TypeRichTextMarked
}

func (*RichTextMarked) RichTextType() string {
	return TypeRichTextMarked
}

func (richTextMarked *RichTextMarked) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextMarked.Text = fieldText

	return nil
}

// A rich text phone number
type RichTextPhoneNumber struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *RichTextPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*RichTextPhoneNumber) GetClass() string {
	return ClassRichText
}

func (*RichTextPhoneNumber) GetType() string {
	return TypeRichTextPhoneNumber
}

func (*RichTextPhoneNumber) RichTextType() string {
	return TypeRichTextPhoneNumber
}

func (richTextPhoneNumber *RichTextPhoneNumber) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text        json.RawMessage `json:"text"`
		PhoneNumber string          `json:"phone_number"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextPhoneNumber.PhoneNumber = tmp.PhoneNumber

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextPhoneNumber.Text = fieldText

	return nil
}

// A small image inside the text
type RichTextIcon struct {
	meta
	// The image represented as a document. The image can be in GIF, JPEG or PNG format
	Document *Document `json:"document"`
	// Width of a bounding box in which the image must be shown; 0 if unknown
	Width int32 `json:"width"`
	// Height of a bounding box in which the image must be shown; 0 if unknown
	Height int32 `json:"height"`
}

func (entity *RichTextIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextIcon

	return json.Marshal((*stub)(entity))
}

func (*RichTextIcon) GetClass() string {
	return ClassRichText
}

func (*RichTextIcon) GetType() string {
	return TypeRichTextIcon
}

func (*RichTextIcon) RichTextType() string {
	return TypeRichTextIcon
}

// A reference to a richTexts object on the same page
type RichTextReference struct {
	meta
	// The text
	Text RichText `json:"text"`
	// The name of a richTextAnchor object, which is the first element of the target richTexts object
	AnchorName string `json:"anchor_name"`
	// An HTTP URL, opening the reference
	Url string `json:"url"`
}

func (entity *RichTextReference) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextReference

	return json.Marshal((*stub)(entity))
}

func (*RichTextReference) GetClass() string {
	return ClassRichText
}

func (*RichTextReference) GetType() string {
	return TypeRichTextReference
}

func (*RichTextReference) RichTextType() string {
	return TypeRichTextReference
}

func (richTextReference *RichTextReference) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text       json.RawMessage `json:"text"`
		AnchorName string          `json:"anchor_name"`
		Url        string          `json:"url"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextReference.AnchorName = tmp.AnchorName
	richTextReference.Url = tmp.Url

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextReference.Text = fieldText

	return nil
}

// An anchor
type RichTextAnchor struct {
	meta
	// Anchor name
	Name string `json:"name"`
}

func (entity *RichTextAnchor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextAnchor

	return json.Marshal((*stub)(entity))
}

func (*RichTextAnchor) GetClass() string {
	return ClassRichText
}

func (*RichTextAnchor) GetType() string {
	return TypeRichTextAnchor
}

func (*RichTextAnchor) RichTextType() string {
	return TypeRichTextAnchor
}

// A link to an anchor on the same page
type RichTextAnchorLink struct {
	meta
	// The link text
	Text RichText `json:"text"`
	// The anchor name. If the name is empty, the link must bring back to top
	AnchorName string `json:"anchor_name"`
	// An HTTP URL, opening the anchor
	Url string `json:"url"`
}

func (entity *RichTextAnchorLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextAnchorLink

	return json.Marshal((*stub)(entity))
}

func (*RichTextAnchorLink) GetClass() string {
	return ClassRichText
}

func (*RichTextAnchorLink) GetType() string {
	return TypeRichTextAnchorLink
}

func (*RichTextAnchorLink) RichTextType() string {
	return TypeRichTextAnchorLink
}

func (richTextAnchorLink *RichTextAnchorLink) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text       json.RawMessage `json:"text"`
		AnchorName string          `json:"anchor_name"`
		Url        string          `json:"url"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextAnchorLink.AnchorName = tmp.AnchorName
	richTextAnchorLink.Url = tmp.Url

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextAnchorLink.Text = fieldText

	return nil
}

// A concatenation of rich texts
type RichTexts struct {
	meta
	// Texts
	Texts []RichText `json:"texts"`
}

func (entity *RichTexts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTexts

	return json.Marshal((*stub)(entity))
}

func (*RichTexts) GetClass() string {
	return ClassRichText
}

func (*RichTexts) GetType() string {
	return TypeRichTexts
}

func (*RichTexts) RichTextType() string {
	return TypeRichTexts
}

func (richTexts *RichTexts) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Texts []json.RawMessage `json:"texts"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTexts, _ := UnmarshalListOfRichText(tmp.Texts)
	richTexts.Texts = fieldTexts

	return nil
}

// Contains a caption of another block
type PageBlockCaption struct {
	meta
	// Content of the caption
	Text RichText `json:"text"`
	// Block credit (like HTML tag <cite>)
	Credit RichText `json:"credit"`
}

func (entity *PageBlockCaption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCaption

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCaption) GetClass() string {
	return ClassPageBlockCaption
}

func (*PageBlockCaption) GetType() string {
	return TypePageBlockCaption
}

func (pageBlockCaption *PageBlockCaption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockCaption.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockCaption.Credit = fieldCredit

	return nil
}

// Describes an item of a list page block
type PageBlockListItem struct {
	meta
	// Item label
	Label string `json:"label"`
	// Item blocks
	PageBlocks []PageBlock `json:"page_blocks"`
}

func (entity *PageBlockListItem) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockListItem

	return json.Marshal((*stub)(entity))
}

func (*PageBlockListItem) GetClass() string {
	return ClassPageBlockListItem
}

func (*PageBlockListItem) GetType() string {
	return TypePageBlockListItem
}

func (pageBlockListItem *PageBlockListItem) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Label      string            `json:"label"`
		PageBlocks []json.RawMessage `json:"page_blocks"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockListItem.Label = tmp.Label

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockListItem.PageBlocks = fieldPageBlocks

	return nil
}

// The content must be left-aligned
type PageBlockHorizontalAlignmentLeft struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentLeft

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentLeft) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentLeft) GetType() string {
	return TypePageBlockHorizontalAlignmentLeft
}

func (*PageBlockHorizontalAlignmentLeft) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentLeft
}

// The content must be center-aligned
type PageBlockHorizontalAlignmentCenter struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentCenter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentCenter

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentCenter) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentCenter) GetType() string {
	return TypePageBlockHorizontalAlignmentCenter
}

func (*PageBlockHorizontalAlignmentCenter) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentCenter
}

// The content must be right-aligned
type PageBlockHorizontalAlignmentRight struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentRight) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentRight

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentRight) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentRight) GetType() string {
	return TypePageBlockHorizontalAlignmentRight
}

func (*PageBlockHorizontalAlignmentRight) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentRight
}

// The content must be top-aligned
type PageBlockVerticalAlignmentTop struct {
	meta
}

func (entity *PageBlockVerticalAlignmentTop) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentTop

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentTop) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentTop) GetType() string {
	return TypePageBlockVerticalAlignmentTop
}

func (*PageBlockVerticalAlignmentTop) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentTop
}

// The content must be middle-aligned
type PageBlockVerticalAlignmentMiddle struct {
	meta
}

func (entity *PageBlockVerticalAlignmentMiddle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentMiddle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentMiddle) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentMiddle) GetType() string {
	return TypePageBlockVerticalAlignmentMiddle
}

func (*PageBlockVerticalAlignmentMiddle) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentMiddle
}

// The content must be bottom-aligned
type PageBlockVerticalAlignmentBottom struct {
	meta
}

func (entity *PageBlockVerticalAlignmentBottom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentBottom

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentBottom) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentBottom) GetType() string {
	return TypePageBlockVerticalAlignmentBottom
}

func (*PageBlockVerticalAlignmentBottom) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentBottom
}

// Represents a cell of a table
type PageBlockTableCell struct {
	meta
	// Cell text; may be null. If the text is null, then the cell must be invisible
	Text RichText `json:"text"`
	// True, if it is a header cell
	IsHeader bool `json:"is_header"`
	// The number of columns the cell spans
	Colspan int32 `json:"colspan"`
	// The number of rows the cell spans
	Rowspan int32 `json:"rowspan"`
	// Horizontal cell content alignment
	Align PageBlockHorizontalAlignment `json:"align"`
	// Vertical cell content alignment
	Valign PageBlockVerticalAlignment `json:"valign"`
}

func (entity *PageBlockTableCell) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTableCell

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTableCell) GetClass() string {
	return ClassPageBlockTableCell
}

func (*PageBlockTableCell) GetType() string {
	return TypePageBlockTableCell
}

func (pageBlockTableCell *PageBlockTableCell) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		IsHeader bool            `json:"is_header"`
		Colspan  int32           `json:"colspan"`
		Rowspan  int32           `json:"rowspan"`
		Align    json.RawMessage `json:"align"`
		Valign   json.RawMessage `json:"valign"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockTableCell.IsHeader = tmp.IsHeader
	pageBlockTableCell.Colspan = tmp.Colspan
	pageBlockTableCell.Rowspan = tmp.Rowspan

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockTableCell.Text = fieldText

	fieldAlign, _ := UnmarshalPageBlockHorizontalAlignment(tmp.Align)
	pageBlockTableCell.Align = fieldAlign

	fieldValign, _ := UnmarshalPageBlockVerticalAlignment(tmp.Valign)
	pageBlockTableCell.Valign = fieldValign

	return nil
}

// Contains information about a related article
type PageBlockRelatedArticle struct {
	meta
	// Related article URL
	Url string `json:"url"`
	// Article title; may be empty
	Title string `json:"title"`
	// Article description; may be empty
	Description string `json:"description"`
	// Article photo; may be null
	Photo *Photo `json:"photo"`
	// Article author; may be empty
	Author string `json:"author"`
	// Point in time (Unix timestamp) when the article was published; 0 if unknown
	PublishDate int32 `json:"publish_date"`
}

func (entity *PageBlockRelatedArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockRelatedArticle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockRelatedArticle) GetClass() string {
	return ClassPageBlockRelatedArticle
}

func (*PageBlockRelatedArticle) GetType() string {
	return TypePageBlockRelatedArticle
}

// The title of a page
type PageBlockTitle struct {
	meta
	// Title
	Title RichText `json:"title"`
}

func (entity *PageBlockTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTitle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTitle) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockTitle) GetType() string {
	return TypePageBlockTitle
}

func (*PageBlockTitle) PageBlockType() string {
	return TypePageBlockTitle
}

func (pageBlockTitle *PageBlockTitle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Title json.RawMessage `json:"title"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTitle, _ := UnmarshalRichText(tmp.Title)
	pageBlockTitle.Title = fieldTitle

	return nil
}

// The subtitle of a page
type PageBlockSubtitle struct {
	meta
	// Subtitle
	Subtitle RichText `json:"subtitle"`
}

func (entity *PageBlockSubtitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSubtitle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSubtitle) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSubtitle) GetType() string {
	return TypePageBlockSubtitle
}

func (*PageBlockSubtitle) PageBlockType() string {
	return TypePageBlockSubtitle
}

func (pageBlockSubtitle *PageBlockSubtitle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Subtitle json.RawMessage `json:"subtitle"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldSubtitle, _ := UnmarshalRichText(tmp.Subtitle)
	pageBlockSubtitle.Subtitle = fieldSubtitle

	return nil
}

// The author and publishing date of a page
type PageBlockAuthorDate struct {
	meta
	// Author
	Author RichText `json:"author"`
	// Point in time (Unix timestamp) when the article was published; 0 if unknown
	PublishDate int32 `json:"publish_date"`
}

func (entity *PageBlockAuthorDate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAuthorDate

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAuthorDate) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAuthorDate) GetType() string {
	return TypePageBlockAuthorDate
}

func (*PageBlockAuthorDate) PageBlockType() string {
	return TypePageBlockAuthorDate
}

func (pageBlockAuthorDate *PageBlockAuthorDate) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Author      json.RawMessage `json:"author"`
		PublishDate int32           `json:"publish_date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockAuthorDate.PublishDate = tmp.PublishDate

	fieldAuthor, _ := UnmarshalRichText(tmp.Author)
	pageBlockAuthorDate.Author = fieldAuthor

	return nil
}

// A header
type PageBlockHeader struct {
	meta
	// Header
	Header RichText `json:"header"`
}

func (entity *PageBlockHeader) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHeader

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHeader) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockHeader) GetType() string {
	return TypePageBlockHeader
}

func (*PageBlockHeader) PageBlockType() string {
	return TypePageBlockHeader
}

func (pageBlockHeader *PageBlockHeader) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header json.RawMessage `json:"header"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockHeader.Header = fieldHeader

	return nil
}

// A subheader
type PageBlockSubheader struct {
	meta
	// Subheader
	Subheader RichText `json:"subheader"`
}

func (entity *PageBlockSubheader) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSubheader

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSubheader) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSubheader) GetType() string {
	return TypePageBlockSubheader
}

func (*PageBlockSubheader) PageBlockType() string {
	return TypePageBlockSubheader
}

func (pageBlockSubheader *PageBlockSubheader) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Subheader json.RawMessage `json:"subheader"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldSubheader, _ := UnmarshalRichText(tmp.Subheader)
	pageBlockSubheader.Subheader = fieldSubheader

	return nil
}

// A kicker
type PageBlockKicker struct {
	meta
	// Kicker
	Kicker RichText `json:"kicker"`
}

func (entity *PageBlockKicker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockKicker

	return json.Marshal((*stub)(entity))
}

func (*PageBlockKicker) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockKicker) GetType() string {
	return TypePageBlockKicker
}

func (*PageBlockKicker) PageBlockType() string {
	return TypePageBlockKicker
}

func (pageBlockKicker *PageBlockKicker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Kicker json.RawMessage `json:"kicker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldKicker, _ := UnmarshalRichText(tmp.Kicker)
	pageBlockKicker.Kicker = fieldKicker

	return nil
}

// A text paragraph
type PageBlockParagraph struct {
	meta
	// Paragraph text
	Text RichText `json:"text"`
}

func (entity *PageBlockParagraph) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockParagraph

	return json.Marshal((*stub)(entity))
}

func (*PageBlockParagraph) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockParagraph) GetType() string {
	return TypePageBlockParagraph
}

func (*PageBlockParagraph) PageBlockType() string {
	return TypePageBlockParagraph
}

func (pageBlockParagraph *PageBlockParagraph) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockParagraph.Text = fieldText

	return nil
}

// A preformatted text paragraph
type PageBlockPreformatted struct {
	meta
	// Paragraph text
	Text RichText `json:"text"`
	// Programming language for which the text needs to be formatted
	Language string `json:"language"`
}

func (entity *PageBlockPreformatted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPreformatted

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPreformatted) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPreformatted) GetType() string {
	return TypePageBlockPreformatted
}

func (*PageBlockPreformatted) PageBlockType() string {
	return TypePageBlockPreformatted
}

func (pageBlockPreformatted *PageBlockPreformatted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		Language string          `json:"language"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockPreformatted.Language = tmp.Language

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockPreformatted.Text = fieldText

	return nil
}

// The footer of a page
type PageBlockFooter struct {
	meta
	// Footer
	Footer RichText `json:"footer"`
}

func (entity *PageBlockFooter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockFooter

	return json.Marshal((*stub)(entity))
}

func (*PageBlockFooter) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockFooter) GetType() string {
	return TypePageBlockFooter
}

func (*PageBlockFooter) PageBlockType() string {
	return TypePageBlockFooter
}

func (pageBlockFooter *PageBlockFooter) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Footer json.RawMessage `json:"footer"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFooter, _ := UnmarshalRichText(tmp.Footer)
	pageBlockFooter.Footer = fieldFooter

	return nil
}

// An empty block separating a page
type PageBlockDivider struct {
	meta
}

func (entity *PageBlockDivider) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockDivider

	return json.Marshal((*stub)(entity))
}

func (*PageBlockDivider) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockDivider) GetType() string {
	return TypePageBlockDivider
}

func (*PageBlockDivider) PageBlockType() string {
	return TypePageBlockDivider
}

// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
type PageBlockAnchor struct {
	meta
	// Name of the anchor
	Name string `json:"name"`
}

func (entity *PageBlockAnchor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAnchor

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAnchor) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAnchor) GetType() string {
	return TypePageBlockAnchor
}

func (*PageBlockAnchor) PageBlockType() string {
	return TypePageBlockAnchor
}

// A list of data blocks
type PageBlockList struct {
	meta
	// The items of the list
	Items []*PageBlockListItem `json:"items"`
}

func (entity *PageBlockList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockList

	return json.Marshal((*stub)(entity))
}

func (*PageBlockList) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockList) GetType() string {
	return TypePageBlockList
}

func (*PageBlockList) PageBlockType() string {
	return TypePageBlockList
}

// A block quote
type PageBlockBlockQuote struct {
	meta
	// Quote text
	Text RichText `json:"text"`
	// Quote credit
	Credit RichText `json:"credit"`
}

func (entity *PageBlockBlockQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockBlockQuote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockBlockQuote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockBlockQuote) GetType() string {
	return TypePageBlockBlockQuote
}

func (*PageBlockBlockQuote) PageBlockType() string {
	return TypePageBlockBlockQuote
}

func (pageBlockBlockQuote *PageBlockBlockQuote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockBlockQuote.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockBlockQuote.Credit = fieldCredit

	return nil
}

// A pull quote
type PageBlockPullQuote struct {
	meta
	// Quote text
	Text RichText `json:"text"`
	// Quote credit
	Credit RichText `json:"credit"`
}

func (entity *PageBlockPullQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPullQuote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPullQuote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPullQuote) GetType() string {
	return TypePageBlockPullQuote
}

func (*PageBlockPullQuote) PageBlockType() string {
	return TypePageBlockPullQuote
}

func (pageBlockPullQuote *PageBlockPullQuote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockPullQuote.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockPullQuote.Credit = fieldCredit

	return nil
}

// An animation
type PageBlockAnimation struct {
	meta
	// Animation file; may be null
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the animation must be played automatically
	NeedAutoplay bool `json:"need_autoplay"`
}

func (entity *PageBlockAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAnimation

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAnimation) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAnimation) GetType() string {
	return TypePageBlockAnimation
}

func (*PageBlockAnimation) PageBlockType() string {
	return TypePageBlockAnimation
}

// An audio file
type PageBlockAudio struct {
	meta
	// Audio file; may be null
	Audio *Audio `json:"audio"`
	// Audio file caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAudio

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAudio) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAudio) GetType() string {
	return TypePageBlockAudio
}

func (*PageBlockAudio) PageBlockType() string {
	return TypePageBlockAudio
}

// A photo
type PageBlockPhoto struct {
	meta
	// Photo file; may be null
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *PageBlockCaption `json:"caption"`
	// URL that needs to be opened when the photo is clicked
	Url string `json:"url"`
}

func (entity *PageBlockPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPhoto

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPhoto) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPhoto) GetType() string {
	return TypePageBlockPhoto
}

func (*PageBlockPhoto) PageBlockType() string {
	return TypePageBlockPhoto
}

// A video
type PageBlockVideo struct {
	meta
	// Video file; may be null
	Video *Video `json:"video"`
	// Video caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the video must be played automatically
	NeedAutoplay bool `json:"need_autoplay"`
	// True, if the video must be looped
	IsLooped bool `json:"is_looped"`
}

func (entity *PageBlockVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVideo

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVideo) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockVideo) GetType() string {
	return TypePageBlockVideo
}

func (*PageBlockVideo) PageBlockType() string {
	return TypePageBlockVideo
}

// A voice note
type PageBlockVoiceNote struct {
	meta
	// Voice note; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// Voice note caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVoiceNote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockVoiceNote) GetType() string {
	return TypePageBlockVoiceNote
}

func (*PageBlockVoiceNote) PageBlockType() string {
	return TypePageBlockVoiceNote
}

// A page cover
type PageBlockCover struct {
	meta
	// Cover
	Cover PageBlock `json:"cover"`
}

func (entity *PageBlockCover) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCover

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCover) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockCover) GetType() string {
	return TypePageBlockCover
}

func (*PageBlockCover) PageBlockType() string {
	return TypePageBlockCover
}

func (pageBlockCover *PageBlockCover) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Cover json.RawMessage `json:"cover"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldCover, _ := UnmarshalPageBlock(tmp.Cover)
	pageBlockCover.Cover = fieldCover

	return nil
}

// An embedded web page
type PageBlockEmbedded struct {
	meta
	// URL of the embedded page, if available
	Url string `json:"url"`
	// HTML-markup of the embedded page
	Html string `json:"html"`
	// Poster photo, if available; may be null
	PosterPhoto *Photo `json:"poster_photo"`
	// Block width; 0 if unknown
	Width int32 `json:"width"`
	// Block height; 0 if unknown
	Height int32 `json:"height"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the block must be full width
	IsFullWidth bool `json:"is_full_width"`
	// True, if scrolling needs to be allowed
	AllowScrolling bool `json:"allow_scrolling"`
}

func (entity *PageBlockEmbedded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockEmbedded

	return json.Marshal((*stub)(entity))
}

func (*PageBlockEmbedded) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockEmbedded) GetType() string {
	return TypePageBlockEmbedded
}

func (*PageBlockEmbedded) PageBlockType() string {
	return TypePageBlockEmbedded
}

// An embedded post
type PageBlockEmbeddedPost struct {
	meta
	// URL of the embedded post
	Url string `json:"url"`
	// Post author
	Author string `json:"author"`
	// Post author photo; may be null
	AuthorPhoto *Photo `json:"author_photo"`
	// Point in time (Unix timestamp) when the post was created; 0 if unknown
	Date int32 `json:"date"`
	// Post content
	PageBlocks []PageBlock `json:"page_blocks"`
	// Post caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockEmbeddedPost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockEmbeddedPost

	return json.Marshal((*stub)(entity))
}

func (*PageBlockEmbeddedPost) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockEmbeddedPost) GetType() string {
	return TypePageBlockEmbeddedPost
}

func (*PageBlockEmbeddedPost) PageBlockType() string {
	return TypePageBlockEmbeddedPost
}

func (pageBlockEmbeddedPost *PageBlockEmbeddedPost) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url         string            `json:"url"`
		Author      string            `json:"author"`
		AuthorPhoto *Photo            `json:"author_photo"`
		Date        int32             `json:"date"`
		PageBlocks  []json.RawMessage `json:"page_blocks"`
		Caption     *PageBlockCaption `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockEmbeddedPost.Url = tmp.Url
	pageBlockEmbeddedPost.Author = tmp.Author
	pageBlockEmbeddedPost.AuthorPhoto = tmp.AuthorPhoto
	pageBlockEmbeddedPost.Date = tmp.Date
	pageBlockEmbeddedPost.Caption = tmp.Caption

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockEmbeddedPost.PageBlocks = fieldPageBlocks

	return nil
}

// A collage
type PageBlockCollage struct {
	meta
	// Collage item contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockCollage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCollage

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCollage) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockCollage) GetType() string {
	return TypePageBlockCollage
}

func (*PageBlockCollage) PageBlockType() string {
	return TypePageBlockCollage
}

func (pageBlockCollage *PageBlockCollage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PageBlocks []json.RawMessage `json:"page_blocks"`
		Caption    *PageBlockCaption `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockCollage.Caption = tmp.Caption

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockCollage.PageBlocks = fieldPageBlocks

	return nil
}

// A slideshow
type PageBlockSlideshow struct {
	meta
	// Slideshow item contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockSlideshow) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSlideshow

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSlideshow) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSlideshow) GetType() string {
	return TypePageBlockSlideshow
}

func (*PageBlockSlideshow) PageBlockType() string {
	return TypePageBlockSlideshow
}

func (pageBlockSlideshow *PageBlockSlideshow) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PageBlocks []json.RawMessage `json:"page_blocks"`
		Caption    *PageBlockCaption `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockSlideshow.Caption = tmp.Caption

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockSlideshow.PageBlocks = fieldPageBlocks

	return nil
}

// A link to a chat
type PageBlockChatLink struct {
	meta
	// Chat title
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
	// Identifier of the accent color for chat title and background of chat photo
	AccentColorId int32 `json:"accent_color_id"`
	// Chat username by which all other information about the chat can be resolved
	Username string `json:"username"`
}

func (entity *PageBlockChatLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockChatLink

	return json.Marshal((*stub)(entity))
}

func (*PageBlockChatLink) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockChatLink) GetType() string {
	return TypePageBlockChatLink
}

func (*PageBlockChatLink) PageBlockType() string {
	return TypePageBlockChatLink
}

// A table
type PageBlockTable struct {
	meta
	// Table caption
	Caption RichText `json:"caption"`
	// Table cells
	Cells [][]*PageBlockTableCell `json:"cells"`
	// True, if the table is bordered
	IsBordered bool `json:"is_bordered"`
	// True, if the table is striped
	IsStriped bool `json:"is_striped"`
}

func (entity *PageBlockTable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTable

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTable) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockTable) GetType() string {
	return TypePageBlockTable
}

func (*PageBlockTable) PageBlockType() string {
	return TypePageBlockTable
}

func (pageBlockTable *PageBlockTable) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Caption    json.RawMessage         `json:"caption"`
		Cells      [][]*PageBlockTableCell `json:"cells"`
		IsBordered bool                    `json:"is_bordered"`
		IsStriped  bool                    `json:"is_striped"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockTable.Cells = tmp.Cells
	pageBlockTable.IsBordered = tmp.IsBordered
	pageBlockTable.IsStriped = tmp.IsStriped

	fieldCaption, _ := UnmarshalRichText(tmp.Caption)
	pageBlockTable.Caption = fieldCaption

	return nil
}

// A collapsible block
type PageBlockDetails struct {
	meta
	// Always visible heading for the block
	Header RichText `json:"header"`
	// Block contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// True, if the block is open by default
	IsOpen bool `json:"is_open"`
}

func (entity *PageBlockDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockDetails

	return json.Marshal((*stub)(entity))
}

func (*PageBlockDetails) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockDetails) GetType() string {
	return TypePageBlockDetails
}

func (*PageBlockDetails) PageBlockType() string {
	return TypePageBlockDetails
}

func (pageBlockDetails *PageBlockDetails) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header     json.RawMessage   `json:"header"`
		PageBlocks []json.RawMessage `json:"page_blocks"`
		IsOpen     bool              `json:"is_open"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockDetails.IsOpen = tmp.IsOpen

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockDetails.Header = fieldHeader

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	pageBlockDetails.PageBlocks = fieldPageBlocks

	return nil
}

// Related articles
type PageBlockRelatedArticles struct {
	meta
	// Block header
	Header RichText `json:"header"`
	// List of related articles
	Articles []*PageBlockRelatedArticle `json:"articles"`
}

func (entity *PageBlockRelatedArticles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockRelatedArticles

	return json.Marshal((*stub)(entity))
}

func (*PageBlockRelatedArticles) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockRelatedArticles) GetType() string {
	return TypePageBlockRelatedArticles
}

func (*PageBlockRelatedArticles) PageBlockType() string {
	return TypePageBlockRelatedArticles
}

func (pageBlockRelatedArticles *PageBlockRelatedArticles) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header   json.RawMessage            `json:"header"`
		Articles []*PageBlockRelatedArticle `json:"articles"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockRelatedArticles.Articles = tmp.Articles

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockRelatedArticles.Header = fieldHeader

	return nil
}

// A map
type PageBlockMap struct {
	meta
	// Location of the map center
	Location *Location `json:"location"`
	// Map zoom level
	Zoom int32 `json:"zoom"`
	// Map width
	Width int32 `json:"width"`
	// Map height
	Height int32 `json:"height"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockMap) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockMap

	return json.Marshal((*stub)(entity))
}

func (*PageBlockMap) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockMap) GetType() string {
	return TypePageBlockMap
}

func (*PageBlockMap) PageBlockType() string {
	return TypePageBlockMap
}

// Describes an instant view page for a web page
type WebPageInstantView struct {
	meta
	// Content of the instant view page
	PageBlocks []PageBlock `json:"page_blocks"`
	// Number of the instant view views; 0 if unknown
	ViewCount int32 `json:"view_count"`
	// Version of the instant view; currently, can be 1 or 2
	Version int32 `json:"version"`
	// True, if the instant view must be shown from right to left
	IsRtl bool `json:"is_rtl"`
	// True, if the instant view contains the full page. A network request might be needed to get the full instant view
	IsFull bool `json:"is_full"`
	// An internal link to be opened to leave feedback about the instant view
	FeedbackLink InternalLinkType `json:"feedback_link"`
}

func (entity *WebPageInstantView) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebPageInstantView

	return json.Marshal((*stub)(entity))
}

func (*WebPageInstantView) GetClass() string {
	return ClassWebPageInstantView
}

func (*WebPageInstantView) GetType() string {
	return TypeWebPageInstantView
}

func (webPageInstantView *WebPageInstantView) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PageBlocks   []json.RawMessage `json:"page_blocks"`
		ViewCount    int32             `json:"view_count"`
		Version      int32             `json:"version"`
		IsRtl        bool              `json:"is_rtl"`
		IsFull       bool              `json:"is_full"`
		FeedbackLink json.RawMessage   `json:"feedback_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	webPageInstantView.ViewCount = tmp.ViewCount
	webPageInstantView.Version = tmp.Version
	webPageInstantView.IsRtl = tmp.IsRtl
	webPageInstantView.IsFull = tmp.IsFull

	fieldPageBlocks, _ := UnmarshalListOfPageBlock(tmp.PageBlocks)
	webPageInstantView.PageBlocks = fieldPageBlocks

	fieldFeedbackLink, _ := UnmarshalInternalLinkType(tmp.FeedbackLink)
	webPageInstantView.FeedbackLink = fieldFeedbackLink

	return nil
}

// The media is a photo
type LinkPreviewAlbumMediaPhoto struct {
	meta
	// Photo description
	Photo *Photo `json:"photo"`
}

func (entity *LinkPreviewAlbumMediaPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewAlbumMediaPhoto

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewAlbumMediaPhoto) GetClass() string {
	return ClassLinkPreviewAlbumMedia
}

func (*LinkPreviewAlbumMediaPhoto) GetType() string {
	return TypeLinkPreviewAlbumMediaPhoto
}

func (*LinkPreviewAlbumMediaPhoto) LinkPreviewAlbumMediaType() string {
	return TypeLinkPreviewAlbumMediaPhoto
}

// The media is a video
type LinkPreviewAlbumMediaVideo struct {
	meta
	// Video description
	Video *Video `json:"video"`
}

func (entity *LinkPreviewAlbumMediaVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewAlbumMediaVideo

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewAlbumMediaVideo) GetClass() string {
	return ClassLinkPreviewAlbumMedia
}

func (*LinkPreviewAlbumMediaVideo) GetType() string {
	return TypeLinkPreviewAlbumMediaVideo
}

func (*LinkPreviewAlbumMediaVideo) LinkPreviewAlbumMediaType() string {
	return TypeLinkPreviewAlbumMediaVideo
}

// The link is a link to a media album consisting of photos and videos
type LinkPreviewTypeAlbum struct {
	meta
	// The list of album media
	Media []LinkPreviewAlbumMedia `json:"media"`
	// Album caption
	Caption string `json:"caption"`
}

func (entity *LinkPreviewTypeAlbum) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeAlbum

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeAlbum) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeAlbum) GetType() string {
	return TypeLinkPreviewTypeAlbum
}

func (*LinkPreviewTypeAlbum) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeAlbum
}

func (linkPreviewTypeAlbum *LinkPreviewTypeAlbum) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Media   []json.RawMessage `json:"media"`
		Caption string            `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	linkPreviewTypeAlbum.Caption = tmp.Caption

	fieldMedia, _ := UnmarshalListOfLinkPreviewAlbumMedia(tmp.Media)
	linkPreviewTypeAlbum.Media = fieldMedia

	return nil
}

// The link is a link to an animation
type LinkPreviewTypeAnimation struct {
	meta
	// The animation
	Animation *Animation `json:"animation"`
}

func (entity *LinkPreviewTypeAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeAnimation

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeAnimation) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeAnimation) GetType() string {
	return TypeLinkPreviewTypeAnimation
}

func (*LinkPreviewTypeAnimation) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeAnimation
}

// The link is a link to an app at App Store or Google Play
type LinkPreviewTypeApp struct {
	meta
	// Photo for the app
	Photo *Photo `json:"photo"`
}

func (entity *LinkPreviewTypeApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeApp

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeApp) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeApp) GetType() string {
	return TypeLinkPreviewTypeApp
}

func (*LinkPreviewTypeApp) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeApp
}

// The link is a link to a web site
type LinkPreviewTypeArticle struct {
	meta
	// Article's main photo; may be null
	Photo *Photo `json:"photo"`
}

func (entity *LinkPreviewTypeArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeArticle

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeArticle) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeArticle) GetType() string {
	return TypeLinkPreviewTypeArticle
}

func (*LinkPreviewTypeArticle) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeArticle
}

// The link is a link to an audio
type LinkPreviewTypeAudio struct {
	meta
	// The audio description
	Audio *Audio `json:"audio"`
}

func (entity *LinkPreviewTypeAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeAudio

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeAudio) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeAudio) GetType() string {
	return TypeLinkPreviewTypeAudio
}

func (*LinkPreviewTypeAudio) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeAudio
}

// The link is a link to a background. Link preview title and description are available only for filled backgrounds
type LinkPreviewTypeBackground struct {
	meta
	// Document with the background; may be null for filled backgrounds
	Document *Document `json:"document"`
	// Type of the background; may be null if unknown
	BackgroundType BackgroundType `json:"background_type"`
}

func (entity *LinkPreviewTypeBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeBackground

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeBackground) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeBackground) GetType() string {
	return TypeLinkPreviewTypeBackground
}

func (*LinkPreviewTypeBackground) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeBackground
}

func (linkPreviewTypeBackground *LinkPreviewTypeBackground) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Document       *Document       `json:"document"`
		BackgroundType json.RawMessage `json:"background_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	linkPreviewTypeBackground.Document = tmp.Document

	fieldBackgroundType, _ := UnmarshalBackgroundType(tmp.BackgroundType)
	linkPreviewTypeBackground.BackgroundType = fieldBackgroundType

	return nil
}

// The link is a link to boost a channel chat
type LinkPreviewTypeChannelBoost struct {
	meta
	// Photo of the chat; may be null
	Photo *ChatPhoto `json:"photo"`
}

func (entity *LinkPreviewTypeChannelBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeChannelBoost

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeChannelBoost) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeChannelBoost) GetType() string {
	return TypeLinkPreviewTypeChannelBoost
}

func (*LinkPreviewTypeChannelBoost) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeChannelBoost
}

// The link is a link to a chat
type LinkPreviewTypeChat struct {
	meta
	// Type of the chat
	Type InviteLinkChatType `json:"type"`
	// Photo of the chat; may be null
	Photo *ChatPhoto `json:"photo"`
	// True, if the link only creates join request
	CreatesJoinRequest bool `json:"creates_join_request"`
}

func (entity *LinkPreviewTypeChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeChat

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeChat) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeChat) GetType() string {
	return TypeLinkPreviewTypeChat
}

func (*LinkPreviewTypeChat) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeChat
}

func (linkPreviewTypeChat *LinkPreviewTypeChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type               json.RawMessage `json:"type"`
		Photo              *ChatPhoto      `json:"photo"`
		CreatesJoinRequest bool            `json:"creates_join_request"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	linkPreviewTypeChat.Photo = tmp.Photo
	linkPreviewTypeChat.CreatesJoinRequest = tmp.CreatesJoinRequest

	fieldType, _ := UnmarshalInviteLinkChatType(tmp.Type)
	linkPreviewTypeChat.Type = fieldType

	return nil
}

// The link is a link to a general file
type LinkPreviewTypeDocument struct {
	meta
	// The document description
	Document *Document `json:"document"`
}

func (entity *LinkPreviewTypeDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeDocument

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeDocument) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeDocument) GetType() string {
	return TypeLinkPreviewTypeDocument
}

func (*LinkPreviewTypeDocument) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeDocument
}

// The link is a link to an animation player
type LinkPreviewTypeEmbeddedAnimationPlayer struct {
	meta
	// URL of the external animation player
	Url string `json:"url"`
	// Thumbnail of the animation; may be null if unknown
	Thumbnail *Photo `json:"thumbnail"`
	// Duration of the animation, in seconds
	Duration int32 `json:"duration"`
	// Expected width of the embedded player
	Width int32 `json:"width"`
	// Expected height of the embedded player
	Height int32 `json:"height"`
}

func (entity *LinkPreviewTypeEmbeddedAnimationPlayer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeEmbeddedAnimationPlayer

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeEmbeddedAnimationPlayer) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeEmbeddedAnimationPlayer) GetType() string {
	return TypeLinkPreviewTypeEmbeddedAnimationPlayer
}

func (*LinkPreviewTypeEmbeddedAnimationPlayer) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeEmbeddedAnimationPlayer
}

// The link is a link to an audio player
type LinkPreviewTypeEmbeddedAudioPlayer struct {
	meta
	// URL of the external audio player
	Url string `json:"url"`
	// Thumbnail of the audio; may be null if unknown
	Thumbnail *Photo `json:"thumbnail"`
	// Duration of the audio, in seconds
	Duration int32 `json:"duration"`
	// Expected width of the embedded player
	Width int32 `json:"width"`
	// Expected height of the embedded player
	Height int32 `json:"height"`
}

func (entity *LinkPreviewTypeEmbeddedAudioPlayer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeEmbeddedAudioPlayer

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeEmbeddedAudioPlayer) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeEmbeddedAudioPlayer) GetType() string {
	return TypeLinkPreviewTypeEmbeddedAudioPlayer
}

func (*LinkPreviewTypeEmbeddedAudioPlayer) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeEmbeddedAudioPlayer
}

// The link is a link to a video player
type LinkPreviewTypeEmbeddedVideoPlayer struct {
	meta
	// URL of the external video player
	Url string `json:"url"`
	// Thumbnail of the video; may be null if unknown
	Thumbnail *Photo `json:"thumbnail"`
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// Expected width of the embedded player
	Width int32 `json:"width"`
	// Expected height of the embedded player
	Height int32 `json:"height"`
}

func (entity *LinkPreviewTypeEmbeddedVideoPlayer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeEmbeddedVideoPlayer

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeEmbeddedVideoPlayer) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeEmbeddedVideoPlayer) GetType() string {
	return TypeLinkPreviewTypeEmbeddedVideoPlayer
}

func (*LinkPreviewTypeEmbeddedVideoPlayer) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeEmbeddedVideoPlayer
}

// The link is a link to an audio file
type LinkPreviewTypeExternalAudio struct {
	meta
	// URL of the audio file
	Url string `json:"url"`
	// MIME type of the audio file
	MimeType string `json:"mime_type"`
	// Duration of the audio, in seconds; 0 if unknown
	Duration int32 `json:"duration"`
}

func (entity *LinkPreviewTypeExternalAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeExternalAudio

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeExternalAudio) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeExternalAudio) GetType() string {
	return TypeLinkPreviewTypeExternalAudio
}

func (*LinkPreviewTypeExternalAudio) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeExternalAudio
}

// The link is a link to a video file
type LinkPreviewTypeExternalVideo struct {
	meta
	// URL of the video file
	Url string `json:"url"`
	// MIME type of the video file
	MimeType string `json:"mime_type"`
	// Expected width of the video preview; 0 if unknown
	Width int32 `json:"width"`
	// Expected height of the video preview; 0 if unknown
	Height int32 `json:"height"`
	// Duration of the video, in seconds; 0 if unknown
	Duration int32 `json:"duration"`
}

func (entity *LinkPreviewTypeExternalVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeExternalVideo

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeExternalVideo) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeExternalVideo) GetType() string {
	return TypeLinkPreviewTypeExternalVideo
}

func (*LinkPreviewTypeExternalVideo) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeExternalVideo
}

// The link is a link to an invoice
type LinkPreviewTypeInvoice struct {
	meta
}

func (entity *LinkPreviewTypeInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeInvoice

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeInvoice) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeInvoice) GetType() string {
	return TypeLinkPreviewTypeInvoice
}

func (*LinkPreviewTypeInvoice) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeInvoice
}

// The link is a link to a text or a poll Telegram message
type LinkPreviewTypeMessage struct {
	meta
}

func (entity *LinkPreviewTypeMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeMessage

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeMessage) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeMessage) GetType() string {
	return TypeLinkPreviewTypeMessage
}

func (*LinkPreviewTypeMessage) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeMessage
}

// The link is a link to a photo
type LinkPreviewTypePhoto struct {
	meta
	// The photo
	Photo *Photo `json:"photo"`
}

func (entity *LinkPreviewTypePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypePhoto

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypePhoto) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypePhoto) GetType() string {
	return TypeLinkPreviewTypePhoto
}

func (*LinkPreviewTypePhoto) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypePhoto
}

// The link is a link to a Telegram Premium gift code
type LinkPreviewTypePremiumGiftCode struct {
	meta
}

func (entity *LinkPreviewTypePremiumGiftCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypePremiumGiftCode

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypePremiumGiftCode) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypePremiumGiftCode) GetType() string {
	return TypeLinkPreviewTypePremiumGiftCode
}

func (*LinkPreviewTypePremiumGiftCode) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypePremiumGiftCode
}

// The link is a link to a shareable chat folder
type LinkPreviewTypeShareableChatFolder struct {
	meta
}

func (entity *LinkPreviewTypeShareableChatFolder) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeShareableChatFolder

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeShareableChatFolder) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeShareableChatFolder) GetType() string {
	return TypeLinkPreviewTypeShareableChatFolder
}

func (*LinkPreviewTypeShareableChatFolder) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeShareableChatFolder
}

// The link is a link to a sticker
type LinkPreviewTypeSticker struct {
	meta
	// The sticker. It can be an arbitrary WEBP image and can have dimensions bigger than 512
	Sticker *Sticker `json:"sticker"`
}

func (entity *LinkPreviewTypeSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeSticker

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeSticker) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeSticker) GetType() string {
	return TypeLinkPreviewTypeSticker
}

func (*LinkPreviewTypeSticker) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeSticker
}

// The link is a link to a sticker set
type LinkPreviewTypeStickerSet struct {
	meta
	// Up to 4 stickers from the sticker set
	Stickers []*Sticker `json:"stickers"`
}

func (entity *LinkPreviewTypeStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeStickerSet

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeStickerSet) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeStickerSet) GetType() string {
	return TypeLinkPreviewTypeStickerSet
}

func (*LinkPreviewTypeStickerSet) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeStickerSet
}

// The link is a link to a story. Link preview description is unavailable
type LinkPreviewTypeStory struct {
	meta
	// The identifier of the chat that posted the story
	StorySenderChatId int64 `json:"story_sender_chat_id"`
	// Story identifier
	StoryId int32 `json:"story_id"`
}

func (entity *LinkPreviewTypeStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeStory

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeStory) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeStory) GetType() string {
	return TypeLinkPreviewTypeStory
}

func (*LinkPreviewTypeStory) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeStory
}

// The link is a link to boost a supergroup chat
type LinkPreviewTypeSupergroupBoost struct {
	meta
	// Photo of the chat; may be null
	Photo *ChatPhoto `json:"photo"`
}

func (entity *LinkPreviewTypeSupergroupBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeSupergroupBoost

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeSupergroupBoost) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeSupergroupBoost) GetType() string {
	return TypeLinkPreviewTypeSupergroupBoost
}

func (*LinkPreviewTypeSupergroupBoost) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeSupergroupBoost
}

// The link is a link to a cloud theme. TDLib has no theme support yet
type LinkPreviewTypeTheme struct {
	meta
	// The list of files with theme description
	Documents []*Document `json:"documents"`
	// Settings for the cloud theme; may be null if unknown
	Settings *ThemeSettings `json:"settings"`
}

func (entity *LinkPreviewTypeTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeTheme

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeTheme) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeTheme) GetType() string {
	return TypeLinkPreviewTypeTheme
}

func (*LinkPreviewTypeTheme) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeTheme
}

// The link preview type is unsupported yet
type LinkPreviewTypeUnsupported struct {
	meta
}

func (entity *LinkPreviewTypeUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeUnsupported

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeUnsupported) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeUnsupported) GetType() string {
	return TypeLinkPreviewTypeUnsupported
}

func (*LinkPreviewTypeUnsupported) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeUnsupported
}

// The link is a link to a user
type LinkPreviewTypeUser struct {
	meta
	// Photo of the user; may be null if none
	Photo *ChatPhoto `json:"photo"`
	// True, if the user is a bot
	IsBot bool `json:"is_bot"`
}

func (entity *LinkPreviewTypeUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeUser

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeUser) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeUser) GetType() string {
	return TypeLinkPreviewTypeUser
}

func (*LinkPreviewTypeUser) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeUser
}

// The link is a link to a video
type LinkPreviewTypeVideo struct {
	meta
	// The video description
	Video *Video `json:"video"`
}

func (entity *LinkPreviewTypeVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeVideo

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeVideo) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeVideo) GetType() string {
	return TypeLinkPreviewTypeVideo
}

func (*LinkPreviewTypeVideo) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeVideo
}

// The link is a link to a video chat
type LinkPreviewTypeVideoChat struct {
	meta
	// Photo of the chat with the video chat; may be null if none
	Photo *ChatPhoto `json:"photo"`
	// True, if the video chat is expected to be a live stream in a channel or a broadcast group
	IsLiveStream bool `json:"is_live_stream"`
}

func (entity *LinkPreviewTypeVideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeVideoChat

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeVideoChat) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeVideoChat) GetType() string {
	return TypeLinkPreviewTypeVideoChat
}

func (*LinkPreviewTypeVideoChat) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeVideoChat
}

// The link is a link to a video note message
type LinkPreviewTypeVideoNote struct {
	meta
	// The video note
	VideoNote *VideoNote `json:"video_note"`
}

func (entity *LinkPreviewTypeVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeVideoNote

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeVideoNote) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeVideoNote) GetType() string {
	return TypeLinkPreviewTypeVideoNote
}

func (*LinkPreviewTypeVideoNote) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeVideoNote
}

// The link is a link to a voice note message
type LinkPreviewTypeVoiceNote struct {
	meta
	// The voice note
	VoiceNote *VoiceNote `json:"voice_note"`
}

func (entity *LinkPreviewTypeVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeVoiceNote) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeVoiceNote) GetType() string {
	return TypeLinkPreviewTypeVoiceNote
}

func (*LinkPreviewTypeVoiceNote) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeVoiceNote
}

// The link is a link to a Web App
type LinkPreviewTypeWebApp struct {
	meta
	// Web App photo; may be null if none
	Photo *Photo `json:"photo"`
}

func (entity *LinkPreviewTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreviewTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*LinkPreviewTypeWebApp) GetClass() string {
	return ClassLinkPreviewType
}

func (*LinkPreviewTypeWebApp) GetType() string {
	return TypeLinkPreviewTypeWebApp
}

func (*LinkPreviewTypeWebApp) LinkPreviewTypeType() string {
	return TypeLinkPreviewTypeWebApp
}

// Describes a link preview
type LinkPreview struct {
	meta
	// Original URL of the link
	Url string `json:"url"`
	// URL to display
	DisplayUrl string `json:"display_url"`
	// Short name of the site (e.g., Google Docs, App Store)
	SiteName string `json:"site_name"`
	// Title of the content
	Title string `json:"title"`
	// Description of the content
	Description *FormattedText `json:"description"`
	// Author of the content
	Author string `json:"author"`
	// Type of the link preview
	Type LinkPreviewType `json:"type"`
	// True, if size of media in the preview can be changed
	HasLargeMedia bool `json:"has_large_media"`
	// True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
	ShowLargeMedia bool `json:"show_large_media"`
	// True, if media must be shown above link preview description; otherwise, the media must be shown below the description
	ShowMediaAboveDescription bool `json:"show_media_above_description"`
	// True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
	SkipConfirmation bool `json:"skip_confirmation"`
	// True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
	ShowAboveText bool `json:"show_above_text"`
	// Version of instant view (currently, can be 1 or 2) for the web page; 0 if none
	InstantViewVersion int32 `json:"instant_view_version"`
}

func (entity *LinkPreview) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LinkPreview

	return json.Marshal((*stub)(entity))
}

func (*LinkPreview) GetClass() string {
	return ClassLinkPreview
}

func (*LinkPreview) GetType() string {
	return TypeLinkPreview
}

func (linkPreview *LinkPreview) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url                       string          `json:"url"`
		DisplayUrl                string          `json:"display_url"`
		SiteName                  string          `json:"site_name"`
		Title                     string          `json:"title"`
		Description               *FormattedText  `json:"description"`
		Author                    string          `json:"author"`
		Type                      json.RawMessage `json:"type"`
		HasLargeMedia             bool            `json:"has_large_media"`
		ShowLargeMedia            bool            `json:"show_large_media"`
		ShowMediaAboveDescription bool            `json:"show_media_above_description"`
		SkipConfirmation          bool            `json:"skip_confirmation"`
		ShowAboveText             bool            `json:"show_above_text"`
		InstantViewVersion        int32           `json:"instant_view_version"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	linkPreview.Url = tmp.Url
	linkPreview.DisplayUrl = tmp.DisplayUrl
	linkPreview.SiteName = tmp.SiteName
	linkPreview.Title = tmp.Title
	linkPreview.Description = tmp.Description
	linkPreview.Author = tmp.Author
	linkPreview.HasLargeMedia = tmp.HasLargeMedia
	linkPreview.ShowLargeMedia = tmp.ShowLargeMedia
	linkPreview.ShowMediaAboveDescription = tmp.ShowMediaAboveDescription
	linkPreview.SkipConfirmation = tmp.SkipConfirmation
	linkPreview.ShowAboveText = tmp.ShowAboveText
	linkPreview.InstantViewVersion = tmp.InstantViewVersion

	fieldType, _ := UnmarshalLinkPreviewType(tmp.Type)
	linkPreview.Type = fieldType

	return nil
}

// Contains information about a country
type CountryInfo struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// Native name of the country
	Name string `json:"name"`
	// English name of the country
	EnglishName string `json:"english_name"`
	// True, if the country must be hidden from the list of all countries
	IsHidden bool `json:"is_hidden"`
	// List of country calling codes
	CallingCodes []string `json:"calling_codes"`
}

func (entity *CountryInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CountryInfo

	return json.Marshal((*stub)(entity))
}

func (*CountryInfo) GetClass() string {
	return ClassCountryInfo
}

func (*CountryInfo) GetType() string {
	return TypeCountryInfo
}

// Contains information about countries
type Countries struct {
	meta
	// The list of countries
	Countries []*CountryInfo `json:"countries"`
}

func (entity *Countries) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Countries

	return json.Marshal((*stub)(entity))
}

func (*Countries) GetClass() string {
	return ClassCountries
}

func (*Countries) GetType() string {
	return TypeCountries
}

// Contains information about a phone number
type PhoneNumberInfo struct {
	meta
	// Information about the country to which the phone number belongs; may be null
	Country *CountryInfo `json:"country"`
	// The part of the phone number denoting country calling code or its part
	CountryCallingCode string `json:"country_calling_code"`
	// The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
	FormattedPhoneNumber string `json:"formatted_phone_number"`
	// True, if the phone number was bought at https://fragment.com and isn't tied to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
	IsAnonymous bool `json:"is_anonymous"`
}

func (entity *PhoneNumberInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberInfo

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberInfo) GetClass() string {
	return ClassPhoneNumberInfo
}

func (*PhoneNumberInfo) GetType() string {
	return TypePhoneNumberInfo
}

// A username
type CollectibleItemTypeUsername struct {
	meta
	// The username
	Username string `json:"username"`
}

func (entity *CollectibleItemTypeUsername) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CollectibleItemTypeUsername

	return json.Marshal((*stub)(entity))
}

func (*CollectibleItemTypeUsername) GetClass() string {
	return ClassCollectibleItemType
}

func (*CollectibleItemTypeUsername) GetType() string {
	return TypeCollectibleItemTypeUsername
}

func (*CollectibleItemTypeUsername) CollectibleItemTypeType() string {
	return TypeCollectibleItemTypeUsername
}

// A phone number
type CollectibleItemTypePhoneNumber struct {
	meta
	// The phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *CollectibleItemTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CollectibleItemTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*CollectibleItemTypePhoneNumber) GetClass() string {
	return ClassCollectibleItemType
}

func (*CollectibleItemTypePhoneNumber) GetType() string {
	return TypeCollectibleItemTypePhoneNumber
}

func (*CollectibleItemTypePhoneNumber) CollectibleItemTypeType() string {
	return TypeCollectibleItemTypePhoneNumber
}

// Contains information about a collectible item and its last purchase
type CollectibleItemInfo struct {
	meta
	// Point in time (Unix timestamp) when the item was purchased
	PurchaseDate int32 `json:"purchase_date"`
	// Currency for the paid amount
	Currency string `json:"currency"`
	// The paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Cryptocurrency used to pay for the item
	Cryptocurrency string `json:"cryptocurrency"`
	// The paid amount, in the smallest units of the cryptocurrency
	CryptocurrencyAmount JsonInt64 `json:"cryptocurrency_amount"`
	// Individual URL for the item on https://fragment.com
	Url string `json:"url"`
}

func (entity *CollectibleItemInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CollectibleItemInfo

	return json.Marshal((*stub)(entity))
}

func (*CollectibleItemInfo) GetClass() string {
	return ClassCollectibleItemInfo
}

func (*CollectibleItemInfo) GetType() string {
	return TypeCollectibleItemInfo
}

// Describes an action associated with a bank card number
type BankCardActionOpenUrl struct {
	meta
	// Action text
	Text string `json:"text"`
	// The URL to be opened
	Url string `json:"url"`
}

func (entity *BankCardActionOpenUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BankCardActionOpenUrl

	return json.Marshal((*stub)(entity))
}

func (*BankCardActionOpenUrl) GetClass() string {
	return ClassBankCardActionOpenUrl
}

func (*BankCardActionOpenUrl) GetType() string {
	return TypeBankCardActionOpenUrl
}

// Information about a bank card
type BankCardInfo struct {
	meta
	// Title of the bank card description
	Title string `json:"title"`
	// Actions that can be done with the bank card number
	Actions []*BankCardActionOpenUrl `json:"actions"`
}

func (entity *BankCardInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BankCardInfo

	return json.Marshal((*stub)(entity))
}

func (*BankCardInfo) GetClass() string {
	return ClassBankCardInfo
}

func (*BankCardInfo) GetType() string {
	return TypeBankCardInfo
}

// Describes an address
type Address struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// State, if applicable
	State string `json:"state"`
	// City
	City string `json:"city"`
	// First line of the address
	StreetLine1 string `json:"street_line1"`
	// Second line of the address
	StreetLine2 string `json:"street_line2"`
	// Address postal code
	PostalCode string `json:"postal_code"`
}

func (entity *Address) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Address

	return json.Marshal((*stub)(entity))
}

func (*Address) GetClass() string {
	return ClassAddress
}

func (*Address) GetType() string {
	return TypeAddress
}

// Describes an address of a location
type LocationAddress struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// State, if applicable; empty if unknown
	State string `json:"state"`
	// City; empty if unknown
	City string `json:"city"`
	// The address; empty if unknown
	Street string `json:"street"`
}

func (entity *LocationAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocationAddress

	return json.Marshal((*stub)(entity))
}

func (*LocationAddress) GetClass() string {
	return ClassLocationAddress
}

func (*LocationAddress) GetType() string {
	return TypeLocationAddress
}

// Portion of the price of a product (e.g., "delivery cost", "tax amount")
type LabeledPricePart struct {
	meta
	// Label for this portion of the product price
	Label string `json:"label"`
	// Currency amount in the smallest units of the currency
	Amount int64 `json:"amount"`
}

func (entity *LabeledPricePart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LabeledPricePart

	return json.Marshal((*stub)(entity))
}

func (*LabeledPricePart) GetClass() string {
	return ClassLabeledPricePart
}

func (*LabeledPricePart) GetType() string {
	return TypeLabeledPricePart
}

// Product invoice
type Invoice struct {
	meta
	// ISO 4217 currency code
	Currency string `json:"currency"`
	// A list of objects used to calculate the total price of the product
	PriceParts []*LabeledPricePart `json:"price_parts"`
	// The number of seconds between consecutive Telegram Star debiting for subscription invoices; 0 if the invoice doesn't create subscription
	SubscriptionPeriod int32 `json:"subscription_period"`
	// The maximum allowed amount of tip in the smallest units of the currency
	MaxTipAmount int64 `json:"max_tip_amount"`
	// Suggested amounts of tip in the smallest units of the currency
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts"`
	// An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
	RecurringPaymentTermsOfServiceUrl string `json:"recurring_payment_terms_of_service_url"`
	// An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
	TermsOfServiceUrl string `json:"terms_of_service_url"`
	// True, if the payment is a test payment
	IsTest bool `json:"is_test"`
	// True, if the user's name is needed for payment
	NeedName bool `json:"need_name"`
	// True, if the user's phone number is needed for payment
	NeedPhoneNumber bool `json:"need_phone_number"`
	// True, if the user's email address is needed for payment
	NeedEmailAddress bool `json:"need_email_address"`
	// True, if the user's shipping address is needed for payment
	NeedShippingAddress bool `json:"need_shipping_address"`
	// True, if the user's phone number will be sent to the provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider"`
	// True, if the user's email address will be sent to the provider
	SendEmailAddressToProvider bool `json:"send_email_address_to_provider"`
	// True, if the total price depends on the shipping method
	IsFlexible bool `json:"is_flexible"`
}

func (entity *Invoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Invoice

	return json.Marshal((*stub)(entity))
}

func (*Invoice) GetClass() string {
	return ClassInvoice
}

func (*Invoice) GetType() string {
	return TypeInvoice
}

// Order information
type OrderInfo struct {
	meta
	// Name of the user
	Name string `json:"name"`
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Email address of the user
	EmailAddress string `json:"email_address"`
	// Shipping address for this order; may be null
	ShippingAddress *Address `json:"shipping_address"`
}

func (entity *OrderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OrderInfo

	return json.Marshal((*stub)(entity))
}

func (*OrderInfo) GetClass() string {
	return ClassOrderInfo
}

func (*OrderInfo) GetType() string {
	return TypeOrderInfo
}

// One shipping option
type ShippingOption struct {
	meta
	// Shipping option identifier
	Id string `json:"id"`
	// Option title
	Title string `json:"title"`
	// A list of objects used to calculate the total shipping costs
	PriceParts []*LabeledPricePart `json:"price_parts"`
}

func (entity *ShippingOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ShippingOption

	return json.Marshal((*stub)(entity))
}

func (*ShippingOption) GetClass() string {
	return ClassShippingOption
}

func (*ShippingOption) GetType() string {
	return TypeShippingOption
}

// Contains information about saved payment credentials
type SavedCredentials struct {
	meta
	// Unique identifier of the saved credentials
	Id string `json:"id"`
	// Title of the saved credentials
	Title string `json:"title"`
}

func (entity *SavedCredentials) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedCredentials

	return json.Marshal((*stub)(entity))
}

func (*SavedCredentials) GetClass() string {
	return ClassSavedCredentials
}

func (*SavedCredentials) GetType() string {
	return TypeSavedCredentials
}

// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
type InputCredentialsSaved struct {
	meta
	// Identifier of the saved credentials
	SavedCredentialsId string `json:"saved_credentials_id"`
}

func (entity *InputCredentialsSaved) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsSaved

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsSaved) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsSaved) GetType() string {
	return TypeInputCredentialsSaved
}

func (*InputCredentialsSaved) InputCredentialsType() string {
	return TypeInputCredentialsSaved
}

// Applies if a user enters new credentials on a payment provider website
type InputCredentialsNew struct {
	meta
	// JSON-encoded data with the credential identifier from the payment provider
	Data string `json:"data"`
	// True, if the credential identifier can be saved on the server side
	AllowSave bool `json:"allow_save"`
}

func (entity *InputCredentialsNew) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsNew

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsNew) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsNew) GetType() string {
	return TypeInputCredentialsNew
}

func (*InputCredentialsNew) InputCredentialsType() string {
	return TypeInputCredentialsNew
}

// Applies if a user enters new credentials using Apple Pay
type InputCredentialsApplePay struct {
	meta
	// JSON-encoded data with the credential identifier
	Data string `json:"data"`
}

func (entity *InputCredentialsApplePay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsApplePay

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsApplePay) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsApplePay) GetType() string {
	return TypeInputCredentialsApplePay
}

func (*InputCredentialsApplePay) InputCredentialsType() string {
	return TypeInputCredentialsApplePay
}

// Applies if a user enters new credentials using Google Pay
type InputCredentialsGooglePay struct {
	meta
	// JSON-encoded data with the credential identifier
	Data string `json:"data"`
}

func (entity *InputCredentialsGooglePay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsGooglePay

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsGooglePay) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsGooglePay) GetType() string {
	return TypeInputCredentialsGooglePay
}

func (*InputCredentialsGooglePay) InputCredentialsType() string {
	return TypeInputCredentialsGooglePay
}

// Smart Glocal payment provider
type PaymentProviderSmartGlocal struct {
	meta
	// Public payment token
	PublicToken string `json:"public_token"`
	// URL for sending card tokenization requests
	TokenizeUrl string `json:"tokenize_url"`
}

func (entity *PaymentProviderSmartGlocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentProviderSmartGlocal

	return json.Marshal((*stub)(entity))
}

func (*PaymentProviderSmartGlocal) GetClass() string {
	return ClassPaymentProvider
}

func (*PaymentProviderSmartGlocal) GetType() string {
	return TypePaymentProviderSmartGlocal
}

func (*PaymentProviderSmartGlocal) PaymentProviderType() string {
	return TypePaymentProviderSmartGlocal
}

// Stripe payment provider
type PaymentProviderStripe struct {
	meta
	// Stripe API publishable key
	PublishableKey string `json:"publishable_key"`
	// True, if the user country must be provided
	NeedCountry bool `json:"need_country"`
	// True, if the user ZIP/postal code must be provided
	NeedPostalCode bool `json:"need_postal_code"`
	// True, if the cardholder name must be provided
	NeedCardholderName bool `json:"need_cardholder_name"`
}

func (entity *PaymentProviderStripe) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentProviderStripe

	return json.Marshal((*stub)(entity))
}

func (*PaymentProviderStripe) GetClass() string {
	return ClassPaymentProvider
}

func (*PaymentProviderStripe) GetType() string {
	return TypePaymentProviderStripe
}

func (*PaymentProviderStripe) PaymentProviderType() string {
	return TypePaymentProviderStripe
}

// Some other payment provider, for which a web payment form must be shown
type PaymentProviderOther struct {
	meta
	// Payment form URL
	Url string `json:"url"`
}

func (entity *PaymentProviderOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentProviderOther

	return json.Marshal((*stub)(entity))
}

func (*PaymentProviderOther) GetClass() string {
	return ClassPaymentProvider
}

func (*PaymentProviderOther) GetType() string {
	return TypePaymentProviderOther
}

func (*PaymentProviderOther) PaymentProviderType() string {
	return TypePaymentProviderOther
}

// Describes an additional payment option
type PaymentOption struct {
	meta
	// Title for the payment option
	Title string `json:"title"`
	// Payment form URL to be opened in a web view
	Url string `json:"url"`
}

func (entity *PaymentOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentOption

	return json.Marshal((*stub)(entity))
}

func (*PaymentOption) GetClass() string {
	return ClassPaymentOption
}

func (*PaymentOption) GetType() string {
	return TypePaymentOption
}

// The payment form is for a regular payment
type PaymentFormTypeRegular struct {
	meta
	// Full information about the invoice
	Invoice *Invoice `json:"invoice"`
	// User identifier of the payment provider bot
	PaymentProviderUserId int64 `json:"payment_provider_user_id"`
	// Information about the payment provider
	PaymentProvider PaymentProvider `json:"payment_provider"`
	// The list of additional payment options
	AdditionalPaymentOptions []*PaymentOption `json:"additional_payment_options"`
	// Saved server-side order information; may be null
	SavedOrderInfo *OrderInfo `json:"saved_order_info"`
	// The list of saved payment credentials
	SavedCredentials []*SavedCredentials `json:"saved_credentials"`
	// True, if the user can choose to save credentials
	CanSaveCredentials bool `json:"can_save_credentials"`
	// True, if the user will be able to save credentials, if sets up a 2-step verification password
	NeedPassword bool `json:"need_password"`
}

func (entity *PaymentFormTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentFormTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*PaymentFormTypeRegular) GetClass() string {
	return ClassPaymentFormType
}

func (*PaymentFormTypeRegular) GetType() string {
	return TypePaymentFormTypeRegular
}

func (*PaymentFormTypeRegular) PaymentFormTypeType() string {
	return TypePaymentFormTypeRegular
}

func (paymentFormTypeRegular *PaymentFormTypeRegular) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Invoice                  *Invoice            `json:"invoice"`
		PaymentProviderUserId    int64               `json:"payment_provider_user_id"`
		PaymentProvider          json.RawMessage     `json:"payment_provider"`
		AdditionalPaymentOptions []*PaymentOption    `json:"additional_payment_options"`
		SavedOrderInfo           *OrderInfo          `json:"saved_order_info"`
		SavedCredentials         []*SavedCredentials `json:"saved_credentials"`
		CanSaveCredentials       bool                `json:"can_save_credentials"`
		NeedPassword             bool                `json:"need_password"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	paymentFormTypeRegular.Invoice = tmp.Invoice
	paymentFormTypeRegular.PaymentProviderUserId = tmp.PaymentProviderUserId
	paymentFormTypeRegular.AdditionalPaymentOptions = tmp.AdditionalPaymentOptions
	paymentFormTypeRegular.SavedOrderInfo = tmp.SavedOrderInfo
	paymentFormTypeRegular.SavedCredentials = tmp.SavedCredentials
	paymentFormTypeRegular.CanSaveCredentials = tmp.CanSaveCredentials
	paymentFormTypeRegular.NeedPassword = tmp.NeedPassword

	fieldPaymentProvider, _ := UnmarshalPaymentProvider(tmp.PaymentProvider)
	paymentFormTypeRegular.PaymentProvider = fieldPaymentProvider

	return nil
}

// The payment form is for a payment in Telegram Stars
type PaymentFormTypeStars struct {
	meta
	// Number of Telegram Stars that will be paid
	StarCount int64 `json:"star_count"`
}

func (entity *PaymentFormTypeStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentFormTypeStars

	return json.Marshal((*stub)(entity))
}

func (*PaymentFormTypeStars) GetClass() string {
	return ClassPaymentFormType
}

func (*PaymentFormTypeStars) GetType() string {
	return TypePaymentFormTypeStars
}

func (*PaymentFormTypeStars) PaymentFormTypeType() string {
	return TypePaymentFormTypeStars
}

// The payment form is for a payment in Telegram Stars for subscription
type PaymentFormTypeStarSubscription struct {
	meta
	// Information about subscription plan
	Pricing *StarSubscriptionPricing `json:"pricing"`
}

func (entity *PaymentFormTypeStarSubscription) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentFormTypeStarSubscription

	return json.Marshal((*stub)(entity))
}

func (*PaymentFormTypeStarSubscription) GetClass() string {
	return ClassPaymentFormType
}

func (*PaymentFormTypeStarSubscription) GetType() string {
	return TypePaymentFormTypeStarSubscription
}

func (*PaymentFormTypeStarSubscription) PaymentFormTypeType() string {
	return TypePaymentFormTypeStarSubscription
}

// Contains information about an invoice payment form
type PaymentForm struct {
	meta
	// The payment form identifier
	Id JsonInt64 `json:"id"`
	// Type of the payment form
	Type PaymentFormType `json:"type"`
	// User identifier of the seller bot
	SellerBotUserId int64 `json:"seller_bot_user_id"`
	// Information about the product
	ProductInfo *ProductInfo `json:"product_info"`
}

func (entity *PaymentForm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentForm

	return json.Marshal((*stub)(entity))
}

func (*PaymentForm) GetClass() string {
	return ClassPaymentForm
}

func (*PaymentForm) GetType() string {
	return TypePaymentForm
}

func (paymentForm *PaymentForm) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id              JsonInt64       `json:"id"`
		Type            json.RawMessage `json:"type"`
		SellerBotUserId int64           `json:"seller_bot_user_id"`
		ProductInfo     *ProductInfo    `json:"product_info"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	paymentForm.Id = tmp.Id
	paymentForm.SellerBotUserId = tmp.SellerBotUserId
	paymentForm.ProductInfo = tmp.ProductInfo

	fieldType, _ := UnmarshalPaymentFormType(tmp.Type)
	paymentForm.Type = fieldType

	return nil
}

// Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options
type ValidatedOrderInfo struct {
	meta
	// Temporary identifier of the order information
	OrderInfoId string `json:"order_info_id"`
	// Available shipping options
	ShippingOptions []*ShippingOption `json:"shipping_options"`
}

func (entity *ValidatedOrderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ValidatedOrderInfo

	return json.Marshal((*stub)(entity))
}

func (*ValidatedOrderInfo) GetClass() string {
	return ClassValidatedOrderInfo
}

func (*ValidatedOrderInfo) GetType() string {
	return TypeValidatedOrderInfo
}

// Contains the result of a payment request
type PaymentResult struct {
	meta
	// True, if the payment request was successful; otherwise, the verification_url will be non-empty
	Success bool `json:"success"`
	// URL for additional payment credentials verification
	VerificationUrl string `json:"verification_url"`
}

func (entity *PaymentResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentResult

	return json.Marshal((*stub)(entity))
}

func (*PaymentResult) GetClass() string {
	return ClassPaymentResult
}

func (*PaymentResult) GetType() string {
	return TypePaymentResult
}

// The payment was done using a third-party payment provider
type PaymentReceiptTypeRegular struct {
	meta
	// User identifier of the payment provider bot
	PaymentProviderUserId int64 `json:"payment_provider_user_id"`
	// Information about the invoice
	Invoice *Invoice `json:"invoice"`
	// Order information; may be null
	OrderInfo *OrderInfo `json:"order_info"`
	// Chosen shipping option; may be null
	ShippingOption *ShippingOption `json:"shipping_option"`
	// Title of the saved credentials chosen by the buyer
	CredentialsTitle string `json:"credentials_title"`
	// The amount of tip chosen by the buyer in the smallest units of the currency
	TipAmount int64 `json:"tip_amount"`
}

func (entity *PaymentReceiptTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentReceiptTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*PaymentReceiptTypeRegular) GetClass() string {
	return ClassPaymentReceiptType
}

func (*PaymentReceiptTypeRegular) GetType() string {
	return TypePaymentReceiptTypeRegular
}

func (*PaymentReceiptTypeRegular) PaymentReceiptTypeType() string {
	return TypePaymentReceiptTypeRegular
}

// The payment was done using Telegram Stars
type PaymentReceiptTypeStars struct {
	meta
	// Number of Telegram Stars that were paid
	StarCount int64 `json:"star_count"`
	// Unique identifier of the transaction that can be used to dispute it
	TransactionId string `json:"transaction_id"`
}

func (entity *PaymentReceiptTypeStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentReceiptTypeStars

	return json.Marshal((*stub)(entity))
}

func (*PaymentReceiptTypeStars) GetClass() string {
	return ClassPaymentReceiptType
}

func (*PaymentReceiptTypeStars) GetType() string {
	return TypePaymentReceiptTypeStars
}

func (*PaymentReceiptTypeStars) PaymentReceiptTypeType() string {
	return TypePaymentReceiptTypeStars
}

// Contains information about a successful payment
type PaymentReceipt struct {
	meta
	// Information about the product
	ProductInfo *ProductInfo `json:"product_info"`
	// Point in time (Unix timestamp) when the payment was made
	Date int32 `json:"date"`
	// User identifier of the seller bot
	SellerBotUserId int64 `json:"seller_bot_user_id"`
	// Type of the payment receipt
	Type PaymentReceiptType `json:"type"`
}

func (entity *PaymentReceipt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentReceipt

	return json.Marshal((*stub)(entity))
}

func (*PaymentReceipt) GetClass() string {
	return ClassPaymentReceipt
}

func (*PaymentReceipt) GetType() string {
	return TypePaymentReceipt
}

func (paymentReceipt *PaymentReceipt) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ProductInfo     *ProductInfo    `json:"product_info"`
		Date            int32           `json:"date"`
		SellerBotUserId int64           `json:"seller_bot_user_id"`
		Type            json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	paymentReceipt.ProductInfo = tmp.ProductInfo
	paymentReceipt.Date = tmp.Date
	paymentReceipt.SellerBotUserId = tmp.SellerBotUserId

	fieldType, _ := UnmarshalPaymentReceiptType(tmp.Type)
	paymentReceipt.Type = fieldType

	return nil
}

// An invoice from a message of the type messageInvoice or paid media purchase from messagePaidMedia
type InputInvoiceMessage struct {
	meta
	// Chat identifier of the message
	ChatId int64 `json:"chat_id"`
	// Message identifier. Use messageProperties.can_be_paid to check whether the message can be used in the method
	MessageId int64 `json:"message_id"`
}

func (entity *InputInvoiceMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInvoiceMessage

	return json.Marshal((*stub)(entity))
}

func (*InputInvoiceMessage) GetClass() string {
	return ClassInputInvoice
}

func (*InputInvoiceMessage) GetType() string {
	return TypeInputInvoiceMessage
}

func (*InputInvoiceMessage) InputInvoiceType() string {
	return TypeInputInvoiceMessage
}

// An invoice from a link of the type internalLinkTypeInvoice
type InputInvoiceName struct {
	meta
	// Name of the invoice
	Name string `json:"name"`
}

func (entity *InputInvoiceName) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInvoiceName

	return json.Marshal((*stub)(entity))
}

func (*InputInvoiceName) GetClass() string {
	return ClassInputInvoice
}

func (*InputInvoiceName) GetType() string {
	return TypeInputInvoiceName
}

func (*InputInvoiceName) InputInvoiceType() string {
	return TypeInputInvoiceName
}

// An invoice for a payment toward Telegram; must not be used in the in-store apps
type InputInvoiceTelegram struct {
	meta
	// Transaction purpose
	Purpose TelegramPaymentPurpose `json:"purpose"`
}

func (entity *InputInvoiceTelegram) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInvoiceTelegram

	return json.Marshal((*stub)(entity))
}

func (*InputInvoiceTelegram) GetClass() string {
	return ClassInputInvoice
}

func (*InputInvoiceTelegram) GetType() string {
	return TypeInputInvoiceTelegram
}

func (*InputInvoiceTelegram) InputInvoiceType() string {
	return TypeInputInvoiceTelegram
}

func (inputInvoiceTelegram *InputInvoiceTelegram) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Purpose json.RawMessage `json:"purpose"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldPurpose, _ := UnmarshalTelegramPaymentPurpose(tmp.Purpose)
	inputInvoiceTelegram.Purpose = fieldPurpose

	return nil
}

// The media is hidden until the invoice is paid
type PaidMediaPreview struct {
	meta
	// Media width; 0 if unknown
	Width int32 `json:"width"`
	// Media height; 0 if unknown
	Height int32 `json:"height"`
	// Media duration, in seconds; 0 if unknown
	Duration int32 `json:"duration"`
	// Media minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
}

func (entity *PaidMediaPreview) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaidMediaPreview

	return json.Marshal((*stub)(entity))
}

func (*PaidMediaPreview) GetClass() string {
	return ClassPaidMedia
}

func (*PaidMediaPreview) GetType() string {
	return TypePaidMediaPreview
}

func (*PaidMediaPreview) PaidMediaType() string {
	return TypePaidMediaPreview
}

// The media is a photo
type PaidMediaPhoto struct {
	meta
	// The photo
	Photo *Photo `json:"photo"`
}

func (entity *PaidMediaPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaidMediaPhoto

	return json.Marshal((*stub)(entity))
}

func (*PaidMediaPhoto) GetClass() string {
	return ClassPaidMedia
}

func (*PaidMediaPhoto) GetType() string {
	return TypePaidMediaPhoto
}

func (*PaidMediaPhoto) PaidMediaType() string {
	return TypePaidMediaPhoto
}

// The media is a video
type PaidMediaVideo struct {
	meta
	// The video
	Video *Video `json:"video"`
}

func (entity *PaidMediaVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaidMediaVideo

	return json.Marshal((*stub)(entity))
}

func (*PaidMediaVideo) GetClass() string {
	return ClassPaidMedia
}

func (*PaidMediaVideo) GetType() string {
	return TypePaidMediaVideo
}

func (*PaidMediaVideo) PaidMediaType() string {
	return TypePaidMediaVideo
}

// The media is unsupported
type PaidMediaUnsupported struct {
	meta
}

func (entity *PaidMediaUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaidMediaUnsupported

	return json.Marshal((*stub)(entity))
}

func (*PaidMediaUnsupported) GetClass() string {
	return ClassPaidMedia
}

func (*PaidMediaUnsupported) GetType() string {
	return TypePaidMediaUnsupported
}

func (*PaidMediaUnsupported) PaidMediaType() string {
	return TypePaidMediaUnsupported
}

// Describes parameters of a giveaway
type GiveawayParameters struct {
	meta
	// Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time. If the chat is a channel, then can_post_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup
	BoostedChatId int64 `json:"boosted_chat_id"`
	// Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
	AdditionalChatIds []int64 `json:"additional_chat_ids"`
	// Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
	WinnersSelectionDate int32 `json:"winners_selection_date"`
	// True, if only new members of the chats will be eligible for the giveaway
	OnlyNewMembers bool `json:"only_new_members"`
	// True, if the list of winners of the giveaway will be available to everyone
	HasPublicWinners bool `json:"has_public_winners"`
	// The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway. There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought at https://fragment.com can participate in any giveaway and the country code "FT" must not be specified in the list
	CountryCodes []string `json:"country_codes"`
	// Additional description of the giveaway prize; 0-128 characters
	PrizeDescription string `json:"prize_description"`
}

func (entity *GiveawayParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GiveawayParameters

	return json.Marshal((*stub)(entity))
}

func (*GiveawayParameters) GetClass() string {
	return ClassGiveawayParameters
}

func (*GiveawayParameters) GetType() string {
	return TypeGiveawayParameters
}

// File with the date it was uploaded
type DatedFile struct {
	meta
	// The file
	File *File `json:"file"`
	// Point in time (Unix timestamp) when the file was uploaded
	Date int32 `json:"date"`
}

func (entity *DatedFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DatedFile

	return json.Marshal((*stub)(entity))
}

func (*DatedFile) GetClass() string {
	return ClassDatedFile
}

func (*DatedFile) GetType() string {
	return TypeDatedFile
}

// A Telegram Passport element containing the user's personal details
type PassportElementTypePersonalDetails struct {
	meta
}

func (entity *PassportElementTypePersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePersonalDetails) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePersonalDetails) GetType() string {
	return TypePassportElementTypePersonalDetails
}

func (*PassportElementTypePersonalDetails) PassportElementTypeType() string {
	return TypePassportElementTypePersonalDetails
}

// A Telegram Passport element containing the user's passport
type PassportElementTypePassport struct {
	meta
}

func (entity *PassportElementTypePassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePassport) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePassport) GetType() string {
	return TypePassportElementTypePassport
}

func (*PassportElementTypePassport) PassportElementTypeType() string {
	return TypePassportElementTypePassport
}

// A Telegram Passport element containing the user's driver license
type PassportElementTypeDriverLicense struct {
	meta
}

func (entity *PassportElementTypeDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeDriverLicense) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeDriverLicense) GetType() string {
	return TypePassportElementTypeDriverLicense
}

func (*PassportElementTypeDriverLicense) PassportElementTypeType() string {
	return TypePassportElementTypeDriverLicense
}

// A Telegram Passport element containing the user's identity card
type PassportElementTypeIdentityCard struct {
	meta
}

func (entity *PassportElementTypeIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeIdentityCard) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeIdentityCard) GetType() string {
	return TypePassportElementTypeIdentityCard
}

func (*PassportElementTypeIdentityCard) PassportElementTypeType() string {
	return TypePassportElementTypeIdentityCard
}

// A Telegram Passport element containing the user's internal passport
type PassportElementTypeInternalPassport struct {
	meta
}

func (entity *PassportElementTypeInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeInternalPassport) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeInternalPassport) GetType() string {
	return TypePassportElementTypeInternalPassport
}

func (*PassportElementTypeInternalPassport) PassportElementTypeType() string {
	return TypePassportElementTypeInternalPassport
}

// A Telegram Passport element containing the user's address
type PassportElementTypeAddress struct {
	meta
}

func (entity *PassportElementTypeAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeAddress) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeAddress) GetType() string {
	return TypePassportElementTypeAddress
}

func (*PassportElementTypeAddress) PassportElementTypeType() string {
	return TypePassportElementTypeAddress
}

// A Telegram Passport element containing the user's utility bill
type PassportElementTypeUtilityBill struct {
	meta
}

func (entity *PassportElementTypeUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeUtilityBill) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeUtilityBill) GetType() string {
	return TypePassportElementTypeUtilityBill
}

func (*PassportElementTypeUtilityBill) PassportElementTypeType() string {
	return TypePassportElementTypeUtilityBill
}

// A Telegram Passport element containing the user's bank statement
type PassportElementTypeBankStatement struct {
	meta
}

func (entity *PassportElementTypeBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeBankStatement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeBankStatement) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeBankStatement) GetType() string {
	return TypePassportElementTypeBankStatement
}

func (*PassportElementTypeBankStatement) PassportElementTypeType() string {
	return TypePassportElementTypeBankStatement
}

// A Telegram Passport element containing the user's rental agreement
type PassportElementTypeRentalAgreement struct {
	meta
}

func (entity *PassportElementTypeRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeRentalAgreement) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeRentalAgreement) GetType() string {
	return TypePassportElementTypeRentalAgreement
}

func (*PassportElementTypeRentalAgreement) PassportElementTypeType() string {
	return TypePassportElementTypeRentalAgreement
}

// A Telegram Passport element containing the registration page of the user's passport
type PassportElementTypePassportRegistration struct {
	meta
}

func (entity *PassportElementTypePassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePassportRegistration) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePassportRegistration) GetType() string {
	return TypePassportElementTypePassportRegistration
}

func (*PassportElementTypePassportRegistration) PassportElementTypeType() string {
	return TypePassportElementTypePassportRegistration
}

// A Telegram Passport element containing the user's temporary registration
type PassportElementTypeTemporaryRegistration struct {
	meta
}

func (entity *PassportElementTypeTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeTemporaryRegistration) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeTemporaryRegistration) GetType() string {
	return TypePassportElementTypeTemporaryRegistration
}

func (*PassportElementTypeTemporaryRegistration) PassportElementTypeType() string {
	return TypePassportElementTypeTemporaryRegistration
}

// A Telegram Passport element containing the user's phone number
type PassportElementTypePhoneNumber struct {
	meta
}

func (entity *PassportElementTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePhoneNumber) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePhoneNumber) GetType() string {
	return TypePassportElementTypePhoneNumber
}

func (*PassportElementTypePhoneNumber) PassportElementTypeType() string {
	return TypePassportElementTypePhoneNumber
}

// A Telegram Passport element containing the user's email address
type PassportElementTypeEmailAddress struct {
	meta
}

func (entity *PassportElementTypeEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeEmailAddress) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeEmailAddress) GetType() string {
	return TypePassportElementTypeEmailAddress
}

func (*PassportElementTypeEmailAddress) PassportElementTypeType() string {
	return TypePassportElementTypeEmailAddress
}

// Represents a date according to the Gregorian calendar
type Date struct {
	meta
	// Day of the month; 1-31
	Day int32 `json:"day"`
	// Month; 1-12
	Month int32 `json:"month"`
	// Year; 1-9999
	Year int32 `json:"year"`
}

func (entity *Date) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Date

	return json.Marshal((*stub)(entity))
}

func (*Date) GetClass() string {
	return ClassDate
}

func (*Date) GetType() string {
	return TypeDate
}

// Contains the user's personal details
type PersonalDetails struct {
	meta
	// First name of the user written in English; 1-255 characters
	FirstName string `json:"first_name"`
	// Middle name of the user written in English; 0-255 characters
	MiddleName string `json:"middle_name"`
	// Last name of the user written in English; 1-255 characters
	LastName string `json:"last_name"`
	// Native first name of the user; 1-255 characters
	NativeFirstName string `json:"native_first_name"`
	// Native middle name of the user; 0-255 characters
	NativeMiddleName string `json:"native_middle_name"`
	// Native last name of the user; 1-255 characters
	NativeLastName string `json:"native_last_name"`
	// Birthdate of the user
	Birthdate *Date `json:"birthdate"`
	// Gender of the user, "male" or "female"
	Gender string `json:"gender"`
	// A two-letter ISO 3166-1 alpha-2 country code of the user's country
	CountryCode string `json:"country_code"`
	// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
	ResidenceCountryCode string `json:"residence_country_code"`
}

func (entity *PersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PersonalDetails) GetClass() string {
	return ClassPersonalDetails
}

func (*PersonalDetails) GetType() string {
	return TypePersonalDetails
}

// An identity document
type IdentityDocument struct {
	meta
	// Document number; 1-24 characters
	Number string `json:"number"`
	// Document expiration date; may be null if not applicable
	ExpirationDate *Date `json:"expiration_date"`
	// Front side of the document
	FrontSide *DatedFile `json:"front_side"`
	// Reverse side of the document; only for driver license and identity card; may be null
	ReverseSide *DatedFile `json:"reverse_side"`
	// Selfie with the document; may be null
	Selfie *DatedFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
}

func (entity *IdentityDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub IdentityDocument

	return json.Marshal((*stub)(entity))
}

func (*IdentityDocument) GetClass() string {
	return ClassIdentityDocument
}

func (*IdentityDocument) GetType() string {
	return TypeIdentityDocument
}

// An identity document to be saved to Telegram Passport
type InputIdentityDocument struct {
	meta
	// Document number; 1-24 characters
	Number string `json:"number"`
	// Document expiration date; pass null if not applicable
	ExpirationDate *Date `json:"expiration_date"`
	// Front side of the document
	FrontSide InputFile `json:"front_side"`
	// Reverse side of the document; only for driver license and identity card; pass null otherwise
	ReverseSide InputFile `json:"reverse_side"`
	// Selfie with the document; pass null if unavailable
	Selfie InputFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []InputFile `json:"translation"`
}

func (entity *InputIdentityDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputIdentityDocument

	return json.Marshal((*stub)(entity))
}

func (*InputIdentityDocument) GetClass() string {
	return ClassInputIdentityDocument
}

func (*InputIdentityDocument) GetType() string {
	return TypeInputIdentityDocument
}

func (inputIdentityDocument *InputIdentityDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Number         string            `json:"number"`
		ExpirationDate *Date             `json:"expiration_date"`
		FrontSide      json.RawMessage   `json:"front_side"`
		ReverseSide    json.RawMessage   `json:"reverse_side"`
		Selfie         json.RawMessage   `json:"selfie"`
		Translation    []json.RawMessage `json:"translation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputIdentityDocument.Number = tmp.Number
	inputIdentityDocument.ExpirationDate = tmp.ExpirationDate

	fieldFrontSide, _ := UnmarshalInputFile(tmp.FrontSide)
	inputIdentityDocument.FrontSide = fieldFrontSide

	fieldReverseSide, _ := UnmarshalInputFile(tmp.ReverseSide)
	inputIdentityDocument.ReverseSide = fieldReverseSide

	fieldSelfie, _ := UnmarshalInputFile(tmp.Selfie)
	inputIdentityDocument.Selfie = fieldSelfie

	fieldTranslation, _ := UnmarshalListOfInputFile(tmp.Translation)
	inputIdentityDocument.Translation = fieldTranslation

	return nil
}

// A personal document, containing some information about a user
type PersonalDocument struct {
	meta
	// List of files containing the pages of the document
	Files []*DatedFile `json:"files"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
}

func (entity *PersonalDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PersonalDocument

	return json.Marshal((*stub)(entity))
}

func (*PersonalDocument) GetClass() string {
	return ClassPersonalDocument
}

func (*PersonalDocument) GetType() string {
	return TypePersonalDocument
}

// A personal document to be saved to Telegram Passport
type InputPersonalDocument struct {
	meta
	// List of files containing the pages of the document
	Files []InputFile `json:"files"`
	// List of files containing a certified English translation of the document
	Translation []InputFile `json:"translation"`
}

func (entity *InputPersonalDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPersonalDocument

	return json.Marshal((*stub)(entity))
}

func (*InputPersonalDocument) GetClass() string {
	return ClassInputPersonalDocument
}

func (*InputPersonalDocument) GetType() string {
	return TypeInputPersonalDocument
}

func (inputPersonalDocument *InputPersonalDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Files       []json.RawMessage `json:"files"`
		Translation []json.RawMessage `json:"translation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFiles, _ := UnmarshalListOfInputFile(tmp.Files)
	inputPersonalDocument.Files = fieldFiles

	fieldTranslation, _ := UnmarshalListOfInputFile(tmp.Translation)
	inputPersonalDocument.Translation = fieldTranslation

	return nil
}

// A Telegram Passport element containing the user's personal details
type PassportElementPersonalDetails struct {
	meta
	// Personal details of the user
	PersonalDetails *PersonalDetails `json:"personal_details"`
}

func (entity *PassportElementPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPersonalDetails) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPersonalDetails) GetType() string {
	return TypePassportElementPersonalDetails
}

func (*PassportElementPersonalDetails) PassportElementType() string {
	return TypePassportElementPersonalDetails
}

// A Telegram Passport element containing the user's passport
type PassportElementPassport struct {
	meta
	// Passport
	Passport *IdentityDocument `json:"passport"`
}

func (entity *PassportElementPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPassport) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPassport) GetType() string {
	return TypePassportElementPassport
}

func (*PassportElementPassport) PassportElementType() string {
	return TypePassportElementPassport
}

// A Telegram Passport element containing the user's driver license
type PassportElementDriverLicense struct {
	meta
	// Driver license
	DriverLicense *IdentityDocument `json:"driver_license"`
}

func (entity *PassportElementDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*PassportElementDriverLicense) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementDriverLicense) GetType() string {
	return TypePassportElementDriverLicense
}

func (*PassportElementDriverLicense) PassportElementType() string {
	return TypePassportElementDriverLicense
}

// A Telegram Passport element containing the user's identity card
type PassportElementIdentityCard struct {
	meta
	// Identity card
	IdentityCard *IdentityDocument `json:"identity_card"`
}

func (entity *PassportElementIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*PassportElementIdentityCard) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementIdentityCard) GetType() string {
	return TypePassportElementIdentityCard
}

func (*PassportElementIdentityCard) PassportElementType() string {
	return TypePassportElementIdentityCard
}

// A Telegram Passport element containing the user's internal passport
type PassportElementInternalPassport struct {
	meta
	// Internal passport
	InternalPassport *IdentityDocument `json:"internal_passport"`
}

func (entity *PassportElementInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementInternalPassport) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementInternalPassport) GetType() string {
	return TypePassportElementInternalPassport
}

func (*PassportElementInternalPassport) PassportElementType() string {
	return TypePassportElementInternalPassport
}

// A Telegram Passport element containing the user's address
type PassportElementAddress struct {
	meta
	// Address
	Address *Address `json:"address"`
}

func (entity *PassportElementAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementAddress) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementAddress) GetType() string {
	return TypePassportElementAddress
}

func (*PassportElementAddress) PassportElementType() string {
	return TypePassportElementAddress
}

// A Telegram Passport element containing the user's utility bill
type PassportElementUtilityBill struct {
	meta
	// Utility bill
	UtilityBill *PersonalDocument `json:"utility_bill"`
}

func (entity *PassportElementUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*PassportElementUtilityBill) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementUtilityBill) GetType() string {
	return TypePassportElementUtilityBill
}

func (*PassportElementUtilityBill) PassportElementType() string {
	return TypePassportElementUtilityBill
}

// A Telegram Passport element containing the user's bank statement
type PassportElementBankStatement struct {
	meta
	// Bank statement
	BankStatement *PersonalDocument `json:"bank_statement"`
}

func (entity *PassportElementBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementBankStatement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementBankStatement) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementBankStatement) GetType() string {
	return TypePassportElementBankStatement
}

func (*PassportElementBankStatement) PassportElementType() string {
	return TypePassportElementBankStatement
}

// A Telegram Passport element containing the user's rental agreement
type PassportElementRentalAgreement struct {
	meta
	// Rental agreement
	RentalAgreement *PersonalDocument `json:"rental_agreement"`
}

func (entity *PassportElementRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementRentalAgreement) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementRentalAgreement) GetType() string {
	return TypePassportElementRentalAgreement
}

func (*PassportElementRentalAgreement) PassportElementType() string {
	return TypePassportElementRentalAgreement
}

// A Telegram Passport element containing the user's passport registration pages
type PassportElementPassportRegistration struct {
	meta
	// Passport registration pages
	PassportRegistration *PersonalDocument `json:"passport_registration"`
}

func (entity *PassportElementPassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPassportRegistration) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPassportRegistration) GetType() string {
	return TypePassportElementPassportRegistration
}

func (*PassportElementPassportRegistration) PassportElementType() string {
	return TypePassportElementPassportRegistration
}

// A Telegram Passport element containing the user's temporary registration
type PassportElementTemporaryRegistration struct {
	meta
	// Temporary registration
	TemporaryRegistration *PersonalDocument `json:"temporary_registration"`
}

func (entity *PassportElementTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTemporaryRegistration) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementTemporaryRegistration) GetType() string {
	return TypePassportElementTemporaryRegistration
}

func (*PassportElementTemporaryRegistration) PassportElementType() string {
	return TypePassportElementTemporaryRegistration
}

// A Telegram Passport element containing the user's phone number
type PassportElementPhoneNumber struct {
	meta
	// Phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *PassportElementPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPhoneNumber) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPhoneNumber) GetType() string {
	return TypePassportElementPhoneNumber
}

func (*PassportElementPhoneNumber) PassportElementType() string {
	return TypePassportElementPhoneNumber
}

// A Telegram Passport element containing the user's email address
type PassportElementEmailAddress struct {
	meta
	// Email address
	EmailAddress string `json:"email_address"`
}

func (entity *PassportElementEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementEmailAddress) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementEmailAddress) GetType() string {
	return TypePassportElementEmailAddress
}

func (*PassportElementEmailAddress) PassportElementType() string {
	return TypePassportElementEmailAddress
}

// A Telegram Passport element to be saved containing the user's personal details
type InputPassportElementPersonalDetails struct {
	meta
	// Personal details of the user
	PersonalDetails *PersonalDetails `json:"personal_details"`
}

func (entity *InputPassportElementPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPersonalDetails) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPersonalDetails) GetType() string {
	return TypeInputPassportElementPersonalDetails
}

func (*InputPassportElementPersonalDetails) InputPassportElementType() string {
	return TypeInputPassportElementPersonalDetails
}

// A Telegram Passport element to be saved containing the user's passport
type InputPassportElementPassport struct {
	meta
	// The passport to be saved
	Passport *InputIdentityDocument `json:"passport"`
}

func (entity *InputPassportElementPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPassport

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPassport) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPassport) GetType() string {
	return TypeInputPassportElementPassport
}

func (*InputPassportElementPassport) InputPassportElementType() string {
	return TypeInputPassportElementPassport
}

// A Telegram Passport element to be saved containing the user's driver license
type InputPassportElementDriverLicense struct {
	meta
	// The driver license to be saved
	DriverLicense *InputIdentityDocument `json:"driver_license"`
}

func (entity *InputPassportElementDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementDriverLicense) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementDriverLicense) GetType() string {
	return TypeInputPassportElementDriverLicense
}

func (*InputPassportElementDriverLicense) InputPassportElementType() string {
	return TypeInputPassportElementDriverLicense
}

// A Telegram Passport element to be saved containing the user's identity card
type InputPassportElementIdentityCard struct {
	meta
	// The identity card to be saved
	IdentityCard *InputIdentityDocument `json:"identity_card"`
}

func (entity *InputPassportElementIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementIdentityCard) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementIdentityCard) GetType() string {
	return TypeInputPassportElementIdentityCard
}

func (*InputPassportElementIdentityCard) InputPassportElementType() string {
	return TypeInputPassportElementIdentityCard
}

// A Telegram Passport element to be saved containing the user's internal passport
type InputPassportElementInternalPassport struct {
	meta
	// The internal passport to be saved
	InternalPassport *InputIdentityDocument `json:"internal_passport"`
}

func (entity *InputPassportElementInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementInternalPassport) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementInternalPassport) GetType() string {
	return TypeInputPassportElementInternalPassport
}

func (*InputPassportElementInternalPassport) InputPassportElementType() string {
	return TypeInputPassportElementInternalPassport
}

// A Telegram Passport element to be saved containing the user's address
type InputPassportElementAddress struct {
	meta
	// The address to be saved
	Address *Address `json:"address"`
}

func (entity *InputPassportElementAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementAddress

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementAddress) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementAddress) GetType() string {
	return TypeInputPassportElementAddress
}

func (*InputPassportElementAddress) InputPassportElementType() string {
	return TypeInputPassportElementAddress
}

// A Telegram Passport element to be saved containing the user's utility bill
type InputPassportElementUtilityBill struct {
	meta
	// The utility bill to be saved
	UtilityBill *InputPersonalDocument `json:"utility_bill"`
}

func (entity *InputPassportElementUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementUtilityBill) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementUtilityBill) GetType() string {
	return TypeInputPassportElementUtilityBill
}

func (*InputPassportElementUtilityBill) InputPassportElementType() string {
	return TypeInputPassportElementUtilityBill
}

// A Telegram Passport element to be saved containing the user's bank statement
type InputPassportElementBankStatement struct {
	meta
	// The bank statement to be saved
	BankStatement *InputPersonalDocument `json:"bank_statement"`
}

func (entity *InputPassportElementBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementBankStatement

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementBankStatement) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementBankStatement) GetType() string {
	return TypeInputPassportElementBankStatement
}

func (*InputPassportElementBankStatement) InputPassportElementType() string {
	return TypeInputPassportElementBankStatement
}

// A Telegram Passport element to be saved containing the user's rental agreement
type InputPassportElementRentalAgreement struct {
	meta
	// The rental agreement to be saved
	RentalAgreement *InputPersonalDocument `json:"rental_agreement"`
}

func (entity *InputPassportElementRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementRentalAgreement) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementRentalAgreement) GetType() string {
	return TypeInputPassportElementRentalAgreement
}

func (*InputPassportElementRentalAgreement) InputPassportElementType() string {
	return TypeInputPassportElementRentalAgreement
}

// A Telegram Passport element to be saved containing the user's passport registration
type InputPassportElementPassportRegistration struct {
	meta
	// The passport registration page to be saved
	PassportRegistration *InputPersonalDocument `json:"passport_registration"`
}

func (entity *InputPassportElementPassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPassportRegistration) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPassportRegistration) GetType() string {
	return TypeInputPassportElementPassportRegistration
}

func (*InputPassportElementPassportRegistration) InputPassportElementType() string {
	return TypeInputPassportElementPassportRegistration
}

// A Telegram Passport element to be saved containing the user's temporary registration
type InputPassportElementTemporaryRegistration struct {
	meta
	// The temporary registration document to be saved
	TemporaryRegistration *InputPersonalDocument `json:"temporary_registration"`
}

func (entity *InputPassportElementTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementTemporaryRegistration) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementTemporaryRegistration) GetType() string {
	return TypeInputPassportElementTemporaryRegistration
}

func (*InputPassportElementTemporaryRegistration) InputPassportElementType() string {
	return TypeInputPassportElementTemporaryRegistration
}

// A Telegram Passport element to be saved containing the user's phone number
type InputPassportElementPhoneNumber struct {
	meta
	// The phone number to be saved
	PhoneNumber string `json:"phone_number"`
}

func (entity *InputPassportElementPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPhoneNumber) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPhoneNumber) GetType() string {
	return TypeInputPassportElementPhoneNumber
}

func (*InputPassportElementPhoneNumber) InputPassportElementType() string {
	return TypeInputPassportElementPhoneNumber
}

// A Telegram Passport element to be saved containing the user's email address
type InputPassportElementEmailAddress struct {
	meta
	// The email address to be saved
	EmailAddress string `json:"email_address"`
}

func (entity *InputPassportElementEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementEmailAddress) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementEmailAddress) GetType() string {
	return TypeInputPassportElementEmailAddress
}

func (*InputPassportElementEmailAddress) InputPassportElementType() string {
	return TypeInputPassportElementEmailAddress
}

// Contains information about saved Telegram Passport elements
type PassportElements struct {
	meta
	// Telegram Passport elements
	Elements []PassportElement `json:"elements"`
}

func (entity *PassportElements) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElements

	return json.Marshal((*stub)(entity))
}

func (*PassportElements) GetClass() string {
	return ClassPassportElements
}

func (*PassportElements) GetType() string {
	return TypePassportElements
}

func (passportElements *PassportElements) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Elements []json.RawMessage `json:"elements"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldElements, _ := UnmarshalListOfPassportElement(tmp.Elements)
	passportElements.Elements = fieldElements

	return nil
}

// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type PassportElementErrorSourceUnspecified struct {
	meta
}

func (entity *PassportElementErrorSourceUnspecified) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceUnspecified

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceUnspecified) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceUnspecified) GetType() string {
	return TypePassportElementErrorSourceUnspecified
}

func (*PassportElementErrorSourceUnspecified) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceUnspecified
}

// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
type PassportElementErrorSourceDataField struct {
	meta
	// Field name
	FieldName string `json:"field_name"`
}

func (entity *PassportElementErrorSourceDataField) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceDataField

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceDataField) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceDataField) GetType() string {
	return TypePassportElementErrorSourceDataField
}

func (*PassportElementErrorSourceDataField) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceDataField
}

// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
type PassportElementErrorSourceFrontSide struct {
	meta
}

func (entity *PassportElementErrorSourceFrontSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFrontSide

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFrontSide) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFrontSide) GetType() string {
	return TypePassportElementErrorSourceFrontSide
}

func (*PassportElementErrorSourceFrontSide) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFrontSide
}

// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
type PassportElementErrorSourceReverseSide struct {
	meta
}

func (entity *PassportElementErrorSourceReverseSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceReverseSide

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceReverseSide) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceReverseSide) GetType() string {
	return TypePassportElementErrorSourceReverseSide
}

func (*PassportElementErrorSourceReverseSide) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceReverseSide
}

// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
type PassportElementErrorSourceSelfie struct {
	meta
}

func (entity *PassportElementErrorSourceSelfie) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceSelfie

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceSelfie) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceSelfie) GetType() string {
	return TypePassportElementErrorSourceSelfie
}

func (*PassportElementErrorSourceSelfie) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceSelfie
}

// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceTranslationFile struct {
	meta
	// Index of a file with the error
	FileIndex int32 `json:"file_index"`
}

func (entity *PassportElementErrorSourceTranslationFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceTranslationFile

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceTranslationFile) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceTranslationFile) GetType() string {
	return TypePassportElementErrorSourceTranslationFile
}

func (*PassportElementErrorSourceTranslationFile) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceTranslationFile
}

// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
type PassportElementErrorSourceTranslationFiles struct {
	meta
}

func (entity *PassportElementErrorSourceTranslationFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceTranslationFiles

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceTranslationFiles) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceTranslationFiles) GetType() string {
	return TypePassportElementErrorSourceTranslationFiles
}

func (*PassportElementErrorSourceTranslationFiles) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceTranslationFiles
}

// The file contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceFile struct {
	meta
	// Index of a file with the error
	FileIndex int32 `json:"file_index"`
}

func (entity *PassportElementErrorSourceFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFile

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFile) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFile) GetType() string {
	return TypePassportElementErrorSourceFile
}

func (*PassportElementErrorSourceFile) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFile
}

// The list of attached files contains an error. The error will be considered resolved when the list of files changes
type PassportElementErrorSourceFiles struct {
	meta
}

func (entity *PassportElementErrorSourceFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFiles

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFiles) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFiles) GetType() string {
	return TypePassportElementErrorSourceFiles
}

func (*PassportElementErrorSourceFiles) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFiles
}

// Contains the description of an error in a Telegram Passport element
type PassportElementError struct {
	meta
	// Type of the Telegram Passport element which has the error
	Type PassportElementType `json:"type"`
	// Error message
	Message string `json:"message"`
	// Error source
	Source PassportElementErrorSource `json:"source"`
}

func (entity *PassportElementError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementError

	return json.Marshal((*stub)(entity))
}

func (*PassportElementError) GetClass() string {
	return ClassPassportElementError
}

func (*PassportElementError) GetType() string {
	return TypePassportElementError
}

func (passportElementError *PassportElementError) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    json.RawMessage `json:"type"`
		Message string          `json:"message"`
		Source  json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportElementError.Message = tmp.Message

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	passportElementError.Type = fieldType

	fieldSource, _ := UnmarshalPassportElementErrorSource(tmp.Source)
	passportElementError.Source = fieldSource

	return nil
}

// Contains information about a Telegram Passport element that was requested by a service
type PassportSuitableElement struct {
	meta
	// Type of the element
	Type PassportElementType `json:"type"`
	// True, if a selfie is required with the identity document
	IsSelfieRequired bool `json:"is_selfie_required"`
	// True, if a certified English translation is required with the document
	IsTranslationRequired bool `json:"is_translation_required"`
	// True, if personal details must include the user's name in the language of their country of residence
	IsNativeNameRequired bool `json:"is_native_name_required"`
}

func (entity *PassportSuitableElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportSuitableElement

	return json.Marshal((*stub)(entity))
}

func (*PassportSuitableElement) GetClass() string {
	return ClassPassportSuitableElement
}

func (*PassportSuitableElement) GetType() string {
	return TypePassportSuitableElement
}

func (passportSuitableElement *PassportSuitableElement) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type                  json.RawMessage `json:"type"`
		IsSelfieRequired      bool            `json:"is_selfie_required"`
		IsTranslationRequired bool            `json:"is_translation_required"`
		IsNativeNameRequired  bool            `json:"is_native_name_required"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportSuitableElement.IsSelfieRequired = tmp.IsSelfieRequired
	passportSuitableElement.IsTranslationRequired = tmp.IsTranslationRequired
	passportSuitableElement.IsNativeNameRequired = tmp.IsNativeNameRequired

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	passportSuitableElement.Type = fieldType

	return nil
}

// Contains a description of the required Telegram Passport element that was requested by a service
type PassportRequiredElement struct {
	meta
	// List of Telegram Passport elements any of which is enough to provide
	SuitableElements []*PassportSuitableElement `json:"suitable_elements"`
}

func (entity *PassportRequiredElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportRequiredElement

	return json.Marshal((*stub)(entity))
}

func (*PassportRequiredElement) GetClass() string {
	return ClassPassportRequiredElement
}

func (*PassportRequiredElement) GetType() string {
	return TypePassportRequiredElement
}

// Contains information about a Telegram Passport authorization form that was requested
type PassportAuthorizationForm struct {
	meta
	// Unique identifier of the authorization form
	Id int32 `json:"id"`
	// Telegram Passport elements that must be provided to complete the form
	RequiredElements []*PassportRequiredElement `json:"required_elements"`
	// URL for the privacy policy of the service; may be empty
	PrivacyPolicyUrl string `json:"privacy_policy_url"`
}

func (entity *PassportAuthorizationForm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportAuthorizationForm

	return json.Marshal((*stub)(entity))
}

func (*PassportAuthorizationForm) GetClass() string {
	return ClassPassportAuthorizationForm
}

func (*PassportAuthorizationForm) GetType() string {
	return TypePassportAuthorizationForm
}

// Contains information about a Telegram Passport elements and corresponding errors
type PassportElementsWithErrors struct {
	meta
	// Telegram Passport elements
	Elements []PassportElement `json:"elements"`
	// Errors in the elements that are already available
	Errors []*PassportElementError `json:"errors"`
}

func (entity *PassportElementsWithErrors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementsWithErrors

	return json.Marshal((*stub)(entity))
}

func (*PassportElementsWithErrors) GetClass() string {
	return ClassPassportElementsWithErrors
}

func (*PassportElementsWithErrors) GetType() string {
	return TypePassportElementsWithErrors
}

func (passportElementsWithErrors *PassportElementsWithErrors) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Elements []json.RawMessage       `json:"elements"`
		Errors   []*PassportElementError `json:"errors"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportElementsWithErrors.Errors = tmp.Errors

	fieldElements, _ := UnmarshalListOfPassportElement(tmp.Elements)
	passportElementsWithErrors.Elements = fieldElements

	return nil
}

// Contains encrypted Telegram Passport data credentials
type EncryptedCredentials struct {
	meta
	// The encrypted credentials
	Data []byte `json:"data"`
	// The decrypted data hash
	Hash []byte `json:"hash"`
	// Secret for data decryption, encrypted with the service's public key
	Secret []byte `json:"secret"`
}

func (entity *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EncryptedCredentials

	return json.Marshal((*stub)(entity))
}

func (*EncryptedCredentials) GetClass() string {
	return ClassEncryptedCredentials
}

func (*EncryptedCredentials) GetType() string {
	return TypeEncryptedCredentials
}

// Contains information about an encrypted Telegram Passport element; for bots only
type EncryptedPassportElement struct {
	meta
	// Type of Telegram Passport element
	Type PassportElementType `json:"type"`
	// Encrypted JSON-encoded data about the user
	Data []byte `json:"data"`
	// The front side of an identity document
	FrontSide *DatedFile `json:"front_side"`
	// The reverse side of an identity document; may be null
	ReverseSide *DatedFile `json:"reverse_side"`
	// Selfie with the document; may be null
	Selfie *DatedFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
	// List of attached files
	Files []*DatedFile `json:"files"`
	// Unencrypted data, phone number or email address
	Value string `json:"value"`
	// Hash of the entire element
	Hash string `json:"hash"`
}

func (entity *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EncryptedPassportElement

	return json.Marshal((*stub)(entity))
}

func (*EncryptedPassportElement) GetClass() string {
	return ClassEncryptedPassportElement
}

func (*EncryptedPassportElement) GetType() string {
	return TypeEncryptedPassportElement
}

func (encryptedPassportElement *EncryptedPassportElement) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type        json.RawMessage `json:"type"`
		Data        []byte          `json:"data"`
		FrontSide   *DatedFile      `json:"front_side"`
		ReverseSide *DatedFile      `json:"reverse_side"`
		Selfie      *DatedFile      `json:"selfie"`
		Translation []*DatedFile    `json:"translation"`
		Files       []*DatedFile    `json:"files"`
		Value       string          `json:"value"`
		Hash        string          `json:"hash"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	encryptedPassportElement.Data = tmp.Data
	encryptedPassportElement.FrontSide = tmp.FrontSide
	encryptedPassportElement.ReverseSide = tmp.ReverseSide
	encryptedPassportElement.Selfie = tmp.Selfie
	encryptedPassportElement.Translation = tmp.Translation
	encryptedPassportElement.Files = tmp.Files
	encryptedPassportElement.Value = tmp.Value
	encryptedPassportElement.Hash = tmp.Hash

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	encryptedPassportElement.Type = fieldType

	return nil
}

// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type InputPassportElementErrorSourceUnspecified struct {
	meta
	// Current hash of the entire element
	ElementHash []byte `json:"element_hash"`
}

func (entity *InputPassportElementErrorSourceUnspecified) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceUnspecified

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceUnspecified) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceUnspecified) GetType() string {
	return TypeInputPassportElementErrorSourceUnspecified
}

func (*InputPassportElementErrorSourceUnspecified) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceUnspecified
}

// A data field contains an error. The error is considered resolved when the field's value changes
type InputPassportElementErrorSourceDataField struct {
	meta
	// Field name
	FieldName string `json:"field_name"`
	// Current data hash
	DataHash []byte `json:"data_hash"`
}

func (entity *InputPassportElementErrorSourceDataField) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceDataField

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceDataField) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceDataField) GetType() string {
	return TypeInputPassportElementErrorSourceDataField
}

func (*InputPassportElementErrorSourceDataField) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceDataField
}

// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
type InputPassportElementErrorSourceFrontSide struct {
	meta
	// Current hash of the file containing the front side
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceFrontSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFrontSide

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFrontSide) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFrontSide) GetType() string {
	return TypeInputPassportElementErrorSourceFrontSide
}

func (*InputPassportElementErrorSourceFrontSide) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFrontSide
}

// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
type InputPassportElementErrorSourceReverseSide struct {
	meta
	// Current hash of the file containing the reverse side
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceReverseSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceReverseSide

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceReverseSide) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceReverseSide) GetType() string {
	return TypeInputPassportElementErrorSourceReverseSide
}

func (*InputPassportElementErrorSourceReverseSide) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceReverseSide
}

// The selfie contains an error. The error is considered resolved when the file with the selfie changes
type InputPassportElementErrorSourceSelfie struct {
	meta
	// Current hash of the file containing the selfie
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceSelfie) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceSelfie

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceSelfie) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceSelfie) GetType() string {
	return TypeInputPassportElementErrorSourceSelfie
}

func (*InputPassportElementErrorSourceSelfie) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceSelfie
}

// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
type InputPassportElementErrorSourceTranslationFile struct {
	meta
	// Current hash of the file containing the translation
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceTranslationFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceTranslationFile

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceTranslationFile) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceTranslationFile) GetType() string {
	return TypeInputPassportElementErrorSourceTranslationFile
}

func (*InputPassportElementErrorSourceTranslationFile) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceTranslationFile
}

// The translation of the document contains an error. The error is considered resolved when the list of files changes
type InputPassportElementErrorSourceTranslationFiles struct {
	meta
	// Current hashes of all files with the translation
	FileHashes [][]byte `json:"file_hashes"`
}

func (entity *InputPassportElementErrorSourceTranslationFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceTranslationFiles

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceTranslationFiles) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceTranslationFiles) GetType() string {
	return TypeInputPassportElementErrorSourceTranslationFiles
}

func (*InputPassportElementErrorSourceTranslationFiles) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceTranslationFiles
}

// The file contains an error. The error is considered resolved when the file changes
type InputPassportElementErrorSourceFile struct {
	meta
	// Current hash of the file which has the error
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFile

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFile) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFile) GetType() string {
	return TypeInputPassportElementErrorSourceFile
}

func (*InputPassportElementErrorSourceFile) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFile
}

// The list of attached files contains an error. The error is considered resolved when the file list changes
type InputPassportElementErrorSourceFiles struct {
	meta
	// Current hashes of all attached files
	FileHashes [][]byte `json:"file_hashes"`
}

func (entity *InputPassportElementErrorSourceFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFiles

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFiles) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFiles) GetType() string {
	return TypeInputPassportElementErrorSourceFiles
}

func (*InputPassportElementErrorSourceFiles) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFiles
}

// Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementError struct {
	meta
	// Type of Telegram Passport element that has the error
	Type PassportElementType `json:"type"`
	// Error message
	Message string `json:"message"`
	// Error source
	Source InputPassportElementErrorSource `json:"source"`
}

func (entity *InputPassportElementError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementError

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementError) GetClass() string {
	return ClassInputPassportElementError
}

func (*InputPassportElementError) GetType() string {
	return TypeInputPassportElementError
}

func (inputPassportElementError *InputPassportElementError) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    json.RawMessage `json:"type"`
		Message string          `json:"message"`
		Source  json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputPassportElementError.Message = tmp.Message

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	inputPassportElementError.Type = fieldType

	fieldSource, _ := UnmarshalInputPassportElementErrorSource(tmp.Source)
	inputPassportElementError.Source = fieldSource

	return nil
}

// A text message
type MessageText struct {
	meta
	// Text of the message
	Text *FormattedText `json:"text"`
	// A link preview attached to the message; may be null
	LinkPreview *LinkPreview `json:"link_preview"`
	// Options which were used for generation of the link preview; may be null if default options were used
	LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options"`
}

func (entity *MessageText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageText

	return json.Marshal((*stub)(entity))
}

func (*MessageText) GetClass() string {
	return ClassMessageContent
}

func (*MessageText) GetType() string {
	return TypeMessageText
}

func (*MessageText) MessageContentType() string {
	return TypeMessageText
}

// An animation message (GIF-style).
type MessageAnimation struct {
	meta
	// The animation description
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// True, if the animation preview must be covered by a spoiler animation
	HasSpoiler bool `json:"has_spoiler"`
	// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAnimation

	return json.Marshal((*stub)(entity))
}

func (*MessageAnimation) GetClass() string {
	return ClassMessageContent
}

func (*MessageAnimation) GetType() string {
	return TypeMessageAnimation
}

func (*MessageAnimation) MessageContentType() string {
	return TypeMessageAnimation
}

// An audio message
type MessageAudio struct {
	meta
	// The audio description
	Audio *Audio `json:"audio"`
	// Audio caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAudio

	return json.Marshal((*stub)(entity))
}

func (*MessageAudio) GetClass() string {
	return ClassMessageContent
}

func (*MessageAudio) GetType() string {
	return TypeMessageAudio
}

func (*MessageAudio) MessageContentType() string {
	return TypeMessageAudio
}

// A document message (general file)
type MessageDocument struct {
	meta
	// The document description
	Document *Document `json:"document"`
	// Document caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageDocument

	return json.Marshal((*stub)(entity))
}

func (*MessageDocument) GetClass() string {
	return ClassMessageContent
}

func (*MessageDocument) GetType() string {
	return TypeMessageDocument
}

func (*MessageDocument) MessageContentType() string {
	return TypeMessageDocument
}

// A message with paid media
type MessagePaidMedia struct {
	meta
	// Number of Telegram Stars needed to buy access to the media in the message
	StarCount int64 `json:"star_count"`
	// Information about the media
	Media []PaidMedia `json:"media"`
	// Media caption
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the media; otherwise, the caption must be shown below the media
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
}

func (entity *MessagePaidMedia) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaidMedia

	return json.Marshal((*stub)(entity))
}

func (*MessagePaidMedia) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaidMedia) GetType() string {
	return TypeMessagePaidMedia
}

func (*MessagePaidMedia) MessageContentType() string {
	return TypeMessagePaidMedia
}

func (messagePaidMedia *MessagePaidMedia) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StarCount             int64             `json:"star_count"`
		Media                 []json.RawMessage `json:"media"`
		Caption               *FormattedText    `json:"caption"`
		ShowCaptionAboveMedia bool              `json:"show_caption_above_media"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messagePaidMedia.StarCount = tmp.StarCount
	messagePaidMedia.Caption = tmp.Caption
	messagePaidMedia.ShowCaptionAboveMedia = tmp.ShowCaptionAboveMedia

	fieldMedia, _ := UnmarshalListOfPaidMedia(tmp.Media)
	messagePaidMedia.Media = fieldMedia

	return nil
}

// A photo message
type MessagePhoto struct {
	meta
	// The photo
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// True, if the photo preview must be covered by a spoiler animation
	HasSpoiler bool `json:"has_spoiler"`
	// True, if the photo must be blurred and must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessagePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessagePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessagePhoto) GetType() string {
	return TypeMessagePhoto
}

func (*MessagePhoto) MessageContentType() string {
	return TypeMessagePhoto
}

// A sticker message
type MessageSticker struct {
	meta
	// The sticker description
	Sticker *Sticker `json:"sticker"`
	// True, if premium animation of the sticker must be played
	IsPremium bool `json:"is_premium"`
}

func (entity *MessageSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSticker

	return json.Marshal((*stub)(entity))
}

func (*MessageSticker) GetClass() string {
	return ClassMessageContent
}

func (*MessageSticker) GetType() string {
	return TypeMessageSticker
}

func (*MessageSticker) MessageContentType() string {
	return TypeMessageSticker
}

// A video message
type MessageVideo struct {
	meta
	// The video description
	Video *Video `json:"video"`
	// Alternative qualities of the video
	AlternativeVideos []*AlternativeVideo `json:"alternative_videos"`
	// Video caption
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the video; otherwise, the caption must be shown below the video
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// True, if the video preview must be covered by a spoiler animation
	HasSpoiler bool `json:"has_spoiler"`
	// True, if the video thumbnail must be blurred and the video must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageVideo) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideo) GetType() string {
	return TypeMessageVideo
}

func (*MessageVideo) MessageContentType() string {
	return TypeMessageVideo
}

// A video note message
type MessageVideoNote struct {
	meta
	// The video note description
	VideoNote *VideoNote `json:"video_note"`
	// True, if at least one of the recipients has viewed the video note
	IsViewed bool `json:"is_viewed"`
	// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoNote

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoNote) GetType() string {
	return TypeMessageVideoNote
}

func (*MessageVideoNote) MessageContentType() string {
	return TypeMessageVideoNote
}

// A voice note message
type MessageVoiceNote struct {
	meta
	// The voice note description
	VoiceNote *VoiceNote `json:"voice_note"`
	// Voice note caption
	Caption *FormattedText `json:"caption"`
	// True, if at least one of the recipients has listened to the voice note
	IsListened bool `json:"is_listened"`
}

func (entity *MessageVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*MessageVoiceNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageVoiceNote) GetType() string {
	return TypeMessageVoiceNote
}

func (*MessageVoiceNote) MessageContentType() string {
	return TypeMessageVoiceNote
}

// A self-destructed photo message
type MessageExpiredPhoto struct {
	meta
}

func (entity *MessageExpiredPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredPhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredPhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredPhoto) GetType() string {
	return TypeMessageExpiredPhoto
}

func (*MessageExpiredPhoto) MessageContentType() string {
	return TypeMessageExpiredPhoto
}

// A self-destructed video message
type MessageExpiredVideo struct {
	meta
}

func (entity *MessageExpiredVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredVideo) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredVideo) GetType() string {
	return TypeMessageExpiredVideo
}

func (*MessageExpiredVideo) MessageContentType() string {
	return TypeMessageExpiredVideo
}

// A self-destructed video note message
type MessageExpiredVideoNote struct {
	meta
}

func (entity *MessageExpiredVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredVideoNote

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredVideoNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredVideoNote) GetType() string {
	return TypeMessageExpiredVideoNote
}

func (*MessageExpiredVideoNote) MessageContentType() string {
	return TypeMessageExpiredVideoNote
}

// A self-destructed voice note message
type MessageExpiredVoiceNote struct {
	meta
}

func (entity *MessageExpiredVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredVoiceNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredVoiceNote) GetType() string {
	return TypeMessageExpiredVoiceNote
}

func (*MessageExpiredVoiceNote) MessageContentType() string {
	return TypeMessageExpiredVoiceNote
}

// A message with a location
type MessageLocation struct {
	meta
	// The location description
	Location *Location `json:"location"`
	// Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever
	LivePeriod int32 `json:"live_period"`
	// Left time for which the location can be updated, in seconds. If 0, then the location can't be updated anymore. The update updateMessageContent is not sent when this field changes
	ExpiresIn int32 `json:"expires_in"`
	// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
	Heading int32 `json:"heading"`
	// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
	ProximityAlertRadius int32 `json:"proximity_alert_radius"`
}

func (entity *MessageLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLocation

	return json.Marshal((*stub)(entity))
}

func (*MessageLocation) GetClass() string {
	return ClassMessageContent
}

func (*MessageLocation) GetType() string {
	return TypeMessageLocation
}

func (*MessageLocation) MessageContentType() string {
	return TypeMessageLocation
}

// A message with information about a venue
type MessageVenue struct {
	meta
	// The venue description
	Venue *Venue `json:"venue"`
}

func (entity *MessageVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVenue

	return json.Marshal((*stub)(entity))
}

func (*MessageVenue) GetClass() string {
	return ClassMessageContent
}

func (*MessageVenue) GetType() string {
	return TypeMessageVenue
}

func (*MessageVenue) MessageContentType() string {
	return TypeMessageVenue
}

// A message with a user contact
type MessageContact struct {
	meta
	// The contact description
	Contact *Contact `json:"contact"`
}

func (entity *MessageContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageContact

	return json.Marshal((*stub)(entity))
}

func (*MessageContact) GetClass() string {
	return ClassMessageContent
}

func (*MessageContact) GetType() string {
	return TypeMessageContact
}

func (*MessageContact) MessageContentType() string {
	return TypeMessageContact
}

// A message with an animated emoji
type MessageAnimatedEmoji struct {
	meta
	// The animated emoji
	AnimatedEmoji *AnimatedEmoji `json:"animated_emoji"`
	// The corresponding emoji
	Emoji string `json:"emoji"`
}

func (entity *MessageAnimatedEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAnimatedEmoji

	return json.Marshal((*stub)(entity))
}

func (*MessageAnimatedEmoji) GetClass() string {
	return ClassMessageContent
}

func (*MessageAnimatedEmoji) GetType() string {
	return TypeMessageAnimatedEmoji
}

func (*MessageAnimatedEmoji) MessageContentType() string {
	return TypeMessageAnimatedEmoji
}

// A dice message. The dice value is randomly generated by the server
type MessageDice struct {
	meta
	// The animated stickers with the initial dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
	InitialState DiceStickers `json:"initial_state"`
	// The animated stickers with the final dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
	FinalState DiceStickers `json:"final_state"`
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`
	// The dice value. If the value is 0, the dice don't have final state yet
	Value int32 `json:"value"`
	// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
	SuccessAnimationFrameNumber int32 `json:"success_animation_frame_number"`
}

func (entity *MessageDice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageDice

	return json.Marshal((*stub)(entity))
}

func (*MessageDice) GetClass() string {
	return ClassMessageContent
}

func (*MessageDice) GetType() string {
	return TypeMessageDice
}

func (*MessageDice) MessageContentType() string {
	return TypeMessageDice
}

func (messageDice *MessageDice) UnmarshalJSON(data []byte) error {
	var tmp struct {
		InitialState                json.RawMessage `json:"initial_state"`
		FinalState                  json.RawMessage `json:"final_state"`
		Emoji                       string          `json:"emoji"`
		Value                       int32           `json:"value"`
		SuccessAnimationFrameNumber int32           `json:"success_animation_frame_number"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageDice.Emoji = tmp.Emoji
	messageDice.Value = tmp.Value
	messageDice.SuccessAnimationFrameNumber = tmp.SuccessAnimationFrameNumber

	fieldInitialState, _ := UnmarshalDiceStickers(tmp.InitialState)
	messageDice.InitialState = fieldInitialState

	fieldFinalState, _ := UnmarshalDiceStickers(tmp.FinalState)
	messageDice.FinalState = fieldFinalState

	return nil
}

// A message with a game
type MessageGame struct {
	meta
	// The game description
	Game *Game `json:"game"`
}

func (entity *MessageGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGame

	return json.Marshal((*stub)(entity))
}

func (*MessageGame) GetClass() string {
	return ClassMessageContent
}

func (*MessageGame) GetType() string {
	return TypeMessageGame
}

func (*MessageGame) MessageContentType() string {
	return TypeMessageGame
}

// A message with a poll
type MessagePoll struct {
	meta
	// The poll description
	Poll *Poll `json:"poll"`
}

func (entity *MessagePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePoll

	return json.Marshal((*stub)(entity))
}

func (*MessagePoll) GetClass() string {
	return ClassMessageContent
}

func (*MessagePoll) GetType() string {
	return TypeMessagePoll
}

func (*MessagePoll) MessageContentType() string {
	return TypeMessagePoll
}

// A message with a forwarded story
type MessageStory struct {
	meta
	// Identifier of the chat that posted the story
	StorySenderChatId int64 `json:"story_sender_chat_id"`
	// Story identifier
	StoryId int32 `json:"story_id"`
	// True, if the story was automatically forwarded because of a mention of the user
	ViaMention bool `json:"via_mention"`
}

func (entity *MessageStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageStory

	return json.Marshal((*stub)(entity))
}

func (*MessageStory) GetClass() string {
	return ClassMessageContent
}

func (*MessageStory) GetType() string {
	return TypeMessageStory
}

func (*MessageStory) MessageContentType() string {
	return TypeMessageStory
}

// A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
type MessageInvoice struct {
	meta
	// Information about the product
	ProductInfo *ProductInfo `json:"product_info"`
	// Currency for the product price
	Currency string `json:"currency"`
	// Product total price in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Unique invoice bot start_parameter to be passed to getInternalLink
	StartParameter string `json:"start_parameter"`
	// True, if the invoice is a test invoice
	IsTest bool `json:"is_test"`
	// True, if the shipping address must be specified
	NeedShippingAddress bool `json:"need_shipping_address"`
	// The identifier of the message with the receipt, after the product has been purchased
	ReceiptMessageId int64 `json:"receipt_message_id"`
	// Extended media attached to the invoice; may be null if none
	PaidMedia PaidMedia `json:"paid_media"`
	// Extended media caption; may be null if none
	PaidMediaCaption *FormattedText `json:"paid_media_caption"`
}

func (entity *MessageInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInvoice

	return json.Marshal((*stub)(entity))
}

func (*MessageInvoice) GetClass() string {
	return ClassMessageContent
}

func (*MessageInvoice) GetType() string {
	return TypeMessageInvoice
}

func (*MessageInvoice) MessageContentType() string {
	return TypeMessageInvoice
}

func (messageInvoice *MessageInvoice) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ProductInfo         *ProductInfo    `json:"product_info"`
		Currency            string          `json:"currency"`
		TotalAmount         int64           `json:"total_amount"`
		StartParameter      string          `json:"start_parameter"`
		IsTest              bool            `json:"is_test"`
		NeedShippingAddress bool            `json:"need_shipping_address"`
		ReceiptMessageId    int64           `json:"receipt_message_id"`
		PaidMedia           json.RawMessage `json:"paid_media"`
		PaidMediaCaption    *FormattedText  `json:"paid_media_caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageInvoice.ProductInfo = tmp.ProductInfo
	messageInvoice.Currency = tmp.Currency
	messageInvoice.TotalAmount = tmp.TotalAmount
	messageInvoice.StartParameter = tmp.StartParameter
	messageInvoice.IsTest = tmp.IsTest
	messageInvoice.NeedShippingAddress = tmp.NeedShippingAddress
	messageInvoice.ReceiptMessageId = tmp.ReceiptMessageId
	messageInvoice.PaidMediaCaption = tmp.PaidMediaCaption

	fieldPaidMedia, _ := UnmarshalPaidMedia(tmp.PaidMedia)
	messageInvoice.PaidMedia = fieldPaidMedia

	return nil
}

// A message with information about an ended call
type MessageCall struct {
	meta
	// True, if the call was a video call
	IsVideo bool `json:"is_video"`
	// Reason why the call was discarded
	DiscardReason CallDiscardReason `json:"discard_reason"`
	// Call duration, in seconds
	Duration int32 `json:"duration"`
}

func (entity *MessageCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCall

	return json.Marshal((*stub)(entity))
}

func (*MessageCall) GetClass() string {
	return ClassMessageContent
}

func (*MessageCall) GetType() string {
	return TypeMessageCall
}

func (*MessageCall) MessageContentType() string {
	return TypeMessageCall
}

func (messageCall *MessageCall) UnmarshalJSON(data []byte) error {
	var tmp struct {
		IsVideo       bool            `json:"is_video"`
		DiscardReason json.RawMessage `json:"discard_reason"`
		Duration      int32           `json:"duration"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageCall.IsVideo = tmp.IsVideo
	messageCall.Duration = tmp.Duration

	fieldDiscardReason, _ := UnmarshalCallDiscardReason(tmp.DiscardReason)
	messageCall.DiscardReason = fieldDiscardReason

	return nil
}

// A new video chat was scheduled
type MessageVideoChatScheduled struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
	// Point in time (Unix timestamp) when the group call is expected to be started by an administrator
	StartDate int32 `json:"start_date"`
}

func (entity *MessageVideoChatScheduled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoChatScheduled

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoChatScheduled) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoChatScheduled) GetType() string {
	return TypeMessageVideoChatScheduled
}

func (*MessageVideoChatScheduled) MessageContentType() string {
	return TypeMessageVideoChatScheduled
}

// A newly created video chat
type MessageVideoChatStarted struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
}

func (entity *MessageVideoChatStarted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoChatStarted

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoChatStarted) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoChatStarted) GetType() string {
	return TypeMessageVideoChatStarted
}

func (*MessageVideoChatStarted) MessageContentType() string {
	return TypeMessageVideoChatStarted
}

// A message with information about an ended video chat
type MessageVideoChatEnded struct {
	meta
	// Call duration, in seconds
	Duration int32 `json:"duration"`
}

func (entity *MessageVideoChatEnded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoChatEnded

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoChatEnded) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoChatEnded) GetType() string {
	return TypeMessageVideoChatEnded
}

func (*MessageVideoChatEnded) MessageContentType() string {
	return TypeMessageVideoChatEnded
}

// A message with information about an invitation to a video chat
type MessageInviteVideoChatParticipants struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
	// Invited user identifiers
	UserIds []int64 `json:"user_ids"`
}

func (entity *MessageInviteVideoChatParticipants) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInviteVideoChatParticipants

	return json.Marshal((*stub)(entity))
}

func (*MessageInviteVideoChatParticipants) GetClass() string {
	return ClassMessageContent
}

func (*MessageInviteVideoChatParticipants) GetType() string {
	return TypeMessageInviteVideoChatParticipants
}

func (*MessageInviteVideoChatParticipants) MessageContentType() string {
	return TypeMessageInviteVideoChatParticipants
}

// A newly created basic group
type MessageBasicGroupChatCreate struct {
	meta
	// Title of the basic group
	Title string `json:"title"`
	// User identifiers of members in the basic group
	MemberUserIds []int64 `json:"member_user_ids"`
}

func (entity *MessageBasicGroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageBasicGroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*MessageBasicGroupChatCreate) GetClass() string {
	return ClassMessageContent
}

func (*MessageBasicGroupChatCreate) GetType() string {
	return TypeMessageBasicGroupChatCreate
}

func (*MessageBasicGroupChatCreate) MessageContentType() string {
	return TypeMessageBasicGroupChatCreate
}

// A newly created supergroup or channel
type MessageSupergroupChatCreate struct {
	meta
	// Title of the supergroup or channel
	Title string `json:"title"`
}

func (entity *MessageSupergroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSupergroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*MessageSupergroupChatCreate) GetClass() string {
	return ClassMessageContent
}

func (*MessageSupergroupChatCreate) GetType() string {
	return TypeMessageSupergroupChatCreate
}

func (*MessageSupergroupChatCreate) MessageContentType() string {
	return TypeMessageSupergroupChatCreate
}

// An updated chat title
type MessageChatChangeTitle struct {
	meta
	// New chat title
	Title string `json:"title"`
}

func (entity *MessageChatChangeTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatChangeTitle

	return json.Marshal((*stub)(entity))
}

func (*MessageChatChangeTitle) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatChangeTitle) GetType() string {
	return TypeMessageChatChangeTitle
}

func (*MessageChatChangeTitle) MessageContentType() string {
	return TypeMessageChatChangeTitle
}

// An updated chat photo
type MessageChatChangePhoto struct {
	meta
	// New chat photo
	Photo *ChatPhoto `json:"photo"`
}

func (entity *MessageChatChangePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatChangePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageChatChangePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatChangePhoto) GetType() string {
	return TypeMessageChatChangePhoto
}

func (*MessageChatChangePhoto) MessageContentType() string {
	return TypeMessageChatChangePhoto
}

// A deleted chat photo
type MessageChatDeletePhoto struct {
	meta
}

func (entity *MessageChatDeletePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatDeletePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageChatDeletePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatDeletePhoto) GetType() string {
	return TypeMessageChatDeletePhoto
}

func (*MessageChatDeletePhoto) MessageContentType() string {
	return TypeMessageChatDeletePhoto
}

// New chat members were added
type MessageChatAddMembers struct {
	meta
	// User identifiers of the new members
	MemberUserIds []int64 `json:"member_user_ids"`
}

func (entity *MessageChatAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatAddMembers

	return json.Marshal((*stub)(entity))
}

func (*MessageChatAddMembers) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatAddMembers) GetType() string {
	return TypeMessageChatAddMembers
}

func (*MessageChatAddMembers) MessageContentType() string {
	return TypeMessageChatAddMembers
}

// A new member joined the chat via an invite link
type MessageChatJoinByLink struct {
	meta
}

func (entity *MessageChatJoinByLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatJoinByLink

	return json.Marshal((*stub)(entity))
}

func (*MessageChatJoinByLink) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatJoinByLink) GetType() string {
	return TypeMessageChatJoinByLink
}

func (*MessageChatJoinByLink) MessageContentType() string {
	return TypeMessageChatJoinByLink
}

// A new member was accepted to the chat by an administrator
type MessageChatJoinByRequest struct {
	meta
}

func (entity *MessageChatJoinByRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatJoinByRequest

	return json.Marshal((*stub)(entity))
}

func (*MessageChatJoinByRequest) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatJoinByRequest) GetType() string {
	return TypeMessageChatJoinByRequest
}

func (*MessageChatJoinByRequest) MessageContentType() string {
	return TypeMessageChatJoinByRequest
}

// A chat member was deleted
type MessageChatDeleteMember struct {
	meta
	// User identifier of the deleted chat member
	UserId int64 `json:"user_id"`
}

func (entity *MessageChatDeleteMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatDeleteMember

	return json.Marshal((*stub)(entity))
}

func (*MessageChatDeleteMember) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatDeleteMember) GetType() string {
	return TypeMessageChatDeleteMember
}

func (*MessageChatDeleteMember) MessageContentType() string {
	return TypeMessageChatDeleteMember
}

// A basic group was upgraded to a supergroup and was deactivated as the result
type MessageChatUpgradeTo struct {
	meta
	// Identifier of the supergroup to which the basic group was upgraded
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *MessageChatUpgradeTo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatUpgradeTo

	return json.Marshal((*stub)(entity))
}

func (*MessageChatUpgradeTo) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatUpgradeTo) GetType() string {
	return TypeMessageChatUpgradeTo
}

func (*MessageChatUpgradeTo) MessageContentType() string {
	return TypeMessageChatUpgradeTo
}

// A supergroup has been created from a basic group
type MessageChatUpgradeFrom struct {
	meta
	// Title of the newly created supergroup
	Title string `json:"title"`
	// The identifier of the original basic group
	BasicGroupId int64 `json:"basic_group_id"`
}

func (entity *MessageChatUpgradeFrom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatUpgradeFrom

	return json.Marshal((*stub)(entity))
}

func (*MessageChatUpgradeFrom) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatUpgradeFrom) GetType() string {
	return TypeMessageChatUpgradeFrom
}

func (*MessageChatUpgradeFrom) MessageContentType() string {
	return TypeMessageChatUpgradeFrom
}

// A message has been pinned
type MessagePinMessage struct {
	meta
	// Identifier of the pinned message, can be an identifier of a deleted message or 0
	MessageId int64 `json:"message_id"`
}

func (entity *MessagePinMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePinMessage

	return json.Marshal((*stub)(entity))
}

func (*MessagePinMessage) GetClass() string {
	return ClassMessageContent
}

func (*MessagePinMessage) GetType() string {
	return TypeMessagePinMessage
}

func (*MessagePinMessage) MessageContentType() string {
	return TypeMessagePinMessage
}

// A screenshot of a message in the chat has been taken
type MessageScreenshotTaken struct {
	meta
}

func (entity *MessageScreenshotTaken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageScreenshotTaken

	return json.Marshal((*stub)(entity))
}

func (*MessageScreenshotTaken) GetClass() string {
	return ClassMessageContent
}

func (*MessageScreenshotTaken) GetType() string {
	return TypeMessageScreenshotTaken
}

func (*MessageScreenshotTaken) MessageContentType() string {
	return TypeMessageScreenshotTaken
}

// A new background was set in the chat
type MessageChatSetBackground struct {
	meta
	// Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
	OldBackgroundMessageId int64 `json:"old_background_message_id"`
	// The new background
	Background *ChatBackground `json:"background"`
	// True, if the background was set only for self
	OnlyForSelf bool `json:"only_for_self"`
}

func (entity *MessageChatSetBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatSetBackground

	return json.Marshal((*stub)(entity))
}

func (*MessageChatSetBackground) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatSetBackground) GetType() string {
	return TypeMessageChatSetBackground
}

func (*MessageChatSetBackground) MessageContentType() string {
	return TypeMessageChatSetBackground
}

// A theme in the chat has been changed
type MessageChatSetTheme struct {
	meta
	// If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
	ThemeName string `json:"theme_name"`
}

func (entity *MessageChatSetTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatSetTheme

	return json.Marshal((*stub)(entity))
}

func (*MessageChatSetTheme) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatSetTheme) GetType() string {
	return TypeMessageChatSetTheme
}

func (*MessageChatSetTheme) MessageContentType() string {
	return TypeMessageChatSetTheme
}

// The auto-delete or self-destruct timer for messages in the chat has been changed
type MessageChatSetMessageAutoDeleteTime struct {
	meta
	// New value auto-delete or self-destruct time, in seconds; 0 if disabled
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"`
	// If not 0, a user identifier, which default setting was automatically applied
	FromUserId int64 `json:"from_user_id"`
}

func (entity *MessageChatSetMessageAutoDeleteTime) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatSetMessageAutoDeleteTime

	return json.Marshal((*stub)(entity))
}

func (*MessageChatSetMessageAutoDeleteTime) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatSetMessageAutoDeleteTime) GetType() string {
	return TypeMessageChatSetMessageAutoDeleteTime
}

func (*MessageChatSetMessageAutoDeleteTime) MessageContentType() string {
	return TypeMessageChatSetMessageAutoDeleteTime
}

// The chat was boosted by the sender of the message
type MessageChatBoost struct {
	meta
	// Number of times the chat was boosted
	BoostCount int32 `json:"boost_count"`
}

func (entity *MessageChatBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatBoost

	return json.Marshal((*stub)(entity))
}

func (*MessageChatBoost) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatBoost) GetType() string {
	return TypeMessageChatBoost
}

func (*MessageChatBoost) MessageContentType() string {
	return TypeMessageChatBoost
}

// A forum topic has been created
type MessageForumTopicCreated struct {
	meta
	// Name of the topic
	Name string `json:"name"`
	// Icon of the topic
	Icon *ForumTopicIcon `json:"icon"`
}

func (entity *MessageForumTopicCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicCreated

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicCreated) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicCreated) GetType() string {
	return TypeMessageForumTopicCreated
}

func (*MessageForumTopicCreated) MessageContentType() string {
	return TypeMessageForumTopicCreated
}

// A forum topic has been edited
type MessageForumTopicEdited struct {
	meta
	// If non-empty, the new name of the topic
	Name string `json:"name"`
	// True, if icon's custom_emoji_id is changed
	EditIconCustomEmojiId bool `json:"edit_icon_custom_emoji_id"`
	// New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
	IconCustomEmojiId JsonInt64 `json:"icon_custom_emoji_id"`
}

func (entity *MessageForumTopicEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicEdited

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicEdited) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicEdited) GetType() string {
	return TypeMessageForumTopicEdited
}

func (*MessageForumTopicEdited) MessageContentType() string {
	return TypeMessageForumTopicEdited
}

// A forum topic has been closed or opened
type MessageForumTopicIsClosedToggled struct {
	meta
	// True, if the topic was closed; otherwise, the topic was reopened
	IsClosed bool `json:"is_closed"`
}

func (entity *MessageForumTopicIsClosedToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicIsClosedToggled

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicIsClosedToggled) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicIsClosedToggled) GetType() string {
	return TypeMessageForumTopicIsClosedToggled
}

func (*MessageForumTopicIsClosedToggled) MessageContentType() string {
	return TypeMessageForumTopicIsClosedToggled
}

// A General forum topic has been hidden or unhidden
type MessageForumTopicIsHiddenToggled struct {
	meta
	// True, if the topic was hidden; otherwise, the topic was unhidden
	IsHidden bool `json:"is_hidden"`
}

func (entity *MessageForumTopicIsHiddenToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForumTopicIsHiddenToggled

	return json.Marshal((*stub)(entity))
}

func (*MessageForumTopicIsHiddenToggled) GetClass() string {
	return ClassMessageContent
}

func (*MessageForumTopicIsHiddenToggled) GetType() string {
	return TypeMessageForumTopicIsHiddenToggled
}

func (*MessageForumTopicIsHiddenToggled) MessageContentType() string {
	return TypeMessageForumTopicIsHiddenToggled
}

// A profile photo was suggested to a user in a private chat
type MessageSuggestProfilePhoto struct {
	meta
	// The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
	Photo *ChatPhoto `json:"photo"`
}

func (entity *MessageSuggestProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSuggestProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageSuggestProfilePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageSuggestProfilePhoto) GetType() string {
	return TypeMessageSuggestProfilePhoto
}

func (*MessageSuggestProfilePhoto) MessageContentType() string {
	return TypeMessageSuggestProfilePhoto
}

// A non-standard action has happened in the chat
type MessageCustomServiceAction struct {
	meta
	// Message text to be shown in the chat
	Text string `json:"text"`
}

func (entity *MessageCustomServiceAction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCustomServiceAction

	return json.Marshal((*stub)(entity))
}

func (*MessageCustomServiceAction) GetClass() string {
	return ClassMessageContent
}

func (*MessageCustomServiceAction) GetType() string {
	return TypeMessageCustomServiceAction
}

func (*MessageCustomServiceAction) MessageContentType() string {
	return TypeMessageCustomServiceAction
}

// A new high score was achieved in a game
type MessageGameScore struct {
	meta
	// Identifier of the message with the game, can be an identifier of a deleted message
	GameMessageId int64 `json:"game_message_id"`
	// Identifier of the game; may be different from the games presented in the message with the game
	GameId JsonInt64 `json:"game_id"`
	// New score
	Score int32 `json:"score"`
}

func (entity *MessageGameScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGameScore

	return json.Marshal((*stub)(entity))
}

func (*MessageGameScore) GetClass() string {
	return ClassMessageContent
}

func (*MessageGameScore) GetType() string {
	return TypeMessageGameScore
}

func (*MessageGameScore) MessageContentType() string {
	return TypeMessageGameScore
}

// A payment has been sent to a bot or a business account
type MessagePaymentSuccessful struct {
	meta
	// Identifier of the chat, containing the corresponding invoice message
	InvoiceChatId int64 `json:"invoice_chat_id"`
	// Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
	InvoiceMessageId int64 `json:"invoice_message_id"`
	// Currency for the price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the payment isn't recurring
	SubscriptionUntilDate int32 `json:"subscription_until_date"`
	// True, if this is a recurring payment
	IsRecurring bool `json:"is_recurring"`
	// True, if this is the first recurring payment
	IsFirstRecurring bool `json:"is_first_recurring"`
	// Name of the invoice; may be empty if unknown
	InvoiceName string `json:"invoice_name"`
}

func (entity *MessagePaymentSuccessful) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentSuccessful

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentSuccessful) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentSuccessful) GetType() string {
	return TypeMessagePaymentSuccessful
}

func (*MessagePaymentSuccessful) MessageContentType() string {
	return TypeMessagePaymentSuccessful
}

// A payment has been received by the bot or the business account
type MessagePaymentSuccessfulBot struct {
	meta
	// Currency for price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the payment isn't recurring
	SubscriptionUntilDate int32 `json:"subscription_until_date"`
	// True, if this is a recurring payment
	IsRecurring bool `json:"is_recurring"`
	// True, if this is the first recurring payment
	IsFirstRecurring bool `json:"is_first_recurring"`
	// Invoice payload
	InvoicePayload []byte `json:"invoice_payload"`
	// Identifier of the shipping option chosen by the user; may be empty if not applicable; for bots only
	ShippingOptionId string `json:"shipping_option_id"`
	// Information about the order; may be null; for bots only
	OrderInfo *OrderInfo `json:"order_info"`
	// Telegram payment identifier
	TelegramPaymentChargeId string `json:"telegram_payment_charge_id"`
	// Provider payment identifier
	ProviderPaymentChargeId string `json:"provider_payment_charge_id"`
}

func (entity *MessagePaymentSuccessfulBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentSuccessfulBot

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentSuccessfulBot) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentSuccessfulBot) GetType() string {
	return TypeMessagePaymentSuccessfulBot
}

func (*MessagePaymentSuccessfulBot) MessageContentType() string {
	return TypeMessagePaymentSuccessfulBot
}

// A payment has been refunded
type MessagePaymentRefunded struct {
	meta
	// Identifier of the previous owner of the Telegram Stars that refunds them
	OwnerId MessageSender `json:"owner_id"`
	// Currency for the price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Invoice payload; only for bots
	InvoicePayload []byte `json:"invoice_payload"`
	// Telegram payment identifier
	TelegramPaymentChargeId string `json:"telegram_payment_charge_id"`
	// Provider payment identifier
	ProviderPaymentChargeId string `json:"provider_payment_charge_id"`
}

func (entity *MessagePaymentRefunded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentRefunded

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentRefunded) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentRefunded) GetType() string {
	return TypeMessagePaymentRefunded
}

func (*MessagePaymentRefunded) MessageContentType() string {
	return TypeMessagePaymentRefunded
}

func (messagePaymentRefunded *MessagePaymentRefunded) UnmarshalJSON(data []byte) error {
	var tmp struct {
		OwnerId                 json.RawMessage `json:"owner_id"`
		Currency                string          `json:"currency"`
		TotalAmount             int64           `json:"total_amount"`
		InvoicePayload          []byte          `json:"invoice_payload"`
		TelegramPaymentChargeId string          `json:"telegram_payment_charge_id"`
		ProviderPaymentChargeId string          `json:"provider_payment_charge_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messagePaymentRefunded.Currency = tmp.Currency
	messagePaymentRefunded.TotalAmount = tmp.TotalAmount
	messagePaymentRefunded.InvoicePayload = tmp.InvoicePayload
	messagePaymentRefunded.TelegramPaymentChargeId = tmp.TelegramPaymentChargeId
	messagePaymentRefunded.ProviderPaymentChargeId = tmp.ProviderPaymentChargeId

	fieldOwnerId, _ := UnmarshalMessageSender(tmp.OwnerId)
	messagePaymentRefunded.OwnerId = fieldOwnerId

	return nil
}

// Telegram Premium was gifted to a user
type MessageGiftedPremium struct {
	meta
	// The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing
	GifterUserId int64 `json:"gifter_user_id"`
	// The identifier of a user that received Telegram Premium; 0 if the gift is incoming
	ReceiverUserId int64 `json:"receiver_user_id"`
	// Message added to the gifted Telegram Premium by the sender
	Text *FormattedText `json:"text"`
	// Currency for the paid amount
	Currency string `json:"currency"`
	// The paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Cryptocurrency used to pay for the gift; may be empty if none
	Cryptocurrency string `json:"cryptocurrency"`
	// The paid amount, in the smallest units of the cryptocurrency; 0 if none
	CryptocurrencyAmount JsonInt64 `json:"cryptocurrency_amount"`
	// Number of months the Telegram Premium subscription will be active
	MonthCount int32 `json:"month_count"`
	// A sticker to be shown in the message; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageGiftedPremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiftedPremium

	return json.Marshal((*stub)(entity))
}

func (*MessageGiftedPremium) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiftedPremium) GetType() string {
	return TypeMessageGiftedPremium
}

func (*MessageGiftedPremium) MessageContentType() string {
	return TypeMessageGiftedPremium
}

// A Telegram Premium gift code was created for the user
type MessagePremiumGiftCode struct {
	meta
	// Identifier of a chat or a user that created the gift code; may be null if unknown
	CreatorId MessageSender `json:"creator_id"`
	// Message added to the gift
	Text *FormattedText `json:"text"`
	// True, if the gift code was created for a giveaway
	IsFromGiveaway bool `json:"is_from_giveaway"`
	// True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
	IsUnclaimed bool `json:"is_unclaimed"`
	// Currency for the paid amount; empty if unknown
	Currency string `json:"currency"`
	// The paid amount, in the smallest units of the currency; 0 if unknown
	Amount int64 `json:"amount"`
	// Cryptocurrency used to pay for the gift; may be empty if none or unknown
	Cryptocurrency string `json:"cryptocurrency"`
	// The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
	CryptocurrencyAmount JsonInt64 `json:"cryptocurrency_amount"`
	// Number of months the Telegram Premium subscription will be active after code activation
	MonthCount int32 `json:"month_count"`
	// A sticker to be shown in the message; may be null if unknown
	Sticker *Sticker `json:"sticker"`
	// The gift code
	Code string `json:"code"`
}

func (entity *MessagePremiumGiftCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePremiumGiftCode

	return json.Marshal((*stub)(entity))
}

func (*MessagePremiumGiftCode) GetClass() string {
	return ClassMessageContent
}

func (*MessagePremiumGiftCode) GetType() string {
	return TypeMessagePremiumGiftCode
}

func (*MessagePremiumGiftCode) MessageContentType() string {
	return TypeMessagePremiumGiftCode
}

func (messagePremiumGiftCode *MessagePremiumGiftCode) UnmarshalJSON(data []byte) error {
	var tmp struct {
		CreatorId            json.RawMessage `json:"creator_id"`
		Text                 *FormattedText  `json:"text"`
		IsFromGiveaway       bool            `json:"is_from_giveaway"`
		IsUnclaimed          bool            `json:"is_unclaimed"`
		Currency             string          `json:"currency"`
		Amount               int64           `json:"amount"`
		Cryptocurrency       string          `json:"cryptocurrency"`
		CryptocurrencyAmount JsonInt64       `json:"cryptocurrency_amount"`
		MonthCount           int32           `json:"month_count"`
		Sticker              *Sticker        `json:"sticker"`
		Code                 string          `json:"code"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messagePremiumGiftCode.Text = tmp.Text
	messagePremiumGiftCode.IsFromGiveaway = tmp.IsFromGiveaway
	messagePremiumGiftCode.IsUnclaimed = tmp.IsUnclaimed
	messagePremiumGiftCode.Currency = tmp.Currency
	messagePremiumGiftCode.Amount = tmp.Amount
	messagePremiumGiftCode.Cryptocurrency = tmp.Cryptocurrency
	messagePremiumGiftCode.CryptocurrencyAmount = tmp.CryptocurrencyAmount
	messagePremiumGiftCode.MonthCount = tmp.MonthCount
	messagePremiumGiftCode.Sticker = tmp.Sticker
	messagePremiumGiftCode.Code = tmp.Code

	fieldCreatorId, _ := UnmarshalMessageSender(tmp.CreatorId)
	messagePremiumGiftCode.CreatorId = fieldCreatorId

	return nil
}

// A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway, storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway to create a giveaway
type MessageGiveawayCreated struct {
	meta
	// Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways
	StarCount int64 `json:"star_count"`
}

func (entity *MessageGiveawayCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiveawayCreated

	return json.Marshal((*stub)(entity))
}

func (*MessageGiveawayCreated) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiveawayCreated) GetType() string {
	return TypeMessageGiveawayCreated
}

func (*MessageGiveawayCreated) MessageContentType() string {
	return TypeMessageGiveawayCreated
}

// A giveaway
type MessageGiveaway struct {
	meta
	// Giveaway parameters
	Parameters *GiveawayParameters `json:"parameters"`
	// Number of users which will receive Telegram Premium subscription gift codes
	WinnerCount int32 `json:"winner_count"`
	// Prize of the giveaway
	Prize GiveawayPrize `json:"prize"`
	// A sticker to be shown in the message; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiveaway

	return json.Marshal((*stub)(entity))
}

func (*MessageGiveaway) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiveaway) GetType() string {
	return TypeMessageGiveaway
}

func (*MessageGiveaway) MessageContentType() string {
	return TypeMessageGiveaway
}

func (messageGiveaway *MessageGiveaway) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Parameters  *GiveawayParameters `json:"parameters"`
		WinnerCount int32               `json:"winner_count"`
		Prize       json.RawMessage     `json:"prize"`
		Sticker     *Sticker            `json:"sticker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageGiveaway.Parameters = tmp.Parameters
	messageGiveaway.WinnerCount = tmp.WinnerCount
	messageGiveaway.Sticker = tmp.Sticker

	fieldPrize, _ := UnmarshalGiveawayPrize(tmp.Prize)
	messageGiveaway.Prize = fieldPrize

	return nil
}

// A giveaway without public winners has been completed for the chat
type MessageGiveawayCompleted struct {
	meta
	// Identifier of the message with the giveaway; can be 0 if the message was deleted
	GiveawayMessageId int64 `json:"giveaway_message_id"`
	// Number of winners in the giveaway
	WinnerCount int32 `json:"winner_count"`
	// True, if the giveaway is a Telegram Star giveaway
	IsStarGiveaway bool `json:"is_star_giveaway"`
	// Number of undistributed prizes; for Telegram Premium giveaways only
	UnclaimedPrizeCount int32 `json:"unclaimed_prize_count"`
}

func (entity *MessageGiveawayCompleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiveawayCompleted

	return json.Marshal((*stub)(entity))
}

func (*MessageGiveawayCompleted) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiveawayCompleted) GetType() string {
	return TypeMessageGiveawayCompleted
}

func (*MessageGiveawayCompleted) MessageContentType() string {
	return TypeMessageGiveawayCompleted
}

// A giveaway with public winners has been completed for the chat
type MessageGiveawayWinners struct {
	meta
	// Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
	BoostedChatId int64 `json:"boosted_chat_id"`
	// Identifier of the message with the giveaway in the boosted chat
	GiveawayMessageId int64 `json:"giveaway_message_id"`
	// Number of other chats that participated in the giveaway
	AdditionalChatCount int32 `json:"additional_chat_count"`
	// Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
	ActualWinnersSelectionDate int32 `json:"actual_winners_selection_date"`
	// True, if only new members of the chats were eligible for the giveaway
	OnlyNewMembers bool `json:"only_new_members"`
	// True, if the giveaway was canceled and was fully refunded
	WasRefunded bool `json:"was_refunded"`
	// Prize of the giveaway
	Prize GiveawayPrize `json:"prize"`
	// Additional description of the giveaway prize
	PrizeDescription string `json:"prize_description"`
	// Total number of winners in the giveaway
	WinnerCount int32 `json:"winner_count"`
	// Up to 100 user identifiers of the winners of the giveaway
	WinnerUserIds []int64 `json:"winner_user_ids"`
	// Number of undistributed prizes; for Telegram Premium giveaways only
	UnclaimedPrizeCount int32 `json:"unclaimed_prize_count"`
}

func (entity *MessageGiveawayWinners) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiveawayWinners

	return json.Marshal((*stub)(entity))
}

func (*MessageGiveawayWinners) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiveawayWinners) GetType() string {
	return TypeMessageGiveawayWinners
}

func (*MessageGiveawayWinners) MessageContentType() string {
	return TypeMessageGiveawayWinners
}

func (messageGiveawayWinners *MessageGiveawayWinners) UnmarshalJSON(data []byte) error {
	var tmp struct {
		BoostedChatId              int64           `json:"boosted_chat_id"`
		GiveawayMessageId          int64           `json:"giveaway_message_id"`
		AdditionalChatCount        int32           `json:"additional_chat_count"`
		ActualWinnersSelectionDate int32           `json:"actual_winners_selection_date"`
		OnlyNewMembers             bool            `json:"only_new_members"`
		WasRefunded                bool            `json:"was_refunded"`
		Prize                      json.RawMessage `json:"prize"`
		PrizeDescription           string          `json:"prize_description"`
		WinnerCount                int32           `json:"winner_count"`
		WinnerUserIds              []int64         `json:"winner_user_ids"`
		UnclaimedPrizeCount        int32           `json:"unclaimed_prize_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageGiveawayWinners.BoostedChatId = tmp.BoostedChatId
	messageGiveawayWinners.GiveawayMessageId = tmp.GiveawayMessageId
	messageGiveawayWinners.AdditionalChatCount = tmp.AdditionalChatCount
	messageGiveawayWinners.ActualWinnersSelectionDate = tmp.ActualWinnersSelectionDate
	messageGiveawayWinners.OnlyNewMembers = tmp.OnlyNewMembers
	messageGiveawayWinners.WasRefunded = tmp.WasRefunded
	messageGiveawayWinners.PrizeDescription = tmp.PrizeDescription
	messageGiveawayWinners.WinnerCount = tmp.WinnerCount
	messageGiveawayWinners.WinnerUserIds = tmp.WinnerUserIds
	messageGiveawayWinners.UnclaimedPrizeCount = tmp.UnclaimedPrizeCount

	fieldPrize, _ := UnmarshalGiveawayPrize(tmp.Prize)
	messageGiveawayWinners.Prize = fieldPrize

	return nil
}

// Telegram Stars were gifted to a user
type MessageGiftedStars struct {
	meta
	// The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing
	GifterUserId int64 `json:"gifter_user_id"`
	// The identifier of a user that received Telegram Stars; 0 if the gift is incoming
	ReceiverUserId int64 `json:"receiver_user_id"`
	// Currency for the paid amount
	Currency string `json:"currency"`
	// The paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Cryptocurrency used to pay for the gift; may be empty if none
	Cryptocurrency string `json:"cryptocurrency"`
	// The paid amount, in the smallest units of the cryptocurrency; 0 if none
	CryptocurrencyAmount JsonInt64 `json:"cryptocurrency_amount"`
	// Number of Telegram Stars that were gifted
	StarCount int64 `json:"star_count"`
	// Identifier of the transaction for Telegram Stars purchase; for receiver only
	TransactionId string `json:"transaction_id"`
	// A sticker to be shown in the message; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageGiftedStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiftedStars

	return json.Marshal((*stub)(entity))
}

func (*MessageGiftedStars) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiftedStars) GetType() string {
	return TypeMessageGiftedStars
}

func (*MessageGiftedStars) MessageContentType() string {
	return TypeMessageGiftedStars
}

// A Telegram Stars were received by the current user from a giveaway
type MessageGiveawayPrizeStars struct {
	meta
	// Number of Telegram Stars that were received
	StarCount int64 `json:"star_count"`
	// Identifier of the transaction for Telegram Stars credit
	TransactionId string `json:"transaction_id"`
	// Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
	BoostedChatId int64 `json:"boosted_chat_id"`
	// Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted
	GiveawayMessageId int64 `json:"giveaway_message_id"`
	// True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat
	IsUnclaimed bool `json:"is_unclaimed"`
	// A sticker to be shown in the message; may be null if unknown
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageGiveawayPrizeStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGiveawayPrizeStars

	return json.Marshal((*stub)(entity))
}

func (*MessageGiveawayPrizeStars) GetClass() string {
	return ClassMessageContent
}

func (*MessageGiveawayPrizeStars) GetType() string {
	return TypeMessageGiveawayPrizeStars
}

func (*MessageGiveawayPrizeStars) MessageContentType() string {
	return TypeMessageGiveawayPrizeStars
}

// A gift was received or sent by the current user
type MessageGift struct {
	meta
	// The gift
	Gift *Gift `json:"gift"`
	// Message added to the gift
	Text *FormattedText `json:"text"`
	// Number of Telegram Stars that can be claimed by the receiver instead of the gift; 0 if the gift can't be sold by the receiver
	SellStarCount int64 `json:"sell_star_count"`
	// True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone will be able to see them
	IsPrivate bool `json:"is_private"`
	// True, if the gift is displayed on the user's profile page; only for the receiver of the gift
	IsSaved bool `json:"is_saved"`
	// True, if the gift was converted to Telegram Stars; only for the receiver of the gift
	WasConverted bool `json:"was_converted"`
}

func (entity *MessageGift) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGift

	return json.Marshal((*stub)(entity))
}

func (*MessageGift) GetClass() string {
	return ClassMessageContent
}

func (*MessageGift) GetType() string {
	return TypeMessageGift
}

func (*MessageGift) MessageContentType() string {
	return TypeMessageGift
}

// A contact has registered with Telegram
type MessageContactRegistered struct {
	meta
}

func (entity *MessageContactRegistered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageContactRegistered

	return json.Marshal((*stub)(entity))
}

func (*MessageContactRegistered) GetClass() string {
	return ClassMessageContent
}

func (*MessageContactRegistered) GetType() string {
	return TypeMessageContactRegistered
}

func (*MessageContactRegistered) MessageContentType() string {
	return TypeMessageContactRegistered
}

// The current user shared users, which were requested by the bot
type MessageUsersShared struct {
	meta
	// The shared users
	Users []*SharedUser `json:"users"`
	// Identifier of the keyboard button with the request
	ButtonId int32 `json:"button_id"`
}

func (entity *MessageUsersShared) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageUsersShared

	return json.Marshal((*stub)(entity))
}

func (*MessageUsersShared) GetClass() string {
	return ClassMessageContent
}

func (*MessageUsersShared) GetType() string {
	return TypeMessageUsersShared
}

func (*MessageUsersShared) MessageContentType() string {
	return TypeMessageUsersShared
}

// The current user shared a chat, which was requested by the bot
type MessageChatShared struct {
	meta
	// The shared chat
	Chat *SharedChat `json:"chat"`
	// Identifier of the keyboard button with the request
	ButtonId int32 `json:"button_id"`
}

func (entity *MessageChatShared) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatShared

	return json.Marshal((*stub)(entity))
}

func (*MessageChatShared) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatShared) GetType() string {
	return TypeMessageChatShared
}

func (*MessageChatShared) MessageContentType() string {
	return TypeMessageChatShared
}

// The user allowed the bot to send messages
type MessageBotWriteAccessAllowed struct {
	meta
	// The reason why the bot was allowed to write messages
	Reason BotWriteAccessAllowReason `json:"reason"`
}

func (entity *MessageBotWriteAccessAllowed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageBotWriteAccessAllowed

	return json.Marshal((*stub)(entity))
}

func (*MessageBotWriteAccessAllowed) GetClass() string {
	return ClassMessageContent
}

func (*MessageBotWriteAccessAllowed) GetType() string {
	return TypeMessageBotWriteAccessAllowed
}

func (*MessageBotWriteAccessAllowed) MessageContentType() string {
	return TypeMessageBotWriteAccessAllowed
}

func (messageBotWriteAccessAllowed *MessageBotWriteAccessAllowed) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Reason json.RawMessage `json:"reason"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldReason, _ := UnmarshalBotWriteAccessAllowReason(tmp.Reason)
	messageBotWriteAccessAllowed.Reason = fieldReason

	return nil
}

// Data from a Web App has been sent to a bot
type MessageWebAppDataSent struct {
	meta
	// Text of the keyboardButtonTypeWebApp button, which opened the Web App
	ButtonText string `json:"button_text"`
}

func (entity *MessageWebAppDataSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageWebAppDataSent

	return json.Marshal((*stub)(entity))
}

func (*MessageWebAppDataSent) GetClass() string {
	return ClassMessageContent
}

func (*MessageWebAppDataSent) GetType() string {
	return TypeMessageWebAppDataSent
}

func (*MessageWebAppDataSent) MessageContentType() string {
	return TypeMessageWebAppDataSent
}

// Data from a Web App has been received; for bots only
type MessageWebAppDataReceived struct {
	meta
	// Text of the keyboardButtonTypeWebApp button, which opened the Web App
	ButtonText string `json:"button_text"`
	// The data
	Data string `json:"data"`
}

func (entity *MessageWebAppDataReceived) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageWebAppDataReceived

	return json.Marshal((*stub)(entity))
}

func (*MessageWebAppDataReceived) GetClass() string {
	return ClassMessageContent
}

func (*MessageWebAppDataReceived) GetType() string {
	return TypeMessageWebAppDataReceived
}

func (*MessageWebAppDataReceived) MessageContentType() string {
	return TypeMessageWebAppDataReceived
}

// Telegram Passport data has been sent to a bot
type MessagePassportDataSent struct {
	meta
	// List of Telegram Passport element types sent
	Types []PassportElementType `json:"types"`
}

func (entity *MessagePassportDataSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePassportDataSent

	return json.Marshal((*stub)(entity))
}

func (*MessagePassportDataSent) GetClass() string {
	return ClassMessageContent
}

func (*MessagePassportDataSent) GetType() string {
	return TypeMessagePassportDataSent
}

func (*MessagePassportDataSent) MessageContentType() string {
	return TypeMessagePassportDataSent
}

func (messagePassportDataSent *MessagePassportDataSent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Types []json.RawMessage `json:"types"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTypes, _ := UnmarshalListOfPassportElementType(tmp.Types)
	messagePassportDataSent.Types = fieldTypes

	return nil
}

// Telegram Passport data has been received; for bots only
type MessagePassportDataReceived struct {
	meta
	// List of received Telegram Passport elements
	Elements []*EncryptedPassportElement `json:"elements"`
	// Encrypted data credentials
	Credentials *EncryptedCredentials `json:"credentials"`
}

func (entity *MessagePassportDataReceived) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePassportDataReceived

	return json.Marshal((*stub)(entity))
}

func (*MessagePassportDataReceived) GetClass() string {
	return ClassMessageContent
}

func (*MessagePassportDataReceived) GetType() string {
	return TypeMessagePassportDataReceived
}

func (*MessagePassportDataReceived) MessageContentType() string {
	return TypeMessagePassportDataReceived
}

// A user in the chat came within proximity alert range
type MessageProximityAlertTriggered struct {
	meta
	// The identifier of a user or chat that triggered the proximity alert
	TravelerId MessageSender `json:"traveler_id"`
	// The identifier of a user or chat that subscribed for the proximity alert
	WatcherId MessageSender `json:"watcher_id"`
	// The distance between the users
	Distance int32 `json:"distance"`
}

func (entity *MessageProximityAlertTriggered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageProximityAlertTriggered

	return json.Marshal((*stub)(entity))
}

func (*MessageProximityAlertTriggered) GetClass() string {
	return ClassMessageContent
}

func (*MessageProximityAlertTriggered) GetType() string {
	return TypeMessageProximityAlertTriggered
}

func (*MessageProximityAlertTriggered) MessageContentType() string {
	return TypeMessageProximityAlertTriggered
}

func (messageProximityAlertTriggered *MessageProximityAlertTriggered) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TravelerId json.RawMessage `json:"traveler_id"`
		WatcherId  json.RawMessage `json:"watcher_id"`
		Distance   int32           `json:"distance"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageProximityAlertTriggered.Distance = tmp.Distance

	fieldTravelerId, _ := UnmarshalMessageSender(tmp.TravelerId)
	messageProximityAlertTriggered.TravelerId = fieldTravelerId

	fieldWatcherId, _ := UnmarshalMessageSender(tmp.WatcherId)
	messageProximityAlertTriggered.WatcherId = fieldWatcherId

	return nil
}

// A message content that is not supported in the current TDLib version
type MessageUnsupported struct {
	meta
}

func (entity *MessageUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageUnsupported

	return json.Marshal((*stub)(entity))
}

func (*MessageUnsupported) GetClass() string {
	return ClassMessageContent
}

func (*MessageUnsupported) GetType() string {
	return TypeMessageUnsupported
}

func (*MessageUnsupported) MessageContentType() string {
	return TypeMessageUnsupported
}

// A mention of a user, a supergroup, or a channel by their username
type TextEntityTypeMention struct {
	meta
}

func (entity *TextEntityTypeMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMention

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMention) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMention) GetType() string {
	return TypeTextEntityTypeMention
}

func (*TextEntityTypeMention) TextEntityTypeType() string {
	return TypeTextEntityTypeMention
}

// A hashtag text, beginning with "#" and optionally containing a chat username at the end
type TextEntityTypeHashtag struct {
	meta
}

func (entity *TextEntityTypeHashtag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeHashtag

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeHashtag) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeHashtag) GetType() string {
	return TypeTextEntityTypeHashtag
}

func (*TextEntityTypeHashtag) TextEntityTypeType() string {
	return TypeTextEntityTypeHashtag
}

// A cashtag text, beginning with "$", consisting of capital English letters (e.g., "$USD"), and optionally containing a chat username at the end
type TextEntityTypeCashtag struct {
	meta
}

func (entity *TextEntityTypeCashtag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCashtag

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCashtag) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCashtag) GetType() string {
	return TypeTextEntityTypeCashtag
}

func (*TextEntityTypeCashtag) TextEntityTypeType() string {
	return TypeTextEntityTypeCashtag
}

// A bot command, beginning with "/"
type TextEntityTypeBotCommand struct {
	meta
}

func (entity *TextEntityTypeBotCommand) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBotCommand

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBotCommand) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBotCommand) GetType() string {
	return TypeTextEntityTypeBotCommand
}

func (*TextEntityTypeBotCommand) TextEntityTypeType() string {
	return TypeTextEntityTypeBotCommand
}

// An HTTP URL
type TextEntityTypeUrl struct {
	meta
}

func (entity *TextEntityTypeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeUrl

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeUrl) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeUrl) GetType() string {
	return TypeTextEntityTypeUrl
}

func (*TextEntityTypeUrl) TextEntityTypeType() string {
	return TypeTextEntityTypeUrl
}

// An email address
type TextEntityTypeEmailAddress struct {
	meta
}

func (entity *TextEntityTypeEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeEmailAddress) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeEmailAddress) GetType() string {
	return TypeTextEntityTypeEmailAddress
}

func (*TextEntityTypeEmailAddress) TextEntityTypeType() string {
	return TypeTextEntityTypeEmailAddress
}

// A phone number
type TextEntityTypePhoneNumber struct {
	meta
}

func (entity *TextEntityTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePhoneNumber) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePhoneNumber) GetType() string {
	return TypeTextEntityTypePhoneNumber
}

func (*TextEntityTypePhoneNumber) TextEntityTypeType() string {
	return TypeTextEntityTypePhoneNumber
}

// A bank card number. The getBankCardInfo method can be used to get information about the bank card
type TextEntityTypeBankCardNumber struct {
	meta
}

func (entity *TextEntityTypeBankCardNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBankCardNumber

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBankCardNumber) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBankCardNumber) GetType() string {
	return TypeTextEntityTypeBankCardNumber
}

func (*TextEntityTypeBankCardNumber) TextEntityTypeType() string {
	return TypeTextEntityTypeBankCardNumber
}

// A bold text
type TextEntityTypeBold struct {
	meta
}

func (entity *TextEntityTypeBold) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBold

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBold) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBold) GetType() string {
	return TypeTextEntityTypeBold
}

func (*TextEntityTypeBold) TextEntityTypeType() string {
	return TypeTextEntityTypeBold
}

// An italic text
type TextEntityTypeItalic struct {
	meta
}

func (entity *TextEntityTypeItalic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeItalic

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeItalic) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeItalic) GetType() string {
	return TypeTextEntityTypeItalic
}

func (*TextEntityTypeItalic) TextEntityTypeType() string {
	return TypeTextEntityTypeItalic
}

// An underlined text
type TextEntityTypeUnderline struct {
	meta
}

func (entity *TextEntityTypeUnderline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeUnderline

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeUnderline) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeUnderline) GetType() string {
	return TypeTextEntityTypeUnderline
}

func (*TextEntityTypeUnderline) TextEntityTypeType() string {
	return TypeTextEntityTypeUnderline
}

// A strikethrough text
type TextEntityTypeStrikethrough struct {
	meta
}

func (entity *TextEntityTypeStrikethrough) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeStrikethrough

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeStrikethrough) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeStrikethrough) GetType() string {
	return TypeTextEntityTypeStrikethrough
}

func (*TextEntityTypeStrikethrough) TextEntityTypeType() string {
	return TypeTextEntityTypeStrikethrough
}

// A spoiler text
type TextEntityTypeSpoiler struct {
	meta
}

func (entity *TextEntityTypeSpoiler) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeSpoiler

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeSpoiler) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeSpoiler) GetType() string {
	return TypeTextEntityTypeSpoiler
}

func (*TextEntityTypeSpoiler) TextEntityTypeType() string {
	return TypeTextEntityTypeSpoiler
}

// Text that must be formatted as if inside a code HTML tag
type TextEntityTypeCode struct {
	meta
}

func (entity *TextEntityTypeCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCode

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCode) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCode) GetType() string {
	return TypeTextEntityTypeCode
}

func (*TextEntityTypeCode) TextEntityTypeType() string {
	return TypeTextEntityTypeCode
}

// Text that must be formatted as if inside a pre HTML tag
type TextEntityTypePre struct {
	meta
}

func (entity *TextEntityTypePre) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePre

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePre) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePre) GetType() string {
	return TypeTextEntityTypePre
}

func (*TextEntityTypePre) TextEntityTypeType() string {
	return TypeTextEntityTypePre
}

// Text that must be formatted as if inside pre, and code HTML tags
type TextEntityTypePreCode struct {
	meta
	// Programming language of the code; as defined by the sender
	Language string `json:"language"`
}

func (entity *TextEntityTypePreCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePreCode

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePreCode) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePreCode) GetType() string {
	return TypeTextEntityTypePreCode
}

func (*TextEntityTypePreCode) TextEntityTypeType() string {
	return TypeTextEntityTypePreCode
}

// Text that must be formatted as if inside a blockquote HTML tag; not supported in secret chats
type TextEntityTypeBlockQuote struct {
	meta
}

func (entity *TextEntityTypeBlockQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBlockQuote

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBlockQuote) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBlockQuote) GetType() string {
	return TypeTextEntityTypeBlockQuote
}

func (*TextEntityTypeBlockQuote) TextEntityTypeType() string {
	return TypeTextEntityTypeBlockQuote
}

// Text that must be formatted as if inside a blockquote HTML tag and collapsed by default to 3 lines with the ability to show full text; not supported in secret chats
type TextEntityTypeExpandableBlockQuote struct {
	meta
}

func (entity *TextEntityTypeExpandableBlockQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeExpandableBlockQuote

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeExpandableBlockQuote) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeExpandableBlockQuote) GetType() string {
	return TypeTextEntityTypeExpandableBlockQuote
}

func (*TextEntityTypeExpandableBlockQuote) TextEntityTypeType() string {
	return TypeTextEntityTypeExpandableBlockQuote
}

// A text description shown instead of a raw URL
type TextEntityTypeTextUrl struct {
	meta
	// HTTP or tg:// URL to be opened when the link is clicked
	Url string `json:"url"`
}

func (entity *TextEntityTypeTextUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeTextUrl

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeTextUrl) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeTextUrl) GetType() string {
	return TypeTextEntityTypeTextUrl
}

func (*TextEntityTypeTextUrl) TextEntityTypeType() string {
	return TypeTextEntityTypeTextUrl
}

// A text shows instead of a raw mention of the user (e.g., when the user has no username)
type TextEntityTypeMentionName struct {
	meta
	// Identifier of the mentioned user
	UserId int64 `json:"user_id"`
}

func (entity *TextEntityTypeMentionName) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMentionName

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMentionName) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMentionName) GetType() string {
	return TypeTextEntityTypeMentionName
}

func (*TextEntityTypeMentionName) TextEntityTypeType() string {
	return TypeTextEntityTypeMentionName
}

// A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji
type TextEntityTypeCustomEmoji struct {
	meta
	// Unique identifier of the custom emoji
	CustomEmojiId JsonInt64 `json:"custom_emoji_id"`
}

func (entity *TextEntityTypeCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCustomEmoji) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCustomEmoji) GetType() string {
	return TypeTextEntityTypeCustomEmoji
}

func (*TextEntityTypeCustomEmoji) TextEntityTypeType() string {
	return TypeTextEntityTypeCustomEmoji
}

// A media timestamp
type TextEntityTypeMediaTimestamp struct {
	meta
	// Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the link preview of the current message, or in the same places in the replied message
	MediaTimestamp int32 `json:"media_timestamp"`
}

func (entity *TextEntityTypeMediaTimestamp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMediaTimestamp

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMediaTimestamp) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMediaTimestamp) GetType() string {
	return TypeTextEntityTypeMediaTimestamp
}

func (*TextEntityTypeMediaTimestamp) TextEntityTypeType() string {
	return TypeTextEntityTypeMediaTimestamp
}

// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
type InputThumbnail struct {
	meta
	// Thumbnail file to send. Sending thumbnails by file_id is currently not supported
	Thumbnail InputFile `json:"thumbnail"`
	// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
	Width int32 `json:"width"`
	// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
	Height int32 `json:"height"`
}

func (entity *InputThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputThumbnail

	return json.Marshal((*stub)(entity))
}

func (*InputThumbnail) GetClass() string {
	return ClassInputThumbnail
}

func (*InputThumbnail) GetType() string {
	return TypeInputThumbnail
}

func (inputThumbnail *InputThumbnail) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Thumbnail json.RawMessage `json:"thumbnail"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputThumbnail.Width = tmp.Width
	inputThumbnail.Height = tmp.Height

	fieldThumbnail, _ := UnmarshalInputFile(tmp.Thumbnail)
	inputThumbnail.Thumbnail = fieldThumbnail

	return nil
}

// The media is a photo. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
type InputPaidMediaTypePhoto struct {
	meta
}

func (entity *InputPaidMediaTypePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPaidMediaTypePhoto

	return json.Marshal((*stub)(entity))
}

func (*InputPaidMediaTypePhoto) GetClass() string {
	return ClassInputPaidMediaType
}

func (*InputPaidMediaTypePhoto) GetType() string {
	return TypeInputPaidMediaTypePhoto
}

func (*InputPaidMediaTypePhoto) InputPaidMediaTypeType() string {
	return TypeInputPaidMediaTypePhoto
}

// The media is a video
type InputPaidMediaTypeVideo struct {
	meta
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// True, if the video is expected to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
}

func (entity *InputPaidMediaTypeVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPaidMediaTypeVideo

	return json.Marshal((*stub)(entity))
}

func (*InputPaidMediaTypeVideo) GetClass() string {
	return ClassInputPaidMediaType
}

func (*InputPaidMediaTypeVideo) GetType() string {
	return TypeInputPaidMediaTypeVideo
}

func (*InputPaidMediaTypeVideo) InputPaidMediaTypeType() string {
	return TypeInputPaidMediaTypeVideo
}

// Describes a paid media to be sent
type InputPaidMedia struct {
	meta
	// Type of the media
	Type InputPaidMediaType `json:"type"`
	// Photo or video to be sent
	Media InputFile `json:"media"`
	// Media thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the media, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Media width
	Width int32 `json:"width"`
	// Media height
	Height int32 `json:"height"`
}

func (entity *InputPaidMedia) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPaidMedia

	return json.Marshal((*stub)(entity))
}

func (*InputPaidMedia) GetClass() string {
	return ClassInputPaidMedia
}

func (*InputPaidMedia) GetType() string {
	return TypeInputPaidMedia
}

func (inputPaidMedia *InputPaidMedia) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type                json.RawMessage `json:"type"`
		Media               json.RawMessage `json:"media"`
		Thumbnail           *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Width               int32           `json:"width"`
		Height              int32           `json:"height"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputPaidMedia.Thumbnail = tmp.Thumbnail
	inputPaidMedia.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputPaidMedia.Width = tmp.Width
	inputPaidMedia.Height = tmp.Height

	fieldType, _ := UnmarshalInputPaidMediaType(tmp.Type)
	inputPaidMedia.Type = fieldType

	fieldMedia, _ := UnmarshalInputFile(tmp.Media)
	inputPaidMedia.Media = fieldMedia

	return nil
}

// The message will be sent at the specified date
type MessageSchedulingStateSendAtDate struct {
	meta
	// Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
	SendDate int32 `json:"send_date"`
}

func (entity *MessageSchedulingStateSendAtDate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendAtDate

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendAtDate) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendAtDate) GetType() string {
	return TypeMessageSchedulingStateSendAtDate
}

func (*MessageSchedulingStateSendAtDate) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendAtDate
}

// The message will be sent when the other user is online. Applicable to private chats only and when the exact online status of the other user is known
type MessageSchedulingStateSendWhenOnline struct {
	meta
}

func (entity *MessageSchedulingStateSendWhenOnline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendWhenOnline

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendWhenOnline) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendWhenOnline) GetType() string {
	return TypeMessageSchedulingStateSendWhenOnline
}

func (*MessageSchedulingStateSendWhenOnline) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendWhenOnline
}

// The message will be sent when the video in the message is converted and optimized; can be used only by the server
type MessageSchedulingStateSendWhenVideoProcessed struct {
	meta
	// Approximate point in time (Unix timestamp) when the message is expected to be sent
	SendDate int32 `json:"send_date"`
}

func (entity *MessageSchedulingStateSendWhenVideoProcessed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendWhenVideoProcessed

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendWhenVideoProcessed) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendWhenVideoProcessed) GetType() string {
	return TypeMessageSchedulingStateSendWhenVideoProcessed
}

func (*MessageSchedulingStateSendWhenVideoProcessed) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendWhenVideoProcessed
}

// The message will be self-destructed in the specified time after its content was opened
type MessageSelfDestructTypeTimer struct {
	meta
	// The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
	SelfDestructTime int32 `json:"self_destruct_time"`
}

func (entity *MessageSelfDestructTypeTimer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSelfDestructTypeTimer

	return json.Marshal((*stub)(entity))
}

func (*MessageSelfDestructTypeTimer) GetClass() string {
	return ClassMessageSelfDestructType
}

func (*MessageSelfDestructTypeTimer) GetType() string {
	return TypeMessageSelfDestructTypeTimer
}

func (*MessageSelfDestructTypeTimer) MessageSelfDestructTypeType() string {
	return TypeMessageSelfDestructTypeTimer
}

// The message can be opened only once and will be self-destructed once closed
type MessageSelfDestructTypeImmediately struct {
	meta
}

func (entity *MessageSelfDestructTypeImmediately) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSelfDestructTypeImmediately

	return json.Marshal((*stub)(entity))
}

func (*MessageSelfDestructTypeImmediately) GetClass() string {
	return ClassMessageSelfDestructType
}

func (*MessageSelfDestructTypeImmediately) GetType() string {
	return TypeMessageSelfDestructTypeImmediately
}

func (*MessageSelfDestructTypeImmediately) MessageSelfDestructTypeType() string {
	return TypeMessageSelfDestructTypeImmediately
}

// Options to be used when a message is sent
type MessageSendOptions struct {
	meta
	// Pass true to disable notification for the message
	DisableNotification bool `json:"disable_notification"`
	// Pass true if the message is sent from the background
	FromBackground bool `json:"from_background"`
	// Pass true if the content of the message must be protected from forwarding and saving; for bots only
	ProtectContent bool `json:"protect_content"`
	// Pass true to allow the message to ignore regular broadcast limits for a small fee; for bots only
	AllowPaidBroadcast bool `json:"allow_paid_broadcast"`
	// Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
	UpdateOrderOfInstalledStickerSets bool `json:"update_order_of_installed_sticker_sets"`
	// Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
	SchedulingState MessageSchedulingState `json:"scheduling_state"`
	// Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats
	EffectId JsonInt64 `json:"effect_id"`
	// Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
	SendingId int32 `json:"sending_id"`
	// Pass true to get a fake message instead of actually sending them
	OnlyPreview bool `json:"only_preview"`
}

func (entity *MessageSendOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendOptions

	return json.Marshal((*stub)(entity))
}

func (*MessageSendOptions) GetClass() string {
	return ClassMessageSendOptions
}

func (*MessageSendOptions) GetType() string {
	return TypeMessageSendOptions
}

func (messageSendOptions *MessageSendOptions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		DisableNotification               bool            `json:"disable_notification"`
		FromBackground                    bool            `json:"from_background"`
		ProtectContent                    bool            `json:"protect_content"`
		AllowPaidBroadcast                bool            `json:"allow_paid_broadcast"`
		UpdateOrderOfInstalledStickerSets bool            `json:"update_order_of_installed_sticker_sets"`
		SchedulingState                   json.RawMessage `json:"scheduling_state"`
		EffectId                          JsonInt64       `json:"effect_id"`
		SendingId                         int32           `json:"sending_id"`
		OnlyPreview                       bool            `json:"only_preview"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageSendOptions.DisableNotification = tmp.DisableNotification
	messageSendOptions.FromBackground = tmp.FromBackground
	messageSendOptions.ProtectContent = tmp.ProtectContent
	messageSendOptions.AllowPaidBroadcast = tmp.AllowPaidBroadcast
	messageSendOptions.UpdateOrderOfInstalledStickerSets = tmp.UpdateOrderOfInstalledStickerSets
	messageSendOptions.EffectId = tmp.EffectId
	messageSendOptions.SendingId = tmp.SendingId
	messageSendOptions.OnlyPreview = tmp.OnlyPreview

	fieldSchedulingState, _ := UnmarshalMessageSchedulingState(tmp.SchedulingState)
	messageSendOptions.SchedulingState = fieldSchedulingState

	return nil
}

// Options to be used when a message content is copied without reference to the original sender. Service messages, messages with messageInvoice, messagePaidMedia, messageGiveaway, or messageGiveawayWinners content can't be copied
type MessageCopyOptions struct {
	meta
	// True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local. Use messageProperties.can_be_saved and messageProperties.can_be_copied_to_secret_chat to check whether the message is suitable
	SendCopy bool `json:"send_copy"`
	// True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
	ReplaceCaption bool `json:"replace_caption"`
	// New message caption; pass null to copy message without caption. Ignored if replace_caption is false
	NewCaption *FormattedText `json:"new_caption"`
	// True, if new caption must be shown above the media; otherwise, new caption must be shown below the media; not supported in secret chats. Ignored if replace_caption is false
	NewShowCaptionAboveMedia bool `json:"new_show_caption_above_media"`
}

func (entity *MessageCopyOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCopyOptions

	return json.Marshal((*stub)(entity))
}

func (*MessageCopyOptions) GetClass() string {
	return ClassMessageCopyOptions
}

func (*MessageCopyOptions) GetType() string {
	return TypeMessageCopyOptions
}

// A text message
type InputMessageText struct {
	meta
	// Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
	Text *FormattedText `json:"text"`
	// Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options
	LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options"`
	// True, if a chat message draft must be deleted
	ClearDraft bool `json:"clear_draft"`
}

func (entity *InputMessageText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageText

	return json.Marshal((*stub)(entity))
}

func (*InputMessageText) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageText) GetType() string {
	return TypeInputMessageText
}

func (*InputMessageText) InputMessageContentType() string {
	return TypeInputMessageText
}

// An animation message (GIF-style).
type InputMessageAnimation struct {
	meta
	// Animation file to be sent
	Animation InputFile `json:"animation"`
	// Animation thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the animation, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Duration of the animation, in seconds
	Duration int32 `json:"duration"`
	// Width of the animation; may be replaced by the server
	Width int32 `json:"width"`
	// Height of the animation; may be replaced by the server
	Height int32 `json:"height"`
	// Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
	HasSpoiler bool `json:"has_spoiler"`
}

func (entity *InputMessageAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputMessageAnimation) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageAnimation) GetType() string {
	return TypeInputMessageAnimation
}

func (*InputMessageAnimation) InputMessageContentType() string {
	return TypeInputMessageAnimation
}

func (inputMessageAnimation *InputMessageAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Animation             json.RawMessage `json:"animation"`
		Thumbnail             *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds   []int32         `json:"added_sticker_file_ids"`
		Duration              int32           `json:"duration"`
		Width                 int32           `json:"width"`
		Height                int32           `json:"height"`
		Caption               *FormattedText  `json:"caption"`
		ShowCaptionAboveMedia bool            `json:"show_caption_above_media"`
		HasSpoiler            bool            `json:"has_spoiler"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageAnimation.Thumbnail = tmp.Thumbnail
	inputMessageAnimation.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessageAnimation.Duration = tmp.Duration
	inputMessageAnimation.Width = tmp.Width
	inputMessageAnimation.Height = tmp.Height
	inputMessageAnimation.Caption = tmp.Caption
	inputMessageAnimation.ShowCaptionAboveMedia = tmp.ShowCaptionAboveMedia
	inputMessageAnimation.HasSpoiler = tmp.HasSpoiler

	fieldAnimation, _ := UnmarshalInputFile(tmp.Animation)
	inputMessageAnimation.Animation = fieldAnimation

	return nil
}

// An audio message
type InputMessageAudio struct {
	meta
	// Audio file to be sent
	Audio InputFile `json:"audio"`
	// Thumbnail of the cover for the album; pass null to skip thumbnail uploading
	AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"`
	// Duration of the audio, in seconds; may be replaced by the server
	Duration int32 `json:"duration"`
	// Title of the audio; 0-64 characters; may be replaced by the server
	Title string `json:"title"`
	// Performer of the audio; 0-64 characters, may be replaced by the server
	Performer string `json:"performer"`
	// Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageAudio

	return json.Marshal((*stub)(entity))
}

func (*InputMessageAudio) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageAudio) GetType() string {
	return TypeInputMessageAudio
}

func (*InputMessageAudio) InputMessageContentType() string {
	return TypeInputMessageAudio
}

func (inputMessageAudio *InputMessageAudio) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Audio               json.RawMessage `json:"audio"`
		AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"`
		Duration            int32           `json:"duration"`
		Title               string          `json:"title"`
		Performer           string          `json:"performer"`
		Caption             *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageAudio.AlbumCoverThumbnail = tmp.AlbumCoverThumbnail
	inputMessageAudio.Duration = tmp.Duration
	inputMessageAudio.Title = tmp.Title
	inputMessageAudio.Performer = tmp.Performer
	inputMessageAudio.Caption = tmp.Caption

	fieldAudio, _ := UnmarshalInputFile(tmp.Audio)
	inputMessageAudio.Audio = fieldAudio

	return nil
}

// A document message (general file)
type InputMessageDocument struct {
	meta
	// Document to be sent
	Document InputFile `json:"document"`
	// Document thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
	DisableContentTypeDetection bool `json:"disable_content_type_detection"`
	// Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageDocument

	return json.Marshal((*stub)(entity))
}

func (*InputMessageDocument) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageDocument) GetType() string {
	return TypeInputMessageDocument
}

func (*InputMessageDocument) InputMessageContentType() string {
	return TypeInputMessageDocument
}

func (inputMessageDocument *InputMessageDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Document                    json.RawMessage `json:"document"`
		Thumbnail                   *InputThumbnail `json:"thumbnail"`
		DisableContentTypeDetection bool            `json:"disable_content_type_detection"`
		Caption                     *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageDocument.Thumbnail = tmp.Thumbnail
	inputMessageDocument.DisableContentTypeDetection = tmp.DisableContentTypeDetection
	inputMessageDocument.Caption = tmp.Caption

	fieldDocument, _ := UnmarshalInputFile(tmp.Document)
	inputMessageDocument.Document = fieldDocument

	return nil
}

// A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed
type InputMessagePaidMedia struct {
	meta
	// The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max")
	StarCount int64 `json:"star_count"`
	// The content of the paid media
	PaidMedia []*InputPaidMedia `json:"paid_media"`
	// Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the media; otherwise, the caption must be shown below the media; not supported in secret chats
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// Bot-provided data for the paid media; bots only
	Payload string `json:"payload"`
}

func (entity *InputMessagePaidMedia) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePaidMedia

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePaidMedia) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePaidMedia) GetType() string {
	return TypeInputMessagePaidMedia
}

func (*InputMessagePaidMedia) InputMessageContentType() string {
	return TypeInputMessagePaidMedia
}

// A photo message
type InputMessagePhoto struct {
	meta
	// Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
	Photo InputFile `json:"photo"`
	// Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the photo, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Photo width
	Width int32 `json:"width"`
	// Photo height
	Height int32 `json:"height"`
	// Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// Photo self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructType `json:"self_destruct_type"`
	// True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
	HasSpoiler bool `json:"has_spoiler"`
}

func (entity *InputMessagePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePhoto

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePhoto) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePhoto) GetType() string {
	return TypeInputMessagePhoto
}

func (*InputMessagePhoto) InputMessageContentType() string {
	return TypeInputMessagePhoto
}

func (inputMessagePhoto *InputMessagePhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Photo                 json.RawMessage `json:"photo"`
		Thumbnail             *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds   []int32         `json:"added_sticker_file_ids"`
		Width                 int32           `json:"width"`
		Height                int32           `json:"height"`
		Caption               *FormattedText  `json:"caption"`
		ShowCaptionAboveMedia bool            `json:"show_caption_above_media"`
		SelfDestructType      json.RawMessage `json:"self_destruct_type"`
		HasSpoiler            bool            `json:"has_spoiler"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessagePhoto.Thumbnail = tmp.Thumbnail
	inputMessagePhoto.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessagePhoto.Width = tmp.Width
	inputMessagePhoto.Height = tmp.Height
	inputMessagePhoto.Caption = tmp.Caption
	inputMessagePhoto.ShowCaptionAboveMedia = tmp.ShowCaptionAboveMedia
	inputMessagePhoto.HasSpoiler = tmp.HasSpoiler

	fieldPhoto, _ := UnmarshalInputFile(tmp.Photo)
	inputMessagePhoto.Photo = fieldPhoto

	fieldSelfDestructType, _ := UnmarshalMessageSelfDestructType(tmp.SelfDestructType)
	inputMessagePhoto.SelfDestructType = fieldSelfDestructType

	return nil
}

// A sticker message
type InputMessageSticker struct {
	meta
	// Sticker to be sent
	Sticker InputFile `json:"sticker"`
	// Sticker thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Sticker width
	Width int32 `json:"width"`
	// Sticker height
	Height int32 `json:"height"`
	// Emoji used to choose the sticker
	Emoji string `json:"emoji"`
}

func (entity *InputMessageSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageSticker

	return json.Marshal((*stub)(entity))
}

func (*InputMessageSticker) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageSticker) GetType() string {
	return TypeInputMessageSticker
}

func (*InputMessageSticker) InputMessageContentType() string {
	return TypeInputMessageSticker
}

func (inputMessageSticker *InputMessageSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sticker   json.RawMessage `json:"sticker"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
		Emoji     string          `json:"emoji"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageSticker.Thumbnail = tmp.Thumbnail
	inputMessageSticker.Width = tmp.Width
	inputMessageSticker.Height = tmp.Height
	inputMessageSticker.Emoji = tmp.Emoji

	fieldSticker, _ := UnmarshalInputFile(tmp.Sticker)
	inputMessageSticker.Sticker = fieldSticker

	return nil
}

// A video message
type InputMessageVideo struct {
	meta
	// Video to be sent. The video is expected to be re-encoded to MPEG4 format with H.264 codec by the sender
	Video InputFile `json:"video"`
	// Video thumbnail; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the video, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// Video width
	Width int32 `json:"width"`
	// Video height
	Height int32 `json:"height"`
	// True, if the video is expected to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
	// Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
	ShowCaptionAboveMedia bool `json:"show_caption_above_media"`
	// Video self-destruct type; pass null if none; private chats only
	SelfDestructType MessageSelfDestructType `json:"self_destruct_type"`
	// True, if the video preview must be covered by a spoiler animation; not supported in secret chats
	HasSpoiler bool `json:"has_spoiler"`
}

func (entity *InputMessageVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVideo

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVideo) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVideo) GetType() string {
	return TypeInputMessageVideo
}

func (*InputMessageVideo) InputMessageContentType() string {
	return TypeInputMessageVideo
}

func (inputMessageVideo *InputMessageVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Video                 json.RawMessage `json:"video"`
		Thumbnail             *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds   []int32         `json:"added_sticker_file_ids"`
		Duration              int32           `json:"duration"`
		Width                 int32           `json:"width"`
		Height                int32           `json:"height"`
		SupportsStreaming     bool            `json:"supports_streaming"`
		Caption               *FormattedText  `json:"caption"`
		ShowCaptionAboveMedia bool            `json:"show_caption_above_media"`
		SelfDestructType      json.RawMessage `json:"self_destruct_type"`
		HasSpoiler            bool            `json:"has_spoiler"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVideo.Thumbnail = tmp.Thumbnail
	inputMessageVideo.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessageVideo.Duration = tmp.Duration
	inputMessageVideo.Width = tmp.Width
	inputMessageVideo.Height = tmp.Height
	inputMessageVideo.SupportsStreaming = tmp.SupportsStreaming
	inputMessageVideo.Caption = tmp.Caption
	inputMessageVideo.ShowCaptionAboveMedia = tmp.ShowCaptionAboveMedia
	inputMessageVideo.HasSpoiler = tmp.HasSpoiler

	fieldVideo, _ := UnmarshalInputFile(tmp.Video)
	inputMessageVideo.Video = fieldVideo

	fieldSelfDestructType, _ := UnmarshalMessageSelfDestructType(tmp.SelfDestructType)
	inputMessageVideo.SelfDestructType = fieldSelfDestructType

	return nil
}

// A video note message
type InputMessageVideoNote struct {
	meta
	// Video note to be sent. The video is expected to be encoded to MPEG4 format with H.264 codec and have no data outside of the visible circle
	VideoNote InputFile `json:"video_note"`
	// Video thumbnail; may be null if empty; pass null to skip thumbnail uploading
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Duration of the video, in seconds; 0-60
	Duration int32 `json:"duration"`
	// Video width and height; must be positive and not greater than 640
	Length int32 `json:"length"`
	// Video note self-destruct type; may be null if none; pass null if none; private chats only
	SelfDestructType MessageSelfDestructType `json:"self_destruct_type"`
}

func (entity *InputMessageVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVideoNote

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVideoNote) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVideoNote) GetType() string {
	return TypeInputMessageVideoNote
}

func (*InputMessageVideoNote) InputMessageContentType() string {
	return TypeInputMessageVideoNote
}

func (inputMessageVideoNote *InputMessageVideoNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		VideoNote        json.RawMessage `json:"video_note"`
		Thumbnail        *InputThumbnail `json:"thumbnail"`
		Duration         int32           `json:"duration"`
		Length           int32           `json:"length"`
		SelfDestructType json.RawMessage `json:"self_destruct_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVideoNote.Thumbnail = tmp.Thumbnail
	inputMessageVideoNote.Duration = tmp.Duration
	inputMessageVideoNote.Length = tmp.Length

	fieldVideoNote, _ := UnmarshalInputFile(tmp.VideoNote)
	inputMessageVideoNote.VideoNote = fieldVideoNote

	fieldSelfDestructType, _ := UnmarshalMessageSelfDestructType(tmp.SelfDestructType)
	inputMessageVideoNote.SelfDestructType = fieldSelfDestructType

	return nil
}

// A voice note message
type InputMessageVoiceNote struct {
	meta
	// Voice note to be sent. The voice note must be encoded with the Opus codec and stored inside an OGG container with a single audio channel, or be in MP3 or M4A format as regular audio
	VoiceNote InputFile `json:"voice_note"`
	// Duration of the voice note, in seconds
	Duration int32 `json:"duration"`
	// Waveform representation of the voice note in 5-bit format
	Waveform []byte `json:"waveform"`
	// Voice note caption; may be null if empty; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// Voice note self-destruct type; may be null if none; pass null if none; private chats only
	SelfDestructType MessageSelfDestructType `json:"self_destruct_type"`
}

func (entity *InputMessageVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVoiceNote) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVoiceNote) GetType() string {
	return TypeInputMessageVoiceNote
}

func (*InputMessageVoiceNote) InputMessageContentType() string {
	return TypeInputMessageVoiceNote
}

func (inputMessageVoiceNote *InputMessageVoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		VoiceNote        json.RawMessage `json:"voice_note"`
		Duration         int32           `json:"duration"`
		Waveform         []byte          `json:"waveform"`
		Caption          *FormattedText  `json:"caption"`
		SelfDestructType json.RawMessage `json:"self_destruct_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVoiceNote.Duration = tmp.Duration
	inputMessageVoiceNote.Waveform = tmp.Waveform
	inputMessageVoiceNote.Caption = tmp.Caption

	fieldVoiceNote, _ := UnmarshalInputFile(tmp.VoiceNote)
	inputMessageVoiceNote.VoiceNote = fieldVoiceNote

	fieldSelfDestructType, _ := UnmarshalMessageSelfDestructType(tmp.SelfDestructType)
	inputMessageVoiceNote.SelfDestructType = fieldSelfDestructType

	return nil
}

// A message with a location
type InputMessageLocation struct {
	meta
	// Location to be sent
	Location *Location `json:"location"`
	// Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise
	LivePeriod int32 `json:"live_period"`
	// For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
	Heading int32 `json:"heading"`
	// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
	ProximityAlertRadius int32 `json:"proximity_alert_radius"`
}

func (entity *InputMessageLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageLocation

	return json.Marshal((*stub)(entity))
}

func (*InputMessageLocation) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageLocation) GetType() string {
	return TypeInputMessageLocation
}

func (*InputMessageLocation) InputMessageContentType() string {
	return TypeInputMessageLocation
}

// A message with information about a venue
type InputMessageVenue struct {
	meta
	// Venue to send
	Venue *Venue `json:"venue"`
}

func (entity *InputMessageVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVenue

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVenue) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVenue) GetType() string {
	return TypeInputMessageVenue
}

func (*InputMessageVenue) InputMessageContentType() string {
	return TypeInputMessageVenue
}

// A message containing a user contact
type InputMessageContact struct {
	meta
	// Contact to send
	Contact *Contact `json:"contact"`
}

func (entity *InputMessageContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageContact

	return json.Marshal((*stub)(entity))
}

func (*InputMessageContact) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageContact) GetType() string {
	return TypeInputMessageContact
}

func (*InputMessageContact) InputMessageContentType() string {
	return TypeInputMessageContact
}

// A dice message
type InputMessageDice struct {
	meta
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`
	// True, if the chat message draft must be deleted
	ClearDraft bool `json:"clear_draft"`
}

func (entity *InputMessageDice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageDice

	return json.Marshal((*stub)(entity))
}

func (*InputMessageDice) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageDice) GetType() string {
	return TypeInputMessageDice
}

func (*InputMessageDice) InputMessageContentType() string {
	return TypeInputMessageDice
}

// A message with a game; not supported for channels or secret chats
type InputMessageGame struct {
	meta
	// User identifier of the bot that owns the game
	BotUserId int64 `json:"bot_user_id"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
}

func (entity *InputMessageGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageGame

	return json.Marshal((*stub)(entity))
}

func (*InputMessageGame) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageGame) GetType() string {
	return TypeInputMessageGame
}

func (*InputMessageGame) InputMessageContentType() string {
	return TypeInputMessageGame
}

// A message with an invoice; can be used only by bots
type InputMessageInvoice struct {
	meta
	// Invoice
	Invoice *Invoice `json:"invoice"`
	// Product title; 1-32 characters
	Title string `json:"title"`
	// Product description; 0-255 characters
	Description string `json:"description"`
	// Product photo URL; optional
	PhotoUrl string `json:"photo_url"`
	// Product photo size
	PhotoSize int32 `json:"photo_size"`
	// Product photo width
	PhotoWidth int32 `json:"photo_width"`
	// Product photo height
	PhotoHeight int32 `json:"photo_height"`
	// The invoice payload
	Payload []byte `json:"payload"`
	// Payment provider token; may be empty for payments in Telegram Stars
	ProviderToken string `json:"provider_token"`
	// JSON-encoded data about the invoice, which will be shared with the payment provider
	ProviderData string `json:"provider_data"`
	// Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
	StartParameter string `json:"start_parameter"`
	// The content of paid media attached to the invoice; pass null if none
	PaidMedia *InputPaidMedia `json:"paid_media"`
	// Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	PaidMediaCaption *FormattedText `json:"paid_media_caption"`
}

func (entity *InputMessageInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageInvoice

	return json.Marshal((*stub)(entity))
}

func (*InputMessageInvoice) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageInvoice) GetType() string {
	return TypeInputMessageInvoice
}

func (*InputMessageInvoice) InputMessageContentType() string {
	return TypeInputMessageInvoice
}

// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
type InputMessagePoll struct {
	meta
	// Poll question; 1-255 characters (up to 300 characters for bots). Only custom emoji entities are allowed to be added and only by Premium users
	Question *FormattedText `json:"question"`
	// List of poll answer options, 2-10 strings 1-100 characters each. Only custom emoji entities are allowed to be added and only by Premium users
	Options []*FormattedText `json:"options"`
	// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
	IsAnonymous bool `json:"is_anonymous"`
	// Type of the poll
	Type PollType `json:"type"`
	// Amount of time the poll will be active after creation, in seconds; for bots only
	OpenPeriod int32 `json:"open_period"`
	// Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
	CloseDate int32 `json:"close_date"`
	// True, if the poll needs to be sent already closed; for bots only
	IsClosed bool `json:"is_closed"`
}

func (entity *InputMessagePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePoll

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePoll) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePoll) GetType() string {
	return TypeInputMessagePoll
}

func (*InputMessagePoll) InputMessageContentType() string {
	return TypeInputMessagePoll
}

func (inputMessagePoll *InputMessagePoll) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Question    *FormattedText   `json:"question"`
		Options     []*FormattedText `json:"options"`
		IsAnonymous bool             `json:"is_anonymous"`
		Type        json.RawMessage  `json:"type"`
		OpenPeriod  int32            `json:"open_period"`
		CloseDate   int32            `json:"close_date"`
		IsClosed    bool             `json:"is_closed"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessagePoll.Question = tmp.Question
	inputMessagePoll.Options = tmp.Options
	inputMessagePoll.IsAnonymous = tmp.IsAnonymous
	inputMessagePoll.OpenPeriod = tmp.OpenPeriod
	inputMessagePoll.CloseDate = tmp.CloseDate
	inputMessagePoll.IsClosed = tmp.IsClosed

	fieldType, _ := UnmarshalPollType(tmp.Type)
	inputMessagePoll.Type = fieldType

	return nil
}

// A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded
type InputMessageStory struct {
	meta
	// Identifier of the chat that posted the story
	StorySenderChatId int64 `json:"story_sender_chat_id"`
	// Story identifier
	StoryId int32 `json:"story_id"`
}

func (entity *InputMessageStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageStory

	return json.Marshal((*stub)(entity))
}

func (*InputMessageStory) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageStory) GetType() string {
	return TypeInputMessageStory
}

func (*InputMessageStory) InputMessageContentType() string {
	return TypeInputMessageStory
}

// A forwarded message
type InputMessageForwarded struct {
	meta
	// Identifier for the chat this forwarded message came from
	FromChatId int64 `json:"from_chat_id"`
	// Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded
	MessageId int64 `json:"message_id"`
	// True, if a game message is being shared from a launched game; applies only to game messages
	InGameShare bool `json:"in_game_share"`
	// Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
	CopyOptions *MessageCopyOptions `json:"copy_options"`
}

func (entity *InputMessageForwarded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageForwarded

	return json.Marshal((*stub)(entity))
}

func (*InputMessageForwarded) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageForwarded) GetType() string {
	return TypeInputMessageForwarded
}

func (*InputMessageForwarded) InputMessageContentType() string {
	return TypeInputMessageForwarded
}

// Contains properties of a message and describes actions that can be done with the message right now
type MessageProperties struct {
	meta
	// True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options
	CanBeCopiedToSecretChat bool `json:"can_be_copied_to_secret_chat"`
	// True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke == false
	CanBeDeletedOnlyForSelf bool `json:"can_be_deleted_only_for_self"`
	// True, if the message can be deleted for all users using the method deleteMessages with revoke == true
	CanBeDeletedForAllUsers bool `json:"can_be_deleted_for_all_users"`
	// True, if the message can be edited using the methods editMessageText, editMessageCaption, or editMessageReplyMarkup. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message
	CanBeEdited bool `json:"can_be_edited"`
	// True, if the message can be forwarded using inputMessageForwarded or forwardMessages
	CanBeForwarded bool `json:"can_be_forwarded"`
	// True, if the message can be paid using inputInvoiceMessage
	CanBePaid bool `json:"can_be_paid"`
	// True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage
	CanBePinned bool `json:"can_be_pinned"`
	// True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage
	CanBeReplied bool `json:"can_be_replied"`
	// True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage
	CanBeRepliedInAnotherChat bool `json:"can_be_replied_in_another_chat"`
	// True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
	CanBeSaved bool `json:"can_be_saved"`
	// True, if the message can be shared in a story using inputStoryAreaTypeMessage
	CanBeSharedInStory bool `json:"can_be_shared_in_story"`
	// True, if the message can be edited using the method editMessageMedia
	CanEditMedia bool `json:"can_edit_media"`
	// True, if scheduling state of the message can be edited
	CanEditSchedulingState bool `json:"can_edit_scheduling_state"`
	// True, if code for message embedding can be received using getMessageEmbeddingCode
	CanGetEmbeddingCode bool `json:"can_get_embedding_code"`
	// True, if a link can be generated for the message using getMessageLink
	CanGetLink bool `json:"can_get_link"`
	// True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink
	CanGetMediaTimestampLinks bool `json:"can_get_media_timestamp_links"`
	// True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
	CanGetMessageThread bool `json:"can_get_message_thread"`
	// True, if read date of the message can be received through getMessageReadDate
	CanGetReadDate bool `json:"can_get_read_date"`
	// True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards
	CanGetStatistics bool `json:"can_get_statistics"`
	// True, if chat members already viewed the message can be received through getMessageViewers
	CanGetViewers bool `json:"can_get_viewers"`
	// True, if speech can be recognized for the message through recognizeSpeech
	CanRecognizeSpeech bool `json:"can_recognize_speech"`
	// True, if the message can be reported using reportChat
	CanReportChat bool `json:"can_report_chat"`
	// True, if reactions on the message can be reported through reportMessageReactions
	CanReportReactions bool `json:"can_report_reactions"`
	// True, if the message can be reported using reportSupergroupSpam
	CanReportSupergroupSpam bool `json:"can_report_supergroup_spam"`
	// True, if fact check for the message can be changed through setMessageFactCheck
	CanSetFactCheck bool `json:"can_set_fact_check"`
	// True, if message statistics must be available from context menu of the message
	NeedShowStatistics bool `json:"need_show_statistics"`
}

func (entity *MessageProperties) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageProperties

	return json.Marshal((*stub)(entity))
}

func (*MessageProperties) GetClass() string {
	return ClassMessageProperties
}

func (*MessageProperties) GetType() string {
	return TypeMessageProperties
}

// Returns all found messages, no filter is applied
type SearchMessagesFilterEmpty struct {
	meta
}

func (entity *SearchMessagesFilterEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterEmpty

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterEmpty) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterEmpty) GetType() string {
	return TypeSearchMessagesFilterEmpty
}

func (*SearchMessagesFilterEmpty) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterEmpty
}

// Returns only animation messages
type SearchMessagesFilterAnimation struct {
	meta
}

func (entity *SearchMessagesFilterAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterAnimation

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterAnimation) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterAnimation) GetType() string {
	return TypeSearchMessagesFilterAnimation
}

func (*SearchMessagesFilterAnimation) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterAnimation
}

// Returns only audio messages
type SearchMessagesFilterAudio struct {
	meta
}

func (entity *SearchMessagesFilterAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterAudio

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterAudio) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterAudio) GetType() string {
	return TypeSearchMessagesFilterAudio
}

func (*SearchMessagesFilterAudio) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterAudio
}

// Returns only document messages
type SearchMessagesFilterDocument struct {
	meta
}

func (entity *SearchMessagesFilterDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterDocument

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterDocument) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterDocument) GetType() string {
	return TypeSearchMessagesFilterDocument
}

func (*SearchMessagesFilterDocument) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterDocument
}

// Returns only photo messages
type SearchMessagesFilterPhoto struct {
	meta
}

func (entity *SearchMessagesFilterPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPhoto

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPhoto) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPhoto) GetType() string {
	return TypeSearchMessagesFilterPhoto
}

func (*SearchMessagesFilterPhoto) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPhoto
}

// Returns only video messages
type SearchMessagesFilterVideo struct {
	meta
}

func (entity *SearchMessagesFilterVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVideo

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVideo) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVideo) GetType() string {
	return TypeSearchMessagesFilterVideo
}

func (*SearchMessagesFilterVideo) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVideo
}

// Returns only voice note messages
type SearchMessagesFilterVoiceNote struct {
	meta
}

func (entity *SearchMessagesFilterVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVoiceNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVoiceNote) GetType() string {
	return TypeSearchMessagesFilterVoiceNote
}

func (*SearchMessagesFilterVoiceNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVoiceNote
}

// Returns only photo and video messages
type SearchMessagesFilterPhotoAndVideo struct {
	meta
}

func (entity *SearchMessagesFilterPhotoAndVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPhotoAndVideo

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPhotoAndVideo) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPhotoAndVideo) GetType() string {
	return TypeSearchMessagesFilterPhotoAndVideo
}

func (*SearchMessagesFilterPhotoAndVideo) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPhotoAndVideo
}

// Returns only messages containing URLs
type SearchMessagesFilterUrl struct {
	meta
}

func (entity *SearchMessagesFilterUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUrl

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUrl) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUrl) GetType() string {
	return TypeSearchMessagesFilterUrl
}

func (*SearchMessagesFilterUrl) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUrl
}

// Returns only messages containing chat photos
type SearchMessagesFilterChatPhoto struct {
	meta
}

func (entity *SearchMessagesFilterChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterChatPhoto) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterChatPhoto) GetType() string {
	return TypeSearchMessagesFilterChatPhoto
}

func (*SearchMessagesFilterChatPhoto) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterChatPhoto
}

// Returns only video note messages
type SearchMessagesFilterVideoNote struct {
	meta
}

func (entity *SearchMessagesFilterVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVideoNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVideoNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVideoNote) GetType() string {
	return TypeSearchMessagesFilterVideoNote
}

func (*SearchMessagesFilterVideoNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVideoNote
}

// Returns only voice and video note messages
type SearchMessagesFilterVoiceAndVideoNote struct {
	meta
}

func (entity *SearchMessagesFilterVoiceAndVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVoiceAndVideoNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVoiceAndVideoNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVoiceAndVideoNote) GetType() string {
	return TypeSearchMessagesFilterVoiceAndVideoNote
}

func (*SearchMessagesFilterVoiceAndVideoNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVoiceAndVideoNote
}

// Returns only messages with mentions of the current user, or messages that are replies to their messages
type SearchMessagesFilterMention struct {
	meta
}

func (entity *SearchMessagesFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterMention

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterMention) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterMention) GetType() string {
	return TypeSearchMessagesFilterMention
}

func (*SearchMessagesFilterMention) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterMention
}

// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
type SearchMessagesFilterUnreadMention struct {
	meta
}

func (entity *SearchMessagesFilterUnreadMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUnreadMention

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUnreadMention) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUnreadMention) GetType() string {
	return TypeSearchMessagesFilterUnreadMention
}

func (*SearchMessagesFilterUnreadMention) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUnreadMention
}

// Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
type SearchMessagesFilterUnreadReaction struct {
	meta
}

func (entity *SearchMessagesFilterUnreadReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUnreadReaction

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUnreadReaction) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUnreadReaction) GetType() string {
	return TypeSearchMessagesFilterUnreadReaction
}

func (*SearchMessagesFilterUnreadReaction) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUnreadReaction
}

// Returns only failed to send messages. This filter can be used only if the message database is used
type SearchMessagesFilterFailedToSend struct {
	meta
}

func (entity *SearchMessagesFilterFailedToSend) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterFailedToSend

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterFailedToSend) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterFailedToSend) GetType() string {
	return TypeSearchMessagesFilterFailedToSend
}

func (*SearchMessagesFilterFailedToSend) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterFailedToSend
}

// Returns only pinned messages
type SearchMessagesFilterPinned struct {
	meta
}

func (entity *SearchMessagesFilterPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPinned

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPinned) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPinned) GetType() string {
	return TypeSearchMessagesFilterPinned
}

func (*SearchMessagesFilterPinned) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPinned
}

// The user is typing a message
type ChatActionTyping struct {
	meta
}

func (entity *ChatActionTyping) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionTyping

	return json.Marshal((*stub)(entity))
}

func (*ChatActionTyping) GetClass() string {
	return ClassChatAction
}

func (*ChatActionTyping) GetType() string {
	return TypeChatActionTyping
}

func (*ChatActionTyping) ChatActionType() string {
	return TypeChatActionTyping
}

// The user is recording a video
type ChatActionRecordingVideo struct {
	meta
}

func (entity *ChatActionRecordingVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVideo

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVideo) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVideo) GetType() string {
	return TypeChatActionRecordingVideo
}

func (*ChatActionRecordingVideo) ChatActionType() string {
	return TypeChatActionRecordingVideo
}

// The user is uploading a video
type ChatActionUploadingVideo struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVideo

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVideo) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVideo) GetType() string {
	return TypeChatActionUploadingVideo
}

func (*ChatActionUploadingVideo) ChatActionType() string {
	return TypeChatActionUploadingVideo
}

// The user is recording a voice note
type ChatActionRecordingVoiceNote struct {
	meta
}

func (entity *ChatActionRecordingVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVoiceNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVoiceNote) GetType() string {
	return TypeChatActionRecordingVoiceNote
}

func (*ChatActionRecordingVoiceNote) ChatActionType() string {
	return TypeChatActionRecordingVoiceNote
}

// The user is uploading a voice note
type ChatActionUploadingVoiceNote struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVoiceNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVoiceNote) GetType() string {
	return TypeChatActionUploadingVoiceNote
}

func (*ChatActionUploadingVoiceNote) ChatActionType() string {
	return TypeChatActionUploadingVoiceNote
}

// The user is uploading a photo
type ChatActionUploadingPhoto struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingPhoto

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingPhoto) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingPhoto) GetType() string {
	return TypeChatActionUploadingPhoto
}

func (*ChatActionUploadingPhoto) ChatActionType() string {
	return TypeChatActionUploadingPhoto
}

// The user is uploading a document
type ChatActionUploadingDocument struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingDocument

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingDocument) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingDocument) GetType() string {
	return TypeChatActionUploadingDocument
}

func (*ChatActionUploadingDocument) ChatActionType() string {
	return TypeChatActionUploadingDocument
}

// The user is picking a sticker to send
type ChatActionChoosingSticker struct {
	meta
}

func (entity *ChatActionChoosingSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingSticker

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingSticker) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingSticker) GetType() string {
	return TypeChatActionChoosingSticker
}

func (*ChatActionChoosingSticker) ChatActionType() string {
	return TypeChatActionChoosingSticker
}

// The user is picking a location or venue to send
type ChatActionChoosingLocation struct {
	meta
}

func (entity *ChatActionChoosingLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingLocation) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingLocation) GetType() string {
	return TypeChatActionChoosingLocation
}

func (*ChatActionChoosingLocation) ChatActionType() string {
	return TypeChatActionChoosingLocation
}

// The user is picking a contact to send
type ChatActionChoosingContact struct {
	meta
}

func (entity *ChatActionChoosingContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingContact

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingContact) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingContact) GetType() string {
	return TypeChatActionChoosingContact
}

func (*ChatActionChoosingContact) ChatActionType() string {
	return TypeChatActionChoosingContact
}

// The user has started to play a game
type ChatActionStartPlayingGame struct {
	meta
}

func (entity *ChatActionStartPlayingGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionStartPlayingGame

	return json.Marshal((*stub)(entity))
}

func (*ChatActionStartPlayingGame) GetClass() string {
	return ClassChatAction
}

func (*ChatActionStartPlayingGame) GetType() string {
	return TypeChatActionStartPlayingGame
}

func (*ChatActionStartPlayingGame) ChatActionType() string {
	return TypeChatActionStartPlayingGame
}

// The user is recording a video note
type ChatActionRecordingVideoNote struct {
	meta
}

func (entity *ChatActionRecordingVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVideoNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVideoNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVideoNote) GetType() string {
	return TypeChatActionRecordingVideoNote
}

func (*ChatActionRecordingVideoNote) ChatActionType() string {
	return TypeChatActionRecordingVideoNote
}

// The user is uploading a video note
type ChatActionUploadingVideoNote struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVideoNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVideoNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVideoNote) GetType() string {
	return TypeChatActionUploadingVideoNote
}

func (*ChatActionUploadingVideoNote) ChatActionType() string {
	return TypeChatActionUploadingVideoNote
}

// The user is watching animations sent by the other party by clicking on an animated emoji
type ChatActionWatchingAnimations struct {
	meta
	// The animated emoji
	Emoji string `json:"emoji"`
}

func (entity *ChatActionWatchingAnimations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionWatchingAnimations

	return json.Marshal((*stub)(entity))
}

func (*ChatActionWatchingAnimations) GetClass() string {
	return ClassChatAction
}

func (*ChatActionWatchingAnimations) GetType() string {
	return TypeChatActionWatchingAnimations
}

func (*ChatActionWatchingAnimations) ChatActionType() string {
	return TypeChatActionWatchingAnimations
}

// The user has canceled the previous action
type ChatActionCancel struct {
	meta
}

func (entity *ChatActionCancel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionCancel

	return json.Marshal((*stub)(entity))
}

func (*ChatActionCancel) GetClass() string {
	return ClassChatAction
}

func (*ChatActionCancel) GetType() string {
	return TypeChatActionCancel
}

func (*ChatActionCancel) ChatActionType() string {
	return TypeChatActionCancel
}

// The user's status has never been changed
type UserStatusEmpty struct {
	meta
}

func (entity *UserStatusEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusEmpty

	return json.Marshal((*stub)(entity))
}

func (*UserStatusEmpty) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusEmpty) GetType() string {
	return TypeUserStatusEmpty
}

func (*UserStatusEmpty) UserStatusType() string {
	return TypeUserStatusEmpty
}

// The user is online
type UserStatusOnline struct {
	meta
	// Point in time (Unix timestamp) when the user's online status will expire
	Expires int32 `json:"expires"`
}

func (entity *UserStatusOnline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusOnline

	return json.Marshal((*stub)(entity))
}

func (*UserStatusOnline) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusOnline) GetType() string {
	return TypeUserStatusOnline
}

func (*UserStatusOnline) UserStatusType() string {
	return TypeUserStatusOnline
}

// The user is offline
type UserStatusOffline struct {
	meta
	// Point in time (Unix timestamp) when the user was last online
	WasOnline int32 `json:"was_online"`
}

func (entity *UserStatusOffline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusOffline

	return json.Marshal((*stub)(entity))
}

func (*UserStatusOffline) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusOffline) GetType() string {
	return TypeUserStatusOffline
}

func (*UserStatusOffline) UserStatusType() string {
	return TypeUserStatusOffline
}

// The user was online recently
type UserStatusRecently struct {
	meta
	// Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
	ByMyPrivacySettings bool `json:"by_my_privacy_settings"`
}

func (entity *UserStatusRecently) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusRecently

	return json.Marshal((*stub)(entity))
}

func (*UserStatusRecently) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusRecently) GetType() string {
	return TypeUserStatusRecently
}

func (*UserStatusRecently) UserStatusType() string {
	return TypeUserStatusRecently
}

// The user is offline, but was online last week
type UserStatusLastWeek struct {
	meta
	// Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
	ByMyPrivacySettings bool `json:"by_my_privacy_settings"`
}

func (entity *UserStatusLastWeek) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusLastWeek

	return json.Marshal((*stub)(entity))
}

func (*UserStatusLastWeek) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusLastWeek) GetType() string {
	return TypeUserStatusLastWeek
}

func (*UserStatusLastWeek) UserStatusType() string {
	return TypeUserStatusLastWeek
}

// The user is offline, but was online last month
type UserStatusLastMonth struct {
	meta
	// Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
	ByMyPrivacySettings bool `json:"by_my_privacy_settings"`
}

func (entity *UserStatusLastMonth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusLastMonth

	return json.Marshal((*stub)(entity))
}

func (*UserStatusLastMonth) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusLastMonth) GetType() string {
	return TypeUserStatusLastMonth
}

func (*UserStatusLastMonth) UserStatusType() string {
	return TypeUserStatusLastMonth
}

// Represents an emoji with its keyword
type EmojiKeyword struct {
	meta
	// The emoji
	Emoji string `json:"emoji"`
	// The keyword
	Keyword string `json:"keyword"`
}

func (entity *EmojiKeyword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiKeyword

	return json.Marshal((*stub)(entity))
}

func (*EmojiKeyword) GetClass() string {
	return ClassEmojiKeyword
}

func (*EmojiKeyword) GetType() string {
	return TypeEmojiKeyword
}

// Represents a list of emojis with their keywords
type EmojiKeywords struct {
	meta
	// List of emojis with their keywords
	EmojiKeywords []*EmojiKeyword `json:"emoji_keywords"`
}

func (entity *EmojiKeywords) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiKeywords

	return json.Marshal((*stub)(entity))
}

func (*EmojiKeywords) GetClass() string {
	return ClassEmojiKeywords
}

func (*EmojiKeywords) GetType() string {
	return TypeEmojiKeywords
}

// Represents a list of stickers
type Stickers struct {
	meta
	// List of stickers
	Stickers []*Sticker `json:"stickers"`
}

func (entity *Stickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Stickers

	return json.Marshal((*stub)(entity))
}

func (*Stickers) GetClass() string {
	return ClassStickers
}

func (*Stickers) GetType() string {
	return TypeStickers
}

// Represents a list of emojis
type Emojis struct {
	meta
	// List of emojis
	Emojis []string `json:"emojis"`
}

func (entity *Emojis) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Emojis

	return json.Marshal((*stub)(entity))
}

func (*Emojis) GetClass() string {
	return ClassEmojis
}

func (*Emojis) GetType() string {
	return TypeEmojis
}

// Represents a sticker set
type StickerSet struct {
	meta
	// Identifier of the sticker set
	Id JsonInt64 `json:"id"`
	// Title of the sticker set
	Title string `json:"title"`
	// Name of the sticker set
	Name string `json:"name"`
	// Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Sticker set thumbnail's outline; may be null if unknown
	ThumbnailOutline *Outline `json:"thumbnail_outline"`
	// True, if the sticker set is owned by the current user
	IsOwned bool `json:"is_owned"`
	// True, if the sticker set has been installed by the current user
	IsInstalled bool `json:"is_installed"`
	// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsArchived bool `json:"is_archived"`
	// True, if the sticker set is official
	IsOfficial bool `json:"is_official"`
	// Type of the stickers in the set
	StickerType StickerType `json:"sticker_type"`
	// True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
	NeedsRepainting bool `json:"needs_repainting"`
	// True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
	IsAllowedAsChatEmojiStatus bool `json:"is_allowed_as_chat_emoji_status"`
	// True for already viewed trending sticker sets
	IsViewed bool `json:"is_viewed"`
	// List of stickers in this set
	Stickers []*Sticker `json:"stickers"`
	// A list of emojis corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
	Emojis []*Emojis `json:"emojis"`
}

func (entity *StickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSet

	return json.Marshal((*stub)(entity))
}

func (*StickerSet) GetClass() string {
	return ClassStickerSet
}

func (*StickerSet) GetType() string {
	return TypeStickerSet
}

func (stickerSet *StickerSet) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                         JsonInt64       `json:"id"`
		Title                      string          `json:"title"`
		Name                       string          `json:"name"`
		Thumbnail                  *Thumbnail      `json:"thumbnail"`
		ThumbnailOutline           *Outline        `json:"thumbnail_outline"`
		IsOwned                    bool            `json:"is_owned"`
		IsInstalled                bool            `json:"is_installed"`
		IsArchived                 bool            `json:"is_archived"`
		IsOfficial                 bool            `json:"is_official"`
		StickerType                json.RawMessage `json:"sticker_type"`
		NeedsRepainting            bool            `json:"needs_repainting"`
		IsAllowedAsChatEmojiStatus bool            `json:"is_allowed_as_chat_emoji_status"`
		IsViewed                   bool            `json:"is_viewed"`
		Stickers                   []*Sticker      `json:"stickers"`
		Emojis                     []*Emojis       `json:"emojis"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	stickerSet.Id = tmp.Id
	stickerSet.Title = tmp.Title
	stickerSet.Name = tmp.Name
	stickerSet.Thumbnail = tmp.Thumbnail
	stickerSet.ThumbnailOutline = tmp.ThumbnailOutline
	stickerSet.IsOwned = tmp.IsOwned
	stickerSet.IsInstalled = tmp.IsInstalled
	stickerSet.IsArchived = tmp.IsArchived
	stickerSet.IsOfficial = tmp.IsOfficial
	stickerSet.NeedsRepainting = tmp.NeedsRepainting
	stickerSet.IsAllowedAsChatEmojiStatus = tmp.IsAllowedAsChatEmojiStatus
	stickerSet.IsViewed = tmp.IsViewed
	stickerSet.Stickers = tmp.Stickers
	stickerSet.Emojis = tmp.Emojis

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	stickerSet.StickerType = fieldStickerType

	return nil
}

// Represents short information about a sticker set
type StickerSetInfo struct {
	meta
	// Identifier of the sticker set
	Id JsonInt64 `json:"id"`
	// Title of the sticker set
	Title string `json:"title"`
	// Name of the sticker set
	Name string `json:"name"`
	// Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Sticker set thumbnail's outline; may be null if unknown
	ThumbnailOutline *Outline `json:"thumbnail_outline"`
	// True, if the sticker set is owned by the current user
	IsOwned bool `json:"is_owned"`
	// True, if the sticker set has been installed by the current user
	IsInstalled bool `json:"is_installed"`
	// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsArchived bool `json:"is_archived"`
	// True, if the sticker set is official
	IsOfficial bool `json:"is_official"`
	// Type of the stickers in the set
	StickerType StickerType `json:"sticker_type"`
	// True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
	NeedsRepainting bool `json:"needs_repainting"`
	// True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
	IsAllowedAsChatEmojiStatus bool `json:"is_allowed_as_chat_emoji_status"`
	// True for already viewed trending sticker sets
	IsViewed bool `json:"is_viewed"`
	// Total number of stickers in the set
	Size int32 `json:"size"`
	// Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
	Covers []*Sticker `json:"covers"`
}

func (entity *StickerSetInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSetInfo

	return json.Marshal((*stub)(entity))
}

func (*StickerSetInfo) GetClass() string {
	return ClassStickerSetInfo
}

func (*StickerSetInfo) GetType() string {
	return TypeStickerSetInfo
}

func (stickerSetInfo *StickerSetInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                         JsonInt64       `json:"id"`
		Title                      string          `json:"title"`
		Name                       string          `json:"name"`
		Thumbnail                  *Thumbnail      `json:"thumbnail"`
		ThumbnailOutline           *Outline        `json:"thumbnail_outline"`
		IsOwned                    bool            `json:"is_owned"`
		IsInstalled                bool            `json:"is_installed"`
		IsArchived                 bool            `json:"is_archived"`
		IsOfficial                 bool            `json:"is_official"`
		StickerType                json.RawMessage `json:"sticker_type"`
		NeedsRepainting            bool            `json:"needs_repainting"`
		IsAllowedAsChatEmojiStatus bool            `json:"is_allowed_as_chat_emoji_status"`
		IsViewed                   bool            `json:"is_viewed"`
		Size                       int32           `json:"size"`
		Covers                     []*Sticker      `json:"covers"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	stickerSetInfo.Id = tmp.Id
	stickerSetInfo.Title = tmp.Title
	stickerSetInfo.Name = tmp.Name
	stickerSetInfo.Thumbnail = tmp.Thumbnail
	stickerSetInfo.ThumbnailOutline = tmp.ThumbnailOutline
	stickerSetInfo.IsOwned = tmp.IsOwned
	stickerSetInfo.IsInstalled = tmp.IsInstalled
	stickerSetInfo.IsArchived = tmp.IsArchived
	stickerSetInfo.IsOfficial = tmp.IsOfficial
	stickerSetInfo.NeedsRepainting = tmp.NeedsRepainting
	stickerSetInfo.IsAllowedAsChatEmojiStatus = tmp.IsAllowedAsChatEmojiStatus
	stickerSetInfo.IsViewed = tmp.IsViewed
	stickerSetInfo.Size = tmp.Size
	stickerSetInfo.Covers = tmp.Covers

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	stickerSetInfo.StickerType = fieldStickerType

	return nil
}

// Represents a list of sticker sets
type StickerSets struct {
	meta
	// Approximate total number of sticker sets found
	TotalCount int32 `json:"total_count"`
	// List of sticker sets
	Sets []*StickerSetInfo `json:"sets"`
}

func (entity *StickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSets

	return json.Marshal((*stub)(entity))
}

func (*StickerSets) GetClass() string {
	return ClassStickerSets
}

func (*StickerSets) GetType() string {
	return TypeStickerSets
}

// Represents a list of trending sticker sets
type TrendingStickerSets struct {
	meta
	// Approximate total number of trending sticker sets
	TotalCount int32 `json:"total_count"`
	// List of trending sticker sets
	Sets []*StickerSetInfo `json:"sets"`
	// True, if the list contains sticker sets with premium stickers
	IsPremium bool `json:"is_premium"`
}

func (entity *TrendingStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TrendingStickerSets

	return json.Marshal((*stub)(entity))
}

func (*TrendingStickerSets) GetClass() string {
	return ClassTrendingStickerSets
}

func (*TrendingStickerSets) GetType() string {
	return TypeTrendingStickerSets
}

// The category contains a list of similar emoji to search for in getStickers and searchStickers for stickers, or getInlineQueryResults with the bot getOption("animation_search_bot_username") for animations
type EmojiCategorySourceSearch struct {
	meta
	// List of emojis to search for
	Emojis []string `json:"emojis"`
}

func (entity *EmojiCategorySourceSearch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategorySourceSearch

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategorySourceSearch) GetClass() string {
	return ClassEmojiCategorySource
}

func (*EmojiCategorySourceSearch) GetType() string {
	return TypeEmojiCategorySourceSearch
}

func (*EmojiCategorySourceSearch) EmojiCategorySourceType() string {
	return TypeEmojiCategorySourceSearch
}

// The category contains premium stickers that must be found by getPremiumStickers
type EmojiCategorySourcePremium struct {
	meta
}

func (entity *EmojiCategorySourcePremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategorySourcePremium

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategorySourcePremium) GetClass() string {
	return ClassEmojiCategorySource
}

func (*EmojiCategorySourcePremium) GetType() string {
	return TypeEmojiCategorySourcePremium
}

func (*EmojiCategorySourcePremium) EmojiCategorySourceType() string {
	return TypeEmojiCategorySourcePremium
}

// Describes an emoji category
type EmojiCategory struct {
	meta
	// Name of the category
	Name string `json:"name"`
	// Custom emoji sticker, which represents icon of the category
	Icon *Sticker `json:"icon"`
	// Source of stickers for the emoji category
	Source EmojiCategorySource `json:"source"`
	// True, if the category must be shown first when choosing a sticker for the start page
	IsGreeting bool `json:"is_greeting"`
}

func (entity *EmojiCategory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategory

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategory) GetClass() string {
	return ClassEmojiCategory
}

func (*EmojiCategory) GetType() string {
	return TypeEmojiCategory
}

func (emojiCategory *EmojiCategory) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Name       string          `json:"name"`
		Icon       *Sticker        `json:"icon"`
		Source     json.RawMessage `json:"source"`
		IsGreeting bool            `json:"is_greeting"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	emojiCategory.Name = tmp.Name
	emojiCategory.Icon = tmp.Icon
	emojiCategory.IsGreeting = tmp.IsGreeting

	fieldSource, _ := UnmarshalEmojiCategorySource(tmp.Source)
	emojiCategory.Source = fieldSource

	return nil
}

// Represents a list of emoji categories
type EmojiCategories struct {
	meta
	// List of categories
	Categories []*EmojiCategory `json:"categories"`
}

func (entity *EmojiCategories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategories

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategories) GetClass() string {
	return ClassEmojiCategories
}

func (*EmojiCategories) GetType() string {
	return TypeEmojiCategories
}

// The category must be used by default (e.g., for custom emoji or animation search)
type EmojiCategoryTypeDefault struct {
	meta
}

func (entity *EmojiCategoryTypeDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeDefault

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeDefault) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeDefault) GetType() string {
	return TypeEmojiCategoryTypeDefault
}

func (*EmojiCategoryTypeDefault) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeDefault
}

// The category must be used by default for regular sticker selection. It may contain greeting emoji category and premium stickers
type EmojiCategoryTypeRegularStickers struct {
	meta
}

func (entity *EmojiCategoryTypeRegularStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeRegularStickers

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeRegularStickers) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeRegularStickers) GetType() string {
	return TypeEmojiCategoryTypeRegularStickers
}

func (*EmojiCategoryTypeRegularStickers) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeRegularStickers
}

// The category must be used for emoji status selection
type EmojiCategoryTypeEmojiStatus struct {
	meta
}

func (entity *EmojiCategoryTypeEmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeEmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeEmojiStatus) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeEmojiStatus) GetType() string {
	return TypeEmojiCategoryTypeEmojiStatus
}

func (*EmojiCategoryTypeEmojiStatus) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeEmojiStatus
}

// The category must be used for chat photo emoji selection
type EmojiCategoryTypeChatPhoto struct {
	meta
}

func (entity *EmojiCategoryTypeChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiCategoryTypeChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*EmojiCategoryTypeChatPhoto) GetClass() string {
	return ClassEmojiCategoryType
}

func (*EmojiCategoryTypeChatPhoto) GetType() string {
	return TypeEmojiCategoryTypeChatPhoto
}

func (*EmojiCategoryTypeChatPhoto) EmojiCategoryTypeType() string {
	return TypeEmojiCategoryTypeChatPhoto
}

// Describes the current weather
type CurrentWeather struct {
	meta
	// Temperature, in degree Celsius
	Temperature float64 `json:"temperature"`
	// Emoji representing the weather
	Emoji string `json:"emoji"`
}

func (entity *CurrentWeather) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CurrentWeather

	return json.Marshal((*stub)(entity))
}

func (*CurrentWeather) GetClass() string {
	return ClassCurrentWeather
}

func (*CurrentWeather) GetType() string {
	return TypeCurrentWeather
}

// Describes position of a clickable rectangle area on a story media
type StoryAreaPosition struct {
	meta
	// The abscissa of the rectangle's center, as a percentage of the media width
	XPercentage float64 `json:"x_percentage"`
	// The ordinate of the rectangle's center, as a percentage of the media height
	YPercentage float64 `json:"y_percentage"`
	// The width of the rectangle, as a percentage of the media width
	WidthPercentage float64 `json:"width_percentage"`
	// The height of the rectangle, as a percentage of the media height
	HeightPercentage float64 `json:"height_percentage"`
	// Clockwise rotation angle of the rectangle, in degrees; 0-360
	RotationAngle float64 `json:"rotation_angle"`
	// The radius of the rectangle corner rounding, as a percentage of the media width
	CornerRadiusPercentage float64 `json:"corner_radius_percentage"`
}

func (entity *StoryAreaPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaPosition

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaPosition) GetClass() string {
	return ClassStoryAreaPosition
}

func (*StoryAreaPosition) GetType() string {
	return TypeStoryAreaPosition
}

// An area pointing to a location
type StoryAreaTypeLocation struct {
	meta
	// The location
	Location *Location `json:"location"`
	// Address of the location; may be null if unknown
	Address *LocationAddress `json:"address"`
}

func (entity *StoryAreaTypeLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaTypeLocation

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaTypeLocation) GetClass() string {
	return ClassStoryAreaType
}

func (*StoryAreaTypeLocation) GetType() string {
	return TypeStoryAreaTypeLocation
}

func (*StoryAreaTypeLocation) StoryAreaTypeType() string {
	return TypeStoryAreaTypeLocation
}

// An area pointing to a venue
type StoryAreaTypeVenue struct {
	meta
	// Information about the venue
	Venue *Venue `json:"venue"`
}

func (entity *StoryAreaTypeVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaTypeVenue

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaTypeVenue) GetClass() string {
	return ClassStoryAreaType
}

func (*StoryAreaTypeVenue) GetType() string {
	return TypeStoryAreaTypeVenue
}

func (*StoryAreaTypeVenue) StoryAreaTypeType() string {
	return TypeStoryAreaTypeVenue
}

// An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked
type StoryAreaTypeSuggestedReaction struct {
	meta
	// Type of the reaction
	ReactionType ReactionType `json:"reaction_type"`
	// Number of times the reaction was added
	TotalCount int32 `json:"total_count"`
	// True, if reaction has a dark background
	IsDark bool `json:"is_dark"`
	// True, if reaction corner is flipped
	IsFlipped bool `json:"is_flipped"`
}

func (entity *StoryAreaTypeSuggestedReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaTypeSuggestedReaction

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaTypeSuggestedReaction) GetClass() string {
	return ClassStoryAreaType
}

func (*StoryAreaTypeSuggestedReaction) GetType() string {
	return TypeStoryAreaTypeSuggestedReaction
}

func (*StoryAreaTypeSuggestedReaction) StoryAreaTypeType() string {
	return TypeStoryAreaTypeSuggestedReaction
}

func (storyAreaTypeSuggestedReaction *StoryAreaTypeSuggestedReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReactionType json.RawMessage `json:"reaction_type"`
		TotalCount   int32           `json:"total_count"`
		IsDark       bool            `json:"is_dark"`
		IsFlipped    bool            `json:"is_flipped"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storyAreaTypeSuggestedReaction.TotalCount = tmp.TotalCount
	storyAreaTypeSuggestedReaction.IsDark = tmp.IsDark
	storyAreaTypeSuggestedReaction.IsFlipped = tmp.IsFlipped

	fieldReactionType, _ := UnmarshalReactionType(tmp.ReactionType)
	storyAreaTypeSuggestedReaction.ReactionType = fieldReactionType

	return nil
}

// An area pointing to a message
type StoryAreaTypeMessage struct {
	meta
	// Identifier of the chat with the message
	ChatId int64 `json:"chat_id"`
	// Identifier of the message
	MessageId int64 `json:"message_id"`
}

func (entity *StoryAreaTypeMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaTypeMessage

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaTypeMessage) GetClass() string {
	return ClassStoryAreaType
}

func (*StoryAreaTypeMessage) GetType() string {
	return TypeStoryAreaTypeMessage
}

func (*StoryAreaTypeMessage) StoryAreaTypeType() string {
	return TypeStoryAreaTypeMessage
}

// An area pointing to a HTTP or tg:// link
type StoryAreaTypeLink struct {
	meta
	// HTTP or tg:// URL to be opened when the area is clicked
	Url string `json:"url"`
}

func (entity *StoryAreaTypeLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaTypeLink

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaTypeLink) GetClass() string {
	return ClassStoryAreaType
}

func (*StoryAreaTypeLink) GetType() string {
	return TypeStoryAreaTypeLink
}

func (*StoryAreaTypeLink) StoryAreaTypeType() string {
	return TypeStoryAreaTypeLink
}

// An area with information about weather
type StoryAreaTypeWeather struct {
	meta
	// Temperature, in degree Celsius
	Temperature float64 `json:"temperature"`
	// Emoji representing the weather
	Emoji string `json:"emoji"`
	// A color of the area background in the ARGB format
	BackgroundColor int32 `json:"background_color"`
}

func (entity *StoryAreaTypeWeather) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryAreaTypeWeather

	return json.Marshal((*stub)(entity))
}

func (*StoryAreaTypeWeather) GetClass() string {
	return ClassStoryAreaType
}

func (*StoryAreaTypeWeather) GetType() string {
	return TypeStoryAreaTypeWeather
}

func (*StoryAreaTypeWeather) StoryAreaTypeType() string {
	return TypeStoryAreaTypeWeather
}

// Describes a clickable rectangle area on a story media
type StoryArea struct {
	meta
	// Position of the area
	Position *StoryAreaPosition `json:"position"`
	// Type of the area
	Type StoryAreaType `json:"type"`
}

func (entity *StoryArea) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryArea

	return json.Marshal((*stub)(entity))
}

func (*StoryArea) GetClass() string {
	return ClassStoryArea
}

func (*StoryArea) GetType() string {
	return TypeStoryArea
}

func (storyArea *StoryArea) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Position *StoryAreaPosition `json:"position"`
		Type     json.RawMessage    `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storyArea.Position = tmp.Position

	fieldType, _ := UnmarshalStoryAreaType(tmp.Type)
	storyArea.Type = fieldType

	return nil
}

// An area pointing to a location
type InputStoryAreaTypeLocation struct {
	meta
	// The location
	Location *Location `json:"location"`
	// Address of the location; pass null if unknown
	Address *LocationAddress `json:"address"`
}

func (entity *InputStoryAreaTypeLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypeLocation

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypeLocation) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypeLocation) GetType() string {
	return TypeInputStoryAreaTypeLocation
}

func (*InputStoryAreaTypeLocation) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypeLocation
}

// An area pointing to a venue found by the bot getOption("venue_search_bot_username")
type InputStoryAreaTypeFoundVenue struct {
	meta
	// Identifier of the inline query, used to found the venue
	QueryId JsonInt64 `json:"query_id"`
	// Identifier of the inline query result
	ResultId string `json:"result_id"`
}

func (entity *InputStoryAreaTypeFoundVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypeFoundVenue

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypeFoundVenue) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypeFoundVenue) GetType() string {
	return TypeInputStoryAreaTypeFoundVenue
}

func (*InputStoryAreaTypeFoundVenue) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypeFoundVenue
}

// An area pointing to a venue already added to the story
type InputStoryAreaTypePreviousVenue struct {
	meta
	// Provider of the venue
	VenueProvider string `json:"venue_provider"`
	// Identifier of the venue in the provider database
	VenueId string `json:"venue_id"`
}

func (entity *InputStoryAreaTypePreviousVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypePreviousVenue

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypePreviousVenue) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypePreviousVenue) GetType() string {
	return TypeInputStoryAreaTypePreviousVenue
}

func (*InputStoryAreaTypePreviousVenue) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypePreviousVenue
}

// An area pointing to a suggested reaction
type InputStoryAreaTypeSuggestedReaction struct {
	meta
	// Type of the reaction
	ReactionType ReactionType `json:"reaction_type"`
	// True, if reaction has a dark background
	IsDark bool `json:"is_dark"`
	// True, if reaction corner is flipped
	IsFlipped bool `json:"is_flipped"`
}

func (entity *InputStoryAreaTypeSuggestedReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypeSuggestedReaction

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypeSuggestedReaction) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypeSuggestedReaction) GetType() string {
	return TypeInputStoryAreaTypeSuggestedReaction
}

func (*InputStoryAreaTypeSuggestedReaction) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypeSuggestedReaction
}

func (inputStoryAreaTypeSuggestedReaction *InputStoryAreaTypeSuggestedReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReactionType json.RawMessage `json:"reaction_type"`
		IsDark       bool            `json:"is_dark"`
		IsFlipped    bool            `json:"is_flipped"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputStoryAreaTypeSuggestedReaction.IsDark = tmp.IsDark
	inputStoryAreaTypeSuggestedReaction.IsFlipped = tmp.IsFlipped

	fieldReactionType, _ := UnmarshalReactionType(tmp.ReactionType)
	inputStoryAreaTypeSuggestedReaction.ReactionType = fieldReactionType

	return nil
}

// An area pointing to a message
type InputStoryAreaTypeMessage struct {
	meta
	// Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
	ChatId int64 `json:"chat_id"`
	// Identifier of the message. Use messageProperties.can_be_shared_in_story to check whether the message is suitable
	MessageId int64 `json:"message_id"`
}

func (entity *InputStoryAreaTypeMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypeMessage

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypeMessage) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypeMessage) GetType() string {
	return TypeInputStoryAreaTypeMessage
}

func (*InputStoryAreaTypeMessage) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypeMessage
}

// An area pointing to a HTTP or tg:// link
type InputStoryAreaTypeLink struct {
	meta
	// HTTP or tg:// URL to be opened when the area is clicked
	Url string `json:"url"`
}

func (entity *InputStoryAreaTypeLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypeLink

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypeLink) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypeLink) GetType() string {
	return TypeInputStoryAreaTypeLink
}

func (*InputStoryAreaTypeLink) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypeLink
}

// An area with information about weather
type InputStoryAreaTypeWeather struct {
	meta
	// Temperature, in degree Celsius
	Temperature float64 `json:"temperature"`
	// Emoji representing the weather
	Emoji string `json:"emoji"`
	// A color of the area background in the ARGB format
	BackgroundColor int32 `json:"background_color"`
}

func (entity *InputStoryAreaTypeWeather) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreaTypeWeather

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreaTypeWeather) GetClass() string {
	return ClassInputStoryAreaType
}

func (*InputStoryAreaTypeWeather) GetType() string {
	return TypeInputStoryAreaTypeWeather
}

func (*InputStoryAreaTypeWeather) InputStoryAreaTypeType() string {
	return TypeInputStoryAreaTypeWeather
}

// Describes a clickable rectangle area on a story media to be added
type InputStoryArea struct {
	meta
	// Position of the area
	Position *StoryAreaPosition `json:"position"`
	// Type of the area
	Type InputStoryAreaType `json:"type"`
}

func (entity *InputStoryArea) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryArea

	return json.Marshal((*stub)(entity))
}

func (*InputStoryArea) GetClass() string {
	return ClassInputStoryArea
}

func (*InputStoryArea) GetType() string {
	return TypeInputStoryArea
}

func (inputStoryArea *InputStoryArea) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Position *StoryAreaPosition `json:"position"`
		Type     json.RawMessage    `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputStoryArea.Position = tmp.Position

	fieldType, _ := UnmarshalInputStoryAreaType(tmp.Type)
	inputStoryArea.Type = fieldType

	return nil
}

// Contains a list of story areas to be added
type InputStoryAreas struct {
	meta
	// List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max") inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, and up to 3 inputStoryAreaTypeWeather areas
	Areas []*InputStoryArea `json:"areas"`
}

func (entity *InputStoryAreas) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryAreas

	return json.Marshal((*stub)(entity))
}

func (*InputStoryAreas) GetClass() string {
	return ClassInputStoryAreas
}

func (*InputStoryAreas) GetType() string {
	return TypeInputStoryAreas
}

// Describes a video file sent in a story
type StoryVideo struct {
	meta
	// Duration of the video, in seconds
	Duration float64 `json:"duration"`
	// Video width
	Width int32 `json:"width"`
	// Video height
	Height int32 `json:"height"`
	// True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
	HasStickers bool `json:"has_stickers"`
	// True, if the video has no sound
	IsAnimation bool `json:"is_animation"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail in JPEG or MPEG4 format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
	// Size of file prefix, which is expected to be preloaded, in bytes
	PreloadPrefixSize int32 `json:"preload_prefix_size"`
	// Timestamp of the frame used as video thumbnail
	CoverFrameTimestamp float64 `json:"cover_frame_timestamp"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *StoryVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryVideo

	return json.Marshal((*stub)(entity))
}

func (*StoryVideo) GetClass() string {
	return ClassStoryVideo
}

func (*StoryVideo) GetType() string {
	return TypeStoryVideo
}

// A photo story
type StoryContentPhoto struct {
	meta
	// The photo
	Photo *Photo `json:"photo"`
}

func (entity *StoryContentPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryContentPhoto

	return json.Marshal((*stub)(entity))
}

func (*StoryContentPhoto) GetClass() string {
	return ClassStoryContent
}

func (*StoryContentPhoto) GetType() string {
	return TypeStoryContentPhoto
}

func (*StoryContentPhoto) StoryContentType() string {
	return TypeStoryContentPhoto
}

// A video story
type StoryContentVideo struct {
	meta
	// The video in MPEG4 format
	Video *StoryVideo `json:"video"`
	// Alternative version of the video in MPEG4 format, encoded with H.264 codec; may be null
	AlternativeVideo *StoryVideo `json:"alternative_video"`
}

func (entity *StoryContentVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryContentVideo

	return json.Marshal((*stub)(entity))
}

func (*StoryContentVideo) GetClass() string {
	return ClassStoryContent
}

func (*StoryContentVideo) GetType() string {
	return TypeStoryContentVideo
}

func (*StoryContentVideo) StoryContentType() string {
	return TypeStoryContentVideo
}

// A story content that is not supported in the current TDLib version
type StoryContentUnsupported struct {
	meta
}

func (entity *StoryContentUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryContentUnsupported

	return json.Marshal((*stub)(entity))
}

func (*StoryContentUnsupported) GetClass() string {
	return ClassStoryContent
}

func (*StoryContentUnsupported) GetType() string {
	return TypeStoryContentUnsupported
}

func (*StoryContentUnsupported) StoryContentType() string {
	return TypeStoryContentUnsupported
}

// A photo story
type InputStoryContentPhoto struct {
	meta
	// Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920
	Photo InputFile `json:"photo"`
	// File identifiers of the stickers added to the photo, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
}

func (entity *InputStoryContentPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryContentPhoto

	return json.Marshal((*stub)(entity))
}

func (*InputStoryContentPhoto) GetClass() string {
	return ClassInputStoryContent
}

func (*InputStoryContentPhoto) GetType() string {
	return TypeInputStoryContentPhoto
}

func (*InputStoryContentPhoto) InputStoryContentType() string {
	return TypeInputStoryContentPhoto
}

func (inputStoryContentPhoto *InputStoryContentPhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Photo               json.RawMessage `json:"photo"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputStoryContentPhoto.AddedStickerFileIds = tmp.AddedStickerFileIds

	fieldPhoto, _ := UnmarshalInputFile(tmp.Photo)
	inputStoryContentPhoto.Photo = fieldPhoto

	return nil
}

// A video story
type InputStoryContentVideo struct {
	meta
	// Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with H.265 codec and key frames added each second
	Video InputFile `json:"video"`
	// File identifiers of the stickers added to the video, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Precise duration of the video, in seconds; 0-60
	Duration float64 `json:"duration"`
	// Timestamp of the frame, which will be used as video thumbnail
	CoverFrameTimestamp float64 `json:"cover_frame_timestamp"`
	// True, if the video has no sound
	IsAnimation bool `json:"is_animation"`
}

func (entity *InputStoryContentVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputStoryContentVideo

	return json.Marshal((*stub)(entity))
}

func (*InputStoryContentVideo) GetClass() string {
	return ClassInputStoryContent
}

func (*InputStoryContentVideo) GetType() string {
	return TypeInputStoryContentVideo
}

func (*InputStoryContentVideo) InputStoryContentType() string {
	return TypeInputStoryContentVideo
}

func (inputStoryContentVideo *InputStoryContentVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Video               json.RawMessage `json:"video"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Duration            float64         `json:"duration"`
		CoverFrameTimestamp float64         `json:"cover_frame_timestamp"`
		IsAnimation         bool            `json:"is_animation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputStoryContentVideo.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputStoryContentVideo.Duration = tmp.Duration
	inputStoryContentVideo.CoverFrameTimestamp = tmp.CoverFrameTimestamp
	inputStoryContentVideo.IsAnimation = tmp.IsAnimation

	fieldVideo, _ := UnmarshalInputFile(tmp.Video)
	inputStoryContentVideo.Video = fieldVideo

	return nil
}

// The list of stories, shown in the main chat list and folder chat lists
type StoryListMain struct {
	meta
}

func (entity *StoryListMain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryListMain

	return json.Marshal((*stub)(entity))
}

func (*StoryListMain) GetClass() string {
	return ClassStoryList
}

func (*StoryListMain) GetType() string {
	return TypeStoryListMain
}

func (*StoryListMain) StoryListType() string {
	return TypeStoryListMain
}

// The list of stories, shown in the Arvhive chat list
type StoryListArchive struct {
	meta
}

func (entity *StoryListArchive) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryListArchive

	return json.Marshal((*stub)(entity))
}

func (*StoryListArchive) GetClass() string {
	return ClassStoryList
}

func (*StoryListArchive) GetType() string {
	return TypeStoryListArchive
}

func (*StoryListArchive) StoryListType() string {
	return TypeStoryListArchive
}

// The original story was a public story with known sender
type StoryOriginPublicStory struct {
	meta
	// Identifier of the chat that posted original story
	ChatId int64 `json:"chat_id"`
	// Story identifier of the original story
	StoryId int32 `json:"story_id"`
}

func (entity *StoryOriginPublicStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryOriginPublicStory

	return json.Marshal((*stub)(entity))
}

func (*StoryOriginPublicStory) GetClass() string {
	return ClassStoryOrigin
}

func (*StoryOriginPublicStory) GetType() string {
	return TypeStoryOriginPublicStory
}

func (*StoryOriginPublicStory) StoryOriginType() string {
	return TypeStoryOriginPublicStory
}

// The original story was sent by an unknown user
type StoryOriginHiddenUser struct {
	meta
	// Name of the story sender
	SenderName string `json:"sender_name"`
}

func (entity *StoryOriginHiddenUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryOriginHiddenUser

	return json.Marshal((*stub)(entity))
}

func (*StoryOriginHiddenUser) GetClass() string {
	return ClassStoryOrigin
}

func (*StoryOriginHiddenUser) GetType() string {
	return TypeStoryOriginHiddenUser
}

func (*StoryOriginHiddenUser) StoryOriginType() string {
	return TypeStoryOriginHiddenUser
}

// Contains information about original story that was reposted
type StoryRepostInfo struct {
	meta
	// Origin of the story that was reposted
	Origin StoryOrigin `json:"origin"`
	// True, if story content was modified during reposting; otherwise, story wasn't modified
	IsContentModified bool `json:"is_content_modified"`
}

func (entity *StoryRepostInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryRepostInfo

	return json.Marshal((*stub)(entity))
}

func (*StoryRepostInfo) GetClass() string {
	return ClassStoryRepostInfo
}

func (*StoryRepostInfo) GetType() string {
	return TypeStoryRepostInfo
}

func (storyRepostInfo *StoryRepostInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Origin            json.RawMessage `json:"origin"`
		IsContentModified bool            `json:"is_content_modified"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storyRepostInfo.IsContentModified = tmp.IsContentModified

	fieldOrigin, _ := UnmarshalStoryOrigin(tmp.Origin)
	storyRepostInfo.Origin = fieldOrigin

	return nil
}

// Contains information about interactions with a story
type StoryInteractionInfo struct {
	meta
	// Number of times the story was viewed
	ViewCount int32 `json:"view_count"`
	// Number of times the story was forwarded; 0 if none or unknown
	ForwardCount int32 `json:"forward_count"`
	// Number of reactions added to the story; 0 if none or unknown
	ReactionCount int32 `json:"reaction_count"`
	// Identifiers of at most 3 recent viewers of the story
	RecentViewerUserIds []int64 `json:"recent_viewer_user_ids"`
}

func (entity *StoryInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*StoryInteractionInfo) GetClass() string {
	return ClassStoryInteractionInfo
}

func (*StoryInteractionInfo) GetType() string {
	return TypeStoryInteractionInfo
}

// Represents a story
type Story struct {
	meta
	// Unique story identifier among stories of the given sender
	Id int32 `json:"id"`
	// Identifier of the chat that posted the story
	SenderChatId int64 `json:"sender_chat_id"`
	// Identifier of the sender of the story; may be null if the story is posted on behalf of the sender_chat_id
	SenderId MessageSender `json:"sender_id"`
	// Point in time (Unix timestamp) when the story was published
	Date int32 `json:"date"`
	// True, if the story is being sent by the current user
	IsBeingSent bool `json:"is_being_sent"`
	// True, if the story is being edited by the current user
	IsBeingEdited bool `json:"is_being_edited"`
	// True, if the story was edited
	IsEdited bool `json:"is_edited"`
	// True, if the story is saved in the sender's profile and will be available there after expiration
	IsPostedToChatPage bool `json:"is_posted_to_chat_page"`
	// True, if the story is visible only for the current user
	IsVisibleOnlyForSelf bool `json:"is_visible_only_for_self"`
	// True, if the story can be deleted
	CanBeDeleted bool `json:"can_be_deleted"`
	// True, if the story can be edited
	CanBeEdited bool `json:"can_be_edited"`
	// True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
	CanBeForwarded bool `json:"can_be_forwarded"`
	// True, if the story can be replied in the chat with the story sender
	CanBeReplied bool `json:"can_be_replied"`
	// True, if the story's is_posted_to_chat_page value can be changed
	CanToggleIsPostedToChatPage bool `json:"can_toggle_is_posted_to_chat_page"`
	// True, if the story statistics are available through getStoryStatistics
	CanGetStatistics bool `json:"can_get_statistics"`
	// True, if interactions with the story can be received through getStoryInteractions
	CanGetInteractions bool `json:"can_get_interactions"`
	// True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
	HasExpiredViewers bool `json:"has_expired_viewers"`
	// Information about the original story; may be null if the story wasn't reposted
	RepostInfo *StoryRepostInfo `json:"repost_info"`
	// Information about interactions with the story; may be null if the story isn't owned or there were no interactions
	InteractionInfo *StoryInteractionInfo `json:"interaction_info"`
	// Type of the chosen reaction; may be null if none
	ChosenReactionType ReactionType `json:"chosen_reaction_type"`
	// Privacy rules affecting story visibility; may be approximate for non-owned stories
	PrivacySettings StoryPrivacySettings `json:"privacy_settings"`
	// Content of the story
	Content StoryContent `json:"content"`
	// Clickable areas to be shown on the story content
	Areas []*StoryArea `json:"areas"`
	// Caption of the story
	Caption *FormattedText `json:"caption"`
}

func (entity *Story) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Story

	return json.Marshal((*stub)(entity))
}

func (*Story) GetClass() string {
	return ClassStory
}

func (*Story) GetType() string {
	return TypeStory
}

func (story *Story) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                          int32                 `json:"id"`
		SenderChatId                int64                 `json:"sender_chat_id"`
		SenderId                    json.RawMessage       `json:"sender_id"`
		Date                        int32                 `json:"date"`
		IsBeingSent                 bool                  `json:"is_being_sent"`
		IsBeingEdited               bool                  `json:"is_being_edited"`
		IsEdited                    bool                  `json:"is_edited"`
		IsPostedToChatPage          bool                  `json:"is_posted_to_chat_page"`
		IsVisibleOnlyForSelf        bool                  `json:"is_visible_only_for_self"`
		CanBeDeleted                bool                  `json:"can_be_deleted"`
		CanBeEdited                 bool                  `json:"can_be_edited"`
		CanBeForwarded              bool                  `json:"can_be_forwarded"`
		CanBeReplied                bool                  `json:"can_be_replied"`
		CanToggleIsPostedToChatPage bool                  `json:"can_toggle_is_posted_to_chat_page"`
		CanGetStatistics            bool                  `json:"can_get_statistics"`
		CanGetInteractions          bool                  `json:"can_get_interactions"`
		HasExpiredViewers           bool                  `json:"has_expired_viewers"`
		RepostInfo                  *StoryRepostInfo      `json:"repost_info"`
		InteractionInfo             *StoryInteractionInfo `json:"interaction_info"`
		ChosenReactionType          json.RawMessage       `json:"chosen_reaction_type"`
		PrivacySettings             json.RawMessage       `json:"privacy_settings"`
		Content                     json.RawMessage       `json:"content"`
		Areas                       []*StoryArea          `json:"areas"`
		Caption                     *FormattedText        `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	story.Id = tmp.Id
	story.SenderChatId = tmp.SenderChatId
	story.Date = tmp.Date
	story.IsBeingSent = tmp.IsBeingSent
	story.IsBeingEdited = tmp.IsBeingEdited
	story.IsEdited = tmp.IsEdited
	story.IsPostedToChatPage = tmp.IsPostedToChatPage
	story.IsVisibleOnlyForSelf = tmp.IsVisibleOnlyForSelf
	story.CanBeDeleted = tmp.CanBeDeleted
	story.CanBeEdited = tmp.CanBeEdited
	story.CanBeForwarded = tmp.CanBeForwarded
	story.CanBeReplied = tmp.CanBeReplied
	story.CanToggleIsPostedToChatPage = tmp.CanToggleIsPostedToChatPage
	story.CanGetStatistics = tmp.CanGetStatistics
	story.CanGetInteractions = tmp.CanGetInteractions
	story.HasExpiredViewers = tmp.HasExpiredViewers
	story.RepostInfo = tmp.RepostInfo
	story.InteractionInfo = tmp.InteractionInfo
	story.Areas = tmp.Areas
	story.Caption = tmp.Caption

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	story.SenderId = fieldSenderId

	fieldChosenReactionType, _ := UnmarshalReactionType(tmp.ChosenReactionType)
	story.ChosenReactionType = fieldChosenReactionType

	fieldPrivacySettings, _ := UnmarshalStoryPrivacySettings(tmp.PrivacySettings)
	story.PrivacySettings = fieldPrivacySettings

	fieldContent, _ := UnmarshalStoryContent(tmp.Content)
	story.Content = fieldContent

	return nil
}

// Represents a list of stories
type Stories struct {
	meta
	// Approximate total number of stories found
	TotalCount int32 `json:"total_count"`
	// The list of stories
	Stories []*Story `json:"stories"`
	// Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from_story_id == 0
	PinnedStoryIds []int32 `json:"pinned_story_ids"`
}

func (entity *Stories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Stories

	return json.Marshal((*stub)(entity))
}

func (*Stories) GetClass() string {
	return ClassStories
}

func (*Stories) GetType() string {
	return TypeStories
}

// Contains a list of stories found by a search
type FoundStories struct {
	meta
	// Approximate total number of stories found
	TotalCount int32 `json:"total_count"`
	// List of stories
	Stories []*Story `json:"stories"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundStories

	return json.Marshal((*stub)(entity))
}

func (*FoundStories) GetClass() string {
	return ClassFoundStories
}

func (*FoundStories) GetType() string {
	return TypeFoundStories
}

// Contains identifier of a story along with identifier of its sender
type StoryFullId struct {
	meta
	// Identifier of the chat that posted the story
	SenderChatId int64 `json:"sender_chat_id"`
	// Unique story identifier among stories of the given sender
	StoryId int32 `json:"story_id"`
}

func (entity *StoryFullId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryFullId

	return json.Marshal((*stub)(entity))
}

func (*StoryFullId) GetClass() string {
	return ClassStoryFullId
}

func (*StoryFullId) GetType() string {
	return TypeStoryFullId
}

// Contains basic information about a story
type StoryInfo struct {
	meta
	// Unique story identifier among stories of the given sender
	StoryId int32 `json:"story_id"`
	// Point in time (Unix timestamp) when the story was published
	Date int32 `json:"date"`
	// True, if the story is available only to close friends
	IsForCloseFriends bool `json:"is_for_close_friends"`
}

func (entity *StoryInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInfo

	return json.Marshal((*stub)(entity))
}

func (*StoryInfo) GetClass() string {
	return ClassStoryInfo
}

func (*StoryInfo) GetType() string {
	return TypeStoryInfo
}

// Describes active stories posted by a chat
type ChatActiveStories struct {
	meta
	// Identifier of the chat that posted the stories
	ChatId int64 `json:"chat_id"`
	// Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list
	List StoryList `json:"list"`
	// A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
	Order int64 `json:"order"`
	// Identifier of the last read active story
	MaxReadStoryId int32 `json:"max_read_story_id"`
	// Basic information about the stories; use getStory to get full information about the stories. The stories are in chronological order (i.e., in order of increasing story identifiers)
	Stories []*StoryInfo `json:"stories"`
}

func (entity *ChatActiveStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActiveStories

	return json.Marshal((*stub)(entity))
}

func (*ChatActiveStories) GetClass() string {
	return ClassChatActiveStories
}

func (*ChatActiveStories) GetType() string {
	return TypeChatActiveStories
}

func (chatActiveStories *ChatActiveStories) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId         int64           `json:"chat_id"`
		List           json.RawMessage `json:"list"`
		Order          int64           `json:"order"`
		MaxReadStoryId int32           `json:"max_read_story_id"`
		Stories        []*StoryInfo    `json:"stories"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatActiveStories.ChatId = tmp.ChatId
	chatActiveStories.Order = tmp.Order
	chatActiveStories.MaxReadStoryId = tmp.MaxReadStoryId
	chatActiveStories.Stories = tmp.Stories

	fieldList, _ := UnmarshalStoryList(tmp.List)
	chatActiveStories.List = fieldList

	return nil
}

// A view of the story
type StoryInteractionTypeView struct {
	meta
	// Type of the reaction that was chosen by the viewer; may be null if none
	ChosenReactionType ReactionType `json:"chosen_reaction_type"`
}

func (entity *StoryInteractionTypeView) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInteractionTypeView

	return json.Marshal((*stub)(entity))
}

func (*StoryInteractionTypeView) GetClass() string {
	return ClassStoryInteractionType
}

func (*StoryInteractionTypeView) GetType() string {
	return TypeStoryInteractionTypeView
}

func (*StoryInteractionTypeView) StoryInteractionTypeType() string {
	return TypeStoryInteractionTypeView
}

func (storyInteractionTypeView *StoryInteractionTypeView) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChosenReactionType json.RawMessage `json:"chosen_reaction_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldChosenReactionType, _ := UnmarshalReactionType(tmp.ChosenReactionType)
	storyInteractionTypeView.ChosenReactionType = fieldChosenReactionType

	return nil
}

// A forward of the story as a message
type StoryInteractionTypeForward struct {
	meta
	// The message with story forward
	Message *Message `json:"message"`
}

func (entity *StoryInteractionTypeForward) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInteractionTypeForward

	return json.Marshal((*stub)(entity))
}

func (*StoryInteractionTypeForward) GetClass() string {
	return ClassStoryInteractionType
}

func (*StoryInteractionTypeForward) GetType() string {
	return TypeStoryInteractionTypeForward
}

func (*StoryInteractionTypeForward) StoryInteractionTypeType() string {
	return TypeStoryInteractionTypeForward
}

// A repost of the story as a story
type StoryInteractionTypeRepost struct {
	meta
	// The reposted story
	Story *Story `json:"story"`
}

func (entity *StoryInteractionTypeRepost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInteractionTypeRepost

	return json.Marshal((*stub)(entity))
}

func (*StoryInteractionTypeRepost) GetClass() string {
	return ClassStoryInteractionType
}

func (*StoryInteractionTypeRepost) GetType() string {
	return TypeStoryInteractionTypeRepost
}

func (*StoryInteractionTypeRepost) StoryInteractionTypeType() string {
	return TypeStoryInteractionTypeRepost
}

// Represents interaction with a story
type StoryInteraction struct {
	meta
	// Identifier of the user or chat that made the interaction
	ActorId MessageSender `json:"actor_id"`
	// Approximate point in time (Unix timestamp) when the interaction happened
	InteractionDate int32 `json:"interaction_date"`
	// Block list to which the actor is added; may be null if none or for chat stories
	BlockList BlockList `json:"block_list"`
	// Type of the interaction
	Type StoryInteractionType `json:"type"`
}

func (entity *StoryInteraction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInteraction

	return json.Marshal((*stub)(entity))
}

func (*StoryInteraction) GetClass() string {
	return ClassStoryInteraction
}

func (*StoryInteraction) GetType() string {
	return TypeStoryInteraction
}

func (storyInteraction *StoryInteraction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ActorId         json.RawMessage `json:"actor_id"`
		InteractionDate int32           `json:"interaction_date"`
		BlockList       json.RawMessage `json:"block_list"`
		Type            json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storyInteraction.InteractionDate = tmp.InteractionDate

	fieldActorId, _ := UnmarshalMessageSender(tmp.ActorId)
	storyInteraction.ActorId = fieldActorId

	fieldBlockList, _ := UnmarshalBlockList(tmp.BlockList)
	storyInteraction.BlockList = fieldBlockList

	fieldType, _ := UnmarshalStoryInteractionType(tmp.Type)
	storyInteraction.Type = fieldType

	return nil
}

// Represents a list of interactions with a story
type StoryInteractions struct {
	meta
	// Approximate total number of interactions found
	TotalCount int32 `json:"total_count"`
	// Approximate total number of found forwards and reposts; always 0 for chat stories
	TotalForwardCount int32 `json:"total_forward_count"`
	// Approximate total number of found reactions; always 0 for chat stories
	TotalReactionCount int32 `json:"total_reaction_count"`
	// List of story interactions
	Interactions []*StoryInteraction `json:"interactions"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *StoryInteractions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryInteractions

	return json.Marshal((*stub)(entity))
}

func (*StoryInteractions) GetClass() string {
	return ClassStoryInteractions
}

func (*StoryInteractions) GetType() string {
	return TypeStoryInteractions
}

// Describes a message that can be used for quick reply
type QuickReplyMessage struct {
	meta
	// Unique message identifier among all quick replies
	Id int64 `json:"id"`
	// The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
	SendingState MessageSendingState `json:"sending_state"`
	// True, if the message can be edited
	CanBeEdited bool `json:"can_be_edited"`
	// The identifier of the quick reply message to which the message replies; 0 if none
	ReplyToMessageId int64 `json:"reply_to_message_id"`
	// If non-zero, the user identifier of the bot through which this message was sent
	ViaBotUserId int64 `json:"via_bot_user_id"`
	// Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
	MediaAlbumId JsonInt64 `json:"media_album_id"`
	// Content of the message
	Content MessageContent `json:"content"`
	// Inline keyboard reply markup for the message; may be null if none
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *QuickReplyMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub QuickReplyMessage

	return json.Marshal((*stub)(entity))
}

func (*QuickReplyMessage) GetClass() string {
	return ClassQuickReplyMessage
}

func (*QuickReplyMessage) GetType() string {
	return TypeQuickReplyMessage
}

func (quickReplyMessage *QuickReplyMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id               int64           `json:"id"`
		SendingState     json.RawMessage `json:"sending_state"`
		CanBeEdited      bool            `json:"can_be_edited"`
		ReplyToMessageId int64           `json:"reply_to_message_id"`
		ViaBotUserId     int64           `json:"via_bot_user_id"`
		MediaAlbumId     JsonInt64       `json:"media_album_id"`
		Content          json.RawMessage `json:"content"`
		ReplyMarkup      json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	quickReplyMessage.Id = tmp.Id
	quickReplyMessage.CanBeEdited = tmp.CanBeEdited
	quickReplyMessage.ReplyToMessageId = tmp.ReplyToMessageId
	quickReplyMessage.ViaBotUserId = tmp.ViaBotUserId
	quickReplyMessage.MediaAlbumId = tmp.MediaAlbumId

	fieldSendingState, _ := UnmarshalMessageSendingState(tmp.SendingState)
	quickReplyMessage.SendingState = fieldSendingState

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	quickReplyMessage.Content = fieldContent

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	quickReplyMessage.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Contains a list of quick reply messages
type QuickReplyMessages struct {
	meta
	// List of quick reply messages; messages may be null
	Messages []*QuickReplyMessage `json:"messages"`
}

func (entity *QuickReplyMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub QuickReplyMessages

	return json.Marshal((*stub)(entity))
}

func (*QuickReplyMessages) GetClass() string {
	return ClassQuickReplyMessages
}

func (*QuickReplyMessages) GetType() string {
	return TypeQuickReplyMessages
}

// Describes a shortcut that can be used for a quick reply
type QuickReplyShortcut struct {
	meta
	// Unique shortcut identifier
	Id int32 `json:"id"`
	// The name of the shortcut that can be used to use the shortcut
	Name string `json:"name"`
	// The first shortcut message
	FirstMessage *QuickReplyMessage `json:"first_message"`
	// The total number of messages in the shortcut
	MessageCount int32 `json:"message_count"`
}

func (entity *QuickReplyShortcut) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub QuickReplyShortcut

	return json.Marshal((*stub)(entity))
}

func (*QuickReplyShortcut) GetClass() string {
	return ClassQuickReplyShortcut
}

func (*QuickReplyShortcut) GetType() string {
	return TypeQuickReplyShortcut
}

// Contains a public forward as a message
type PublicForwardMessage struct {
	meta
	// Information about the message
	Message *Message `json:"message"`
}

func (entity *PublicForwardMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicForwardMessage

	return json.Marshal((*stub)(entity))
}

func (*PublicForwardMessage) GetClass() string {
	return ClassPublicForward
}

func (*PublicForwardMessage) GetType() string {
	return TypePublicForwardMessage
}

func (*PublicForwardMessage) PublicForwardType() string {
	return TypePublicForwardMessage
}

// Contains a public repost to a story
type PublicForwardStory struct {
	meta
	// Information about the story
	Story *Story `json:"story"`
}

func (entity *PublicForwardStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicForwardStory

	return json.Marshal((*stub)(entity))
}

func (*PublicForwardStory) GetClass() string {
	return ClassPublicForward
}

func (*PublicForwardStory) GetType() string {
	return TypePublicForwardStory
}

func (*PublicForwardStory) PublicForwardType() string {
	return TypePublicForwardStory
}

// Represents a list of public forwards and reposts as a story of a message or a story
type PublicForwards struct {
	meta
	// Approximate total number of messages and stories found
	TotalCount int32 `json:"total_count"`
	// List of found public forwards and reposts
	Forwards []PublicForward `json:"forwards"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *PublicForwards) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicForwards

	return json.Marshal((*stub)(entity))
}

func (*PublicForwards) GetClass() string {
	return ClassPublicForwards
}

func (*PublicForwards) GetType() string {
	return TypePublicForwards
}

func (publicForwards *PublicForwards) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TotalCount int32             `json:"total_count"`
		Forwards   []json.RawMessage `json:"forwards"`
		NextOffset string            `json:"next_offset"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	publicForwards.TotalCount = tmp.TotalCount
	publicForwards.NextOffset = tmp.NextOffset

	fieldForwards, _ := UnmarshalListOfPublicForward(tmp.Forwards)
	publicForwards.Forwards = fieldForwards

	return nil
}

// Describes media previews of a bot
type BotMediaPreview struct {
	meta
	// Point in time (Unix timestamp) when the preview was added or changed last time
	Date int32 `json:"date"`
	// Content of the preview
	Content StoryContent `json:"content"`
}

func (entity *BotMediaPreview) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotMediaPreview

	return json.Marshal((*stub)(entity))
}

func (*BotMediaPreview) GetClass() string {
	return ClassBotMediaPreview
}

func (*BotMediaPreview) GetType() string {
	return TypeBotMediaPreview
}

func (botMediaPreview *BotMediaPreview) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Date    int32           `json:"date"`
		Content json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	botMediaPreview.Date = tmp.Date

	fieldContent, _ := UnmarshalStoryContent(tmp.Content)
	botMediaPreview.Content = fieldContent

	return nil
}

// Contains a list of media previews of a bot
type BotMediaPreviews struct {
	meta
	// List of media previews
	Previews []*BotMediaPreview `json:"previews"`
}

func (entity *BotMediaPreviews) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotMediaPreviews

	return json.Marshal((*stub)(entity))
}

func (*BotMediaPreviews) GetClass() string {
	return ClassBotMediaPreviews
}

func (*BotMediaPreviews) GetType() string {
	return TypeBotMediaPreviews
}

// Contains a list of media previews of a bot for the given language and the list of languages for which the bot has dedicated previews
type BotMediaPreviewInfo struct {
	meta
	// List of media previews
	Previews []*BotMediaPreview `json:"previews"`
	// List of language codes for which the bot has dedicated previews
	LanguageCodes []string `json:"language_codes"`
}

func (entity *BotMediaPreviewInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotMediaPreviewInfo

	return json.Marshal((*stub)(entity))
}

func (*BotMediaPreviewInfo) GetClass() string {
	return ClassBotMediaPreviewInfo
}

func (*BotMediaPreviewInfo) GetType() string {
	return TypeBotMediaPreviewInfo
}

// Contains a list of features available on a specific chat boost level
type ChatBoostLevelFeatures struct {
	meta
	// Target chat boost level
	Level int32 `json:"level"`
	// Number of stories that the chat can publish daily
	StoryPerDayCount int32 `json:"story_per_day_count"`
	// Number of custom emoji reactions that can be added to the list of available reactions
	CustomEmojiReactionCount int32 `json:"custom_emoji_reaction_count"`
	// Number of custom colors for chat title
	TitleColorCount int32 `json:"title_color_count"`
	// Number of custom colors for profile photo background
	ProfileAccentColorCount int32 `json:"profile_accent_color_count"`
	// True, if custom emoji for profile background can be set
	CanSetProfileBackgroundCustomEmoji bool `json:"can_set_profile_background_custom_emoji"`
	// Number of custom colors for background of empty chat photo, replies to messages and link previews
	AccentColorCount int32 `json:"accent_color_count"`
	// True, if custom emoji for reply header and link preview background can be set
	CanSetBackgroundCustomEmoji bool `json:"can_set_background_custom_emoji"`
	// True, if emoji status can be set
	CanSetEmojiStatus bool `json:"can_set_emoji_status"`
	// Number of chat theme backgrounds that can be set as chat background
	ChatThemeBackgroundCount int32 `json:"chat_theme_background_count"`
	// True, if custom background can be set in the chat for all users
	CanSetCustomBackground bool `json:"can_set_custom_background"`
	// True, if custom emoji sticker set can be set for the chat
	CanSetCustomEmojiStickerSet bool `json:"can_set_custom_emoji_sticker_set"`
	// True, if speech recognition can be used for video note and voice note messages by all users
	CanRecognizeSpeech bool `json:"can_recognize_speech"`
	// True, if sponsored messages can be disabled in the chat
	CanDisableSponsoredMessages bool `json:"can_disable_sponsored_messages"`
}

func (entity *ChatBoostLevelFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostLevelFeatures

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostLevelFeatures) GetClass() string {
	return ClassChatBoostLevelFeatures
}

func (*ChatBoostLevelFeatures) GetType() string {
	return TypeChatBoostLevelFeatures
}

// Contains a list of features available on the first chat boost levels
type ChatBoostFeatures struct {
	meta
	// The list of features
	Features []*ChatBoostLevelFeatures `json:"features"`
	// The minimum boost level required to set custom emoji for profile background
	MinProfileBackgroundCustomEmojiBoostLevel int32 `json:"min_profile_background_custom_emoji_boost_level"`
	// The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only
	MinBackgroundCustomEmojiBoostLevel int32 `json:"min_background_custom_emoji_boost_level"`
	// The minimum boost level required to set emoji status
	MinEmojiStatusBoostLevel int32 `json:"min_emoji_status_boost_level"`
	// The minimum boost level required to set a chat theme background as chat background
	MinChatThemeBackgroundBoostLevel int32 `json:"min_chat_theme_background_boost_level"`
	// The minimum boost level required to set custom chat background
	MinCustomBackgroundBoostLevel int32 `json:"min_custom_background_boost_level"`
	// The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only
	MinCustomEmojiStickerSetBoostLevel int32 `json:"min_custom_emoji_sticker_set_boost_level"`
	// The minimum boost level allowing to recognize speech in video note and voice note messages for non-Premium users; for supergroup chats only
	MinSpeechRecognitionBoostLevel int32 `json:"min_speech_recognition_boost_level"`
	// The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only
	MinSponsoredMessageDisableBoostLevel int32 `json:"min_sponsored_message_disable_boost_level"`
}

func (entity *ChatBoostFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostFeatures

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostFeatures) GetClass() string {
	return ClassChatBoostFeatures
}

func (*ChatBoostFeatures) GetType() string {
	return TypeChatBoostFeatures
}

// The chat created a Telegram Premium gift code for a user
type ChatBoostSourceGiftCode struct {
	meta
	// Identifier of a user, for which the gift code was created
	UserId int64 `json:"user_id"`
	// The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
	GiftCode string `json:"gift_code"`
}

func (entity *ChatBoostSourceGiftCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostSourceGiftCode

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostSourceGiftCode) GetClass() string {
	return ClassChatBoostSource
}

func (*ChatBoostSourceGiftCode) GetType() string {
	return TypeChatBoostSourceGiftCode
}

func (*ChatBoostSourceGiftCode) ChatBoostSourceType() string {
	return TypeChatBoostSourceGiftCode
}

// The chat created a giveaway
type ChatBoostSourceGiveaway struct {
	meta
	// Identifier of a user that won in the giveaway; 0 if none
	UserId int64 `json:"user_id"`
	// The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only
	GiftCode string `json:"gift_code"`
	// Number of Telegram Stars distributed among winners of the giveaway
	StarCount int64 `json:"star_count"`
	// Identifier of the corresponding giveaway message; can be an identifier of a deleted message
	GiveawayMessageId int64 `json:"giveaway_message_id"`
	// True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants
	IsUnclaimed bool `json:"is_unclaimed"`
}

func (entity *ChatBoostSourceGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostSourceGiveaway

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostSourceGiveaway) GetClass() string {
	return ClassChatBoostSource
}

func (*ChatBoostSourceGiveaway) GetType() string {
	return TypeChatBoostSourceGiveaway
}

func (*ChatBoostSourceGiveaway) ChatBoostSourceType() string {
	return TypeChatBoostSourceGiveaway
}

// A user with Telegram Premium subscription or gifted Telegram Premium boosted the chat
type ChatBoostSourcePremium struct {
	meta
	// Identifier of the user
	UserId int64 `json:"user_id"`
}

func (entity *ChatBoostSourcePremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostSourcePremium

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostSourcePremium) GetClass() string {
	return ClassChatBoostSource
}

func (*ChatBoostSourcePremium) GetType() string {
	return TypeChatBoostSourcePremium
}

func (*ChatBoostSourcePremium) ChatBoostSourceType() string {
	return TypeChatBoostSourcePremium
}

// Describes a prepaid giveaway
type PrepaidGiveaway struct {
	meta
	// Unique identifier of the prepaid giveaway
	Id JsonInt64 `json:"id"`
	// Number of users which will receive giveaway prize
	WinnerCount int32 `json:"winner_count"`
	// Prize of the giveaway
	Prize GiveawayPrize `json:"prize"`
	// The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only
	BoostCount int32 `json:"boost_count"`
	// Point in time (Unix timestamp) when the giveaway was paid
	PaymentDate int32 `json:"payment_date"`
}

func (entity *PrepaidGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PrepaidGiveaway

	return json.Marshal((*stub)(entity))
}

func (*PrepaidGiveaway) GetClass() string {
	return ClassPrepaidGiveaway
}

func (*PrepaidGiveaway) GetType() string {
	return TypePrepaidGiveaway
}

func (prepaidGiveaway *PrepaidGiveaway) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id          JsonInt64       `json:"id"`
		WinnerCount int32           `json:"winner_count"`
		Prize       json.RawMessage `json:"prize"`
		BoostCount  int32           `json:"boost_count"`
		PaymentDate int32           `json:"payment_date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	prepaidGiveaway.Id = tmp.Id
	prepaidGiveaway.WinnerCount = tmp.WinnerCount
	prepaidGiveaway.BoostCount = tmp.BoostCount
	prepaidGiveaway.PaymentDate = tmp.PaymentDate

	fieldPrize, _ := UnmarshalGiveawayPrize(tmp.Prize)
	prepaidGiveaway.Prize = fieldPrize

	return nil
}

// Describes current boost status of a chat
type ChatBoostStatus struct {
	meta
	// An HTTP URL, which can be used to boost the chat
	BoostUrl string `json:"boost_url"`
	// Identifiers of boost slots of the current user applied to the chat
	AppliedSlotIds []int32 `json:"applied_slot_ids"`
	// Current boost level of the chat
	Level int32 `json:"level"`
	// The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
	GiftCodeBoostCount int32 `json:"gift_code_boost_count"`
	// The number of boosts received by the chat
	BoostCount int32 `json:"boost_count"`
	// The number of boosts added to reach the current level
	CurrentLevelBoostCount int32 `json:"current_level_boost_count"`
	// The number of boosts needed to reach the next level; 0 if the next level isn't available
	NextLevelBoostCount int32 `json:"next_level_boost_count"`
	// Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
	PremiumMemberCount int32 `json:"premium_member_count"`
	// A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
	PremiumMemberPercentage float64 `json:"premium_member_percentage"`
	// The list of prepaid giveaways available for the chat; only for chat administrators
	PrepaidGiveaways []*PrepaidGiveaway `json:"prepaid_giveaways"`
}

func (entity *ChatBoostStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostStatus

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostStatus) GetClass() string {
	return ClassChatBoostStatus
}

func (*ChatBoostStatus) GetType() string {
	return TypeChatBoostStatus
}

// Describes a boost applied to a chat
type ChatBoost struct {
	meta
	// Unique identifier of the boost
	Id string `json:"id"`
	// The number of identical boosts applied
	Count int32 `json:"count"`
	// Source of the boost
	Source ChatBoostSource `json:"source"`
	// Point in time (Unix timestamp) when the chat was boosted
	StartDate int32 `json:"start_date"`
	// Point in time (Unix timestamp) when the boost will expire
	ExpirationDate int32 `json:"expiration_date"`
}

func (entity *ChatBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoost

	return json.Marshal((*stub)(entity))
}

func (*ChatBoost) GetClass() string {
	return ClassChatBoost
}

func (*ChatBoost) GetType() string {
	return TypeChatBoost
}

func (chatBoost *ChatBoost) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id             string          `json:"id"`
		Count          int32           `json:"count"`
		Source         json.RawMessage `json:"source"`
		StartDate      int32           `json:"start_date"`
		ExpirationDate int32           `json:"expiration_date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatBoost.Id = tmp.Id
	chatBoost.Count = tmp.Count
	chatBoost.StartDate = tmp.StartDate
	chatBoost.ExpirationDate = tmp.ExpirationDate

	fieldSource, _ := UnmarshalChatBoostSource(tmp.Source)
	chatBoost.Source = fieldSource

	return nil
}

// Contains a list of boosts applied to a chat
type FoundChatBoosts struct {
	meta
	// Total number of boosts applied to the chat
	TotalCount int32 `json:"total_count"`
	// List of boosts
	Boosts []*ChatBoost `json:"boosts"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *FoundChatBoosts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundChatBoosts

	return json.Marshal((*stub)(entity))
}

func (*FoundChatBoosts) GetClass() string {
	return ClassFoundChatBoosts
}

func (*FoundChatBoosts) GetType() string {
	return TypeFoundChatBoosts
}

// Describes a slot for chat boost
type ChatBoostSlot struct {
	meta
	// Unique identifier of the slot
	SlotId int32 `json:"slot_id"`
	// Identifier of the currently boosted chat; 0 if none
	CurrentlyBoostedChatId int64 `json:"currently_boosted_chat_id"`
	// Point in time (Unix timestamp) when the chat was boosted; 0 if none
	StartDate int32 `json:"start_date"`
	// Point in time (Unix timestamp) when the boost will expire
	ExpirationDate int32 `json:"expiration_date"`
	// Point in time (Unix timestamp) after which the boost can be used for another chat
	CooldownUntilDate int32 `json:"cooldown_until_date"`
}

func (entity *ChatBoostSlot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostSlot

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostSlot) GetClass() string {
	return ClassChatBoostSlot
}

func (*ChatBoostSlot) GetType() string {
	return TypeChatBoostSlot
}

// Contains a list of chat boost slots
type ChatBoostSlots struct {
	meta
	// List of boost slots
	Slots []*ChatBoostSlot `json:"slots"`
}

func (entity *ChatBoostSlots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostSlots

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostSlots) GetClass() string {
	return ClassChatBoostSlots
}

func (*ChatBoostSlots) GetType() string {
	return TypeChatBoostSlots
}

// The user requested to resend the code
type ResendCodeReasonUserRequest struct {
	meta
}

func (entity *ResendCodeReasonUserRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResendCodeReasonUserRequest

	return json.Marshal((*stub)(entity))
}

func (*ResendCodeReasonUserRequest) GetClass() string {
	return ClassResendCodeReason
}

func (*ResendCodeReasonUserRequest) GetType() string {
	return TypeResendCodeReasonUserRequest
}

func (*ResendCodeReasonUserRequest) ResendCodeReasonType() string {
	return TypeResendCodeReasonUserRequest
}

// The code is re-sent, because device verification has failed
type ResendCodeReasonVerificationFailed struct {
	meta
	// Cause of the verification failure, for example, PLAY_SERVICES_NOT_AVAILABLE, APNS_RECEIVE_TIMEOUT, or APNS_INIT_FAILED
	ErrorMessage string `json:"error_message"`
}

func (entity *ResendCodeReasonVerificationFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResendCodeReasonVerificationFailed

	return json.Marshal((*stub)(entity))
}

func (*ResendCodeReasonVerificationFailed) GetClass() string {
	return ClassResendCodeReason
}

func (*ResendCodeReasonVerificationFailed) GetType() string {
	return TypeResendCodeReasonVerificationFailed
}

func (*ResendCodeReasonVerificationFailed) ResendCodeReasonType() string {
	return TypeResendCodeReasonVerificationFailed
}

// The call wasn't discarded, or the reason is unknown
type CallDiscardReasonEmpty struct {
	meta
}

func (entity *CallDiscardReasonEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonEmpty

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonEmpty) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonEmpty) GetType() string {
	return TypeCallDiscardReasonEmpty
}

func (*CallDiscardReasonEmpty) CallDiscardReasonType() string {
	return TypeCallDiscardReasonEmpty
}

// The call was ended before the conversation started. It was canceled by the caller or missed by the other party
type CallDiscardReasonMissed struct {
	meta
}

func (entity *CallDiscardReasonMissed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonMissed

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonMissed) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonMissed) GetType() string {
	return TypeCallDiscardReasonMissed
}

func (*CallDiscardReasonMissed) CallDiscardReasonType() string {
	return TypeCallDiscardReasonMissed
}

// The call was ended before the conversation started. It was declined by the other party
type CallDiscardReasonDeclined struct {
	meta
}

func (entity *CallDiscardReasonDeclined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonDeclined

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonDeclined) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonDeclined) GetType() string {
	return TypeCallDiscardReasonDeclined
}

func (*CallDiscardReasonDeclined) CallDiscardReasonType() string {
	return TypeCallDiscardReasonDeclined
}

// The call was ended during the conversation because the users were disconnected
type CallDiscardReasonDisconnected struct {
	meta
}

func (entity *CallDiscardReasonDisconnected) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonDisconnected

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonDisconnected) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonDisconnected) GetType() string {
	return TypeCallDiscardReasonDisconnected
}

func (*CallDiscardReasonDisconnected) CallDiscardReasonType() string {
	return TypeCallDiscardReasonDisconnected
}

// The call was ended because one of the parties hung up
type CallDiscardReasonHungUp struct {
	meta
}

func (entity *CallDiscardReasonHungUp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonHungUp

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonHungUp) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonHungUp) GetType() string {
	return TypeCallDiscardReasonHungUp
}

func (*CallDiscardReasonHungUp) CallDiscardReasonType() string {
	return TypeCallDiscardReasonHungUp
}

// Specifies the supported call protocols
type CallProtocol struct {
	meta
	// True, if UDP peer-to-peer connections are supported
	UdpP2p bool `json:"udp_p2p"`
	// True, if connection through UDP reflectors is supported
	UdpReflector bool `json:"udp_reflector"`
	// The minimum supported API layer; use 65
	MinLayer int32 `json:"min_layer"`
	// The maximum supported API layer; use 92
	MaxLayer int32 `json:"max_layer"`
	// List of supported tgcalls versions
	LibraryVersions []string `json:"library_versions"`
}

func (entity *CallProtocol) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProtocol

	return json.Marshal((*stub)(entity))
}

func (*CallProtocol) GetClass() string {
	return ClassCallProtocol
}

func (*CallProtocol) GetType() string {
	return TypeCallProtocol
}

// A Telegram call reflector
type CallServerTypeTelegramReflector struct {
	meta
	// A peer tag to be used with the reflector
	PeerTag []byte `json:"peer_tag"`
	// True, if the server uses TCP instead of UDP
	IsTcp bool `json:"is_tcp"`
}

func (entity *CallServerTypeTelegramReflector) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallServerTypeTelegramReflector

	return json.Marshal((*stub)(entity))
}

func (*CallServerTypeTelegramReflector) GetClass() string {
	return ClassCallServerType
}

func (*CallServerTypeTelegramReflector) GetType() string {
	return TypeCallServerTypeTelegramReflector
}

func (*CallServerTypeTelegramReflector) CallServerTypeType() string {
	return TypeCallServerTypeTelegramReflector
}

// A WebRTC server
type CallServerTypeWebrtc struct {
	meta
	// Username to be used for authentication
	Username string `json:"username"`
	// Authentication password
	Password string `json:"password"`
	// True, if the server supports TURN
	SupportsTurn bool `json:"supports_turn"`
	// True, if the server supports STUN
	SupportsStun bool `json:"supports_stun"`
}

func (entity *CallServerTypeWebrtc) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallServerTypeWebrtc

	return json.Marshal((*stub)(entity))
}

func (*CallServerTypeWebrtc) GetClass() string {
	return ClassCallServerType
}

func (*CallServerTypeWebrtc) GetType() string {
	return TypeCallServerTypeWebrtc
}

func (*CallServerTypeWebrtc) CallServerTypeType() string {
	return TypeCallServerTypeWebrtc
}

// Describes a server for relaying call data
type CallServer struct {
	meta
	// Server identifier
	Id JsonInt64 `json:"id"`
	// Server IPv4 address
	IpAddress string `json:"ip_address"`
	// Server IPv6 address
	Ipv6Address string `json:"ipv6_address"`
	// Server port number
	Port int32 `json:"port"`
	// Server type
	Type CallServerType `json:"type"`
}

func (entity *CallServer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallServer

	return json.Marshal((*stub)(entity))
}

func (*CallServer) GetClass() string {
	return ClassCallServer
}

func (*CallServer) GetType() string {
	return TypeCallServer
}

func (callServer *CallServer) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id          JsonInt64       `json:"id"`
		IpAddress   string          `json:"ip_address"`
		Ipv6Address string          `json:"ipv6_address"`
		Port        int32           `json:"port"`
		Type        json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	callServer.Id = tmp.Id
	callServer.IpAddress = tmp.IpAddress
	callServer.Ipv6Address = tmp.Ipv6Address
	callServer.Port = tmp.Port

	fieldType, _ := UnmarshalCallServerType(tmp.Type)
	callServer.Type = fieldType

	return nil
}

// Contains the call identifier
type CallId struct {
	meta
	// Call identifier
	Id int32 `json:"id"`
}

func (entity *CallId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallId

	return json.Marshal((*stub)(entity))
}

func (*CallId) GetClass() string {
	return ClassCallId
}

func (*CallId) GetType() string {
	return TypeCallId
}

// Contains the group call identifier
type GroupCallId struct {
	meta
	// Group call identifier
	Id int32 `json:"id"`
}

func (entity *GroupCallId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallId

	return json.Marshal((*stub)(entity))
}

func (*GroupCallId) GetClass() string {
	return ClassGroupCallId
}

func (*GroupCallId) GetType() string {
	return TypeGroupCallId
}

// The call is pending, waiting to be accepted by a user
type CallStatePending struct {
	meta
	// True, if the call has already been created by the server
	IsCreated bool `json:"is_created"`
	// True, if the call has already been received by the other party
	IsReceived bool `json:"is_received"`
}

func (entity *CallStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStatePending

	return json.Marshal((*stub)(entity))
}

func (*CallStatePending) GetClass() string {
	return ClassCallState
}

func (*CallStatePending) GetType() string {
	return TypeCallStatePending
}

func (*CallStatePending) CallStateType() string {
	return TypeCallStatePending
}

// The call has been answered and encryption keys are being exchanged
type CallStateExchangingKeys struct {
	meta
}

func (entity *CallStateExchangingKeys) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateExchangingKeys

	return json.Marshal((*stub)(entity))
}

func (*CallStateExchangingKeys) GetClass() string {
	return ClassCallState
}

func (*CallStateExchangingKeys) GetType() string {
	return TypeCallStateExchangingKeys
}

func (*CallStateExchangingKeys) CallStateType() string {
	return TypeCallStateExchangingKeys
}

// The call is ready to use
type CallStateReady struct {
	meta
	// Call protocols supported by the other call participant
	Protocol *CallProtocol `json:"protocol"`
	// List of available call servers
	Servers []*CallServer `json:"servers"`
	// A JSON-encoded call config
	Config string `json:"config"`
	// Call encryption key
	EncryptionKey []byte `json:"encryption_key"`
	// Encryption key fingerprint represented as 4 emoji
	Emojis []string `json:"emojis"`
	// True, if peer-to-peer connection is allowed by users privacy settings
	AllowP2p bool `json:"allow_p2p"`
	// Custom JSON-encoded call parameters to be passed to tgcalls
	CustomParameters string `json:"custom_parameters"`
}

func (entity *CallStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateReady

	return json.Marshal((*stub)(entity))
}

func (*CallStateReady) GetClass() string {
	return ClassCallState
}

func (*CallStateReady) GetType() string {
	return TypeCallStateReady
}

func (*CallStateReady) CallStateType() string {
	return TypeCallStateReady
}

// The call is hanging up after discardCall has been called
type CallStateHangingUp struct {
	meta
}

func (entity *CallStateHangingUp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateHangingUp

	return json.Marshal((*stub)(entity))
}

func (*CallStateHangingUp) GetClass() string {
	return ClassCallState
}

func (*CallStateHangingUp) GetType() string {
	return TypeCallStateHangingUp
}

func (*CallStateHangingUp) CallStateType() string {
	return TypeCallStateHangingUp
}

// The call has ended successfully
type CallStateDiscarded struct {
	meta
	// The reason why the call has ended
	Reason CallDiscardReason `json:"reason"`
	// True, if the call rating must be sent to the server
	NeedRating bool `json:"need_rating"`
	// True, if the call debug information must be sent to the server
	NeedDebugInformation bool `json:"need_debug_information"`
	// True, if the call log must be sent to the server
	NeedLog bool `json:"need_log"`
}

func (entity *CallStateDiscarded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateDiscarded

	return json.Marshal((*stub)(entity))
}

func (*CallStateDiscarded) GetClass() string {
	return ClassCallState
}

func (*CallStateDiscarded) GetType() string {
	return TypeCallStateDiscarded
}

func (*CallStateDiscarded) CallStateType() string {
	return TypeCallStateDiscarded
}

func (callStateDiscarded *CallStateDiscarded) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Reason               json.RawMessage `json:"reason"`
		NeedRating           bool            `json:"need_rating"`
		NeedDebugInformation bool            `json:"need_debug_information"`
		NeedLog              bool            `json:"need_log"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	callStateDiscarded.NeedRating = tmp.NeedRating
	callStateDiscarded.NeedDebugInformation = tmp.NeedDebugInformation
	callStateDiscarded.NeedLog = tmp.NeedLog

	fieldReason, _ := UnmarshalCallDiscardReason(tmp.Reason)
	callStateDiscarded.Reason = fieldReason

	return nil
}

// The call has ended with an error
type CallStateError struct {
	meta
	// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
	Error *Error `json:"error"`
}

func (entity *CallStateError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateError

	return json.Marshal((*stub)(entity))
}

func (*CallStateError) GetClass() string {
	return ClassCallState
}

func (*CallStateError) GetType() string {
	return TypeCallStateError
}

func (*CallStateError) CallStateType() string {
	return TypeCallStateError
}

// The worst available video quality
type GroupCallVideoQualityThumbnail struct {
	meta
}

func (entity *GroupCallVideoQualityThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoQualityThumbnail

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoQualityThumbnail) GetClass() string {
	return ClassGroupCallVideoQuality
}

func (*GroupCallVideoQualityThumbnail) GetType() string {
	return TypeGroupCallVideoQualityThumbnail
}

func (*GroupCallVideoQualityThumbnail) GroupCallVideoQualityType() string {
	return TypeGroupCallVideoQualityThumbnail
}

// The medium video quality
type GroupCallVideoQualityMedium struct {
	meta
}

func (entity *GroupCallVideoQualityMedium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoQualityMedium

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoQualityMedium) GetClass() string {
	return ClassGroupCallVideoQuality
}

func (*GroupCallVideoQualityMedium) GetType() string {
	return TypeGroupCallVideoQualityMedium
}

func (*GroupCallVideoQualityMedium) GroupCallVideoQualityType() string {
	return TypeGroupCallVideoQualityMedium
}

// The best available video quality
type GroupCallVideoQualityFull struct {
	meta
}

func (entity *GroupCallVideoQualityFull) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoQualityFull

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoQualityFull) GetClass() string {
	return ClassGroupCallVideoQuality
}

func (*GroupCallVideoQualityFull) GetType() string {
	return TypeGroupCallVideoQualityFull
}

func (*GroupCallVideoQualityFull) GroupCallVideoQualityType() string {
	return TypeGroupCallVideoQualityFull
}

// Describes an available stream in a group call
type GroupCallStream struct {
	meta
	// Identifier of an audio/video channel
	ChannelId int32 `json:"channel_id"`
	// Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
	Scale int32 `json:"scale"`
	// Point in time when the stream currently ends; Unix timestamp in milliseconds
	TimeOffset int64 `json:"time_offset"`
}

func (entity *GroupCallStream) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallStream

	return json.Marshal((*stub)(entity))
}

func (*GroupCallStream) GetClass() string {
	return ClassGroupCallStream
}

func (*GroupCallStream) GetType() string {
	return TypeGroupCallStream
}

// Represents a list of group call streams
type GroupCallStreams struct {
	meta
	// A list of group call streams
	Streams []*GroupCallStream `json:"streams"`
}

func (entity *GroupCallStreams) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallStreams

	return json.Marshal((*stub)(entity))
}

func (*GroupCallStreams) GetClass() string {
	return ClassGroupCallStreams
}

func (*GroupCallStreams) GetType() string {
	return TypeGroupCallStreams
}

// Represents an RTMP URL
type RtmpUrl struct {
	meta
	// The URL
	Url string `json:"url"`
	// Stream key
	StreamKey string `json:"stream_key"`
}

func (entity *RtmpUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RtmpUrl

	return json.Marshal((*stub)(entity))
}

func (*RtmpUrl) GetClass() string {
	return ClassRtmpUrl
}

func (*RtmpUrl) GetType() string {
	return TypeRtmpUrl
}

// Describes a recently speaking participant in a group call
type GroupCallRecentSpeaker struct {
	meta
	// Group call participant identifier
	ParticipantId MessageSender `json:"participant_id"`
	// True, is the user has spoken recently
	IsSpeaking bool `json:"is_speaking"`
}

func (entity *GroupCallRecentSpeaker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallRecentSpeaker

	return json.Marshal((*stub)(entity))
}

func (*GroupCallRecentSpeaker) GetClass() string {
	return ClassGroupCallRecentSpeaker
}

func (*GroupCallRecentSpeaker) GetType() string {
	return TypeGroupCallRecentSpeaker
}

func (groupCallRecentSpeaker *GroupCallRecentSpeaker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId json.RawMessage `json:"participant_id"`
		IsSpeaking    bool            `json:"is_speaking"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	groupCallRecentSpeaker.IsSpeaking = tmp.IsSpeaking

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	groupCallRecentSpeaker.ParticipantId = fieldParticipantId

	return nil
}

// Describes a group call
type GroupCall struct {
	meta
	// Group call identifier
	Id int32 `json:"id"`
	// Group call title
	Title string `json:"title"`
	// Point in time (Unix timestamp) when the group call is expected to be started by an administrator; 0 if it is already active or was ended
	ScheduledStartDate int32 `json:"scheduled_start_date"`
	// True, if the group call is scheduled and the current user will receive a notification when the group call starts
	EnabledStartNotification bool `json:"enabled_start_notification"`
	// True, if the call is active
	IsActive bool `json:"is_active"`
	// True, if the chat is an RTMP stream instead of an ordinary video chat
	IsRtmpStream bool `json:"is_rtmp_stream"`
	// True, if the call is joined
	IsJoined bool `json:"is_joined"`
	// True, if user was kicked from the call because of network loss and the call needs to be rejoined
	NeedRejoin bool `json:"need_rejoin"`
	// True, if the current user can manage the group call
	CanBeManaged bool `json:"can_be_managed"`
	// Number of participants in the group call
	ParticipantCount int32 `json:"participant_count"`
	// True, if group call participants, which are muted, aren't returned in participant list
	HasHiddenListeners bool `json:"has_hidden_listeners"`
	// True, if all group call participants are loaded
	LoadedAllParticipants bool `json:"loaded_all_participants"`
	// At most 3 recently speaking users in the group call
	RecentSpeakers []*GroupCallRecentSpeaker `json:"recent_speakers"`
	// True, if the current user's video is enabled
	IsMyVideoEnabled bool `json:"is_my_video_enabled"`
	// True, if the current user's video is paused
	IsMyVideoPaused bool `json:"is_my_video_paused"`
	// True, if the current user can broadcast video or share screen
	CanEnableVideo bool `json:"can_enable_video"`
	// True, if only group call administrators can unmute new participants
	MuteNewParticipants bool `json:"mute_new_participants"`
	// True, if the current user can enable or disable mute_new_participants setting
	CanToggleMuteNewParticipants bool `json:"can_toggle_mute_new_participants"`
	// Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
	RecordDuration int32 `json:"record_duration"`
	// True, if a video file is being recorded for the call
	IsVideoRecorded bool `json:"is_video_recorded"`
	// Call duration, in seconds; for ended calls only
	Duration int32 `json:"duration"`
}

func (entity *GroupCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCall

	return json.Marshal((*stub)(entity))
}

func (*GroupCall) GetClass() string {
	return ClassGroupCall
}

func (*GroupCall) GetType() string {
	return TypeGroupCall
}

// Describes a group of video synchronization source identifiers
type GroupCallVideoSourceGroup struct {
	meta
	// The semantics of sources, one of "SIM" or "FID"
	Semantics string `json:"semantics"`
	// The list of synchronization source identifiers
	SourceIds []int32 `json:"source_ids"`
}

func (entity *GroupCallVideoSourceGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallVideoSourceGroup

	return json.Marshal((*stub)(entity))
}

func (*GroupCallVideoSourceGroup) GetClass() string {
	return ClassGroupCallVideoSourceGroup
}

func (*GroupCallVideoSourceGroup) GetType() string {
	return TypeGroupCallVideoSourceGroup
}

// Contains information about a group call participant's video channel
type GroupCallParticipantVideoInfo struct {
	meta
	// List of synchronization source groups of the video
	SourceGroups []*GroupCallVideoSourceGroup `json:"source_groups"`
	// Video channel endpoint identifier
	EndpointId string `json:"endpoint_id"`
	// True, if the video is paused. This flag needs to be ignored, if new video frames are received
	IsPaused bool `json:"is_paused"`
}

func (entity *GroupCallParticipantVideoInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallParticipantVideoInfo

	return json.Marshal((*stub)(entity))
}

func (*GroupCallParticipantVideoInfo) GetClass() string {
	return ClassGroupCallParticipantVideoInfo
}

func (*GroupCallParticipantVideoInfo) GetType() string {
	return TypeGroupCallParticipantVideoInfo
}

// Represents a group call participant
type GroupCallParticipant struct {
	meta
	// Identifier of the group call participant
	ParticipantId MessageSender `json:"participant_id"`
	// User's audio channel synchronization source identifier
	AudioSourceId int32 `json:"audio_source_id"`
	// User's screen sharing audio channel synchronization source identifier
	ScreenSharingAudioSourceId int32 `json:"screen_sharing_audio_source_id"`
	// Information about user's video channel; may be null if there is no active video
	VideoInfo *GroupCallParticipantVideoInfo `json:"video_info"`
	// Information about user's screen sharing video channel; may be null if there is no active screen sharing video
	ScreenSharingVideoInfo *GroupCallParticipantVideoInfo `json:"screen_sharing_video_info"`
	// The participant user's bio or the participant chat's description
	Bio string `json:"bio"`
	// True, if the participant is the current user
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
	IsSpeaking bool `json:"is_speaking"`
	// True, if the participant hand is raised
	IsHandRaised bool `json:"is_hand_raised"`
	// True, if the current user can mute the participant for all other group call participants
	CanBeMutedForAllUsers bool `json:"can_be_muted_for_all_users"`
	// True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
	CanBeUnmutedForAllUsers bool `json:"can_be_unmuted_for_all_users"`
	// True, if the current user can mute the participant only for self
	CanBeMutedForCurrentUser bool `json:"can_be_muted_for_current_user"`
	// True, if the current user can unmute the participant for self
	CanBeUnmutedForCurrentUser bool `json:"can_be_unmuted_for_current_user"`
	// True, if the participant is muted for all users
	IsMutedForAllUsers bool `json:"is_muted_for_all_users"`
	// True, if the participant is muted for the current user
	IsMutedForCurrentUser bool `json:"is_muted_for_current_user"`
	// True, if the participant is muted for all users, but can unmute themselves
	CanUnmuteSelf bool `json:"can_unmute_self"`
	// Participant's volume level; 1-20000 in hundreds of percents
	VolumeLevel int32 `json:"volume_level"`
	// User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
	Order string `json:"order"`
}

func (entity *GroupCallParticipant) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GroupCallParticipant

	return json.Marshal((*stub)(entity))
}

func (*GroupCallParticipant) GetClass() string {
	return ClassGroupCallParticipant
}

func (*GroupCallParticipant) GetType() string {
	return TypeGroupCallParticipant
}

func (groupCallParticipant *GroupCallParticipant) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId              json.RawMessage                `json:"participant_id"`
		AudioSourceId              int32                          `json:"audio_source_id"`
		ScreenSharingAudioSourceId int32                          `json:"screen_sharing_audio_source_id"`
		VideoInfo                  *GroupCallParticipantVideoInfo `json:"video_info"`
		ScreenSharingVideoInfo     *GroupCallParticipantVideoInfo `json:"screen_sharing_video_info"`
		Bio                        string                         `json:"bio"`
		IsCurrentUser              bool                           `json:"is_current_user"`
		IsSpeaking                 bool                           `json:"is_speaking"`
		IsHandRaised               bool                           `json:"is_hand_raised"`
		CanBeMutedForAllUsers      bool                           `json:"can_be_muted_for_all_users"`
		CanBeUnmutedForAllUsers    bool                           `json:"can_be_unmuted_for_all_users"`
		CanBeMutedForCurrentUser   bool                           `json:"can_be_muted_for_current_user"`
		CanBeUnmutedForCurrentUser bool                           `json:"can_be_unmuted_for_current_user"`
		IsMutedForAllUsers         bool                           `json:"is_muted_for_all_users"`
		IsMutedForCurrentUser      bool                           `json:"is_muted_for_current_user"`
		CanUnmuteSelf              bool                           `json:"can_unmute_self"`
		VolumeLevel                int32                          `json:"volume_level"`
		Order                      string                         `json:"order"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	groupCallParticipant.AudioSourceId = tmp.AudioSourceId
	groupCallParticipant.ScreenSharingAudioSourceId = tmp.ScreenSharingAudioSourceId
	groupCallParticipant.VideoInfo = tmp.VideoInfo
	groupCallParticipant.ScreenSharingVideoInfo = tmp.ScreenSharingVideoInfo
	groupCallParticipant.Bio = tmp.Bio
	groupCallParticipant.IsCurrentUser = tmp.IsCurrentUser
	groupCallParticipant.IsSpeaking = tmp.IsSpeaking
	groupCallParticipant.IsHandRaised = tmp.IsHandRaised
	groupCallParticipant.CanBeMutedForAllUsers = tmp.CanBeMutedForAllUsers
	groupCallParticipant.CanBeUnmutedForAllUsers = tmp.CanBeUnmutedForAllUsers
	groupCallParticipant.CanBeMutedForCurrentUser = tmp.CanBeMutedForCurrentUser
	groupCallParticipant.CanBeUnmutedForCurrentUser = tmp.CanBeUnmutedForCurrentUser
	groupCallParticipant.IsMutedForAllUsers = tmp.IsMutedForAllUsers
	groupCallParticipant.IsMutedForCurrentUser = tmp.IsMutedForCurrentUser
	groupCallParticipant.CanUnmuteSelf = tmp.CanUnmuteSelf
	groupCallParticipant.VolumeLevel = tmp.VolumeLevel
	groupCallParticipant.Order = tmp.Order

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	groupCallParticipant.ParticipantId = fieldParticipantId

	return nil
}

// The user heard their own voice
type CallProblemEcho struct {
	meta
}

func (entity *CallProblemEcho) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemEcho

	return json.Marshal((*stub)(entity))
}

func (*CallProblemEcho) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemEcho) GetType() string {
	return TypeCallProblemEcho
}

func (*CallProblemEcho) CallProblemType() string {
	return TypeCallProblemEcho
}

// The user heard background noise
type CallProblemNoise struct {
	meta
}

func (entity *CallProblemNoise) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemNoise

	return json.Marshal((*stub)(entity))
}

func (*CallProblemNoise) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemNoise) GetType() string {
	return TypeCallProblemNoise
}

func (*CallProblemNoise) CallProblemType() string {
	return TypeCallProblemNoise
}

// The other side kept disappearing
type CallProblemInterruptions struct {
	meta
}

func (entity *CallProblemInterruptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemInterruptions

	return json.Marshal((*stub)(entity))
}

func (*CallProblemInterruptions) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemInterruptions) GetType() string {
	return TypeCallProblemInterruptions
}

func (*CallProblemInterruptions) CallProblemType() string {
	return TypeCallProblemInterruptions
}

// The speech was distorted
type CallProblemDistortedSpeech struct {
	meta
}

func (entity *CallProblemDistortedSpeech) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDistortedSpeech

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDistortedSpeech) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDistortedSpeech) GetType() string {
	return TypeCallProblemDistortedSpeech
}

func (*CallProblemDistortedSpeech) CallProblemType() string {
	return TypeCallProblemDistortedSpeech
}

// The user couldn't hear the other side
type CallProblemSilentLocal struct {
	meta
}

func (entity *CallProblemSilentLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemSilentLocal

	return json.Marshal((*stub)(entity))
}

func (*CallProblemSilentLocal) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemSilentLocal) GetType() string {
	return TypeCallProblemSilentLocal
}

func (*CallProblemSilentLocal) CallProblemType() string {
	return TypeCallProblemSilentLocal
}

// The other side couldn't hear the user
type CallProblemSilentRemote struct {
	meta
}

func (entity *CallProblemSilentRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemSilentRemote

	return json.Marshal((*stub)(entity))
}

func (*CallProblemSilentRemote) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemSilentRemote) GetType() string {
	return TypeCallProblemSilentRemote
}

func (*CallProblemSilentRemote) CallProblemType() string {
	return TypeCallProblemSilentRemote
}

// The call ended unexpectedly
type CallProblemDropped struct {
	meta
}

func (entity *CallProblemDropped) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDropped

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDropped) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDropped) GetType() string {
	return TypeCallProblemDropped
}

func (*CallProblemDropped) CallProblemType() string {
	return TypeCallProblemDropped
}

// The video was distorted
type CallProblemDistortedVideo struct {
	meta
}

func (entity *CallProblemDistortedVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDistortedVideo

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDistortedVideo) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDistortedVideo) GetType() string {
	return TypeCallProblemDistortedVideo
}

func (*CallProblemDistortedVideo) CallProblemType() string {
	return TypeCallProblemDistortedVideo
}

// The video was pixelated
type CallProblemPixelatedVideo struct {
	meta
}

func (entity *CallProblemPixelatedVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemPixelatedVideo

	return json.Marshal((*stub)(entity))
}

func (*CallProblemPixelatedVideo) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemPixelatedVideo) GetType() string {
	return TypeCallProblemPixelatedVideo
}

func (*CallProblemPixelatedVideo) CallProblemType() string {
	return TypeCallProblemPixelatedVideo
}

// Describes a call
type Call struct {
	meta
	// Call identifier, not persistent
	Id int32 `json:"id"`
	// User identifier of the other call participant
	UserId int64 `json:"user_id"`
	// True, if the call is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the call is a video call
	IsVideo bool `json:"is_video"`
	// Call state
	State CallState `json:"state"`
}

func (entity *Call) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Call

	return json.Marshal((*stub)(entity))
}

func (*Call) GetClass() string {
	return ClassCall
}

func (*Call) GetType() string {
	return TypeCall
}

func (call *Call) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         int32           `json:"id"`
		UserId     int64           `json:"user_id"`
		IsOutgoing bool            `json:"is_outgoing"`
		IsVideo    bool            `json:"is_video"`
		State      json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	call.Id = tmp.Id
	call.UserId = tmp.UserId
	call.IsOutgoing = tmp.IsOutgoing
	call.IsVideo = tmp.IsVideo

	fieldState, _ := UnmarshalCallState(tmp.State)
	call.State = fieldState

	return nil
}

// Settings for Firebase Authentication in the official Android application
type FirebaseAuthenticationSettingsAndroid struct {
	meta
}

func (entity *FirebaseAuthenticationSettingsAndroid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FirebaseAuthenticationSettingsAndroid

	return json.Marshal((*stub)(entity))
}

func (*FirebaseAuthenticationSettingsAndroid) GetClass() string {
	return ClassFirebaseAuthenticationSettings
}

func (*FirebaseAuthenticationSettingsAndroid) GetType() string {
	return TypeFirebaseAuthenticationSettingsAndroid
}

func (*FirebaseAuthenticationSettingsAndroid) FirebaseAuthenticationSettingsType() string {
	return TypeFirebaseAuthenticationSettingsAndroid
}

// Settings for Firebase Authentication in the official iOS application
type FirebaseAuthenticationSettingsIos struct {
	meta
	// Device token from Apple Push Notification service
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
}

func (entity *FirebaseAuthenticationSettingsIos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FirebaseAuthenticationSettingsIos

	return json.Marshal((*stub)(entity))
}

func (*FirebaseAuthenticationSettingsIos) GetClass() string {
	return ClassFirebaseAuthenticationSettings
}

func (*FirebaseAuthenticationSettingsIos) GetType() string {
	return TypeFirebaseAuthenticationSettingsIos
}

func (*FirebaseAuthenticationSettingsIos) FirebaseAuthenticationSettingsType() string {
	return TypeFirebaseAuthenticationSettingsIos
}

// Contains settings for the authentication of the user's phone number
type PhoneNumberAuthenticationSettings struct {
	meta
	// Pass true if the authentication code may be sent via a flash call to the specified phone number
	AllowFlashCall bool `json:"allow_flash_call"`
	// Pass true if the authentication code may be sent via a missed call to the specified phone number
	AllowMissedCall bool `json:"allow_missed_call"`
	// Pass true if the authenticated phone number is used on the current device
	IsCurrentPhoneNumber bool `json:"is_current_phone_number"`
	// Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches
	HasUnknownPhoneNumber bool `json:"has_unknown_phone_number"`
	// For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
	AllowSmsRetrieverApi bool `json:"allow_sms_retriever_api"`
	// For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication
	FirebaseAuthenticationSettings FirebaseAuthenticationSettings `json:"firebase_authentication_settings"`
	// List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
	AuthenticationTokens []string `json:"authentication_tokens"`
}

func (entity *PhoneNumberAuthenticationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberAuthenticationSettings

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberAuthenticationSettings) GetClass() string {
	return ClassPhoneNumberAuthenticationSettings
}

func (*PhoneNumberAuthenticationSettings) GetType() string {
	return TypePhoneNumberAuthenticationSettings
}

func (phoneNumberAuthenticationSettings *PhoneNumberAuthenticationSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AllowFlashCall                 bool            `json:"allow_flash_call"`
		AllowMissedCall                bool            `json:"allow_missed_call"`
		IsCurrentPhoneNumber           bool            `json:"is_current_phone_number"`
		HasUnknownPhoneNumber          bool            `json:"has_unknown_phone_number"`
		AllowSmsRetrieverApi           bool            `json:"allow_sms_retriever_api"`
		FirebaseAuthenticationSettings json.RawMessage `json:"firebase_authentication_settings"`
		AuthenticationTokens           []string        `json:"authentication_tokens"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	phoneNumberAuthenticationSettings.AllowFlashCall = tmp.AllowFlashCall
	phoneNumberAuthenticationSettings.AllowMissedCall = tmp.AllowMissedCall
	phoneNumberAuthenticationSettings.IsCurrentPhoneNumber = tmp.IsCurrentPhoneNumber
	phoneNumberAuthenticationSettings.HasUnknownPhoneNumber = tmp.HasUnknownPhoneNumber
	phoneNumberAuthenticationSettings.AllowSmsRetrieverApi = tmp.AllowSmsRetrieverApi
	phoneNumberAuthenticationSettings.AuthenticationTokens = tmp.AuthenticationTokens

	fieldFirebaseAuthenticationSettings, _ := UnmarshalFirebaseAuthenticationSettings(tmp.FirebaseAuthenticationSettings)
	phoneNumberAuthenticationSettings.FirebaseAuthenticationSettings = fieldFirebaseAuthenticationSettings

	return nil
}

// Represents a reaction applied to a message
type AddedReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// Identifier of the chat member, applied the reaction
	SenderId MessageSender `json:"sender_id"`
	// True, if the reaction was added by the current user
	IsOutgoing bool `json:"is_outgoing"`
	// Point in time (Unix timestamp) when the reaction was added
	Date int32 `json:"date"`
}

func (entity *AddedReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AddedReaction

	return json.Marshal((*stub)(entity))
}

func (*AddedReaction) GetClass() string {
	return ClassAddedReaction
}

func (*AddedReaction) GetType() string {
	return TypeAddedReaction
}

func (addedReaction *AddedReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type       json.RawMessage `json:"type"`
		SenderId   json.RawMessage `json:"sender_id"`
		IsOutgoing bool            `json:"is_outgoing"`
		Date       int32           `json:"date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	addedReaction.IsOutgoing = tmp.IsOutgoing
	addedReaction.Date = tmp.Date

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	addedReaction.Type = fieldType

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	addedReaction.SenderId = fieldSenderId

	return nil
}

// Represents a list of reactions added to a message
type AddedReactions struct {
	meta
	// The total number of found reactions
	TotalCount int32 `json:"total_count"`
	// The list of added reactions
	Reactions []*AddedReaction `json:"reactions"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *AddedReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AddedReactions

	return json.Marshal((*stub)(entity))
}

func (*AddedReactions) GetClass() string {
	return ClassAddedReactions
}

func (*AddedReactions) GetType() string {
	return TypeAddedReactions
}

// Represents an available reaction
type AvailableReaction struct {
	meta
	// Type of the reaction
	Type ReactionType `json:"type"`
	// True, if Telegram Premium is needed to send the reaction
	NeedsPremium bool `json:"needs_premium"`
}

func (entity *AvailableReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AvailableReaction

	return json.Marshal((*stub)(entity))
}

func (*AvailableReaction) GetClass() string {
	return ClassAvailableReaction
}

func (*AvailableReaction) GetType() string {
	return TypeAvailableReaction
}

func (availableReaction *AvailableReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type         json.RawMessage `json:"type"`
		NeedsPremium bool            `json:"needs_premium"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	availableReaction.NeedsPremium = tmp.NeedsPremium

	fieldType, _ := UnmarshalReactionType(tmp.Type)
	availableReaction.Type = fieldType

	return nil
}

// Represents a list of reactions that can be added to a message
type AvailableReactions struct {
	meta
	// List of reactions to be shown at the top
	TopReactions []*AvailableReaction `json:"top_reactions"`
	// List of recently used reactions
	RecentReactions []*AvailableReaction `json:"recent_reactions"`
	// List of popular reactions
	PopularReactions []*AvailableReaction `json:"popular_reactions"`
	// True, if any custom emoji reaction can be added by Telegram Premium subscribers
	AllowCustomEmoji bool `json:"allow_custom_emoji"`
	// True, if the reactions will be tags and the message can be found by them
	AreTags bool `json:"are_tags"`
	// The reason why the current user can't add reactions to the message, despite some other users can; may be null if none
	UnavailabilityReason ReactionUnavailabilityReason `json:"unavailability_reason"`
}

func (entity *AvailableReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AvailableReactions

	return json.Marshal((*stub)(entity))
}

func (*AvailableReactions) GetClass() string {
	return ClassAvailableReactions
}

func (*AvailableReactions) GetType() string {
	return TypeAvailableReactions
}

func (availableReactions *AvailableReactions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TopReactions         []*AvailableReaction `json:"top_reactions"`
		RecentReactions      []*AvailableReaction `json:"recent_reactions"`
		PopularReactions     []*AvailableReaction `json:"popular_reactions"`
		AllowCustomEmoji     bool                 `json:"allow_custom_emoji"`
		AreTags              bool                 `json:"are_tags"`
		UnavailabilityReason json.RawMessage      `json:"unavailability_reason"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	availableReactions.TopReactions = tmp.TopReactions
	availableReactions.RecentReactions = tmp.RecentReactions
	availableReactions.PopularReactions = tmp.PopularReactions
	availableReactions.AllowCustomEmoji = tmp.AllowCustomEmoji
	availableReactions.AreTags = tmp.AreTags

	fieldUnavailabilityReason, _ := UnmarshalReactionUnavailabilityReason(tmp.UnavailabilityReason)
	availableReactions.UnavailabilityReason = fieldUnavailabilityReason

	return nil
}

// Contains information about an emoji reaction
type EmojiReaction struct {
	meta
	// Text representation of the reaction
	Emoji string `json:"emoji"`
	// Reaction title
	Title string `json:"title"`
	// True, if the reaction can be added to new messages and enabled in chats
	IsActive bool `json:"is_active"`
	// Static icon for the reaction
	StaticIcon *Sticker `json:"static_icon"`
	// Appear animation for the reaction
	AppearAnimation *Sticker `json:"appear_animation"`
	// Select animation for the reaction
	SelectAnimation *Sticker `json:"select_animation"`
	// Activate animation for the reaction
	ActivateAnimation *Sticker `json:"activate_animation"`
	// Effect animation for the reaction
	EffectAnimation *Sticker `json:"effect_animation"`
	// Around animation for the reaction; may be null
	AroundAnimation *Sticker `json:"around_animation"`
	// Center animation for the reaction; may be null
	CenterAnimation *Sticker `json:"center_animation"`
}

func (entity *EmojiReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmojiReaction

	return json.Marshal((*stub)(entity))
}

func (*EmojiReaction) GetClass() string {
	return ClassEmojiReaction
}

func (*EmojiReaction) GetType() string {
	return TypeEmojiReaction
}

// The user is an anonymous administrator in the supergroup, but isn't a creator of it, so they can't vote on behalf of the supergroup
type ReactionUnavailabilityReasonAnonymousAdministrator struct {
	meta
}

func (entity *ReactionUnavailabilityReasonAnonymousAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionUnavailabilityReasonAnonymousAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ReactionUnavailabilityReasonAnonymousAdministrator) GetClass() string {
	return ClassReactionUnavailabilityReason
}

func (*ReactionUnavailabilityReasonAnonymousAdministrator) GetType() string {
	return TypeReactionUnavailabilityReasonAnonymousAdministrator
}

func (*ReactionUnavailabilityReasonAnonymousAdministrator) ReactionUnavailabilityReasonType() string {
	return TypeReactionUnavailabilityReasonAnonymousAdministrator
}

// The user isn't a member of the supergroup and can't send messages and reactions there without joining
type ReactionUnavailabilityReasonGuest struct {
	meta
}

func (entity *ReactionUnavailabilityReasonGuest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReactionUnavailabilityReasonGuest

	return json.Marshal((*stub)(entity))
}

func (*ReactionUnavailabilityReasonGuest) GetClass() string {
	return ClassReactionUnavailabilityReason
}

func (*ReactionUnavailabilityReasonGuest) GetType() string {
	return TypeReactionUnavailabilityReasonGuest
}

func (*ReactionUnavailabilityReasonGuest) ReactionUnavailabilityReasonType() string {
	return TypeReactionUnavailabilityReasonGuest
}

// Represents a list of animations
type Animations struct {
	meta
	// List of animations
	Animations []*Animation `json:"animations"`
}

func (entity *Animations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Animations

	return json.Marshal((*stub)(entity))
}

func (*Animations) GetClass() string {
	return ClassAnimations
}

func (*Animations) GetType() string {
	return TypeAnimations
}

// A regular animated sticker
type DiceStickersRegular struct {
	meta
	// The animated sticker with the dice animation
	Sticker *Sticker `json:"sticker"`
}

func (entity *DiceStickersRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DiceStickersRegular

	return json.Marshal((*stub)(entity))
}

func (*DiceStickersRegular) GetClass() string {
	return ClassDiceStickers
}

func (*DiceStickersRegular) GetType() string {
	return TypeDiceStickersRegular
}

func (*DiceStickersRegular) DiceStickersType() string {
	return TypeDiceStickersRegular
}

// Animated stickers to be combined into a slot machine
type DiceStickersSlotMachine struct {
	meta
	// The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
	Background *Sticker `json:"background"`
	// The animated sticker with the lever animation. The lever animation must play once in the initial dice state
	Lever *Sticker `json:"lever"`
	// The animated sticker with the left reel
	LeftReel *Sticker `json:"left_reel"`
	// The animated sticker with the center reel
	CenterReel *Sticker `json:"center_reel"`
	// The animated sticker with the right reel
	RightReel *Sticker `json:"right_reel"`
}

func (entity *DiceStickersSlotMachine) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DiceStickersSlotMachine

	return json.Marshal((*stub)(entity))
}

func (*DiceStickersSlotMachine) GetClass() string {
	return ClassDiceStickers
}

func (*DiceStickersSlotMachine) GetType() string {
	return TypeDiceStickersSlotMachine
}

func (*DiceStickersSlotMachine) DiceStickersType() string {
	return TypeDiceStickersSlotMachine
}

// Represents the result of an importContacts request
type ImportedContacts struct {
	meta
	// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
	UserIds []int64 `json:"user_ids"`
	// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
	ImporterCount []int32 `json:"importer_count"`
}

func (entity *ImportedContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ImportedContacts

	return json.Marshal((*stub)(entity))
}

func (*ImportedContacts) GetClass() string {
	return ClassImportedContacts
}

func (*ImportedContacts) GetType() string {
	return TypeImportedContacts
}

// The speech recognition is ongoing
type SpeechRecognitionResultPending struct {
	meta
	// Partially recognized text
	PartialText string `json:"partial_text"`
}

func (entity *SpeechRecognitionResultPending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SpeechRecognitionResultPending

	return json.Marshal((*stub)(entity))
}

func (*SpeechRecognitionResultPending) GetClass() string {
	return ClassSpeechRecognitionResult
}

func (*SpeechRecognitionResultPending) GetType() string {
	return TypeSpeechRecognitionResultPending
}

func (*SpeechRecognitionResultPending) SpeechRecognitionResultType() string {
	return TypeSpeechRecognitionResultPending
}

// The speech recognition successfully finished
type SpeechRecognitionResultText struct {
	meta
	// Recognized text
	Text string `json:"text"`
}

func (entity *SpeechRecognitionResultText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SpeechRecognitionResultText

	return json.Marshal((*stub)(entity))
}

func (*SpeechRecognitionResultText) GetClass() string {
	return ClassSpeechRecognitionResult
}

func (*SpeechRecognitionResultText) GetType() string {
	return TypeSpeechRecognitionResultText
}

func (*SpeechRecognitionResultText) SpeechRecognitionResultType() string {
	return TypeSpeechRecognitionResultText
}

// The speech recognition failed
type SpeechRecognitionResultError struct {
	meta
	// Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
	Error *Error `json:"error"`
}

func (entity *SpeechRecognitionResultError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SpeechRecognitionResultError

	return json.Marshal((*stub)(entity))
}

func (*SpeechRecognitionResultError) GetClass() string {
	return ClassSpeechRecognitionResult
}

func (*SpeechRecognitionResultError) GetType() string {
	return TypeSpeechRecognitionResultError
}

func (*SpeechRecognitionResultError) SpeechRecognitionResultType() string {
	return TypeSpeechRecognitionResultError
}

// Describes a connection of the bot with a business account
type BusinessConnection struct {
	meta
	// Unique identifier of the connection
	Id string `json:"id"`
	// Identifier of the business user that created the connection
	UserId int64 `json:"user_id"`
	// Chat identifier of the private chat with the user
	UserChatId int64 `json:"user_chat_id"`
	// Point in time (Unix timestamp) when the connection was established
	Date int32 `json:"date"`
	// True, if the bot can send messages to the connected user; false otherwise
	CanReply bool `json:"can_reply"`
	// True, if the connection is enabled; false otherwise
	IsEnabled bool `json:"is_enabled"`
}

func (entity *BusinessConnection) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessConnection

	return json.Marshal((*stub)(entity))
}

func (*BusinessConnection) GetClass() string {
	return ClassBusinessConnection
}

func (*BusinessConnection) GetType() string {
	return TypeBusinessConnection
}

// Describes a color to highlight a bot added to attachment menu
type AttachmentMenuBotColor struct {
	meta
	// Color in the RGB format for light themes
	LightColor int32 `json:"light_color"`
	// Color in the RGB format for dark themes
	DarkColor int32 `json:"dark_color"`
}

func (entity *AttachmentMenuBotColor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AttachmentMenuBotColor

	return json.Marshal((*stub)(entity))
}

func (*AttachmentMenuBotColor) GetClass() string {
	return ClassAttachmentMenuBotColor
}

func (*AttachmentMenuBotColor) GetType() string {
	return TypeAttachmentMenuBotColor
}

// Represents a bot, which can be added to attachment or side menu
type AttachmentMenuBot struct {
	meta
	// User identifier of the bot
	BotUserId int64 `json:"bot_user_id"`
	// True, if the bot supports opening from attachment menu in the chat with the bot
	SupportsSelfChat bool `json:"supports_self_chat"`
	// True, if the bot supports opening from attachment menu in private chats with ordinary users
	SupportsUserChats bool `json:"supports_user_chats"`
	// True, if the bot supports opening from attachment menu in private chats with other bots
	SupportsBotChats bool `json:"supports_bot_chats"`
	// True, if the bot supports opening from attachment menu in basic group and supergroup chats
	SupportsGroupChats bool `json:"supports_group_chats"`
	// True, if the bot supports opening from attachment menu in channel chats
	SupportsChannelChats bool `json:"supports_channel_chats"`
	// True, if the user must be asked for the permission to send messages to the bot
	RequestWriteAccess bool `json:"request_write_access"`
	// True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
	IsAdded bool `json:"is_added"`
	// True, if the bot must be shown in the attachment menu
	ShowInAttachmentMenu bool `json:"show_in_attachment_menu"`
	// True, if the bot must be shown in the side menu
	ShowInSideMenu bool `json:"show_in_side_menu"`
	// True, if a disclaimer, why the bot is shown in the side menu, is needed
	ShowDisclaimerInSideMenu bool `json:"show_disclaimer_in_side_menu"`
	// Name for the bot in attachment menu
	Name string `json:"name"`
	// Color to highlight selected name of the bot if appropriate; may be null
	NameColor *AttachmentMenuBotColor `json:"name_color"`
	// Default icon for the bot in SVG format; may be null
	DefaultIcon *File `json:"default_icon"`
	// Icon for the bot in SVG format for the official iOS app; may be null
	IosStaticIcon *File `json:"ios_static_icon"`
	// Icon for the bot in TGS format for the official iOS app; may be null
	IosAnimatedIcon *File `json:"ios_animated_icon"`
	// Icon for the bot in PNG format for the official iOS app side menu; may be null
	IosSideMenuIcon *File `json:"ios_side_menu_icon"`
	// Icon for the bot in TGS format for the official Android app; may be null
	AndroidIcon *File `json:"android_icon"`
	// Icon for the bot in SVG format for the official Android app side menu; may be null
	AndroidSideMenuIcon *File `json:"android_side_menu_icon"`
	// Icon for the bot in TGS format for the official native macOS app; may be null
	MacosIcon *File `json:"macos_icon"`
	// Icon for the bot in PNG format for the official macOS app side menu; may be null
	MacosSideMenuIcon *File `json:"macos_side_menu_icon"`
	// Color to highlight selected icon of the bot if appropriate; may be null
	IconColor *AttachmentMenuBotColor `json:"icon_color"`
	// Default placeholder for opened Web Apps in SVG format; may be null
	WebAppPlaceholder *File `json:"web_app_placeholder"`
}

func (entity *AttachmentMenuBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AttachmentMenuBot

	return json.Marshal((*stub)(entity))
}

func (*AttachmentMenuBot) GetClass() string {
	return ClassAttachmentMenuBot
}

func (*AttachmentMenuBot) GetType() string {
	return TypeAttachmentMenuBot
}

// Information about the message sent by answerWebAppQuery
type SentWebAppMessage struct {
	meta
	// Identifier of the sent inline message, if known
	InlineMessageId string `json:"inline_message_id"`
}

func (entity *SentWebAppMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SentWebAppMessage

	return json.Marshal((*stub)(entity))
}

func (*SentWebAppMessage) GetClass() string {
	return ClassSentWebAppMessage
}

func (*SentWebAppMessage) GetType() string {
	return TypeSentWebAppMessage
}

// The user connected a website by logging in using Telegram Login Widget on it
type BotWriteAccessAllowReasonConnectedWebsite struct {
	meta
	// Domain name of the connected website
	DomainName string `json:"domain_name"`
}

func (entity *BotWriteAccessAllowReasonConnectedWebsite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotWriteAccessAllowReasonConnectedWebsite

	return json.Marshal((*stub)(entity))
}

func (*BotWriteAccessAllowReasonConnectedWebsite) GetClass() string {
	return ClassBotWriteAccessAllowReason
}

func (*BotWriteAccessAllowReasonConnectedWebsite) GetType() string {
	return TypeBotWriteAccessAllowReasonConnectedWebsite
}

func (*BotWriteAccessAllowReasonConnectedWebsite) BotWriteAccessAllowReasonType() string {
	return TypeBotWriteAccessAllowReasonConnectedWebsite
}

// The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu
type BotWriteAccessAllowReasonAddedToAttachmentMenu struct {
	meta
}

func (entity *BotWriteAccessAllowReasonAddedToAttachmentMenu) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotWriteAccessAllowReasonAddedToAttachmentMenu

	return json.Marshal((*stub)(entity))
}

func (*BotWriteAccessAllowReasonAddedToAttachmentMenu) GetClass() string {
	return ClassBotWriteAccessAllowReason
}

func (*BotWriteAccessAllowReasonAddedToAttachmentMenu) GetType() string {
	return TypeBotWriteAccessAllowReasonAddedToAttachmentMenu
}

func (*BotWriteAccessAllowReasonAddedToAttachmentMenu) BotWriteAccessAllowReasonType() string {
	return TypeBotWriteAccessAllowReasonAddedToAttachmentMenu
}

// The user launched a Web App using getWebAppLinkUrl
type BotWriteAccessAllowReasonLaunchedWebApp struct {
	meta
	// Information about the Web App
	WebApp *WebApp `json:"web_app"`
}

func (entity *BotWriteAccessAllowReasonLaunchedWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotWriteAccessAllowReasonLaunchedWebApp

	return json.Marshal((*stub)(entity))
}

func (*BotWriteAccessAllowReasonLaunchedWebApp) GetClass() string {
	return ClassBotWriteAccessAllowReason
}

func (*BotWriteAccessAllowReasonLaunchedWebApp) GetType() string {
	return TypeBotWriteAccessAllowReasonLaunchedWebApp
}

func (*BotWriteAccessAllowReasonLaunchedWebApp) BotWriteAccessAllowReasonType() string {
	return TypeBotWriteAccessAllowReasonLaunchedWebApp
}

// The user accepted bot's request to send messages with allowBotToSendMessages
type BotWriteAccessAllowReasonAcceptedRequest struct {
	meta
}

func (entity *BotWriteAccessAllowReasonAcceptedRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotWriteAccessAllowReasonAcceptedRequest

	return json.Marshal((*stub)(entity))
}

func (*BotWriteAccessAllowReasonAcceptedRequest) GetClass() string {
	return ClassBotWriteAccessAllowReason
}

func (*BotWriteAccessAllowReasonAcceptedRequest) GetType() string {
	return TypeBotWriteAccessAllowReasonAcceptedRequest
}

func (*BotWriteAccessAllowReasonAcceptedRequest) BotWriteAccessAllowReasonType() string {
	return TypeBotWriteAccessAllowReasonAcceptedRequest
}

// Contains an HTTP URL
type HttpUrl struct {
	meta
	// The URL
	Url string `json:"url"`
}

func (entity *HttpUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub HttpUrl

	return json.Marshal((*stub)(entity))
}

func (*HttpUrl) GetClass() string {
	return ClassHttpUrl
}

func (*HttpUrl) GetType() string {
	return TypeHttpUrl
}

// Contains an HTTPS URL, which can be used to get information about a user
type UserLink struct {
	meta
	// The URL
	Url string `json:"url"`
	// Left time for which the link is valid, in seconds; 0 if the link is a public username link
	ExpiresIn int32 `json:"expires_in"`
}

func (entity *UserLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserLink

	return json.Marshal((*stub)(entity))
}

func (*UserLink) GetClass() string {
	return ClassUserLink
}

func (*UserLink) GetType() string {
	return TypeUserLink
}

// Describes allowed types for the target chat
type TargetChatTypes struct {
	meta
	// True, if private chats with ordinary users are allowed
	AllowUserChats bool `json:"allow_user_chats"`
	// True, if private chats with other bots are allowed
	AllowBotChats bool `json:"allow_bot_chats"`
	// True, if basic group and supergroup chats are allowed
	AllowGroupChats bool `json:"allow_group_chats"`
	// True, if channel chats are allowed
	AllowChannelChats bool `json:"allow_channel_chats"`
}

func (entity *TargetChatTypes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatTypes

	return json.Marshal((*stub)(entity))
}

func (*TargetChatTypes) GetClass() string {
	return ClassTargetChatTypes
}

func (*TargetChatTypes) GetType() string {
	return TypeTargetChatTypes
}

// The currently opened chat needs to be kept
type TargetChatCurrent struct {
	meta
}

func (entity *TargetChatCurrent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatCurrent

	return json.Marshal((*stub)(entity))
}

func (*TargetChatCurrent) GetClass() string {
	return ClassTargetChat
}

func (*TargetChatCurrent) GetType() string {
	return TypeTargetChatCurrent
}

func (*TargetChatCurrent) TargetChatType() string {
	return TypeTargetChatCurrent
}

// The chat needs to be chosen by the user among chats of the specified types
type TargetChatChosen struct {
	meta
	// Allowed types for the chat
	Types *TargetChatTypes `json:"types"`
}

func (entity *TargetChatChosen) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatChosen

	return json.Marshal((*stub)(entity))
}

func (*TargetChatChosen) GetClass() string {
	return ClassTargetChat
}

func (*TargetChatChosen) GetType() string {
	return TypeTargetChatChosen
}

func (*TargetChatChosen) TargetChatType() string {
	return TypeTargetChatChosen
}

// The chat needs to be open with the provided internal link
type TargetChatInternalLink struct {
	meta
	// An internal link pointing to the chat
	Link InternalLinkType `json:"link"`
}

func (entity *TargetChatInternalLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TargetChatInternalLink

	return json.Marshal((*stub)(entity))
}

func (*TargetChatInternalLink) GetClass() string {
	return ClassTargetChat
}

func (*TargetChatInternalLink) GetType() string {
	return TypeTargetChatInternalLink
}

func (*TargetChatInternalLink) TargetChatType() string {
	return TypeTargetChatInternalLink
}

func (targetChatInternalLink *TargetChatInternalLink) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Link json.RawMessage `json:"link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldLink, _ := UnmarshalInternalLinkType(tmp.Link)
	targetChatInternalLink.Link = fieldLink

	return nil
}

// Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
type InputInlineQueryResultAnimation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the query result
	Title string `json:"title"`
	// URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
	ThumbnailMimeType string `json:"thumbnail_mime_type"`
	// The URL of the video file (file size must not exceed 1MB)
	VideoUrl string `json:"video_url"`
	// MIME type of the video file. Must be one of "image/gif" and "video/mp4"
	VideoMimeType string `json:"video_mime_type"`
	// Duration of the video, in seconds
	VideoDuration int32 `json:"video_duration"`
	// Width of the video
	VideoWidth int32 `json:"video_width"`
	// Height of the video
	VideoHeight int32 `json:"video_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAnimation) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAnimation) GetType() string {
	return TypeInputInlineQueryResultAnimation
}

func (*InputInlineQueryResultAnimation) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAnimation
}

func (inputInlineQueryResultAnimation *InputInlineQueryResultAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailMimeType   string          `json:"thumbnail_mime_type"`
		VideoUrl            string          `json:"video_url"`
		VideoMimeType       string          `json:"video_mime_type"`
		VideoDuration       int32           `json:"video_duration"`
		VideoWidth          int32           `json:"video_width"`
		VideoHeight         int32           `json:"video_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAnimation.Id = tmp.Id
	inputInlineQueryResultAnimation.Title = tmp.Title
	inputInlineQueryResultAnimation.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultAnimation.ThumbnailMimeType = tmp.ThumbnailMimeType
	inputInlineQueryResultAnimation.VideoUrl = tmp.VideoUrl
	inputInlineQueryResultAnimation.VideoMimeType = tmp.VideoMimeType
	inputInlineQueryResultAnimation.VideoDuration = tmp.VideoDuration
	inputInlineQueryResultAnimation.VideoWidth = tmp.VideoWidth
	inputInlineQueryResultAnimation.VideoHeight = tmp.VideoHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAnimation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAnimation.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an article or web page
type InputInlineQueryResultArticle struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the result, if it exists
	Url string `json:"url"`
	// True, if the URL must be not shown
	HideUrl bool `json:"hide_url"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result
	Description string `json:"description"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultArticle

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultArticle) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultArticle) GetType() string {
	return TypeInputInlineQueryResultArticle
}

func (*InputInlineQueryResultArticle) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultArticle
}

func (inputInlineQueryResultArticle *InputInlineQueryResultArticle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Url                 string          `json:"url"`
		HideUrl             bool            `json:"hide_url"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultArticle.Id = tmp.Id
	inputInlineQueryResultArticle.Url = tmp.Url
	inputInlineQueryResultArticle.HideUrl = tmp.HideUrl
	inputInlineQueryResultArticle.Title = tmp.Title
	inputInlineQueryResultArticle.Description = tmp.Description
	inputInlineQueryResultArticle.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultArticle.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultArticle.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultArticle.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultArticle.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an MP3 audio file
type InputInlineQueryResultAudio struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the audio file
	Title string `json:"title"`
	// Performer of the audio file
	Performer string `json:"performer"`
	// The URL of the audio file
	AudioUrl string `json:"audio_url"`
	// Audio file duration, in seconds
	AudioDuration int32 `json:"audio_duration"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAudio

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAudio) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAudio) GetType() string {
	return TypeInputInlineQueryResultAudio
}

func (*InputInlineQueryResultAudio) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAudio
}

func (inputInlineQueryResultAudio *InputInlineQueryResultAudio) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Performer           string          `json:"performer"`
		AudioUrl            string          `json:"audio_url"`
		AudioDuration       int32           `json:"audio_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAudio.Id = tmp.Id
	inputInlineQueryResultAudio.Title = tmp.Title
	inputInlineQueryResultAudio.Performer = tmp.Performer
	inputInlineQueryResultAudio.AudioUrl = tmp.AudioUrl
	inputInlineQueryResultAudio.AudioDuration = tmp.AudioDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAudio.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAudio.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a user contact
type InputInlineQueryResultContact struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// User contact
	Contact *Contact `json:"contact"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultContact

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultContact) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultContact) GetType() string {
	return TypeInputInlineQueryResultContact
}

func (*InputInlineQueryResultContact) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultContact
}

func (inputInlineQueryResultContact *InputInlineQueryResultContact) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Contact             *Contact        `json:"contact"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultContact.Id = tmp.Id
	inputInlineQueryResultContact.Contact = tmp.Contact
	inputInlineQueryResultContact.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultContact.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultContact.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultContact.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultContact.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a file
type InputInlineQueryResultDocument struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the resulting file
	Title string `json:"title"`
	// Short description of the result, if known
	Description string `json:"description"`
	// URL of the file
	DocumentUrl string `json:"document_url"`
	// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
	MimeType string `json:"mime_type"`
	// The URL of the file thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Width of the thumbnail
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Height of the thumbnail
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultDocument

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultDocument) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultDocument) GetType() string {
	return TypeInputInlineQueryResultDocument
}

func (*InputInlineQueryResultDocument) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultDocument
}

func (inputInlineQueryResultDocument *InputInlineQueryResultDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		DocumentUrl         string          `json:"document_url"`
		MimeType            string          `json:"mime_type"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultDocument.Id = tmp.Id
	inputInlineQueryResultDocument.Title = tmp.Title
	inputInlineQueryResultDocument.Description = tmp.Description
	inputInlineQueryResultDocument.DocumentUrl = tmp.DocumentUrl
	inputInlineQueryResultDocument.MimeType = tmp.MimeType
	inputInlineQueryResultDocument.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultDocument.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultDocument.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultDocument.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultDocument.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a game
type InputInlineQueryResultGame struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *InputInlineQueryResultGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultGame

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultGame) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultGame) GetType() string {
	return TypeInputInlineQueryResultGame
}

func (*InputInlineQueryResultGame) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultGame
}

func (inputInlineQueryResultGame *InputInlineQueryResultGame) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id            string          `json:"id"`
		GameShortName string          `json:"game_short_name"`
		ReplyMarkup   json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultGame.Id = tmp.Id
	inputInlineQueryResultGame.GameShortName = tmp.GameShortName

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultGame.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Represents a point on the map
type InputInlineQueryResultLocation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Location result
	Location *Location `json:"location"`
	// Amount of time relative to the message sent time until the location can be updated, in seconds
	LivePeriod int32 `json:"live_period"`
	// Title of the result
	Title string `json:"title"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultLocation

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultLocation) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultLocation) GetType() string {
	return TypeInputInlineQueryResultLocation
}

func (*InputInlineQueryResultLocation) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultLocation
}

func (inputInlineQueryResultLocation *InputInlineQueryResultLocation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Location            *Location       `json:"location"`
		LivePeriod          int32           `json:"live_period"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultLocation.Id = tmp.Id
	inputInlineQueryResultLocation.Location = tmp.Location
	inputInlineQueryResultLocation.LivePeriod = tmp.LivePeriod
	inputInlineQueryResultLocation.Title = tmp.Title
	inputInlineQueryResultLocation.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultLocation.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultLocation.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultLocation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultLocation.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents link to a JPEG image
type InputInlineQueryResultPhoto struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result, if known
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
	// URL of the photo thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the JPEG photo (photo size must not exceed 5MB)
	PhotoUrl string `json:"photo_url"`
	// Width of the photo
	PhotoWidth int32 `json:"photo_width"`
	// Height of the photo
	PhotoHeight int32 `json:"photo_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultPhoto

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultPhoto) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultPhoto) GetType() string {
	return TypeInputInlineQueryResultPhoto
}

func (*InputInlineQueryResultPhoto) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultPhoto
}

func (inputInlineQueryResultPhoto *InputInlineQueryResultPhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		PhotoUrl            string          `json:"photo_url"`
		PhotoWidth          int32           `json:"photo_width"`
		PhotoHeight         int32           `json:"photo_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultPhoto.Id = tmp.Id
	inputInlineQueryResultPhoto.Title = tmp.Title
	inputInlineQueryResultPhoto.Description = tmp.Description
	inputInlineQueryResultPhoto.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultPhoto.PhotoUrl = tmp.PhotoUrl
	inputInlineQueryResultPhoto.PhotoWidth = tmp.PhotoWidth
	inputInlineQueryResultPhoto.PhotoHeight = tmp.PhotoHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultPhoto.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultPhoto.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a WEBP, TGS, or WEBM sticker
type InputInlineQueryResultSticker struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the sticker thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
	StickerUrl string `json:"sticker_url"`
	// Width of the sticker
	StickerWidth int32 `json:"sticker_width"`
	// Height of the sticker
	StickerHeight int32 `json:"sticker_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultSticker

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultSticker) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultSticker) GetType() string {
	return TypeInputInlineQueryResultSticker
}

func (*InputInlineQueryResultSticker) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultSticker
}

func (inputInlineQueryResultSticker *InputInlineQueryResultSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		StickerUrl          string          `json:"sticker_url"`
		StickerWidth        int32           `json:"sticker_width"`
		StickerHeight       int32           `json:"sticker_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultSticker.Id = tmp.Id
	inputInlineQueryResultSticker.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultSticker.StickerUrl = tmp.StickerUrl
	inputInlineQueryResultSticker.StickerWidth = tmp.StickerWidth
	inputInlineQueryResultSticker.StickerHeight = tmp.StickerHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultSticker.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultSticker.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents information about a venue
type InputInlineQueryResultVenue struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Venue result
	Venue *Venue `json:"venue"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVenue

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVenue) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVenue) GetType() string {
	return TypeInputInlineQueryResultVenue
}

func (*InputInlineQueryResultVenue) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVenue
}

func (inputInlineQueryResultVenue *InputInlineQueryResultVenue) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Venue               *Venue          `json:"venue"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVenue.Id = tmp.Id
	inputInlineQueryResultVenue.Venue = tmp.Venue
	inputInlineQueryResultVenue.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultVenue.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultVenue.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVenue.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVenue.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a page containing an embedded video player or a video file
type InputInlineQueryResultVideo struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
	// The URL of the video thumbnail (JPEG), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// URL of the embedded video player or video file
	VideoUrl string `json:"video_url"`
	// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
	MimeType string `json:"mime_type"`
	// Width of the video
	VideoWidth int32 `json:"video_width"`
	// Height of the video
	VideoHeight int32 `json:"video_height"`
	// Video duration, in seconds
	VideoDuration int32 `json:"video_duration"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVideo

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVideo) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVideo) GetType() string {
	return TypeInputInlineQueryResultVideo
}

func (*InputInlineQueryResultVideo) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVideo
}

func (inputInlineQueryResultVideo *InputInlineQueryResultVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		VideoUrl            string          `json:"video_url"`
		MimeType            string          `json:"mime_type"`
		VideoWidth          int32           `json:"video_width"`
		VideoHeight         int32           `json:"video_height"`
		VideoDuration       int32           `json:"video_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVideo.Id = tmp.Id
	inputInlineQueryResultVideo.Title = tmp.Title
	inputInlineQueryResultVideo.Description = tmp.Description
	inputInlineQueryResultVideo.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultVideo.VideoUrl = tmp.VideoUrl
	inputInlineQueryResultVideo.MimeType = tmp.MimeType
	inputInlineQueryResultVideo.VideoWidth = tmp.VideoWidth
	inputInlineQueryResultVideo.VideoHeight = tmp.VideoHeight
	inputInlineQueryResultVideo.VideoDuration = tmp.VideoDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVideo.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVideo.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
type InputInlineQueryResultVoiceNote struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the voice note
	Title string `json:"title"`
	// The URL of the voice note file
	VoiceNoteUrl string `json:"voice_note_url"`
	// Duration of the voice note, in seconds
	VoiceNoteDuration int32 `json:"voice_note_duration"`
	// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVoiceNote) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVoiceNote) GetType() string {
	return TypeInputInlineQueryResultVoiceNote
}

func (*InputInlineQueryResultVoiceNote) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVoiceNote
}

func (inputInlineQueryResultVoiceNote *InputInlineQueryResultVoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		VoiceNoteUrl        string          `json:"voice_note_url"`
		VoiceNoteDuration   int32           `json:"voice_note_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVoiceNote.Id = tmp.Id
	inputInlineQueryResultVoiceNote.Title = tmp.Title
	inputInlineQueryResultVoiceNote.VoiceNoteUrl = tmp.VoiceNoteUrl
	inputInlineQueryResultVoiceNote.VoiceNoteDuration = tmp.VoiceNoteDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVoiceNote.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVoiceNote.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an article or web page
type InlineQueryResultArticle struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the result, if it exists
	Url string `json:"url"`
	// True, if the URL must be not shown
	HideUrl bool `json:"hide_url"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result
	Description string `json:"description"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultArticle

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultArticle) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultArticle) GetType() string {
	return TypeInlineQueryResultArticle
}

func (*InlineQueryResultArticle) InlineQueryResultType() string {
	return TypeInlineQueryResultArticle
}

// Represents a user contact
type InlineQueryResultContact struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// A user contact
	Contact *Contact `json:"contact"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultContact

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultContact) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultContact) GetType() string {
	return TypeInlineQueryResultContact
}

func (*InlineQueryResultContact) InlineQueryResultType() string {
	return TypeInlineQueryResultContact
}

// Represents a point on the map
type InlineQueryResultLocation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Location result
	Location *Location `json:"location"`
	// Title of the result
	Title string `json:"title"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultLocation

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultLocation) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultLocation) GetType() string {
	return TypeInlineQueryResultLocation
}

func (*InlineQueryResultLocation) InlineQueryResultType() string {
	return TypeInlineQueryResultLocation
}

// Represents information about a venue
type InlineQueryResultVenue struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Venue result
	Venue *Venue `json:"venue"`
	// Result thumbnail in JPEG format; may be null
	Thumbnail *Thumbnail `json:"thumbnail"`
}

func (entity *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVenue

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVenue) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVenue) GetType() string {
	return TypeInlineQueryResultVenue
}

func (*InlineQueryResultVenue) InlineQueryResultType() string {
	return TypeInlineQueryResultVenue
}

// Represents information about a game
type InlineQueryResultGame struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Game result
	Game *Game `json:"game"`
}

func (entity *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultGame

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultGame) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultGame) GetType() string {
	return TypeInlineQueryResultGame
}

func (*InlineQueryResultGame) InlineQueryResultType() string {
	return TypeInlineQueryResultGame
}

// Represents an animation file
type InlineQueryResultAnimation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Animation file
	Animation *Animation `json:"animation"`
	// Animation title
	Title string `json:"title"`
}

func (entity *InlineQueryResultAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultAnimation

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultAnimation) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultAnimation) GetType() string {
	return TypeInlineQueryResultAnimation
}

func (*InlineQueryResultAnimation) InlineQueryResultType() string {
	return TypeInlineQueryResultAnimation
}

// Represents an audio file
type InlineQueryResultAudio struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Audio file
	Audio *Audio `json:"audio"`
}

func (entity *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultAudio

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultAudio) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultAudio) GetType() string {
	return TypeInlineQueryResultAudio
}

func (*InlineQueryResultAudio) InlineQueryResultType() string {
	return TypeInlineQueryResultAudio
}

// Represents a document
type InlineQueryResultDocument struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Document
	Document *Document `json:"document"`
	// Document title
	Title string `json:"title"`
	// Document description
	Description string `json:"description"`
}

func (entity *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultDocument

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultDocument) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultDocument) GetType() string {
	return TypeInlineQueryResultDocument
}

func (*InlineQueryResultDocument) InlineQueryResultType() string {
	return TypeInlineQueryResultDocument
}

// Represents a photo
type InlineQueryResultPhoto struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Photo
	Photo *Photo `json:"photo"`
	// Title of the result, if known
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
}

func (entity *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultPhoto

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultPhoto) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultPhoto) GetType() string {
	return TypeInlineQueryResultPhoto
}

func (*InlineQueryResultPhoto) InlineQueryResultType() string {
	return TypeInlineQueryResultPhoto
}

// Represents a sticker
type InlineQueryResultSticker struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Sticker
	Sticker *Sticker `json:"sticker"`
}

func (entity *InlineQueryResultSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultSticker

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultSticker) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultSticker) GetType() string {
	return TypeInlineQueryResultSticker
}

func (*InlineQueryResultSticker) InlineQueryResultType() string {
	return TypeInlineQueryResultSticker
}

// Represents a video
type InlineQueryResultVideo struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Video
	Video *Video `json:"video"`
	// Title of the video
	Title string `json:"title"`
	// Description of the video
	Description string `json:"description"`
}

func (entity *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVideo

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVideo) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVideo) GetType() string {
	return TypeInlineQueryResultVideo
}

func (*InlineQueryResultVideo) InlineQueryResultType() string {
	return TypeInlineQueryResultVideo
}

// Represents a voice note
type InlineQueryResultVoiceNote struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Voice note
	VoiceNote *VoiceNote `json:"voice_note"`
	// Title of the voice note
	Title string `json:"title"`
}

func (entity *InlineQueryResultVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVoiceNote) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVoiceNote) GetType() string {
	return TypeInlineQueryResultVoiceNote
}

func (*InlineQueryResultVoiceNote) InlineQueryResultType() string {
	return TypeInlineQueryResultVoiceNote
}

// Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter
type InlineQueryResultsButtonTypeStartBot struct {
	meta
	// The parameter for the bot start message
	Parameter string `json:"parameter"`
}

func (entity *InlineQueryResultsButtonTypeStartBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultsButtonTypeStartBot

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultsButtonTypeStartBot) GetClass() string {
	return ClassInlineQueryResultsButtonType
}

func (*InlineQueryResultsButtonTypeStartBot) GetType() string {
	return TypeInlineQueryResultsButtonTypeStartBot
}

func (*InlineQueryResultsButtonTypeStartBot) InlineQueryResultsButtonTypeType() string {
	return TypeInlineQueryResultsButtonTypeStartBot
}

// Describes the button that opens a Web App by calling getWebAppUrl
type InlineQueryResultsButtonTypeWebApp struct {
	meta
	// An HTTP URL to pass to getWebAppUrl
	Url string `json:"url"`
}

func (entity *InlineQueryResultsButtonTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultsButtonTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultsButtonTypeWebApp) GetClass() string {
	return ClassInlineQueryResultsButtonType
}

func (*InlineQueryResultsButtonTypeWebApp) GetType() string {
	return TypeInlineQueryResultsButtonTypeWebApp
}

func (*InlineQueryResultsButtonTypeWebApp) InlineQueryResultsButtonTypeType() string {
	return TypeInlineQueryResultsButtonTypeWebApp
}

// Represents a button to be shown above inline query results
type InlineQueryResultsButton struct {
	meta
	// The text of the button
	Text string `json:"text"`
	// Type of the button
	Type InlineQueryResultsButtonType `json:"type"`
}

func (entity *InlineQueryResultsButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultsButton

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultsButton) GetClass() string {
	return ClassInlineQueryResultsButton
}

func (*InlineQueryResultsButton) GetType() string {
	return TypeInlineQueryResultsButton
}

func (inlineQueryResultsButton *InlineQueryResultsButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineQueryResultsButton.Text = tmp.Text

	fieldType, _ := UnmarshalInlineQueryResultsButtonType(tmp.Type)
	inlineQueryResultsButton.Type = fieldType

	return nil
}

// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
type InlineQueryResults struct {
	meta
	// Unique identifier of the inline query
	InlineQueryId JsonInt64 `json:"inline_query_id"`
	// Button to be shown above inline query results; may be null
	Button *InlineQueryResultsButton `json:"button"`
	// Results of the query
	Results []InlineQueryResult `json:"results"`
	// The offset for the next request. If empty, then there are no more results
	NextOffset string `json:"next_offset"`
}

func (entity *InlineQueryResults) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResults

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResults) GetClass() string {
	return ClassInlineQueryResults
}

func (*InlineQueryResults) GetType() string {
	return TypeInlineQueryResults
}

func (inlineQueryResults *InlineQueryResults) UnmarshalJSON(data []byte) error {
	var tmp struct {
		InlineQueryId JsonInt64                 `json:"inline_query_id"`
		Button        *InlineQueryResultsButton `json:"button"`
		Results       []json.RawMessage         `json:"results"`
		NextOffset    string                    `json:"next_offset"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineQueryResults.InlineQueryId = tmp.InlineQueryId
	inlineQueryResults.Button = tmp.Button
	inlineQueryResults.NextOffset = tmp.NextOffset

	fieldResults, _ := UnmarshalListOfInlineQueryResult(tmp.Results)
	inlineQueryResults.Results = fieldResults

	return nil
}

// Represents an inline message that can be sent via the bot
type PreparedInlineMessageId struct {
	meta
	// Unique identifier for the message
	Id string `json:"id"`
	// Point in time (Unix timestamp) when the message can't be used anymore
	ExpirationDate int32 `json:"expiration_date"`
}

func (entity *PreparedInlineMessageId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PreparedInlineMessageId

	return json.Marshal((*stub)(entity))
}

func (*PreparedInlineMessageId) GetClass() string {
	return ClassPreparedInlineMessageId
}

func (*PreparedInlineMessageId) GetType() string {
	return TypePreparedInlineMessageId
}

// Represents a ready to send inline message. Use sendInlineQueryResultMessage to send the message
type PreparedInlineMessage struct {
	meta
	// Unique identifier of the inline query to pass to sendInlineQueryResultMessage
	InlineQueryId JsonInt64 `json:"inline_query_id"`
	// Resulted inline message of the query
	Result InlineQueryResult `json:"result"`
	// Types of the chats to which the message can be sent
	ChatTypes *TargetChatTypes `json:"chat_types"`
}

func (entity *PreparedInlineMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PreparedInlineMessage

	return json.Marshal((*stub)(entity))
}

func (*PreparedInlineMessage) GetClass() string {
	return ClassPreparedInlineMessage
}

func (*PreparedInlineMessage) GetType() string {
	return TypePreparedInlineMessage
}

func (preparedInlineMessage *PreparedInlineMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		InlineQueryId JsonInt64        `json:"inline_query_id"`
		Result        json.RawMessage  `json:"result"`
		ChatTypes     *TargetChatTypes `json:"chat_types"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	preparedInlineMessage.InlineQueryId = tmp.InlineQueryId
	preparedInlineMessage.ChatTypes = tmp.ChatTypes

	fieldResult, _ := UnmarshalInlineQueryResult(tmp.Result)
	preparedInlineMessage.Result = fieldResult

	return nil
}

// The payload for a general callback button
type CallbackQueryPayloadData struct {
	meta
	// Data that was attached to the callback button
	Data []byte `json:"data"`
}

func (entity *CallbackQueryPayloadData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadData

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadData) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadData) GetType() string {
	return TypeCallbackQueryPayloadData
}

func (*CallbackQueryPayloadData) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadData
}

// The payload for a callback button requiring password
type CallbackQueryPayloadDataWithPassword struct {
	meta
	// The 2-step verification password for the current user
	Password string `json:"password"`
	// Data that was attached to the callback button
	Data []byte `json:"data"`
}

func (entity *CallbackQueryPayloadDataWithPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadDataWithPassword

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadDataWithPassword) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadDataWithPassword) GetType() string {
	return TypeCallbackQueryPayloadDataWithPassword
}

func (*CallbackQueryPayloadDataWithPassword) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadDataWithPassword
}

// The payload for a game callback button
type CallbackQueryPayloadGame struct {
	meta
	// A short name of the game that was attached to the callback button
	GameShortName string `json:"game_short_name"`
}

func (entity *CallbackQueryPayloadGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadGame

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadGame) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadGame) GetType() string {
	return TypeCallbackQueryPayloadGame
}

func (*CallbackQueryPayloadGame) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadGame
}

// Contains a bot's answer to a callback query
type CallbackQueryAnswer struct {
	meta
	// Text of the answer
	Text string `json:"text"`
	// True, if an alert must be shown to the user instead of a toast notification
	ShowAlert bool `json:"show_alert"`
	// URL to be opened
	Url string `json:"url"`
}

func (entity *CallbackQueryAnswer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryAnswer

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryAnswer) GetClass() string {
	return ClassCallbackQueryAnswer
}

func (*CallbackQueryAnswer) GetType() string {
	return TypeCallbackQueryAnswer
}

// Contains the result of a custom request
type CustomRequestResult struct {
	meta
	// A JSON-serialized result
	Result string `json:"result"`
}

func (entity *CustomRequestResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CustomRequestResult

	return json.Marshal((*stub)(entity))
}

func (*CustomRequestResult) GetClass() string {
	return ClassCustomRequestResult
}

func (*CustomRequestResult) GetType() string {
	return TypeCustomRequestResult
}

// Contains one row of the game high score table
type GameHighScore struct {
	meta
	// Position in the high score table
	Position int32 `json:"position"`
	// User identifier
	UserId int64 `json:"user_id"`
	// User score
	Score int32 `json:"score"`
}

func (entity *GameHighScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GameHighScore

	return json.Marshal((*stub)(entity))
}

func (*GameHighScore) GetClass() string {
	return ClassGameHighScore
}

func (*GameHighScore) GetType() string {
	return TypeGameHighScore
}

// Contains a list of game high scores
type GameHighScores struct {
	meta
	// A list of game high scores
	Scores []*GameHighScore `json:"scores"`
}

func (entity *GameHighScores) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GameHighScores

	return json.Marshal((*stub)(entity))
}

func (*GameHighScores) GetClass() string {
	return ClassGameHighScores
}

func (*GameHighScores) GetType() string {
	return TypeGameHighScores
}

// A message was edited
type ChatEventMessageEdited struct {
	meta
	// The original message before the edit
	OldMessage *Message `json:"old_message"`
	// The message after it was edited
	NewMessage *Message `json:"new_message"`
}

func (entity *ChatEventMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageEdited) GetType() string {
	return TypeChatEventMessageEdited
}

func (*ChatEventMessageEdited) ChatEventActionType() string {
	return TypeChatEventMessageEdited
}

// A message was deleted
type ChatEventMessageDeleted struct {
	meta
	// Deleted message
	Message *Message `json:"message"`
	// True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
	CanReportAntiSpamFalsePositive bool `json:"can_report_anti_spam_false_positive"`
}

func (entity *ChatEventMessageDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageDeleted) GetType() string {
	return TypeChatEventMessageDeleted
}

func (*ChatEventMessageDeleted) ChatEventActionType() string {
	return TypeChatEventMessageDeleted
}

// A message was pinned
type ChatEventMessagePinned struct {
	meta
	// Pinned message
	Message *Message `json:"message"`
}

func (entity *ChatEventMessagePinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessagePinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessagePinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessagePinned) GetType() string {
	return TypeChatEventMessagePinned
}

func (*ChatEventMessagePinned) ChatEventActionType() string {
	return TypeChatEventMessagePinned
}

// A message was unpinned
type ChatEventMessageUnpinned struct {
	meta
	// Unpinned message
	Message *Message `json:"message"`
}

func (entity *ChatEventMessageUnpinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageUnpinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageUnpinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageUnpinned) GetType() string {
	return TypeChatEventMessageUnpinned
}

func (*ChatEventMessageUnpinned) ChatEventActionType() string {
	return TypeChatEventMessageUnpinned
}

// A poll in a message was stopped
type ChatEventPollStopped struct {
	meta
	// The message with the poll
	Message *Message `json:"message"`
}

func (entity *ChatEventPollStopped) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPollStopped

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPollStopped) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPollStopped) GetType() string {
	return TypeChatEventPollStopped
}

func (*ChatEventPollStopped) ChatEventActionType() string {
	return TypeChatEventPollStopped
}

// A new member joined the chat
type ChatEventMemberJoined struct {
	meta
}

func (entity *ChatEventMemberJoined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoined

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoined) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoined) GetType() string {
	return TypeChatEventMemberJoined
}

func (*ChatEventMemberJoined) ChatEventActionType() string {
	return TypeChatEventMemberJoined
}

// A new member joined the chat via an invite link
type ChatEventMemberJoinedByInviteLink struct {
	meta
	// Invite link used to join the chat
	InviteLink *ChatInviteLink `json:"invite_link"`
	// True, if the user has joined the chat using an invite link for a chat folder
	ViaChatFolderInviteLink bool `json:"via_chat_folder_invite_link"`
}

func (entity *ChatEventMemberJoinedByInviteLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoinedByInviteLink

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoinedByInviteLink) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoinedByInviteLink) GetType() string {
	return TypeChatEventMemberJoinedByInviteLink
}

func (*ChatEventMemberJoinedByInviteLink) ChatEventActionType() string {
	return TypeChatEventMemberJoinedByInviteLink
}

// A new member was accepted to the chat by an administrator
type ChatEventMemberJoinedByRequest struct {
	meta
	// User identifier of the chat administrator, approved user join request
	ApproverUserId int64 `json:"approver_user_id"`
	// Invite link used to join the chat; may be null
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventMemberJoinedByRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoinedByRequest

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoinedByRequest) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoinedByRequest) GetType() string {
	return TypeChatEventMemberJoinedByRequest
}

func (*ChatEventMemberJoinedByRequest) ChatEventActionType() string {
	return TypeChatEventMemberJoinedByRequest
}

// A new chat member was invited
type ChatEventMemberInvited struct {
	meta
	// New member user identifier
	UserId int64 `json:"user_id"`
	// New member status
	Status ChatMemberStatus `json:"status"`
}

func (entity *ChatEventMemberInvited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberInvited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberInvited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberInvited) GetType() string {
	return TypeChatEventMemberInvited
}

func (*ChatEventMemberInvited) ChatEventActionType() string {
	return TypeChatEventMemberInvited
}

func (chatEventMemberInvited *ChatEventMemberInvited) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int64           `json:"user_id"`
		Status json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberInvited.UserId = tmp.UserId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	chatEventMemberInvited.Status = fieldStatus

	return nil
}

// A member left the chat
type ChatEventMemberLeft struct {
	meta
}

func (entity *ChatEventMemberLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberLeft

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberLeft) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberLeft) GetType() string {
	return TypeChatEventMemberLeft
}

func (*ChatEventMemberLeft) ChatEventActionType() string {
	return TypeChatEventMemberLeft
}

// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
type ChatEventMemberPromoted struct {
	meta
	// Affected chat member user identifier
	UserId int64 `json:"user_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberPromoted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberPromoted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberPromoted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberPromoted) GetType() string {
	return TypeChatEventMemberPromoted
}

func (*ChatEventMemberPromoted) ChatEventActionType() string {
	return TypeChatEventMemberPromoted
}

func (chatEventMemberPromoted *ChatEventMemberPromoted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId    int64           `json:"user_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberPromoted.UserId = tmp.UserId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberPromoted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberPromoted.NewStatus = fieldNewStatus

	return nil
}

// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
type ChatEventMemberRestricted struct {
	meta
	// Affected chat member identifier
	MemberId MessageSender `json:"member_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberRestricted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberRestricted) GetType() string {
	return TypeChatEventMemberRestricted
}

func (*ChatEventMemberRestricted) ChatEventActionType() string {
	return TypeChatEventMemberRestricted
}

func (chatEventMemberRestricted *ChatEventMemberRestricted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MemberId  json.RawMessage `json:"member_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldMemberId, _ := UnmarshalMessageSender(tmp.MemberId)
	chatEventMemberRestricted.MemberId = fieldMemberId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberRestricted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberRestricted.NewStatus = fieldNewStatus

	return nil
}

// A chat member extended their subscription to the chat
type ChatEventMemberSubscriptionExtended struct {
	meta
	// Affected chat member user identifier
	UserId int64 `json:"user_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberSubscriptionExtended) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberSubscriptionExtended

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberSubscriptionExtended) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberSubscriptionExtended) GetType() string {
	return TypeChatEventMemberSubscriptionExtended
}

func (*ChatEventMemberSubscriptionExtended) ChatEventActionType() string {
	return TypeChatEventMemberSubscriptionExtended
}

func (chatEventMemberSubscriptionExtended *ChatEventMemberSubscriptionExtended) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId    int64           `json:"user_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberSubscriptionExtended.UserId = tmp.UserId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberSubscriptionExtended.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberSubscriptionExtended.NewStatus = fieldNewStatus

	return nil
}

// The chat available reactions were changed
type ChatEventAvailableReactionsChanged struct {
	meta
	// Previous chat available reactions
	OldAvailableReactions ChatAvailableReactions `json:"old_available_reactions"`
	// New chat available reactions
	NewAvailableReactions ChatAvailableReactions `json:"new_available_reactions"`
}

func (entity *ChatEventAvailableReactionsChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventAvailableReactionsChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventAvailableReactionsChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventAvailableReactionsChanged) GetType() string {
	return TypeChatEventAvailableReactionsChanged
}

func (*ChatEventAvailableReactionsChanged) ChatEventActionType() string {
	return TypeChatEventAvailableReactionsChanged
}

func (chatEventAvailableReactionsChanged *ChatEventAvailableReactionsChanged) UnmarshalJSON(data []byte) error {
	var tmp struct {
		OldAvailableReactions json.RawMessage `json:"old_available_reactions"`
		NewAvailableReactions json.RawMessage `json:"new_available_reactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldOldAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.OldAvailableReactions)
	chatEventAvailableReactionsChanged.OldAvailableReactions = fieldOldAvailableReactions

	fieldNewAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.NewAvailableReactions)
	chatEventAvailableReactionsChanged.NewAvailableReactions = fieldNewAvailableReactions

	return nil
}

// The chat background was changed
type ChatEventBackgroundChanged struct {
	meta
	// Previous background; may be null if none
	OldBackground *ChatBackground `json:"old_background"`
	// New background; may be null if none
	NewBackground *ChatBackground `json:"new_background"`
}

func (entity *ChatEventBackgroundChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventBackgroundChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventBackgroundChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventBackgroundChanged) GetType() string {
	return TypeChatEventBackgroundChanged
}

func (*ChatEventBackgroundChanged) ChatEventActionType() string {
	return TypeChatEventBackgroundChanged
}

// The chat description was changed
type ChatEventDescriptionChanged struct {
	meta
	// Previous chat description
	OldDescription string `json:"old_description"`
	// New chat description
	NewDescription string `json:"new_description"`
}

func (entity *ChatEventDescriptionChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventDescriptionChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventDescriptionChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventDescriptionChanged) GetType() string {
	return TypeChatEventDescriptionChanged
}

func (*ChatEventDescriptionChanged) ChatEventActionType() string {
	return TypeChatEventDescriptionChanged
}

// The chat emoji status was changed
type ChatEventEmojiStatusChanged struct {
	meta
	// Previous emoji status; may be null if none
	OldEmojiStatus *EmojiStatus `json:"old_emoji_status"`
	// New emoji status; may be null if none
	NewEmojiStatus *EmojiStatus `json:"new_emoji_status"`
}

func (entity *ChatEventEmojiStatusChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventEmojiStatusChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventEmojiStatusChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventEmojiStatusChanged) GetType() string {
	return TypeChatEventEmojiStatusChanged
}

func (*ChatEventEmojiStatusChanged) ChatEventActionType() string {
	return TypeChatEventEmojiStatusChanged
}

// The linked chat of a supergroup was changed
type ChatEventLinkedChatChanged struct {
	meta
	// Previous supergroup linked chat identifier
	OldLinkedChatId int64 `json:"old_linked_chat_id"`
	// New supergroup linked chat identifier
	NewLinkedChatId int64 `json:"new_linked_chat_id"`
}

func (entity *ChatEventLinkedChatChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLinkedChatChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLinkedChatChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventLinkedChatChanged) GetType() string {
	return TypeChatEventLinkedChatChanged
}

func (*ChatEventLinkedChatChanged) ChatEventActionType() string {
	return TypeChatEventLinkedChatChanged
}

// The supergroup location was changed
type ChatEventLocationChanged struct {
	meta
	// Previous location; may be null
	OldLocation *ChatLocation `json:"old_location"`
	// New location; may be null
	NewLocation *ChatLocation `json:"new_location"`
}

func (entity *ChatEventLocationChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLocationChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLocationChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventLocationChanged) GetType() string {
	return TypeChatEventLocationChanged
}

func (*ChatEventLocationChanged) ChatEventActionType() string {
	return TypeChatEventLocationChanged
}

// The message auto-delete timer was changed
type ChatEventMessageAutoDeleteTimeChanged struct {
	meta
	// Previous value of message_auto_delete_time
	OldMessageAutoDeleteTime int32 `json:"old_message_auto_delete_time"`
	// New value of message_auto_delete_time
	NewMessageAutoDeleteTime int32 `json:"new_message_auto_delete_time"`
}

func (entity *ChatEventMessageAutoDeleteTimeChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageAutoDeleteTimeChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageAutoDeleteTimeChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageAutoDeleteTimeChanged) GetType() string {
	return TypeChatEventMessageAutoDeleteTimeChanged
}

func (*ChatEventMessageAutoDeleteTimeChanged) ChatEventActionType() string {
	return TypeChatEventMessageAutoDeleteTimeChanged
}

// The chat permissions were changed
type ChatEventPermissionsChanged struct {
	meta
	// Previous chat permissions
	OldPermissions *ChatPermissions `json:"old_permissions"`
	// New chat permissions
	NewPermissions *ChatPermissions `json:"new_permissions"`
}

func (entity *ChatEventPermissionsChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPermissionsChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPermissionsChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPermissionsChanged) GetType() string {
	return TypeChatEventPermissionsChanged
}

func (*ChatEventPermissionsChanged) ChatEventActionType() string {
	return TypeChatEventPermissionsChanged
}

// The chat photo was changed
type ChatEventPhotoChanged struct {
	meta
	// Previous chat photo value; may be null
	OldPhoto *ChatPhoto `json:"old_photo"`
	// New chat photo value; may be null
	NewPhoto *ChatPhoto `json:"new_photo"`
}

func (entity *ChatEventPhotoChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPhotoChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPhotoChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPhotoChanged) GetType() string {
	return TypeChatEventPhotoChanged
}

func (*ChatEventPhotoChanged) ChatEventActionType() string {
	return TypeChatEventPhotoChanged
}

// The slow_mode_delay setting of a supergroup was changed
type ChatEventSlowModeDelayChanged struct {
	meta
	// Previous value of slow_mode_delay, in seconds
	OldSlowModeDelay int32 `json:"old_slow_mode_delay"`
	// New value of slow_mode_delay, in seconds
	NewSlowModeDelay int32 `json:"new_slow_mode_delay"`
}

func (entity *ChatEventSlowModeDelayChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventSlowModeDelayChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventSlowModeDelayChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventSlowModeDelayChanged) GetType() string {
	return TypeChatEventSlowModeDelayChanged
}

func (*ChatEventSlowModeDelayChanged) ChatEventActionType() string {
	return TypeChatEventSlowModeDelayChanged
}

// The supergroup sticker set was changed
type ChatEventStickerSetChanged struct {
	meta
	// Previous identifier of the chat sticker set; 0 if none
	OldStickerSetId JsonInt64 `json:"old_sticker_set_id"`
	// New identifier of the chat sticker set; 0 if none
	NewStickerSetId JsonInt64 `json:"new_sticker_set_id"`
}

func (entity *ChatEventStickerSetChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventStickerSetChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventStickerSetChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventStickerSetChanged) GetType() string {
	return TypeChatEventStickerSetChanged
}

func (*ChatEventStickerSetChanged) ChatEventActionType() string {
	return TypeChatEventStickerSetChanged
}

// The supergroup sticker set with allowed custom emoji was changed
type ChatEventCustomEmojiStickerSetChanged struct {
	meta
	// Previous identifier of the chat sticker set; 0 if none
	OldStickerSetId JsonInt64 `json:"old_sticker_set_id"`
	// New identifier of the chat sticker set; 0 if none
	NewStickerSetId JsonInt64 `json:"new_sticker_set_id"`
}

func (entity *ChatEventCustomEmojiStickerSetChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventCustomEmojiStickerSetChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventCustomEmojiStickerSetChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventCustomEmojiStickerSetChanged) GetType() string {
	return TypeChatEventCustomEmojiStickerSetChanged
}

func (*ChatEventCustomEmojiStickerSetChanged) ChatEventActionType() string {
	return TypeChatEventCustomEmojiStickerSetChanged
}

// The chat title was changed
type ChatEventTitleChanged struct {
	meta
	// Previous chat title
	OldTitle string `json:"old_title"`
	// New chat title
	NewTitle string `json:"new_title"`
}

func (entity *ChatEventTitleChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventTitleChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventTitleChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventTitleChanged) GetType() string {
	return TypeChatEventTitleChanged
}

func (*ChatEventTitleChanged) ChatEventActionType() string {
	return TypeChatEventTitleChanged
}

// The chat editable username was changed
type ChatEventUsernameChanged struct {
	meta
	// Previous chat username
	OldUsername string `json:"old_username"`
	// New chat username
	NewUsername string `json:"new_username"`
}

func (entity *ChatEventUsernameChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventUsernameChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventUsernameChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventUsernameChanged) GetType() string {
	return TypeChatEventUsernameChanged
}

func (*ChatEventUsernameChanged) ChatEventActionType() string {
	return TypeChatEventUsernameChanged
}

// The chat active usernames were changed
type ChatEventActiveUsernamesChanged struct {
	meta
	// Previous list of active usernames
	OldUsernames []string `json:"old_usernames"`
	// New list of active usernames
	NewUsernames []string `json:"new_usernames"`
}

func (entity *ChatEventActiveUsernamesChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventActiveUsernamesChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventActiveUsernamesChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventActiveUsernamesChanged) GetType() string {
	return TypeChatEventActiveUsernamesChanged
}

func (*ChatEventActiveUsernamesChanged) ChatEventActionType() string {
	return TypeChatEventActiveUsernamesChanged
}

// The chat accent color or background custom emoji were changed
type ChatEventAccentColorChanged struct {
	meta
	// Previous identifier of chat accent color
	OldAccentColorId int32 `json:"old_accent_color_id"`
	// Previous identifier of the custom emoji; 0 if none
	OldBackgroundCustomEmojiId JsonInt64 `json:"old_background_custom_emoji_id"`
	// New identifier of chat accent color
	NewAccentColorId int32 `json:"new_accent_color_id"`
	// New identifier of the custom emoji; 0 if none
	NewBackgroundCustomEmojiId JsonInt64 `json:"new_background_custom_emoji_id"`
}

func (entity *ChatEventAccentColorChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventAccentColorChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventAccentColorChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventAccentColorChanged) GetType() string {
	return TypeChatEventAccentColorChanged
}

func (*ChatEventAccentColorChanged) ChatEventActionType() string {
	return TypeChatEventAccentColorChanged
}

// The chat's profile accent color or profile background custom emoji were changed
type ChatEventProfileAccentColorChanged struct {
	meta
	// Previous identifier of chat's profile accent color; -1 if none
	OldProfileAccentColorId int32 `json:"old_profile_accent_color_id"`
	// Previous identifier of the custom emoji; 0 if none
	OldProfileBackgroundCustomEmojiId JsonInt64 `json:"old_profile_background_custom_emoji_id"`
	// New identifier of chat's profile accent color; -1 if none
	NewProfileAccentColorId int32 `json:"new_profile_accent_color_id"`
	// New identifier of the custom emoji; 0 if none
	NewProfileBackgroundCustomEmojiId JsonInt64 `json:"new_profile_background_custom_emoji_id"`
}

func (entity *ChatEventProfileAccentColorChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventProfileAccentColorChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventProfileAccentColorChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventProfileAccentColorChanged) GetType() string {
	return TypeChatEventProfileAccentColorChanged
}

func (*ChatEventProfileAccentColorChanged) ChatEventActionType() string {
	return TypeChatEventProfileAccentColorChanged
}

// The has_protected_content setting of a channel was toggled
type ChatEventHasProtectedContentToggled struct {
	meta
	// New value of has_protected_content
	HasProtectedContent bool `json:"has_protected_content"`
}

func (entity *ChatEventHasProtectedContentToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventHasProtectedContentToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventHasProtectedContentToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventHasProtectedContentToggled) GetType() string {
	return TypeChatEventHasProtectedContentToggled
}

func (*ChatEventHasProtectedContentToggled) ChatEventActionType() string {
	return TypeChatEventHasProtectedContentToggled
}

// The can_invite_users permission of a supergroup chat was toggled
type ChatEventInvitesToggled struct {
	meta
	// New value of can_invite_users permission
	CanInviteUsers bool `json:"can_invite_users"`
}

func (entity *ChatEventInvitesToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInvitesToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInvitesToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInvitesToggled) GetType() string {
	return TypeChatEventInvitesToggled
}

func (*ChatEventInvitesToggled) ChatEventActionType() string {
	return TypeChatEventInvitesToggled
}

// The is_all_history_available setting of a supergroup was toggled
type ChatEventIsAllHistoryAvailableToggled struct {
	meta
	// New value of is_all_history_available
	IsAllHistoryAvailable bool `json:"is_all_history_available"`
}

func (entity *ChatEventIsAllHistoryAvailableToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventIsAllHistoryAvailableToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventIsAllHistoryAvailableToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventIsAllHistoryAvailableToggled) GetType() string {
	return TypeChatEventIsAllHistoryAvailableToggled
}

func (*ChatEventIsAllHistoryAvailableToggled) ChatEventActionType() string {
	return TypeChatEventIsAllHistoryAvailableToggled
}

// The has_aggressive_anti_spam_enabled setting of a supergroup was toggled
type ChatEventHasAggressiveAntiSpamEnabledToggled struct {
	meta
	// New value of has_aggressive_anti_spam_enabled
	HasAggressiveAntiSpamEnabled bool `json:"has_aggressive_anti_spam_enabled"`
}

func (entity *ChatEventHasAggressiveAntiSpamEnabledToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventHasAggressiveAntiSpamEnabledToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventHasAggressiveAntiSpamEnabledToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventHasAggressiveAntiSpamEnabledToggled) GetType() string {
	return TypeChatEventHasAggressiveAntiSpamEnabledToggled
}

func (*ChatEventHasAggressiveAntiSpamEnabledToggled) ChatEventActionType() string {
	return TypeChatEventHasAggressiveAntiSpamEnabledToggled
}

// The sign_messages setting of a channel was toggled
type ChatEventSignMessagesToggled struct {
	meta
	// New value of sign_messages
	SignMessages bool `json:"sign_messages"`
}

func (entity *ChatEventSignMessagesToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventSignMessagesToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventSignMessagesToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventSignMessagesToggled) GetType() string {
	return TypeChatEventSignMessagesToggled
}

func (*ChatEventSignMessagesToggled) ChatEventActionType() string {
	return TypeChatEventSignMessagesToggled
}

// The show_message_sender setting of a channel was toggled
type ChatEventShowMessageSenderToggled struct {
	meta
	// New value of show_message_sender
	ShowMessageSender bool `json:"show_message_sender"`
}

func (entity *ChatEventShowMessageSenderToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventShowMessageSenderToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventShowMessageSenderToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventShowMessageSenderToggled) GetType() string {
	return TypeChatEventShowMessageSenderToggled
}

func (*ChatEventShowMessageSenderToggled) ChatEventActionType() string {
	return TypeChatEventShowMessageSenderToggled
}

// A chat invite link was edited
type ChatEventInviteLinkEdited struct {
	meta
	// Previous information about the invite link
	OldInviteLink *ChatInviteLink `json:"old_invite_link"`
	// New information about the invite link
	NewInviteLink *ChatInviteLink `json:"new_invite_link"`
}

func (entity *ChatEventInviteLinkEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInviteLinkEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInviteLinkEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInviteLinkEdited) GetType() string {
	return TypeChatEventInviteLinkEdited
}

func (*ChatEventInviteLinkEdited) ChatEventActionType() string {
	return TypeChatEventInviteLinkEdited
}

// A chat invite link was revoked
type ChatEventInviteLinkRevoked struct {
	meta
	// The invite link
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventInviteLinkRevoked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInviteLinkRevoked

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInviteLinkRevoked) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInviteLinkRevoked) GetType() string {
	return TypeChatEventInviteLinkRevoked
}

func (*ChatEventInviteLinkRevoked) ChatEventActionType() string {
	return TypeChatEventInviteLinkRevoked
}

// A revoked chat invite link was deleted
type ChatEventInviteLinkDeleted struct {
	meta
	// The invite link
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *ChatEventInviteLinkDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInviteLinkDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInviteLinkDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInviteLinkDeleted) GetType() string {
	return TypeChatEventInviteLinkDeleted
}

func (*ChatEventInviteLinkDeleted) ChatEventActionType() string {
	return TypeChatEventInviteLinkDeleted
}

// A video chat was created
type ChatEventVideoChatCreated struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
}

func (entity *ChatEventVideoChatCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatCreated

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatCreated) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatCreated) GetType() string {
	return TypeChatEventVideoChatCreated
}

func (*ChatEventVideoChatCreated) ChatEventActionType() string {
	return TypeChatEventVideoChatCreated
}

// A video chat was ended
type ChatEventVideoChatEnded struct {
	meta
	// Identifier of the video chat. The video chat can be received through the method getGroupCall
	GroupCallId int32 `json:"group_call_id"`
}

func (entity *ChatEventVideoChatEnded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatEnded

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatEnded) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatEnded) GetType() string {
	return TypeChatEventVideoChatEnded
}

func (*ChatEventVideoChatEnded) ChatEventActionType() string {
	return TypeChatEventVideoChatEnded
}

// The mute_new_participants setting of a video chat was toggled
type ChatEventVideoChatMuteNewParticipantsToggled struct {
	meta
	// New value of the mute_new_participants setting
	MuteNewParticipants bool `json:"mute_new_participants"`
}

func (entity *ChatEventVideoChatMuteNewParticipantsToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatMuteNewParticipantsToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatMuteNewParticipantsToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatMuteNewParticipantsToggled) GetType() string {
	return TypeChatEventVideoChatMuteNewParticipantsToggled
}

func (*ChatEventVideoChatMuteNewParticipantsToggled) ChatEventActionType() string {
	return TypeChatEventVideoChatMuteNewParticipantsToggled
}

// A video chat participant was muted or unmuted
type ChatEventVideoChatParticipantIsMutedToggled struct {
	meta
	// Identifier of the affected group call participant
	ParticipantId MessageSender `json:"participant_id"`
	// New value of is_muted
	IsMuted bool `json:"is_muted"`
}

func (entity *ChatEventVideoChatParticipantIsMutedToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatParticipantIsMutedToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatParticipantIsMutedToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatParticipantIsMutedToggled) GetType() string {
	return TypeChatEventVideoChatParticipantIsMutedToggled
}

func (*ChatEventVideoChatParticipantIsMutedToggled) ChatEventActionType() string {
	return TypeChatEventVideoChatParticipantIsMutedToggled
}

func (chatEventVideoChatParticipantIsMutedToggled *ChatEventVideoChatParticipantIsMutedToggled) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId json.RawMessage `json:"participant_id"`
		IsMuted       bool            `json:"is_muted"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventVideoChatParticipantIsMutedToggled.IsMuted = tmp.IsMuted

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	chatEventVideoChatParticipantIsMutedToggled.ParticipantId = fieldParticipantId

	return nil
}

// A video chat participant volume level was changed
type ChatEventVideoChatParticipantVolumeLevelChanged struct {
	meta
	// Identifier of the affected group call participant
	ParticipantId MessageSender `json:"participant_id"`
	// New value of volume_level; 1-20000 in hundreds of percents
	VolumeLevel int32 `json:"volume_level"`
}

func (entity *ChatEventVideoChatParticipantVolumeLevelChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventVideoChatParticipantVolumeLevelChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventVideoChatParticipantVolumeLevelChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventVideoChatParticipantVolumeLevelChanged) GetType() string {
	return TypeChatEventVideoChatParticipantVolumeLevelChanged
}

func (*ChatEventVideoChatParticipantVolumeLevelChanged) ChatEventActionType() string {
	return TypeChatEventVideoChatParticipantVolumeLevelChanged
}

func (chatEventVideoChatParticipantVolumeLevelChanged *ChatEventVideoChatParticipantVolumeLevelChanged) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ParticipantId json.RawMessage `json:"participant_id"`
		VolumeLevel   int32           `json:"volume_level"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventVideoChatParticipantVolumeLevelChanged.VolumeLevel = tmp.VolumeLevel

	fieldParticipantId, _ := UnmarshalMessageSender(tmp.ParticipantId)
	chatEventVideoChatParticipantVolumeLevelChanged.ParticipantId = fieldParticipantId

	return nil
}

// The is_forum setting of a channel was toggled
type ChatEventIsForumToggled struct {
	meta
	// New value of is_forum
	IsForum bool `json:"is_forum"`
}

func (entity *ChatEventIsForumToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventIsForumToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventIsForumToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventIsForumToggled) GetType() string {
	return TypeChatEventIsForumToggled
}

func (*ChatEventIsForumToggled) ChatEventActionType() string {
	return TypeChatEventIsForumToggled
}

// A new forum topic was created
type ChatEventForumTopicCreated struct {
	meta
	// Information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicCreated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicCreated

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicCreated) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicCreated) GetType() string {
	return TypeChatEventForumTopicCreated
}

func (*ChatEventForumTopicCreated) ChatEventActionType() string {
	return TypeChatEventForumTopicCreated
}

// A forum topic was edited
type ChatEventForumTopicEdited struct {
	meta
	// Old information about the topic
	OldTopicInfo *ForumTopicInfo `json:"old_topic_info"`
	// New information about the topic
	NewTopicInfo *ForumTopicInfo `json:"new_topic_info"`
}

func (entity *ChatEventForumTopicEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicEdited) GetType() string {
	return TypeChatEventForumTopicEdited
}

func (*ChatEventForumTopicEdited) ChatEventActionType() string {
	return TypeChatEventForumTopicEdited
}

// A forum topic was closed or reopened
type ChatEventForumTopicToggleIsClosed struct {
	meta
	// New information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicToggleIsClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicToggleIsClosed

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicToggleIsClosed) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicToggleIsClosed) GetType() string {
	return TypeChatEventForumTopicToggleIsClosed
}

func (*ChatEventForumTopicToggleIsClosed) ChatEventActionType() string {
	return TypeChatEventForumTopicToggleIsClosed
}

// The General forum topic was hidden or unhidden
type ChatEventForumTopicToggleIsHidden struct {
	meta
	// New information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicToggleIsHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicToggleIsHidden

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicToggleIsHidden) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicToggleIsHidden) GetType() string {
	return TypeChatEventForumTopicToggleIsHidden
}

func (*ChatEventForumTopicToggleIsHidden) ChatEventActionType() string {
	return TypeChatEventForumTopicToggleIsHidden
}

// A forum topic was deleted
type ChatEventForumTopicDeleted struct {
	meta
	// Information about the topic
	TopicInfo *ForumTopicInfo `json:"topic_info"`
}

func (entity *ChatEventForumTopicDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicDeleted) GetType() string {
	return TypeChatEventForumTopicDeleted
}

func (*ChatEventForumTopicDeleted) ChatEventActionType() string {
	return TypeChatEventForumTopicDeleted
}

// A pinned forum topic was changed
type ChatEventForumTopicPinned struct {
	meta
	// Information about the old pinned topic; may be null
	OldTopicInfo *ForumTopicInfo `json:"old_topic_info"`
	// Information about the new pinned topic; may be null
	NewTopicInfo *ForumTopicInfo `json:"new_topic_info"`
}

func (entity *ChatEventForumTopicPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventForumTopicPinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventForumTopicPinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventForumTopicPinned) GetType() string {
	return TypeChatEventForumTopicPinned
}

func (*ChatEventForumTopicPinned) ChatEventActionType() string {
	return TypeChatEventForumTopicPinned
}

// Represents a chat event
type ChatEvent struct {
	meta
	// Chat event identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the event happened
	Date int32 `json:"date"`
	// Identifier of the user or chat who performed the action
	MemberId MessageSender `json:"member_id"`
	// The action
	Action ChatEventAction `json:"action"`
}

func (entity *ChatEvent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEvent

	return json.Marshal((*stub)(entity))
}

func (*ChatEvent) GetClass() string {
	return ClassChatEvent
}

func (*ChatEvent) GetType() string {
	return TypeChatEvent
}

func (chatEvent *ChatEvent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id       JsonInt64       `json:"id"`
		Date     int32           `json:"date"`
		MemberId json.RawMessage `json:"member_id"`
		Action   json.RawMessage `json:"action"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEvent.Id = tmp.Id
	chatEvent.Date = tmp.Date

	fieldMemberId, _ := UnmarshalMessageSender(tmp.MemberId)
	chatEvent.MemberId = fieldMemberId

	fieldAction, _ := UnmarshalChatEventAction(tmp.Action)
	chatEvent.Action = fieldAction

	return nil
}

// Contains a list of chat events
type ChatEvents struct {
	meta
	// List of events
	Events []*ChatEvent `json:"events"`
}

func (entity *ChatEvents) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEvents

	return json.Marshal((*stub)(entity))
}

func (*ChatEvents) GetClass() string {
	return ClassChatEvents
}

func (*ChatEvents) GetType() string {
	return TypeChatEvents
}

// Represents a set of filters used to obtain a chat event log
type ChatEventLogFilters struct {
	meta
	// True, if message edits need to be returned
	MessageEdits bool `json:"message_edits"`
	// True, if message deletions need to be returned
	MessageDeletions bool `json:"message_deletions"`
	// True, if pin/unpin events need to be returned
	MessagePins bool `json:"message_pins"`
	// True, if members joining events need to be returned
	MemberJoins bool `json:"member_joins"`
	// True, if members leaving events need to be returned
	MemberLeaves bool `json:"member_leaves"`
	// True, if invited member events need to be returned
	MemberInvites bool `json:"member_invites"`
	// True, if member promotion/demotion events need to be returned
	MemberPromotions bool `json:"member_promotions"`
	// True, if member restricted/unrestricted/banned/unbanned events need to be returned
	MemberRestrictions bool `json:"member_restrictions"`
	// True, if changes in chat information need to be returned
	InfoChanges bool `json:"info_changes"`
	// True, if changes in chat settings need to be returned
	SettingChanges bool `json:"setting_changes"`
	// True, if changes to invite links need to be returned
	InviteLinkChanges bool `json:"invite_link_changes"`
	// True, if video chat actions need to be returned
	VideoChatChanges bool `json:"video_chat_changes"`
	// True, if forum-related actions need to be returned
	ForumChanges bool `json:"forum_changes"`
	// True, if subscription extensions need to be returned
	SubscriptionExtensions bool `json:"subscription_extensions"`
}

func (entity *ChatEventLogFilters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLogFilters

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLogFilters) GetClass() string {
	return ClassChatEventLogFilters
}

func (*ChatEventLogFilters) GetType() string {
	return TypeChatEventLogFilters
}

// An ordinary language pack string
type LanguagePackStringValueOrdinary struct {
	meta
	// String value
	Value string `json:"value"`
}

func (entity *LanguagePackStringValueOrdinary) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValueOrdinary

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValueOrdinary) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValueOrdinary) GetType() string {
	return TypeLanguagePackStringValueOrdinary
}

func (*LanguagePackStringValueOrdinary) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValueOrdinary
}

// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
type LanguagePackStringValuePluralized struct {
	meta
	// Value for zero objects
	ZeroValue string `json:"zero_value"`
	// Value for one object
	OneValue string `json:"one_value"`
	// Value for two objects
	TwoValue string `json:"two_value"`
	// Value for few objects
	FewValue string `json:"few_value"`
	// Value for many objects
	ManyValue string `json:"many_value"`
	// Default value
	OtherValue string `json:"other_value"`
}

func (entity *LanguagePackStringValuePluralized) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValuePluralized

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValuePluralized) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValuePluralized) GetType() string {
	return TypeLanguagePackStringValuePluralized
}

func (*LanguagePackStringValuePluralized) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValuePluralized
}

// A deleted language pack string, the value must be taken from the built-in English language pack
type LanguagePackStringValueDeleted struct {
	meta
}

func (entity *LanguagePackStringValueDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValueDeleted

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValueDeleted) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValueDeleted) GetType() string {
	return TypeLanguagePackStringValueDeleted
}

func (*LanguagePackStringValueDeleted) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValueDeleted
}

// Represents one language pack string
type LanguagePackString struct {
	meta
	// String key
	Key string `json:"key"`
	// String value; pass null if the string needs to be taken from the built-in English language pack
	Value LanguagePackStringValue `json:"value"`
}

func (entity *LanguagePackString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackString

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackString) GetClass() string {
	return ClassLanguagePackString
}

func (*LanguagePackString) GetType() string {
	return TypeLanguagePackString
}

func (languagePackString *LanguagePackString) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Key   string          `json:"key"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	languagePackString.Key = tmp.Key

	fieldValue, _ := UnmarshalLanguagePackStringValue(tmp.Value)
	languagePackString.Value = fieldValue

	return nil
}

// Contains a list of language pack strings
type LanguagePackStrings struct {
	meta
	// A list of language pack strings
	Strings []*LanguagePackString `json:"strings"`
}

func (entity *LanguagePackStrings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStrings

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStrings) GetClass() string {
	return ClassLanguagePackStrings
}

func (*LanguagePackStrings) GetType() string {
	return TypeLanguagePackStrings
}

// Contains information about a language pack
type LanguagePackInfo struct {
	meta
	// Unique language pack identifier
	Id string `json:"id"`
	// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
	BaseLanguagePackId string `json:"base_language_pack_id"`
	// Language name
	Name string `json:"name"`
	// Name of the language in that language
	NativeName string `json:"native_name"`
	// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
	PluralCode string `json:"plural_code"`
	// True, if the language pack is official
	IsOfficial bool `json:"is_official"`
	// True, if the language pack strings are RTL
	IsRtl bool `json:"is_rtl"`
	// True, if the language pack is a beta language pack
	IsBeta bool `json:"is_beta"`
	// True, if the language pack is installed by the current user
	IsInstalled bool `json:"is_installed"`
	// Total number of non-deleted strings from the language pack
	TotalStringCount int32 `json:"total_string_count"`
	// Total number of translated strings from the language pack
	TranslatedStringCount int32 `json:"translated_string_count"`
	// Total number of non-deleted strings from the language pack available locally
	LocalStringCount int32 `json:"local_string_count"`
	// Link to language translation interface; empty for custom local language packs
	TranslationUrl string `json:"translation_url"`
}

func (entity *LanguagePackInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackInfo

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackInfo) GetClass() string {
	return ClassLanguagePackInfo
}

func (*LanguagePackInfo) GetType() string {
	return TypeLanguagePackInfo
}

// Contains information about the current localization target
type LocalizationTargetInfo struct {
	meta
	// List of available language packs for this application
	LanguagePacks []*LanguagePackInfo `json:"language_packs"`
}

func (entity *LocalizationTargetInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocalizationTargetInfo

	return json.Marshal((*stub)(entity))
}

func (*LocalizationTargetInfo) GetClass() string {
	return ClassLocalizationTargetInfo
}

func (*LocalizationTargetInfo) GetType() string {
	return TypeLocalizationTargetInfo
}

// The maximum number of joined supergroups and channels
type PremiumLimitTypeSupergroupCount struct {
	meta
}

func (entity *PremiumLimitTypeSupergroupCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeSupergroupCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeSupergroupCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeSupergroupCount) GetType() string {
	return TypePremiumLimitTypeSupergroupCount
}

func (*PremiumLimitTypeSupergroupCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeSupergroupCount
}

// The maximum number of pinned chats in the main chat list
type PremiumLimitTypePinnedChatCount struct {
	meta
}

func (entity *PremiumLimitTypePinnedChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypePinnedChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypePinnedChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypePinnedChatCount) GetType() string {
	return TypePremiumLimitTypePinnedChatCount
}

func (*PremiumLimitTypePinnedChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypePinnedChatCount
}

// The maximum number of created public chats
type PremiumLimitTypeCreatedPublicChatCount struct {
	meta
}

func (entity *PremiumLimitTypeCreatedPublicChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeCreatedPublicChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeCreatedPublicChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeCreatedPublicChatCount) GetType() string {
	return TypePremiumLimitTypeCreatedPublicChatCount
}

func (*PremiumLimitTypeCreatedPublicChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeCreatedPublicChatCount
}

// The maximum number of saved animations
type PremiumLimitTypeSavedAnimationCount struct {
	meta
}

func (entity *PremiumLimitTypeSavedAnimationCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeSavedAnimationCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeSavedAnimationCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeSavedAnimationCount) GetType() string {
	return TypePremiumLimitTypeSavedAnimationCount
}

func (*PremiumLimitTypeSavedAnimationCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeSavedAnimationCount
}

// The maximum number of favorite stickers
type PremiumLimitTypeFavoriteStickerCount struct {
	meta
}

func (entity *PremiumLimitTypeFavoriteStickerCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeFavoriteStickerCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeFavoriteStickerCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeFavoriteStickerCount) GetType() string {
	return TypePremiumLimitTypeFavoriteStickerCount
}

func (*PremiumLimitTypeFavoriteStickerCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeFavoriteStickerCount
}

// The maximum number of chat folders
type PremiumLimitTypeChatFolderCount struct {
	meta
}

func (entity *PremiumLimitTypeChatFolderCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeChatFolderCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeChatFolderCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeChatFolderCount) GetType() string {
	return TypePremiumLimitTypeChatFolderCount
}

func (*PremiumLimitTypeChatFolderCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeChatFolderCount
}

// The maximum number of pinned and always included, or always excluded chats in a chat folder
type PremiumLimitTypeChatFolderChosenChatCount struct {
	meta
}

func (entity *PremiumLimitTypeChatFolderChosenChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeChatFolderChosenChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeChatFolderChosenChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeChatFolderChosenChatCount) GetType() string {
	return TypePremiumLimitTypeChatFolderChosenChatCount
}

func (*PremiumLimitTypeChatFolderChosenChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeChatFolderChosenChatCount
}

// The maximum number of pinned chats in the archive chat list
type PremiumLimitTypePinnedArchivedChatCount struct {
	meta
}

func (entity *PremiumLimitTypePinnedArchivedChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypePinnedArchivedChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypePinnedArchivedChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypePinnedArchivedChatCount) GetType() string {
	return TypePremiumLimitTypePinnedArchivedChatCount
}

func (*PremiumLimitTypePinnedArchivedChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypePinnedArchivedChatCount
}

// The maximum number of pinned Saved Messages topics
type PremiumLimitTypePinnedSavedMessagesTopicCount struct {
	meta
}

func (entity *PremiumLimitTypePinnedSavedMessagesTopicCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypePinnedSavedMessagesTopicCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypePinnedSavedMessagesTopicCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypePinnedSavedMessagesTopicCount) GetType() string {
	return TypePremiumLimitTypePinnedSavedMessagesTopicCount
}

func (*PremiumLimitTypePinnedSavedMessagesTopicCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypePinnedSavedMessagesTopicCount
}

// The maximum length of sent media caption
type PremiumLimitTypeCaptionLength struct {
	meta
}

func (entity *PremiumLimitTypeCaptionLength) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeCaptionLength

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeCaptionLength) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeCaptionLength) GetType() string {
	return TypePremiumLimitTypeCaptionLength
}

func (*PremiumLimitTypeCaptionLength) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeCaptionLength
}

// The maximum length of the user's bio
type PremiumLimitTypeBioLength struct {
	meta
}

func (entity *PremiumLimitTypeBioLength) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeBioLength

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeBioLength) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeBioLength) GetType() string {
	return TypePremiumLimitTypeBioLength
}

func (*PremiumLimitTypeBioLength) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeBioLength
}

// The maximum number of invite links for a chat folder
type PremiumLimitTypeChatFolderInviteLinkCount struct {
	meta
}

func (entity *PremiumLimitTypeChatFolderInviteLinkCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeChatFolderInviteLinkCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeChatFolderInviteLinkCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeChatFolderInviteLinkCount) GetType() string {
	return TypePremiumLimitTypeChatFolderInviteLinkCount
}

func (*PremiumLimitTypeChatFolderInviteLinkCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeChatFolderInviteLinkCount
}

// The maximum number of added shareable chat folders
type PremiumLimitTypeShareableChatFolderCount struct {
	meta
}

func (entity *PremiumLimitTypeShareableChatFolderCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeShareableChatFolderCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeShareableChatFolderCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeShareableChatFolderCount) GetType() string {
	return TypePremiumLimitTypeShareableChatFolderCount
}

func (*PremiumLimitTypeShareableChatFolderCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeShareableChatFolderCount
}

// The maximum number of active stories
type PremiumLimitTypeActiveStoryCount struct {
	meta
}

func (entity *PremiumLimitTypeActiveStoryCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeActiveStoryCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeActiveStoryCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeActiveStoryCount) GetType() string {
	return TypePremiumLimitTypeActiveStoryCount
}

func (*PremiumLimitTypeActiveStoryCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeActiveStoryCount
}

// The maximum number of stories sent per week
type PremiumLimitTypeWeeklySentStoryCount struct {
	meta
}

func (entity *PremiumLimitTypeWeeklySentStoryCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeWeeklySentStoryCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeWeeklySentStoryCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeWeeklySentStoryCount) GetType() string {
	return TypePremiumLimitTypeWeeklySentStoryCount
}

func (*PremiumLimitTypeWeeklySentStoryCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeWeeklySentStoryCount
}

// The maximum number of stories sent per month
type PremiumLimitTypeMonthlySentStoryCount struct {
	meta
}

func (entity *PremiumLimitTypeMonthlySentStoryCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeMonthlySentStoryCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeMonthlySentStoryCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeMonthlySentStoryCount) GetType() string {
	return TypePremiumLimitTypeMonthlySentStoryCount
}

func (*PremiumLimitTypeMonthlySentStoryCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeMonthlySentStoryCount
}

// The maximum length of captions of sent stories
type PremiumLimitTypeStoryCaptionLength struct {
	meta
}

func (entity *PremiumLimitTypeStoryCaptionLength) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeStoryCaptionLength

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeStoryCaptionLength) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeStoryCaptionLength) GetType() string {
	return TypePremiumLimitTypeStoryCaptionLength
}

func (*PremiumLimitTypeStoryCaptionLength) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeStoryCaptionLength
}

// The maximum number of suggested reaction areas on a story
type PremiumLimitTypeStorySuggestedReactionAreaCount struct {
	meta
}

func (entity *PremiumLimitTypeStorySuggestedReactionAreaCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeStorySuggestedReactionAreaCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeStorySuggestedReactionAreaCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeStorySuggestedReactionAreaCount) GetType() string {
	return TypePremiumLimitTypeStorySuggestedReactionAreaCount
}

func (*PremiumLimitTypeStorySuggestedReactionAreaCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeStorySuggestedReactionAreaCount
}

// The maximum number of received similar chats
type PremiumLimitTypeSimilarChatCount struct {
	meta
}

func (entity *PremiumLimitTypeSimilarChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimitTypeSimilarChatCount

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimitTypeSimilarChatCount) GetClass() string {
	return ClassPremiumLimitType
}

func (*PremiumLimitTypeSimilarChatCount) GetType() string {
	return TypePremiumLimitTypeSimilarChatCount
}

func (*PremiumLimitTypeSimilarChatCount) PremiumLimitTypeType() string {
	return TypePremiumLimitTypeSimilarChatCount
}

// Increased limits
type PremiumFeatureIncreasedLimits struct {
	meta
}

func (entity *PremiumFeatureIncreasedLimits) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureIncreasedLimits

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureIncreasedLimits) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureIncreasedLimits) GetType() string {
	return TypePremiumFeatureIncreasedLimits
}

func (*PremiumFeatureIncreasedLimits) PremiumFeatureType() string {
	return TypePremiumFeatureIncreasedLimits
}

// Increased maximum upload file size
type PremiumFeatureIncreasedUploadFileSize struct {
	meta
}

func (entity *PremiumFeatureIncreasedUploadFileSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureIncreasedUploadFileSize

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureIncreasedUploadFileSize) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureIncreasedUploadFileSize) GetType() string {
	return TypePremiumFeatureIncreasedUploadFileSize
}

func (*PremiumFeatureIncreasedUploadFileSize) PremiumFeatureType() string {
	return TypePremiumFeatureIncreasedUploadFileSize
}

// Improved download speed
type PremiumFeatureImprovedDownloadSpeed struct {
	meta
}

func (entity *PremiumFeatureImprovedDownloadSpeed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureImprovedDownloadSpeed

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureImprovedDownloadSpeed) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureImprovedDownloadSpeed) GetType() string {
	return TypePremiumFeatureImprovedDownloadSpeed
}

func (*PremiumFeatureImprovedDownloadSpeed) PremiumFeatureType() string {
	return TypePremiumFeatureImprovedDownloadSpeed
}

// The ability to convert voice notes to text
type PremiumFeatureVoiceRecognition struct {
	meta
}

func (entity *PremiumFeatureVoiceRecognition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureVoiceRecognition

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureVoiceRecognition) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureVoiceRecognition) GetType() string {
	return TypePremiumFeatureVoiceRecognition
}

func (*PremiumFeatureVoiceRecognition) PremiumFeatureType() string {
	return TypePremiumFeatureVoiceRecognition
}

// Disabled ads
type PremiumFeatureDisabledAds struct {
	meta
}

func (entity *PremiumFeatureDisabledAds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureDisabledAds

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureDisabledAds) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureDisabledAds) GetType() string {
	return TypePremiumFeatureDisabledAds
}

func (*PremiumFeatureDisabledAds) PremiumFeatureType() string {
	return TypePremiumFeatureDisabledAds
}

// Allowed to use more reactions
type PremiumFeatureUniqueReactions struct {
	meta
}

func (entity *PremiumFeatureUniqueReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureUniqueReactions

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureUniqueReactions) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureUniqueReactions) GetType() string {
	return TypePremiumFeatureUniqueReactions
}

func (*PremiumFeatureUniqueReactions) PremiumFeatureType() string {
	return TypePremiumFeatureUniqueReactions
}

// Allowed to use premium stickers with unique effects
type PremiumFeatureUniqueStickers struct {
	meta
}

func (entity *PremiumFeatureUniqueStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureUniqueStickers

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureUniqueStickers) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureUniqueStickers) GetType() string {
	return TypePremiumFeatureUniqueStickers
}

func (*PremiumFeatureUniqueStickers) PremiumFeatureType() string {
	return TypePremiumFeatureUniqueStickers
}

// Allowed to use custom emoji stickers in message texts and captions
type PremiumFeatureCustomEmoji struct {
	meta
}

func (entity *PremiumFeatureCustomEmoji) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureCustomEmoji

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureCustomEmoji) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureCustomEmoji) GetType() string {
	return TypePremiumFeatureCustomEmoji
}

func (*PremiumFeatureCustomEmoji) PremiumFeatureType() string {
	return TypePremiumFeatureCustomEmoji
}

// Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
type PremiumFeatureAdvancedChatManagement struct {
	meta
}

func (entity *PremiumFeatureAdvancedChatManagement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAdvancedChatManagement

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAdvancedChatManagement) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAdvancedChatManagement) GetType() string {
	return TypePremiumFeatureAdvancedChatManagement
}

func (*PremiumFeatureAdvancedChatManagement) PremiumFeatureType() string {
	return TypePremiumFeatureAdvancedChatManagement
}

// A badge in the user's profile
type PremiumFeatureProfileBadge struct {
	meta
}

func (entity *PremiumFeatureProfileBadge) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureProfileBadge

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureProfileBadge) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureProfileBadge) GetType() string {
	return TypePremiumFeatureProfileBadge
}

func (*PremiumFeatureProfileBadge) PremiumFeatureType() string {
	return TypePremiumFeatureProfileBadge
}

// The ability to show an emoji status along with the user's name
type PremiumFeatureEmojiStatus struct {
	meta
}

func (entity *PremiumFeatureEmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureEmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureEmojiStatus) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureEmojiStatus) GetType() string {
	return TypePremiumFeatureEmojiStatus
}

func (*PremiumFeatureEmojiStatus) PremiumFeatureType() string {
	return TypePremiumFeatureEmojiStatus
}

// Profile photo animation on message and chat screens
type PremiumFeatureAnimatedProfilePhoto struct {
	meta
}

func (entity *PremiumFeatureAnimatedProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAnimatedProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAnimatedProfilePhoto) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAnimatedProfilePhoto) GetType() string {
	return TypePremiumFeatureAnimatedProfilePhoto
}

func (*PremiumFeatureAnimatedProfilePhoto) PremiumFeatureType() string {
	return TypePremiumFeatureAnimatedProfilePhoto
}

// The ability to set a custom emoji as a forum topic icon
type PremiumFeatureForumTopicIcon struct {
	meta
}

func (entity *PremiumFeatureForumTopicIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureForumTopicIcon

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureForumTopicIcon) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureForumTopicIcon) GetType() string {
	return TypePremiumFeatureForumTopicIcon
}

func (*PremiumFeatureForumTopicIcon) PremiumFeatureType() string {
	return TypePremiumFeatureForumTopicIcon
}

// Allowed to set a premium application icons
type PremiumFeatureAppIcons struct {
	meta
}

func (entity *PremiumFeatureAppIcons) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAppIcons

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAppIcons) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAppIcons) GetType() string {
	return TypePremiumFeatureAppIcons
}

func (*PremiumFeatureAppIcons) PremiumFeatureType() string {
	return TypePremiumFeatureAppIcons
}

// Allowed to translate chat messages real-time
type PremiumFeatureRealTimeChatTranslation struct {
	meta
}

func (entity *PremiumFeatureRealTimeChatTranslation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureRealTimeChatTranslation

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureRealTimeChatTranslation) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureRealTimeChatTranslation) GetType() string {
	return TypePremiumFeatureRealTimeChatTranslation
}

func (*PremiumFeatureRealTimeChatTranslation) PremiumFeatureType() string {
	return TypePremiumFeatureRealTimeChatTranslation
}

// Allowed to use many additional features for stories
type PremiumFeatureUpgradedStories struct {
	meta
}

func (entity *PremiumFeatureUpgradedStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureUpgradedStories

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureUpgradedStories) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureUpgradedStories) GetType() string {
	return TypePremiumFeatureUpgradedStories
}

func (*PremiumFeatureUpgradedStories) PremiumFeatureType() string {
	return TypePremiumFeatureUpgradedStories
}

// The ability to boost chats
type PremiumFeatureChatBoost struct {
	meta
}

func (entity *PremiumFeatureChatBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureChatBoost

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureChatBoost) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureChatBoost) GetType() string {
	return TypePremiumFeatureChatBoost
}

func (*PremiumFeatureChatBoost) PremiumFeatureType() string {
	return TypePremiumFeatureChatBoost
}

// The ability to choose accent color for replies and user profile
type PremiumFeatureAccentColor struct {
	meta
}

func (entity *PremiumFeatureAccentColor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureAccentColor

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureAccentColor) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureAccentColor) GetType() string {
	return TypePremiumFeatureAccentColor
}

func (*PremiumFeatureAccentColor) PremiumFeatureType() string {
	return TypePremiumFeatureAccentColor
}

// The ability to set private chat background for both users
type PremiumFeatureBackgroundForBoth struct {
	meta
}

func (entity *PremiumFeatureBackgroundForBoth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureBackgroundForBoth

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureBackgroundForBoth) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureBackgroundForBoth) GetType() string {
	return TypePremiumFeatureBackgroundForBoth
}

func (*PremiumFeatureBackgroundForBoth) PremiumFeatureType() string {
	return TypePremiumFeatureBackgroundForBoth
}

// The ability to use tags in Saved Messages
type PremiumFeatureSavedMessagesTags struct {
	meta
}

func (entity *PremiumFeatureSavedMessagesTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureSavedMessagesTags

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureSavedMessagesTags) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureSavedMessagesTags) GetType() string {
	return TypePremiumFeatureSavedMessagesTags
}

func (*PremiumFeatureSavedMessagesTags) PremiumFeatureType() string {
	return TypePremiumFeatureSavedMessagesTags
}

// The ability to disallow incoming voice and video note messages in private chats using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
type PremiumFeatureMessagePrivacy struct {
	meta
}

func (entity *PremiumFeatureMessagePrivacy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureMessagePrivacy

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureMessagePrivacy) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureMessagePrivacy) GetType() string {
	return TypePremiumFeatureMessagePrivacy
}

func (*PremiumFeatureMessagePrivacy) PremiumFeatureType() string {
	return TypePremiumFeatureMessagePrivacy
}

// The ability to view last seen and read times of other users even they can't view last seen or read time for the current user
type PremiumFeatureLastSeenTimes struct {
	meta
}

func (entity *PremiumFeatureLastSeenTimes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureLastSeenTimes

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureLastSeenTimes) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureLastSeenTimes) GetType() string {
	return TypePremiumFeatureLastSeenTimes
}

func (*PremiumFeatureLastSeenTimes) PremiumFeatureType() string {
	return TypePremiumFeatureLastSeenTimes
}

// The ability to use Business features
type PremiumFeatureBusiness struct {
	meta
}

func (entity *PremiumFeatureBusiness) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureBusiness

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureBusiness) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureBusiness) GetType() string {
	return TypePremiumFeatureBusiness
}

func (*PremiumFeatureBusiness) PremiumFeatureType() string {
	return TypePremiumFeatureBusiness
}

// The ability to use all available message effects
type PremiumFeatureMessageEffects struct {
	meta
}

func (entity *PremiumFeatureMessageEffects) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatureMessageEffects

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatureMessageEffects) GetClass() string {
	return ClassPremiumFeature
}

func (*PremiumFeatureMessageEffects) GetType() string {
	return TypePremiumFeatureMessageEffects
}

func (*PremiumFeatureMessageEffects) PremiumFeatureType() string {
	return TypePremiumFeatureMessageEffects
}

// The ability to set location
type BusinessFeatureLocation struct {
	meta
}

func (entity *BusinessFeatureLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureLocation

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureLocation) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureLocation) GetType() string {
	return TypeBusinessFeatureLocation
}

func (*BusinessFeatureLocation) BusinessFeatureType() string {
	return TypeBusinessFeatureLocation
}

// The ability to set opening hours
type BusinessFeatureOpeningHours struct {
	meta
}

func (entity *BusinessFeatureOpeningHours) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureOpeningHours

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureOpeningHours) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureOpeningHours) GetType() string {
	return TypeBusinessFeatureOpeningHours
}

func (*BusinessFeatureOpeningHours) BusinessFeatureType() string {
	return TypeBusinessFeatureOpeningHours
}

// The ability to use quick replies
type BusinessFeatureQuickReplies struct {
	meta
}

func (entity *BusinessFeatureQuickReplies) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureQuickReplies

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureQuickReplies) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureQuickReplies) GetType() string {
	return TypeBusinessFeatureQuickReplies
}

func (*BusinessFeatureQuickReplies) BusinessFeatureType() string {
	return TypeBusinessFeatureQuickReplies
}

// The ability to set up a greeting message
type BusinessFeatureGreetingMessage struct {
	meta
}

func (entity *BusinessFeatureGreetingMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureGreetingMessage

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureGreetingMessage) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureGreetingMessage) GetType() string {
	return TypeBusinessFeatureGreetingMessage
}

func (*BusinessFeatureGreetingMessage) BusinessFeatureType() string {
	return TypeBusinessFeatureGreetingMessage
}

// The ability to set up an away message
type BusinessFeatureAwayMessage struct {
	meta
}

func (entity *BusinessFeatureAwayMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureAwayMessage

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureAwayMessage) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureAwayMessage) GetType() string {
	return TypeBusinessFeatureAwayMessage
}

func (*BusinessFeatureAwayMessage) BusinessFeatureType() string {
	return TypeBusinessFeatureAwayMessage
}

// The ability to create links to the business account with predefined message text
type BusinessFeatureAccountLinks struct {
	meta
}

func (entity *BusinessFeatureAccountLinks) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureAccountLinks

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureAccountLinks) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureAccountLinks) GetType() string {
	return TypeBusinessFeatureAccountLinks
}

func (*BusinessFeatureAccountLinks) BusinessFeatureType() string {
	return TypeBusinessFeatureAccountLinks
}

// The ability to customize start page
type BusinessFeatureStartPage struct {
	meta
}

func (entity *BusinessFeatureStartPage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureStartPage

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureStartPage) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureStartPage) GetType() string {
	return TypeBusinessFeatureStartPage
}

func (*BusinessFeatureStartPage) BusinessFeatureType() string {
	return TypeBusinessFeatureStartPage
}

// The ability to connect a bot to the account
type BusinessFeatureBots struct {
	meta
}

func (entity *BusinessFeatureBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureBots

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureBots) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureBots) GetType() string {
	return TypeBusinessFeatureBots
}

func (*BusinessFeatureBots) BusinessFeatureType() string {
	return TypeBusinessFeatureBots
}

// The ability to show an emoji status along with the business name
type BusinessFeatureEmojiStatus struct {
	meta
}

func (entity *BusinessFeatureEmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureEmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureEmojiStatus) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureEmojiStatus) GetType() string {
	return TypeBusinessFeatureEmojiStatus
}

func (*BusinessFeatureEmojiStatus) BusinessFeatureType() string {
	return TypeBusinessFeatureEmojiStatus
}

// The ability to display folder names for each chat in the chat list
type BusinessFeatureChatFolderTags struct {
	meta
}

func (entity *BusinessFeatureChatFolderTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureChatFolderTags

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureChatFolderTags) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureChatFolderTags) GetType() string {
	return TypeBusinessFeatureChatFolderTags
}

func (*BusinessFeatureChatFolderTags) BusinessFeatureType() string {
	return TypeBusinessFeatureChatFolderTags
}

// Allowed to use many additional features for stories
type BusinessFeatureUpgradedStories struct {
	meta
}

func (entity *BusinessFeatureUpgradedStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatureUpgradedStories

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatureUpgradedStories) GetClass() string {
	return ClassBusinessFeature
}

func (*BusinessFeatureUpgradedStories) GetType() string {
	return TypeBusinessFeatureUpgradedStories
}

func (*BusinessFeatureUpgradedStories) BusinessFeatureType() string {
	return TypeBusinessFeatureUpgradedStories
}

// Stories of the current user are displayed before stories of non-Premium contacts, supergroups, and channels
type PremiumStoryFeaturePriorityOrder struct {
	meta
}

func (entity *PremiumStoryFeaturePriorityOrder) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeaturePriorityOrder

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeaturePriorityOrder) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeaturePriorityOrder) GetType() string {
	return TypePremiumStoryFeaturePriorityOrder
}

func (*PremiumStoryFeaturePriorityOrder) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeaturePriorityOrder
}

// The ability to hide the fact that the user viewed other's stories
type PremiumStoryFeatureStealthMode struct {
	meta
}

func (entity *PremiumStoryFeatureStealthMode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeatureStealthMode

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeatureStealthMode) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeatureStealthMode) GetType() string {
	return TypePremiumStoryFeatureStealthMode
}

func (*PremiumStoryFeatureStealthMode) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeatureStealthMode
}

// The ability to check who opened the current user's stories after they expire
type PremiumStoryFeaturePermanentViewsHistory struct {
	meta
}

func (entity *PremiumStoryFeaturePermanentViewsHistory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeaturePermanentViewsHistory

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeaturePermanentViewsHistory) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeaturePermanentViewsHistory) GetType() string {
	return TypePremiumStoryFeaturePermanentViewsHistory
}

func (*PremiumStoryFeaturePermanentViewsHistory) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeaturePermanentViewsHistory
}

// The ability to set custom expiration duration for stories
type PremiumStoryFeatureCustomExpirationDuration struct {
	meta
}

func (entity *PremiumStoryFeatureCustomExpirationDuration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeatureCustomExpirationDuration

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeatureCustomExpirationDuration) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeatureCustomExpirationDuration) GetType() string {
	return TypePremiumStoryFeatureCustomExpirationDuration
}

func (*PremiumStoryFeatureCustomExpirationDuration) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeatureCustomExpirationDuration
}

// The ability to save other's unprotected stories
type PremiumStoryFeatureSaveStories struct {
	meta
}

func (entity *PremiumStoryFeatureSaveStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeatureSaveStories

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeatureSaveStories) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeatureSaveStories) GetType() string {
	return TypePremiumStoryFeatureSaveStories
}

func (*PremiumStoryFeatureSaveStories) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeatureSaveStories
}

// The ability to use links and formatting in story caption, and use inputStoryAreaTypeLink areas
type PremiumStoryFeatureLinksAndFormatting struct {
	meta
}

func (entity *PremiumStoryFeatureLinksAndFormatting) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeatureLinksAndFormatting

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeatureLinksAndFormatting) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeatureLinksAndFormatting) GetType() string {
	return TypePremiumStoryFeatureLinksAndFormatting
}

func (*PremiumStoryFeatureLinksAndFormatting) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeatureLinksAndFormatting
}

// The ability to choose better quality for viewed stories
type PremiumStoryFeatureVideoQuality struct {
	meta
}

func (entity *PremiumStoryFeatureVideoQuality) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumStoryFeatureVideoQuality

	return json.Marshal((*stub)(entity))
}

func (*PremiumStoryFeatureVideoQuality) GetClass() string {
	return ClassPremiumStoryFeature
}

func (*PremiumStoryFeatureVideoQuality) GetType() string {
	return TypePremiumStoryFeatureVideoQuality
}

func (*PremiumStoryFeatureVideoQuality) PremiumStoryFeatureType() string {
	return TypePremiumStoryFeatureVideoQuality
}

// Contains information about a limit, increased for Premium users
type PremiumLimit struct {
	meta
	// The type of the limit
	Type PremiumLimitType `json:"type"`
	// Default value of the limit
	DefaultValue int32 `json:"default_value"`
	// Value of the limit for Premium users
	PremiumValue int32 `json:"premium_value"`
}

func (entity *PremiumLimit) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumLimit

	return json.Marshal((*stub)(entity))
}

func (*PremiumLimit) GetClass() string {
	return ClassPremiumLimit
}

func (*PremiumLimit) GetType() string {
	return TypePremiumLimit
}

func (premiumLimit *PremiumLimit) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type         json.RawMessage `json:"type"`
		DefaultValue int32           `json:"default_value"`
		PremiumValue int32           `json:"premium_value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumLimit.DefaultValue = tmp.DefaultValue
	premiumLimit.PremiumValue = tmp.PremiumValue

	fieldType, _ := UnmarshalPremiumLimitType(tmp.Type)
	premiumLimit.Type = fieldType

	return nil
}

// Contains information about features, available to Premium users
type PremiumFeatures struct {
	meta
	// The list of available features
	Features []PremiumFeature `json:"features"`
	// The list of limits, increased for Premium users
	Limits []*PremiumLimit `json:"limits"`
	// An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
	PaymentLink InternalLinkType `json:"payment_link"`
}

func (entity *PremiumFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeatures

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeatures) GetClass() string {
	return ClassPremiumFeatures
}

func (*PremiumFeatures) GetType() string {
	return TypePremiumFeatures
}

func (premiumFeatures *PremiumFeatures) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Features    []json.RawMessage `json:"features"`
		Limits      []*PremiumLimit   `json:"limits"`
		PaymentLink json.RawMessage   `json:"payment_link"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumFeatures.Limits = tmp.Limits

	fieldFeatures, _ := UnmarshalListOfPremiumFeature(tmp.Features)
	premiumFeatures.Features = fieldFeatures

	fieldPaymentLink, _ := UnmarshalInternalLinkType(tmp.PaymentLink)
	premiumFeatures.PaymentLink = fieldPaymentLink

	return nil
}

// Contains information about features, available to Business user accounts
type BusinessFeatures struct {
	meta
	// The list of available business features
	Features []BusinessFeature `json:"features"`
}

func (entity *BusinessFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeatures

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeatures) GetClass() string {
	return ClassBusinessFeatures
}

func (*BusinessFeatures) GetType() string {
	return TypeBusinessFeatures
}

func (businessFeatures *BusinessFeatures) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Features []json.RawMessage `json:"features"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFeatures, _ := UnmarshalListOfBusinessFeature(tmp.Features)
	businessFeatures.Features = fieldFeatures

	return nil
}

// A limit was exceeded
type PremiumSourceLimitExceeded struct {
	meta
	// Type of the exceeded limit
	LimitType PremiumLimitType `json:"limit_type"`
}

func (entity *PremiumSourceLimitExceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceLimitExceeded

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceLimitExceeded) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceLimitExceeded) GetType() string {
	return TypePremiumSourceLimitExceeded
}

func (*PremiumSourceLimitExceeded) PremiumSourceType() string {
	return TypePremiumSourceLimitExceeded
}

func (premiumSourceLimitExceeded *PremiumSourceLimitExceeded) UnmarshalJSON(data []byte) error {
	var tmp struct {
		LimitType json.RawMessage `json:"limit_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldLimitType, _ := UnmarshalPremiumLimitType(tmp.LimitType)
	premiumSourceLimitExceeded.LimitType = fieldLimitType

	return nil
}

// A user tried to use a Premium feature
type PremiumSourceFeature struct {
	meta
	// The used feature
	Feature PremiumFeature `json:"feature"`
}

func (entity *PremiumSourceFeature) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceFeature

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceFeature) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceFeature) GetType() string {
	return TypePremiumSourceFeature
}

func (*PremiumSourceFeature) PremiumSourceType() string {
	return TypePremiumSourceFeature
}

func (premiumSourceFeature *PremiumSourceFeature) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature json.RawMessage `json:"feature"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFeature, _ := UnmarshalPremiumFeature(tmp.Feature)
	premiumSourceFeature.Feature = fieldFeature

	return nil
}

// A user tried to use a Business feature
type PremiumSourceBusinessFeature struct {
	meta
	// The used feature; pass null if none specific feature was used
	Feature BusinessFeature `json:"feature"`
}

func (entity *PremiumSourceBusinessFeature) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceBusinessFeature

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceBusinessFeature) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceBusinessFeature) GetType() string {
	return TypePremiumSourceBusinessFeature
}

func (*PremiumSourceBusinessFeature) PremiumSourceType() string {
	return TypePremiumSourceBusinessFeature
}

func (premiumSourceBusinessFeature *PremiumSourceBusinessFeature) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature json.RawMessage `json:"feature"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFeature, _ := UnmarshalBusinessFeature(tmp.Feature)
	premiumSourceBusinessFeature.Feature = fieldFeature

	return nil
}

// A user tried to use a Premium story feature
type PremiumSourceStoryFeature struct {
	meta
	// The used feature
	Feature PremiumStoryFeature `json:"feature"`
}

func (entity *PremiumSourceStoryFeature) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceStoryFeature

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceStoryFeature) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceStoryFeature) GetType() string {
	return TypePremiumSourceStoryFeature
}

func (*PremiumSourceStoryFeature) PremiumSourceType() string {
	return TypePremiumSourceStoryFeature
}

func (premiumSourceStoryFeature *PremiumSourceStoryFeature) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature json.RawMessage `json:"feature"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFeature, _ := UnmarshalPremiumStoryFeature(tmp.Feature)
	premiumSourceStoryFeature.Feature = fieldFeature

	return nil
}

// A user opened an internal link of the type internalLinkTypePremiumFeatures
type PremiumSourceLink struct {
	meta
	// The referrer from the link
	Referrer string `json:"referrer"`
}

func (entity *PremiumSourceLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceLink

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceLink) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceLink) GetType() string {
	return TypePremiumSourceLink
}

func (*PremiumSourceLink) PremiumSourceType() string {
	return TypePremiumSourceLink
}

// A user opened the Premium features screen from settings
type PremiumSourceSettings struct {
	meta
}

func (entity *PremiumSourceSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumSourceSettings

	return json.Marshal((*stub)(entity))
}

func (*PremiumSourceSettings) GetClass() string {
	return ClassPremiumSource
}

func (*PremiumSourceSettings) GetType() string {
	return TypePremiumSourceSettings
}

func (*PremiumSourceSettings) PremiumSourceType() string {
	return TypePremiumSourceSettings
}

// Describes a promotion animation for a Premium feature
type PremiumFeaturePromotionAnimation struct {
	meta
	// Premium feature
	Feature PremiumFeature `json:"feature"`
	// Promotion animation for the feature
	Animation *Animation `json:"animation"`
}

func (entity *PremiumFeaturePromotionAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumFeaturePromotionAnimation

	return json.Marshal((*stub)(entity))
}

func (*PremiumFeaturePromotionAnimation) GetClass() string {
	return ClassPremiumFeaturePromotionAnimation
}

func (*PremiumFeaturePromotionAnimation) GetType() string {
	return TypePremiumFeaturePromotionAnimation
}

func (premiumFeaturePromotionAnimation *PremiumFeaturePromotionAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature   json.RawMessage `json:"feature"`
		Animation *Animation      `json:"animation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	premiumFeaturePromotionAnimation.Animation = tmp.Animation

	fieldFeature, _ := UnmarshalPremiumFeature(tmp.Feature)
	premiumFeaturePromotionAnimation.Feature = fieldFeature

	return nil
}

// Describes a promotion animation for a Business feature
type BusinessFeaturePromotionAnimation struct {
	meta
	// Business feature
	Feature BusinessFeature `json:"feature"`
	// Promotion animation for the feature
	Animation *Animation `json:"animation"`
}

func (entity *BusinessFeaturePromotionAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BusinessFeaturePromotionAnimation

	return json.Marshal((*stub)(entity))
}

func (*BusinessFeaturePromotionAnimation) GetClass() string {
	return ClassBusinessFeaturePromotionAnimation
}

func (*BusinessFeaturePromotionAnimation) GetType() string {
	return TypeBusinessFeaturePromotionAnimation
}

func (businessFeaturePromotionAnimation *BusinessFeaturePromotionAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Feature   json.RawMessage `json:"feature"`
		Animation *Animation      `json:"animation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	businessFeaturePromotionAnimation.Animation = tmp.Animation

	fieldFeature, _ := UnmarshalBusinessFeature(tmp.Feature)
	businessFeaturePromotionAnimation.Feature = fieldFeature

	return nil
}

// Contains state of Telegram Premium subscription and promotion videos for Premium features
type PremiumState struct {
	meta
	// Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
	State *FormattedText `json:"state"`
	// The list of available options for buying Telegram Premium
	PaymentOptions []*PremiumStatePaymentOption `json:"payment_options"`
	// The list of available promotion animations for Premium features
	Animations []*PremiumFeaturePromotionAnimation `json:"animations"`
	// The list of available promotion animations for Business features
	BusinessAnimations []*BusinessFeaturePromotionAnimation `json:"business_animations"`
}

func (entity *PremiumState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PremiumState

	return json.Marshal((*stub)(entity))
}

func (*PremiumState) GetClass() string {
	return ClassPremiumState
}

func (*PremiumState) GetType() string {
	return TypePremiumState
}

// The user subscribing to Telegram Premium
type StorePaymentPurposePremiumSubscription struct {
	meta
	// Pass true if this is a restore of a Telegram Premium purchase; only for App Store
	IsRestore bool `json:"is_restore"`
	// Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
	IsUpgrade bool `json:"is_upgrade"`
}

func (entity *StorePaymentPurposePremiumSubscription) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposePremiumSubscription

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposePremiumSubscription) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposePremiumSubscription) GetType() string {
	return TypeStorePaymentPurposePremiumSubscription
}

func (*StorePaymentPurposePremiumSubscription) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposePremiumSubscription
}

// The user creating Telegram Premium gift codes for other users
type StorePaymentPurposePremiumGiftCodes struct {
	meta
	// Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
	BoostedChatId int64 `json:"boosted_chat_id"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Identifiers of the users which can activate the gift codes
	UserIds []int64 `json:"user_ids"`
	// Text to show along with the gift codes; 0-getOption("gift_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed
	Text *FormattedText `json:"text"`
}

func (entity *StorePaymentPurposePremiumGiftCodes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposePremiumGiftCodes

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposePremiumGiftCodes) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposePremiumGiftCodes) GetType() string {
	return TypeStorePaymentPurposePremiumGiftCodes
}

func (*StorePaymentPurposePremiumGiftCodes) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposePremiumGiftCodes
}

// The user creating a Telegram Premium giveaway
type StorePaymentPurposePremiumGiveaway struct {
	meta
	// Giveaway parameters
	Parameters *GiveawayParameters `json:"parameters"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
}

func (entity *StorePaymentPurposePremiumGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposePremiumGiveaway

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposePremiumGiveaway) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposePremiumGiveaway) GetType() string {
	return TypeStorePaymentPurposePremiumGiveaway
}

func (*StorePaymentPurposePremiumGiveaway) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposePremiumGiveaway
}

// The user creating a Telegram Star giveaway
type StorePaymentPurposeStarGiveaway struct {
	meta
	// Giveaway parameters
	Parameters *GiveawayParameters `json:"parameters"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// The number of users to receive Telegram Stars
	WinnerCount int32 `json:"winner_count"`
	// The number of Telegram Stars to be distributed through the giveaway
	StarCount int64 `json:"star_count"`
}

func (entity *StorePaymentPurposeStarGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposeStarGiveaway

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposeStarGiveaway) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposeStarGiveaway) GetType() string {
	return TypeStorePaymentPurposeStarGiveaway
}

func (*StorePaymentPurposeStarGiveaway) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposeStarGiveaway
}

// The user buying Telegram Stars
type StorePaymentPurposeStars struct {
	meta
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of bought Telegram Stars
	StarCount int64 `json:"star_count"`
}

func (entity *StorePaymentPurposeStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposeStars

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposeStars) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposeStars) GetType() string {
	return TypeStorePaymentPurposeStars
}

func (*StorePaymentPurposeStars) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposeStars
}

// The user buying Telegram Stars for other users
type StorePaymentPurposeGiftedStars struct {
	meta
	// Identifier of the user to which Telegram Stars are gifted
	UserId int64 `json:"user_id"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of bought Telegram Stars
	StarCount int64 `json:"star_count"`
}

func (entity *StorePaymentPurposeGiftedStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorePaymentPurposeGiftedStars

	return json.Marshal((*stub)(entity))
}

func (*StorePaymentPurposeGiftedStars) GetClass() string {
	return ClassStorePaymentPurpose
}

func (*StorePaymentPurposeGiftedStars) GetType() string {
	return TypeStorePaymentPurposeGiftedStars
}

func (*StorePaymentPurposeGiftedStars) StorePaymentPurposeType() string {
	return TypeStorePaymentPurposeGiftedStars
}

// The user creating Telegram Premium gift codes for other users
type TelegramPaymentPurposePremiumGiftCodes struct {
	meta
	// Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
	BoostedChatId int64 `json:"boosted_chat_id"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Identifiers of the users which can activate the gift codes
	UserIds []int64 `json:"user_ids"`
	// Number of months the Telegram Premium subscription will be active for the users
	MonthCount int32 `json:"month_count"`
	// Text to show along with the gift codes; 0-getOption("gift_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed
	Text *FormattedText `json:"text"`
}

func (entity *TelegramPaymentPurposePremiumGiftCodes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TelegramPaymentPurposePremiumGiftCodes

	return json.Marshal((*stub)(entity))
}

func (*TelegramPaymentPurposePremiumGiftCodes) GetClass() string {
	return ClassTelegramPaymentPurpose
}

func (*TelegramPaymentPurposePremiumGiftCodes) GetType() string {
	return TypeTelegramPaymentPurposePremiumGiftCodes
}

func (*TelegramPaymentPurposePremiumGiftCodes) TelegramPaymentPurposeType() string {
	return TypeTelegramPaymentPurposePremiumGiftCodes
}

// The user creating a Telegram Premium giveaway
type TelegramPaymentPurposePremiumGiveaway struct {
	meta
	// Giveaway parameters
	Parameters *GiveawayParameters `json:"parameters"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of users which will be able to activate the gift codes
	WinnerCount int32 `json:"winner_count"`
	// Number of months the Telegram Premium subscription will be active for the users
	MonthCount int32 `json:"month_count"`
}

func (entity *TelegramPaymentPurposePremiumGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TelegramPaymentPurposePremiumGiveaway

	return json.Marshal((*stub)(entity))
}

func (*TelegramPaymentPurposePremiumGiveaway) GetClass() string {
	return ClassTelegramPaymentPurpose
}

func (*TelegramPaymentPurposePremiumGiveaway) GetType() string {
	return TypeTelegramPaymentPurposePremiumGiveaway
}

func (*TelegramPaymentPurposePremiumGiveaway) TelegramPaymentPurposeType() string {
	return TypeTelegramPaymentPurposePremiumGiveaway
}

// The user buying Telegram Stars
type TelegramPaymentPurposeStars struct {
	meta
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of bought Telegram Stars
	StarCount int64 `json:"star_count"`
}

func (entity *TelegramPaymentPurposeStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TelegramPaymentPurposeStars

	return json.Marshal((*stub)(entity))
}

func (*TelegramPaymentPurposeStars) GetClass() string {
	return ClassTelegramPaymentPurpose
}

func (*TelegramPaymentPurposeStars) GetType() string {
	return TypeTelegramPaymentPurposeStars
}

func (*TelegramPaymentPurposeStars) TelegramPaymentPurposeType() string {
	return TypeTelegramPaymentPurposeStars
}

// The user buying Telegram Stars for other users
type TelegramPaymentPurposeGiftedStars struct {
	meta
	// Identifier of the user to which Telegram Stars are gifted
	UserId int64 `json:"user_id"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// Number of bought Telegram Stars
	StarCount int64 `json:"star_count"`
}

func (entity *TelegramPaymentPurposeGiftedStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TelegramPaymentPurposeGiftedStars

	return json.Marshal((*stub)(entity))
}

func (*TelegramPaymentPurposeGiftedStars) GetClass() string {
	return ClassTelegramPaymentPurpose
}

func (*TelegramPaymentPurposeGiftedStars) GetType() string {
	return TypeTelegramPaymentPurposeGiftedStars
}

func (*TelegramPaymentPurposeGiftedStars) TelegramPaymentPurposeType() string {
	return TypeTelegramPaymentPurposeGiftedStars
}

// The user creating a Telegram Star giveaway
type TelegramPaymentPurposeStarGiveaway struct {
	meta
	// Giveaway parameters
	Parameters *GiveawayParameters `json:"parameters"`
	// ISO 4217 currency code of the payment currency
	Currency string `json:"currency"`
	// Paid amount, in the smallest units of the currency
	Amount int64 `json:"amount"`
	// The number of users to receive Telegram Stars
	WinnerCount int32 `json:"winner_count"`
	// The number of Telegram Stars to be distributed through the giveaway
	StarCount int64 `json:"star_count"`
}

func (entity *TelegramPaymentPurposeStarGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TelegramPaymentPurposeStarGiveaway

	return json.Marshal((*stub)(entity))
}

func (*TelegramPaymentPurposeStarGiveaway) GetClass() string {
	return ClassTelegramPaymentPurpose
}

func (*TelegramPaymentPurposeStarGiveaway) GetType() string {
	return TypeTelegramPaymentPurposeStarGiveaway
}

func (*TelegramPaymentPurposeStarGiveaway) TelegramPaymentPurposeType() string {
	return TypeTelegramPaymentPurposeStarGiveaway
}

// The user joins a chat and subscribes to regular payments in Telegram Stars
type TelegramPaymentPurposeJoinChat struct {
	meta
	// Invite link to use
	InviteLink string `json:"invite_link"`
}

func (entity *TelegramPaymentPurposeJoinChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TelegramPaymentPurposeJoinChat

	return json.Marshal((*stub)(entity))
}

func (*TelegramPaymentPurposeJoinChat) GetClass() string {
	return ClassTelegramPaymentPurpose
}

func (*TelegramPaymentPurposeJoinChat) GetType() string {
	return TypeTelegramPaymentPurposeJoinChat
}

func (*TelegramPaymentPurposeJoinChat) TelegramPaymentPurposeType() string {
	return TypeTelegramPaymentPurposeJoinChat
}

// A token for Firebase Cloud Messaging
type DeviceTokenFirebaseCloudMessaging struct {
	meta
	// Device registration token; may be empty to deregister a device
	Token string `json:"token"`
	// True, if push notifications must be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenFirebaseCloudMessaging) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenFirebaseCloudMessaging

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenFirebaseCloudMessaging) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenFirebaseCloudMessaging) GetType() string {
	return TypeDeviceTokenFirebaseCloudMessaging
}

func (*DeviceTokenFirebaseCloudMessaging) DeviceTokenType() string {
	return TypeDeviceTokenFirebaseCloudMessaging
}

// A token for Apple Push Notification service
type DeviceTokenApplePush struct {
	meta
	// Device token; may be empty to deregister a device
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
}

func (entity *DeviceTokenApplePush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenApplePush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenApplePush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenApplePush) GetType() string {
	return TypeDeviceTokenApplePush
}

func (*DeviceTokenApplePush) DeviceTokenType() string {
	return TypeDeviceTokenApplePush
}

// A token for Apple Push Notification service VoIP notifications
type DeviceTokenApplePushVoIP struct {
	meta
	// Device token; may be empty to deregister a device
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
	// True, if push notifications must be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenApplePushVoIP) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenApplePushVoIP

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenApplePushVoIP) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenApplePushVoIP) GetType() string {
	return TypeDeviceTokenApplePushVoIP
}

func (*DeviceTokenApplePushVoIP) DeviceTokenType() string {
	return TypeDeviceTokenApplePushVoIP
}

// A token for Windows Push Notification Services
type DeviceTokenWindowsPush struct {
	meta
	// The access token that will be used to send notifications; may be empty to deregister a device
	AccessToken string `json:"access_token"`
}

func (entity *DeviceTokenWindowsPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenWindowsPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenWindowsPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenWindowsPush) GetType() string {
	return TypeDeviceTokenWindowsPush
}

func (*DeviceTokenWindowsPush) DeviceTokenType() string {
	return TypeDeviceTokenWindowsPush
}

// A token for Microsoft Push Notification Service
type DeviceTokenMicrosoftPush struct {
	meta
	// Push notification channel URI; may be empty to deregister a device
	ChannelUri string `json:"channel_uri"`
}

func (entity *DeviceTokenMicrosoftPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenMicrosoftPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenMicrosoftPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenMicrosoftPush) GetType() string {
	return TypeDeviceTokenMicrosoftPush
}

func (*DeviceTokenMicrosoftPush) DeviceTokenType() string {
	return TypeDeviceTokenMicrosoftPush
}

// A token for Microsoft Push Notification Service VoIP channel
type DeviceTokenMicrosoftPushVoIP struct {
	meta
	// Push notification channel URI; may be empty to deregister a device
	ChannelUri string `json:"channel_uri"`
}

func (entity *DeviceTokenMicrosoftPushVoIP) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenMicrosoftPushVoIP

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenMicrosoftPushVoIP) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenMicrosoftPushVoIP) GetType() string {
	return TypeDeviceTokenMicrosoftPushVoIP
}

func (*DeviceTokenMicrosoftPushVoIP) DeviceTokenType() string {
	return TypeDeviceTokenMicrosoftPushVoIP
}

// A token for web Push API
type DeviceTokenWebPush struct {
	meta
	// Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
	Endpoint string `json:"endpoint"`
	// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
	P256dhBase64url string `json:"p256dh_base64url"`
	// Base64url-encoded authentication secret
	AuthBase64url string `json:"auth_base64url"`
}

func (entity *DeviceTokenWebPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenWebPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenWebPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenWebPush) GetType() string {
	return TypeDeviceTokenWebPush
}

func (*DeviceTokenWebPush) DeviceTokenType() string {
	return TypeDeviceTokenWebPush
}

// A token for Simple Push API for Firefox OS
type DeviceTokenSimplePush struct {
	meta
	// Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
	Endpoint string `json:"endpoint"`
}

func (entity *DeviceTokenSimplePush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenSimplePush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenSimplePush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenSimplePush) GetType() string {
	return TypeDeviceTokenSimplePush
}

func (*DeviceTokenSimplePush) DeviceTokenType() string {
	return TypeDeviceTokenSimplePush
}

// A token for Ubuntu Push Client service
type DeviceTokenUbuntuPush struct {
	meta
	// Token; may be empty to deregister a device
	Token string `json:"token"`
}

func (entity *DeviceTokenUbuntuPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenUbuntuPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenUbuntuPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenUbuntuPush) GetType() string {
	return TypeDeviceTokenUbuntuPush
}

func (*DeviceTokenUbuntuPush) DeviceTokenType() string {
	return TypeDeviceTokenUbuntuPush
}

// A token for BlackBerry Push Service
type DeviceTokenBlackBerryPush struct {
	meta
	// Token; may be empty to deregister a device
	Token string `json:"token"`
}

func (entity *DeviceTokenBlackBerryPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenBlackBerryPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenBlackBerryPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenBlackBerryPush) GetType() string {
	return TypeDeviceTokenBlackBerryPush
}

func (*DeviceTokenBlackBerryPush) DeviceTokenType() string {
	return TypeDeviceTokenBlackBerryPush
}

// A token for Tizen Push Service
type DeviceTokenTizenPush struct {
	meta
	// Push service registration identifier; may be empty to deregister a device
	RegId string `json:"reg_id"`
}

func (entity *DeviceTokenTizenPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenTizenPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenTizenPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenTizenPush) GetType() string {
	return TypeDeviceTokenTizenPush
}

func (*DeviceTokenTizenPush) DeviceTokenType() string {
	return TypeDeviceTokenTizenPush
}

// A token for HUAWEI Push Service
type DeviceTokenHuaweiPush struct {
	meta
	// Device registration token; may be empty to deregister a device
	Token string `json:"token"`
	// True, if push notifications must be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenHuaweiPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenHuaweiPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenHuaweiPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenHuaweiPush) GetType() string {
	return TypeDeviceTokenHuaweiPush
}

func (*DeviceTokenHuaweiPush) DeviceTokenType() string {
	return TypeDeviceTokenHuaweiPush
}

// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
type PushReceiverId struct {
	meta
	// The globally unique identifier of push notification subscription
	Id JsonInt64 `json:"id"`
}

func (entity *PushReceiverId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushReceiverId

	return json.Marshal((*stub)(entity))
}

func (*PushReceiverId) GetClass() string {
	return ClassPushReceiverId
}

func (*PushReceiverId) GetType() string {
	return TypePushReceiverId
}

// Describes a solid fill of a background
type BackgroundFillSolid struct {
	meta
	// A color of the background in the RGB format
	Color int32 `json:"color"`
}

func (entity *BackgroundFillSolid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillSolid

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillSolid) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillSolid) GetType() string {
	return TypeBackgroundFillSolid
}

func (*BackgroundFillSolid) BackgroundFillType() string {
	return TypeBackgroundFillSolid
}

// Describes a gradient fill of a background
type BackgroundFillGradient struct {
	meta
	// A top color of the background in the RGB format
	TopColor int32 `json:"top_color"`
	// A bottom color of the background in the RGB format
	BottomColor int32 `json:"bottom_color"`
	// Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
	RotationAngle int32 `json:"rotation_angle"`
}

func (entity *BackgroundFillGradient) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillGradient

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillGradient) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillGradient) GetType() string {
	return TypeBackgroundFillGradient
}

func (*BackgroundFillGradient) BackgroundFillType() string {
	return TypeBackgroundFillGradient
}

// Describes a freeform gradient fill of a background
type BackgroundFillFreeformGradient struct {
	meta
	// A list of 3 or 4 colors of the freeform gradient in the RGB format
	Colors []int32 `json:"colors"`
}

func (entity *BackgroundFillFreeformGradient) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillFreeformGradient

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillFreeformGradient) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillFreeformGradient) GetType() string {
	return TypeBackgroundFillFreeformGradient
}

func (*BackgroundFillFreeformGradient) BackgroundFillType() string {
	return TypeBackgroundFillFreeformGradient
}

// A wallpaper in JPEG format
type BackgroundTypeWallpaper struct {
	meta
	// True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
	IsBlurred bool `json:"is_blurred"`
	// True, if the background needs to be slightly moved when device is tilted
	IsMoving bool `json:"is_moving"`
}

func (entity *BackgroundTypeWallpaper) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeWallpaper

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeWallpaper) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeWallpaper) GetType() string {
	return TypeBackgroundTypeWallpaper
}

func (*BackgroundTypeWallpaper) BackgroundTypeType() string {
	return TypeBackgroundTypeWallpaper
}

// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
type BackgroundTypePattern struct {
	meta
	// Fill of the background
	Fill BackgroundFill `json:"fill"`
	// Intensity of the pattern when it is shown above the filled background; 0-100
	Intensity int32 `json:"intensity"`
	// True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
	IsInverted bool `json:"is_inverted"`
	// True, if the background needs to be slightly moved when device is tilted
	IsMoving bool `json:"is_moving"`
}

func (entity *BackgroundTypePattern) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypePattern

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypePattern) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypePattern) GetType() string {
	return TypeBackgroundTypePattern
}

func (*BackgroundTypePattern) BackgroundTypeType() string {
	return TypeBackgroundTypePattern
}

func (backgroundTypePattern *BackgroundTypePattern) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Fill       json.RawMessage `json:"fill"`
		Intensity  int32           `json:"intensity"`
		IsInverted bool            `json:"is_inverted"`
		IsMoving   bool            `json:"is_moving"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	backgroundTypePattern.Intensity = tmp.Intensity
	backgroundTypePattern.IsInverted = tmp.IsInverted
	backgroundTypePattern.IsMoving = tmp.IsMoving

	fieldFill, _ := UnmarshalBackgroundFill(tmp.Fill)
	backgroundTypePattern.Fill = fieldFill

	return nil
}

// A filled background
type BackgroundTypeFill struct {
	meta
	// The background fill
	Fill BackgroundFill `json:"fill"`
}

func (entity *BackgroundTypeFill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeFill

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeFill) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeFill) GetType() string {
	return TypeBackgroundTypeFill
}

func (*BackgroundTypeFill) BackgroundTypeType() string {
	return TypeBackgroundTypeFill
}

func (backgroundTypeFill *BackgroundTypeFill) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Fill json.RawMessage `json:"fill"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFill, _ := UnmarshalBackgroundFill(tmp.Fill)
	backgroundTypeFill.Fill = fieldFill

	return nil
}

// A background from a chat theme; can be used only as a chat background in channels
type BackgroundTypeChatTheme struct {
	meta
	// Name of the chat theme
	ThemeName string `json:"theme_name"`
}

func (entity *BackgroundTypeChatTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeChatTheme

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeChatTheme) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeChatTheme) GetType() string {
	return TypeBackgroundTypeChatTheme
}

func (*BackgroundTypeChatTheme) BackgroundTypeType() string {
	return TypeBackgroundTypeChatTheme
}

// A background from a local file
type InputBackgroundLocal struct {
	meta
	// Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
	Background InputFile `json:"background"`
}

func (entity *InputBackgroundLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundLocal

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundLocal) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundLocal) GetType() string {
	return TypeInputBackgroundLocal
}

func (*InputBackgroundLocal) InputBackgroundType() string {
	return TypeInputBackgroundLocal
}

func (inputBackgroundLocal *InputBackgroundLocal) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Background json.RawMessage `json:"background"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldBackground, _ := UnmarshalInputFile(tmp.Background)
	inputBackgroundLocal.Background = fieldBackground

	return nil
}

// A background from the server
type InputBackgroundRemote struct {
	meta
	// The background identifier
	BackgroundId JsonInt64 `json:"background_id"`
}

func (entity *InputBackgroundRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundRemote

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundRemote) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundRemote) GetType() string {
	return TypeInputBackgroundRemote
}

func (*InputBackgroundRemote) InputBackgroundType() string {
	return TypeInputBackgroundRemote
}

// A background previously set in the chat; for chat backgrounds only
type InputBackgroundPrevious struct {
	meta
	// Identifier of the message with the background
	MessageId int64 `json:"message_id"`
}

func (entity *InputBackgroundPrevious) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundPrevious

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundPrevious) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundPrevious) GetType() string {
	return TypeInputBackgroundPrevious
}

func (*InputBackgroundPrevious) InputBackgroundType() string {
	return TypeInputBackgroundPrevious
}

// Describes a chat theme
type ChatTheme struct {
	meta
	// Theme name
	Name string `json:"name"`
	// Theme settings for a light chat theme
	LightSettings *ThemeSettings `json:"light_settings"`
	// Theme settings for a dark chat theme
	DarkSettings *ThemeSettings `json:"dark_settings"`
}

func (entity *ChatTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTheme

	return json.Marshal((*stub)(entity))
}

func (*ChatTheme) GetClass() string {
	return ClassChatTheme
}

func (*ChatTheme) GetType() string {
	return TypeChatTheme
}

// Describes a time zone
type TimeZone struct {
	meta
	// Unique time zone identifier
	Id string `json:"id"`
	// Time zone name
	Name string `json:"name"`
	// Current UTC time offset for the time zone
	UtcTimeOffset int32 `json:"utc_time_offset"`
}

func (entity *TimeZone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TimeZone

	return json.Marshal((*stub)(entity))
}

func (*TimeZone) GetClass() string {
	return ClassTimeZone
}

func (*TimeZone) GetType() string {
	return TypeTimeZone
}

// Contains a list of time zones
type TimeZones struct {
	meta
	// A list of time zones
	TimeZones []*TimeZone `json:"time_zones"`
}

func (entity *TimeZones) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TimeZones

	return json.Marshal((*stub)(entity))
}

func (*TimeZones) GetClass() string {
	return ClassTimeZones
}

func (*TimeZones) GetType() string {
	return TypeTimeZones
}

// Contains a list of hashtags
type Hashtags struct {
	meta
	// A list of hashtags
	Hashtags []string `json:"hashtags"`
}

func (entity *Hashtags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Hashtags

	return json.Marshal((*stub)(entity))
}

func (*Hashtags) GetClass() string {
	return ClassHashtags
}

func (*Hashtags) GetType() string {
	return TypeHashtags
}

// A story can be sent
type CanSendStoryResultOk struct {
	meta
}

func (entity *CanSendStoryResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendStoryResultOk

	return json.Marshal((*stub)(entity))
}

func (*CanSendStoryResultOk) GetClass() string {
	return ClassCanSendStoryResult
}

func (*CanSendStoryResultOk) GetType() string {
	return TypeCanSendStoryResultOk
}

func (*CanSendStoryResultOk) CanSendStoryResultType() string {
	return TypeCanSendStoryResultOk
}

// The user must subscribe to Telegram Premium to be able to post stories
type CanSendStoryResultPremiumNeeded struct {
	meta
}

func (entity *CanSendStoryResultPremiumNeeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendStoryResultPremiumNeeded

	return json.Marshal((*stub)(entity))
}

func (*CanSendStoryResultPremiumNeeded) GetClass() string {
	return ClassCanSendStoryResult
}

func (*CanSendStoryResultPremiumNeeded) GetType() string {
	return TypeCanSendStoryResultPremiumNeeded
}

func (*CanSendStoryResultPremiumNeeded) CanSendStoryResultType() string {
	return TypeCanSendStoryResultPremiumNeeded
}

// The chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat
type CanSendStoryResultBoostNeeded struct {
	meta
}

func (entity *CanSendStoryResultBoostNeeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendStoryResultBoostNeeded

	return json.Marshal((*stub)(entity))
}

func (*CanSendStoryResultBoostNeeded) GetClass() string {
	return ClassCanSendStoryResult
}

func (*CanSendStoryResultBoostNeeded) GetType() string {
	return TypeCanSendStoryResultBoostNeeded
}

func (*CanSendStoryResultBoostNeeded) CanSendStoryResultType() string {
	return TypeCanSendStoryResultBoostNeeded
}

// The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire
type CanSendStoryResultActiveStoryLimitExceeded struct {
	meta
}

func (entity *CanSendStoryResultActiveStoryLimitExceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendStoryResultActiveStoryLimitExceeded

	return json.Marshal((*stub)(entity))
}

func (*CanSendStoryResultActiveStoryLimitExceeded) GetClass() string {
	return ClassCanSendStoryResult
}

func (*CanSendStoryResultActiveStoryLimitExceeded) GetType() string {
	return TypeCanSendStoryResultActiveStoryLimitExceeded
}

func (*CanSendStoryResultActiveStoryLimitExceeded) CanSendStoryResultType() string {
	return TypeCanSendStoryResultActiveStoryLimitExceeded
}

// The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
type CanSendStoryResultWeeklyLimitExceeded struct {
	meta
	// Time left before the user can send the next story
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanSendStoryResultWeeklyLimitExceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendStoryResultWeeklyLimitExceeded

	return json.Marshal((*stub)(entity))
}

func (*CanSendStoryResultWeeklyLimitExceeded) GetClass() string {
	return ClassCanSendStoryResult
}

func (*CanSendStoryResultWeeklyLimitExceeded) GetType() string {
	return TypeCanSendStoryResultWeeklyLimitExceeded
}

func (*CanSendStoryResultWeeklyLimitExceeded) CanSendStoryResultType() string {
	return TypeCanSendStoryResultWeeklyLimitExceeded
}

// The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
type CanSendStoryResultMonthlyLimitExceeded struct {
	meta
	// Time left before the user can send the next story
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanSendStoryResultMonthlyLimitExceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendStoryResultMonthlyLimitExceeded

	return json.Marshal((*stub)(entity))
}

func (*CanSendStoryResultMonthlyLimitExceeded) GetClass() string {
	return ClassCanSendStoryResult
}

func (*CanSendStoryResultMonthlyLimitExceeded) GetType() string {
	return TypeCanSendStoryResultMonthlyLimitExceeded
}

func (*CanSendStoryResultMonthlyLimitExceeded) CanSendStoryResultType() string {
	return TypeCanSendStoryResultMonthlyLimitExceeded
}

// The session can be used
type CanTransferOwnershipResultOk struct {
	meta
}

func (entity *CanTransferOwnershipResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultOk

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultOk) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultOk) GetType() string {
	return TypeCanTransferOwnershipResultOk
}

func (*CanTransferOwnershipResultOk) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultOk
}

// The 2-step verification needs to be enabled first
type CanTransferOwnershipResultPasswordNeeded struct {
	meta
}

func (entity *CanTransferOwnershipResultPasswordNeeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultPasswordNeeded

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultPasswordNeeded) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultPasswordNeeded) GetType() string {
	return TypeCanTransferOwnershipResultPasswordNeeded
}

func (*CanTransferOwnershipResultPasswordNeeded) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultPasswordNeeded
}

// The 2-step verification was enabled recently, user needs to wait
type CanTransferOwnershipResultPasswordTooFresh struct {
	meta
	// Time left before the session can be used to transfer ownership of a chat, in seconds
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanTransferOwnershipResultPasswordTooFresh) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultPasswordTooFresh

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultPasswordTooFresh) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultPasswordTooFresh) GetType() string {
	return TypeCanTransferOwnershipResultPasswordTooFresh
}

func (*CanTransferOwnershipResultPasswordTooFresh) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultPasswordTooFresh
}

// The session was created recently, user needs to wait
type CanTransferOwnershipResultSessionTooFresh struct {
	meta
	// Time left before the session can be used to transfer ownership of a chat, in seconds
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanTransferOwnershipResultSessionTooFresh) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultSessionTooFresh

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultSessionTooFresh) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultSessionTooFresh) GetType() string {
	return TypeCanTransferOwnershipResultSessionTooFresh
}

func (*CanTransferOwnershipResultSessionTooFresh) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultSessionTooFresh
}

// The username can be set
type CheckChatUsernameResultOk struct {
	meta
}

func (entity *CheckChatUsernameResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultOk

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultOk) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultOk) GetType() string {
	return TypeCheckChatUsernameResultOk
}

func (*CheckChatUsernameResultOk) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultOk
}

// The username is invalid
type CheckChatUsernameResultUsernameInvalid struct {
	meta
}

func (entity *CheckChatUsernameResultUsernameInvalid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernameInvalid

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernameInvalid) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernameInvalid) GetType() string {
	return TypeCheckChatUsernameResultUsernameInvalid
}

func (*CheckChatUsernameResultUsernameInvalid) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernameInvalid
}

// The username is occupied
type CheckChatUsernameResultUsernameOccupied struct {
	meta
}

func (entity *CheckChatUsernameResultUsernameOccupied) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernameOccupied

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernameOccupied) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernameOccupied) GetType() string {
	return TypeCheckChatUsernameResultUsernameOccupied
}

func (*CheckChatUsernameResultUsernameOccupied) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernameOccupied
}

// The username can be purchased at https://fragment.com. Information about the username can be received using getCollectibleItemInfo
type CheckChatUsernameResultUsernamePurchasable struct {
	meta
}

func (entity *CheckChatUsernameResultUsernamePurchasable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernamePurchasable

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernamePurchasable) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernamePurchasable) GetType() string {
	return TypeCheckChatUsernameResultUsernamePurchasable
}

func (*CheckChatUsernameResultUsernamePurchasable) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernamePurchasable
}

// The user has too many chats with username, one of them must be made private first
type CheckChatUsernameResultPublicChatsTooMany struct {
	meta
}

func (entity *CheckChatUsernameResultPublicChatsTooMany) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultPublicChatsTooMany

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultPublicChatsTooMany) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultPublicChatsTooMany) GetType() string {
	return TypeCheckChatUsernameResultPublicChatsTooMany
}

func (*CheckChatUsernameResultPublicChatsTooMany) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultPublicChatsTooMany
}

// The user can't be a member of a public supergroup
type CheckChatUsernameResultPublicGroupsUnavailable struct {
	meta
}

func (entity *CheckChatUsernameResultPublicGroupsUnavailable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultPublicGroupsUnavailable

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) GetType() string {
	return TypeCheckChatUsernameResultPublicGroupsUnavailable
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultPublicGroupsUnavailable
}

// The name can be set
type CheckStickerSetNameResultOk struct {
	meta
}

func (entity *CheckStickerSetNameResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckStickerSetNameResultOk

	return json.Marshal((*stub)(entity))
}

func (*CheckStickerSetNameResultOk) GetClass() string {
	return ClassCheckStickerSetNameResult
}

func (*CheckStickerSetNameResultOk) GetType() string {
	return TypeCheckStickerSetNameResultOk
}

func (*CheckStickerSetNameResultOk) CheckStickerSetNameResultType() string {
	return TypeCheckStickerSetNameResultOk
}

// The name is invalid
type CheckStickerSetNameResultNameInvalid struct {
	meta
}

func (entity *CheckStickerSetNameResultNameInvalid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckStickerSetNameResultNameInvalid

	return json.Marshal((*stub)(entity))
}

func (*CheckStickerSetNameResultNameInvalid) GetClass() string {
	return ClassCheckStickerSetNameResult
}

func (*CheckStickerSetNameResultNameInvalid) GetType() string {
	return TypeCheckStickerSetNameResultNameInvalid
}

func (*CheckStickerSetNameResultNameInvalid) CheckStickerSetNameResultType() string {
	return TypeCheckStickerSetNameResultNameInvalid
}

// The name is occupied
type CheckStickerSetNameResultNameOccupied struct {
	meta
}

func (entity *CheckStickerSetNameResultNameOccupied) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckStickerSetNameResultNameOccupied

	return json.Marshal((*stub)(entity))
}

func (*CheckStickerSetNameResultNameOccupied) GetClass() string {
	return ClassCheckStickerSetNameResult
}

func (*CheckStickerSetNameResultNameOccupied) GetType() string {
	return TypeCheckStickerSetNameResultNameOccupied
}

func (*CheckStickerSetNameResultNameOccupied) CheckStickerSetNameResultType() string {
	return TypeCheckStickerSetNameResultNameOccupied
}

// The password was reset
type ResetPasswordResultOk struct {
	meta
}

func (entity *ResetPasswordResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResetPasswordResultOk

	return json.Marshal((*stub)(entity))
}

func (*ResetPasswordResultOk) GetClass() string {
	return ClassResetPasswordResult
}

func (*ResetPasswordResultOk) GetType() string {
	return TypeResetPasswordResultOk
}

func (*ResetPasswordResultOk) ResetPasswordResultType() string {
	return TypeResetPasswordResultOk
}

// The password reset request is pending
type ResetPasswordResultPending struct {
	meta
	// Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
	PendingResetDate int32 `json:"pending_reset_date"`
}

func (entity *ResetPasswordResultPending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResetPasswordResultPending

	return json.Marshal((*stub)(entity))
}

func (*ResetPasswordResultPending) GetClass() string {
	return ClassResetPasswordResult
}

func (*ResetPasswordResultPending) GetType() string {
	return TypeResetPasswordResultPending
}

func (*ResetPasswordResultPending) ResetPasswordResultType() string {
	return TypeResetPasswordResultPending
}

// The password reset request was declined
type ResetPasswordResultDeclined struct {
	meta
	// Point in time (Unix timestamp) when the password reset can be retried
	RetryDate int32 `json:"retry_date"`
}

func (entity *ResetPasswordResultDeclined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ResetPasswordResultDeclined

	return json.Marshal((*stub)(entity))
}

func (*ResetPasswordResultDeclined) GetClass() string {
	return ClassResetPasswordResult
}

func (*ResetPasswordResultDeclined) GetType() string {
	return TypeResetPasswordResultDeclined
}

func (*ResetPasswordResultDeclined) ResetPasswordResultType() string {
	return TypeResetPasswordResultDeclined
}

// The messages were exported from a private chat
type MessageFileTypePrivate struct {
	meta
	// Name of the other party; may be empty if unrecognized
	Name string `json:"name"`
}

func (entity *MessageFileTypePrivate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageFileTypePrivate

	return json.Marshal((*stub)(entity))
}

func (*MessageFileTypePrivate) GetClass() string {
	return ClassMessageFileType
}

func (*MessageFileTypePrivate) GetType() string {
	return TypeMessageFileTypePrivate
}

func (*MessageFileTypePrivate) MessageFileTypeType() string {
	return TypeMessageFileTypePrivate
}

// The messages were exported from a group chat
type MessageFileTypeGroup struct {
	meta
	// Title of the group chat; may be empty if unrecognized
	Title string `json:"title"`
}

func (entity *MessageFileTypeGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageFileTypeGroup

	return json.Marshal((*stub)(entity))
}

func (*MessageFileTypeGroup) GetClass() string {
	return ClassMessageFileType
}

func (*MessageFileTypeGroup) GetType() string {
	return TypeMessageFileTypeGroup
}

func (*MessageFileTypeGroup) MessageFileTypeType() string {
	return TypeMessageFileTypeGroup
}

// The messages were exported from a chat of unknown type
type MessageFileTypeUnknown struct {
	meta
}

func (entity *MessageFileTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageFileTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*MessageFileTypeUnknown) GetClass() string {
	return ClassMessageFileType
}

func (*MessageFileTypeUnknown) GetType() string {
	return TypeMessageFileTypeUnknown
}

func (*MessageFileTypeUnknown) MessageFileTypeType() string {
	return TypeMessageFileTypeUnknown
}

// A general message with hidden content
type PushMessageContentHidden struct {
	meta
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentHidden

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentHidden) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentHidden) GetType() string {
	return TypePushMessageContentHidden
}

func (*PushMessageContentHidden) PushMessageContentType() string {
	return TypePushMessageContentHidden
}

// An animation message (GIF-style).
type PushMessageContentAnimation struct {
	meta
	// Message content; may be null
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption string `json:"caption"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentAnimation

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentAnimation) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentAnimation) GetType() string {
	return TypePushMessageContentAnimation
}

func (*PushMessageContentAnimation) PushMessageContentType() string {
	return TypePushMessageContentAnimation
}

// An audio message
type PushMessageContentAudio struct {
	meta
	// Message content; may be null
	Audio *Audio `json:"audio"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentAudio

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentAudio) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentAudio) GetType() string {
	return TypePushMessageContentAudio
}

func (*PushMessageContentAudio) PushMessageContentType() string {
	return TypePushMessageContentAudio
}

// A message with a user contact
type PushMessageContentContact struct {
	meta
	// Contact's name
	Name string `json:"name"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentContact

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentContact) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentContact) GetType() string {
	return TypePushMessageContentContact
}

func (*PushMessageContentContact) PushMessageContentType() string {
	return TypePushMessageContentContact
}

// A contact has registered with Telegram
type PushMessageContentContactRegistered struct {
	meta
}

func (entity *PushMessageContentContactRegistered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentContactRegistered

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentContactRegistered) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentContactRegistered) GetType() string {
	return TypePushMessageContentContactRegistered
}

func (*PushMessageContentContactRegistered) PushMessageContentType() string {
	return TypePushMessageContentContactRegistered
}

// A document message (a general file)
type PushMessageContentDocument struct {
	meta
	// Message content; may be null
	Document *Document `json:"document"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentDocument

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentDocument) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentDocument) GetType() string {
	return TypePushMessageContentDocument
}

func (*PushMessageContentDocument) PushMessageContentType() string {
	return TypePushMessageContentDocument
}

// A message with a game
type PushMessageContentGame struct {
	meta
	// Game title, empty for pinned game message
	Title string `json:"title"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGame

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGame) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGame) GetType() string {
	return TypePushMessageContentGame
}

func (*PushMessageContentGame) PushMessageContentType() string {
	return TypePushMessageContentGame
}

// A new high score was achieved in a game
type PushMessageContentGameScore struct {
	meta
	// Game title, empty for pinned message
	Title string `json:"title"`
	// New score, 0 for pinned message
	Score int32 `json:"score"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGameScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGameScore

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGameScore) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGameScore) GetType() string {
	return TypePushMessageContentGameScore
}

func (*PushMessageContentGameScore) PushMessageContentType() string {
	return TypePushMessageContentGameScore
}

// A message with an invoice from a bot
type PushMessageContentInvoice struct {
	meta
	// Product price
	Price string `json:"price"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentInvoice

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentInvoice) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentInvoice) GetType() string {
	return TypePushMessageContentInvoice
}

func (*PushMessageContentInvoice) PushMessageContentType() string {
	return TypePushMessageContentInvoice
}

// A message with a location
type PushMessageContentLocation struct {
	meta
	// True, if the location is live
	IsLive bool `json:"is_live"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentLocation

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentLocation) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentLocation) GetType() string {
	return TypePushMessageContentLocation
}

func (*PushMessageContentLocation) PushMessageContentType() string {
	return TypePushMessageContentLocation
}

// A message with paid media
type PushMessageContentPaidMedia struct {
	meta
	// Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message
	StarCount int64 `json:"star_count"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPaidMedia) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPaidMedia

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPaidMedia) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPaidMedia) GetType() string {
	return TypePushMessageContentPaidMedia
}

func (*PushMessageContentPaidMedia) PushMessageContentType() string {
	return TypePushMessageContentPaidMedia
}

// A photo message
type PushMessageContentPhoto struct {
	meta
	// Message content; may be null
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption string `json:"caption"`
	// True, if the photo is secret
	IsSecret bool `json:"is_secret"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPhoto) GetType() string {
	return TypePushMessageContentPhoto
}

func (*PushMessageContentPhoto) PushMessageContentType() string {
	return TypePushMessageContentPhoto
}

// A message with a poll
type PushMessageContentPoll struct {
	meta
	// Poll question
	Question string `json:"question"`
	// True, if the poll is regular and not in quiz mode
	IsRegular bool `json:"is_regular"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPoll

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPoll) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPoll) GetType() string {
	return TypePushMessageContentPoll
}

func (*PushMessageContentPoll) PushMessageContentType() string {
	return TypePushMessageContentPoll
}

// A message with a Telegram Premium gift code created for the user
type PushMessageContentPremiumGiftCode struct {
	meta
	// Number of months the Telegram Premium subscription will be active after code activation
	MonthCount int32 `json:"month_count"`
}

func (entity *PushMessageContentPremiumGiftCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPremiumGiftCode

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPremiumGiftCode) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPremiumGiftCode) GetType() string {
	return TypePushMessageContentPremiumGiftCode
}

func (*PushMessageContentPremiumGiftCode) PushMessageContentType() string {
	return TypePushMessageContentPremiumGiftCode
}

// A message with a giveaway
type PushMessageContentGiveaway struct {
	meta
	// Number of users which will receive giveaway prizes; 0 for pinned message
	WinnerCount int32 `json:"winner_count"`
	// Prize of the giveaway; may be null for pinned message
	Prize GiveawayPrize `json:"prize"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGiveaway) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGiveaway

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGiveaway) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGiveaway) GetType() string {
	return TypePushMessageContentGiveaway
}

func (*PushMessageContentGiveaway) PushMessageContentType() string {
	return TypePushMessageContentGiveaway
}

func (pushMessageContentGiveaway *PushMessageContentGiveaway) UnmarshalJSON(data []byte) error {
	var tmp struct {
		WinnerCount int32           `json:"winner_count"`
		Prize       json.RawMessage `json:"prize"`
		IsPinned    bool            `json:"is_pinned"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pushMessageContentGiveaway.WinnerCount = tmp.WinnerCount
	pushMessageContentGiveaway.IsPinned = tmp.IsPinned

	fieldPrize, _ := UnmarshalGiveawayPrize(tmp.Prize)
	pushMessageContentGiveaway.Prize = fieldPrize

	return nil
}

// A message with a gift
type PushMessageContentGift struct {
	meta
	// Number of Telegram Stars that sender paid for the gift
	StarCount int64 `json:"star_count"`
}

func (entity *PushMessageContentGift) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGift

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGift) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGift) GetType() string {
	return TypePushMessageContentGift
}

func (*PushMessageContentGift) PushMessageContentType() string {
	return TypePushMessageContentGift
}

// A screenshot of a message in the chat has been taken
type PushMessageContentScreenshotTaken struct {
	meta
}

func (entity *PushMessageContentScreenshotTaken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentScreenshotTaken

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentScreenshotTaken) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentScreenshotTaken) GetType() string {
	return TypePushMessageContentScreenshotTaken
}

func (*PushMessageContentScreenshotTaken) PushMessageContentType() string {
	return TypePushMessageContentScreenshotTaken
}

// A message with a sticker
type PushMessageContentSticker struct {
	meta
	// Message content; may be null
	Sticker *Sticker `json:"sticker"`
	// Emoji corresponding to the sticker; may be empty
	Emoji string `json:"emoji"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentSticker

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentSticker) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentSticker) GetType() string {
	return TypePushMessageContentSticker
}

func (*PushMessageContentSticker) PushMessageContentType() string {
	return TypePushMessageContentSticker
}

// A message with a story
type PushMessageContentStory struct {
	meta
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentStory

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentStory) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentStory) GetType() string {
	return TypePushMessageContentStory
}

func (*PushMessageContentStory) PushMessageContentType() string {
	return TypePushMessageContentStory
}

// A text message
type PushMessageContentText struct {
	meta
	// Message text
	Text string `json:"text"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentText

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentText) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentText) GetType() string {
	return TypePushMessageContentText
}

func (*PushMessageContentText) PushMessageContentType() string {
	return TypePushMessageContentText
}

// A video message
type PushMessageContentVideo struct {
	meta
	// Message content; may be null
	Video *Video `json:"video"`
	// Video caption
	Caption string `json:"caption"`
	// True, if the video is secret
	IsSecret bool `json:"is_secret"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVideo

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVideo) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVideo) GetType() string {
	return TypePushMessageContentVideo
}

func (*PushMessageContentVideo) PushMessageContentType() string {
	return TypePushMessageContentVideo
}

// A video note message
type PushMessageContentVideoNote struct {
	meta
	// Message content; may be null
	VideoNote *VideoNote `json:"video_note"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVideoNote

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVideoNote) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVideoNote) GetType() string {
	return TypePushMessageContentVideoNote
}

func (*PushMessageContentVideoNote) PushMessageContentType() string {
	return TypePushMessageContentVideoNote
}

// A voice note message
type PushMessageContentVoiceNote struct {
	meta
	// Message content; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVoiceNote) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVoiceNote) GetType() string {
	return TypePushMessageContentVoiceNote
}

func (*PushMessageContentVoiceNote) PushMessageContentType() string {
	return TypePushMessageContentVoiceNote
}

// A newly created basic group
type PushMessageContentBasicGroupChatCreate struct {
	meta
}

func (entity *PushMessageContentBasicGroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentBasicGroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentBasicGroupChatCreate) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentBasicGroupChatCreate) GetType() string {
	return TypePushMessageContentBasicGroupChatCreate
}

func (*PushMessageContentBasicGroupChatCreate) PushMessageContentType() string {
	return TypePushMessageContentBasicGroupChatCreate
}

// New chat members were invited to a group
type PushMessageContentChatAddMembers struct {
	meta
	// Name of the added member
	MemberName string `json:"member_name"`
	// True, if the current user was added to the group
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the user has returned to the group themselves
	IsReturned bool `json:"is_returned"`
}

func (entity *PushMessageContentChatAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatAddMembers

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatAddMembers) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatAddMembers) GetType() string {
	return TypePushMessageContentChatAddMembers
}

func (*PushMessageContentChatAddMembers) PushMessageContentType() string {
	return TypePushMessageContentChatAddMembers
}

// A chat photo was edited
type PushMessageContentChatChangePhoto struct {
	meta
}

func (entity *PushMessageContentChatChangePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatChangePhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatChangePhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatChangePhoto) GetType() string {
	return TypePushMessageContentChatChangePhoto
}

func (*PushMessageContentChatChangePhoto) PushMessageContentType() string {
	return TypePushMessageContentChatChangePhoto
}

// A chat title was edited
type PushMessageContentChatChangeTitle struct {
	meta
	// New chat title
	Title string `json:"title"`
}

func (entity *PushMessageContentChatChangeTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatChangeTitle

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatChangeTitle) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatChangeTitle) GetType() string {
	return TypePushMessageContentChatChangeTitle
}

func (*PushMessageContentChatChangeTitle) PushMessageContentType() string {
	return TypePushMessageContentChatChangeTitle
}

// A chat background was edited
type PushMessageContentChatSetBackground struct {
	meta
	// True, if the set background is the same as the background of the current user
	IsSame bool `json:"is_same"`
}

func (entity *PushMessageContentChatSetBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatSetBackground

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatSetBackground) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatSetBackground) GetType() string {
	return TypePushMessageContentChatSetBackground
}

func (*PushMessageContentChatSetBackground) PushMessageContentType() string {
	return TypePushMessageContentChatSetBackground
}

// A chat theme was edited
type PushMessageContentChatSetTheme struct {
	meta
	// If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
	ThemeName string `json:"theme_name"`
}

func (entity *PushMessageContentChatSetTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatSetTheme

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatSetTheme) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatSetTheme) GetType() string {
	return TypePushMessageContentChatSetTheme
}

func (*PushMessageContentChatSetTheme) PushMessageContentType() string {
	return TypePushMessageContentChatSetTheme
}

// A chat member was deleted
type PushMessageContentChatDeleteMember struct {
	meta
	// Name of the deleted member
	MemberName string `json:"member_name"`
	// True, if the current user was deleted from the group
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the user has left the group themselves
	IsLeft bool `json:"is_left"`
}

func (entity *PushMessageContentChatDeleteMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatDeleteMember

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatDeleteMember) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatDeleteMember) GetType() string {
	return TypePushMessageContentChatDeleteMember
}

func (*PushMessageContentChatDeleteMember) PushMessageContentType() string {
	return TypePushMessageContentChatDeleteMember
}

// A new member joined the chat via an invite link
type PushMessageContentChatJoinByLink struct {
	meta
}

func (entity *PushMessageContentChatJoinByLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatJoinByLink

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatJoinByLink) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatJoinByLink) GetType() string {
	return TypePushMessageContentChatJoinByLink
}

func (*PushMessageContentChatJoinByLink) PushMessageContentType() string {
	return TypePushMessageContentChatJoinByLink
}

// A new member was accepted to the chat by an administrator
type PushMessageContentChatJoinByRequest struct {
	meta
}

func (entity *PushMessageContentChatJoinByRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatJoinByRequest

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatJoinByRequest) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatJoinByRequest) GetType() string {
	return TypePushMessageContentChatJoinByRequest
}

func (*PushMessageContentChatJoinByRequest) PushMessageContentType() string {
	return TypePushMessageContentChatJoinByRequest
}

// A new recurring payment was made by the current user
type PushMessageContentRecurringPayment struct {
	meta
	// The paid amount
	Amount string `json:"amount"`
}

func (entity *PushMessageContentRecurringPayment) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentRecurringPayment

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentRecurringPayment) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentRecurringPayment) GetType() string {
	return TypePushMessageContentRecurringPayment
}

func (*PushMessageContentRecurringPayment) PushMessageContentType() string {
	return TypePushMessageContentRecurringPayment
}

// A profile photo was suggested to the user
type PushMessageContentSuggestProfilePhoto struct {
	meta
}

func (entity *PushMessageContentSuggestProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentSuggestProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentSuggestProfilePhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentSuggestProfilePhoto) GetType() string {
	return TypePushMessageContentSuggestProfilePhoto
}

func (*PushMessageContentSuggestProfilePhoto) PushMessageContentType() string {
	return TypePushMessageContentSuggestProfilePhoto
}

// A forwarded messages
type PushMessageContentMessageForwards struct {
	meta
	// Number of forwarded messages
	TotalCount int32 `json:"total_count"`
}

func (entity *PushMessageContentMessageForwards) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentMessageForwards

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentMessageForwards) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentMessageForwards) GetType() string {
	return TypePushMessageContentMessageForwards
}

func (*PushMessageContentMessageForwards) PushMessageContentType() string {
	return TypePushMessageContentMessageForwards
}

// A media album
type PushMessageContentMediaAlbum struct {
	meta
	// Number of messages in the album
	TotalCount int32 `json:"total_count"`
	// True, if the album has at least one photo
	HasPhotos bool `json:"has_photos"`
	// True, if the album has at least one video file
	HasVideos bool `json:"has_videos"`
	// True, if the album has at least one audio file
	HasAudios bool `json:"has_audios"`
	// True, if the album has at least one document
	HasDocuments bool `json:"has_documents"`
}

func (entity *PushMessageContentMediaAlbum) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentMediaAlbum

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentMediaAlbum) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentMediaAlbum) GetType() string {
	return TypePushMessageContentMediaAlbum
}

func (*PushMessageContentMediaAlbum) PushMessageContentType() string {
	return TypePushMessageContentMediaAlbum
}

// New message was received
type NotificationTypeNewMessage struct {
	meta
	// The message
	Message *Message `json:"message"`
	// True, if message content must be displayed in notifications
	ShowPreview bool `json:"show_preview"`
}

func (entity *NotificationTypeNewMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewMessage

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewMessage) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewMessage) GetType() string {
	return TypeNotificationTypeNewMessage
}

func (*NotificationTypeNewMessage) NotificationTypeType() string {
	return TypeNotificationTypeNewMessage
}

// New secret chat was created
type NotificationTypeNewSecretChat struct {
	meta
}

func (entity *NotificationTypeNewSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewSecretChat

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewSecretChat) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewSecretChat) GetType() string {
	return TypeNotificationTypeNewSecretChat
}

func (*NotificationTypeNewSecretChat) NotificationTypeType() string {
	return TypeNotificationTypeNewSecretChat
}

// New call was received
type NotificationTypeNewCall struct {
	meta
	// Call identifier
	CallId int32 `json:"call_id"`
}

func (entity *NotificationTypeNewCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewCall

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewCall) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewCall) GetType() string {
	return TypeNotificationTypeNewCall
}

func (*NotificationTypeNewCall) NotificationTypeType() string {
	return TypeNotificationTypeNewCall
}

// New message was received through a push notification
type NotificationTypeNewPushMessage struct {
	meta
	// The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
	MessageId int64 `json:"message_id"`
	// Identifier of the sender of the message. Corresponding user or chat may be inaccessible
	SenderId MessageSender `json:"sender_id"`
	// Name of the sender
	SenderName string `json:"sender_name"`
	// True, if the message is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// Push message content
	Content PushMessageContent `json:"content"`
}

func (entity *NotificationTypeNewPushMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewPushMessage

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewPushMessage) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewPushMessage) GetType() string {
	return TypeNotificationTypeNewPushMessage
}

func (*NotificationTypeNewPushMessage) NotificationTypeType() string {
	return TypeNotificationTypeNewPushMessage
}

func (notificationTypeNewPushMessage *NotificationTypeNewPushMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageId  int64           `json:"message_id"`
		SenderId   json.RawMessage `json:"sender_id"`
		SenderName string          `json:"sender_name"`
		IsOutgoing bool            `json:"is_outgoing"`
		Content    json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notificationTypeNewPushMessage.MessageId = tmp.MessageId
	notificationTypeNewPushMessage.SenderName = tmp.SenderName
	notificationTypeNewPushMessage.IsOutgoing = tmp.IsOutgoing

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	notificationTypeNewPushMessage.SenderId = fieldSenderId

	fieldContent, _ := UnmarshalPushMessageContent(tmp.Content)
	notificationTypeNewPushMessage.Content = fieldContent

	return nil
}

// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
type NotificationGroupTypeMessages struct {
	meta
}

func (entity *NotificationGroupTypeMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeMessages

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeMessages) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeMessages) GetType() string {
	return TypeNotificationGroupTypeMessages
}

func (*NotificationGroupTypeMessages) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeMessages
}

// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
type NotificationGroupTypeMentions struct {
	meta
}

func (entity *NotificationGroupTypeMentions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeMentions

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeMentions) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeMentions) GetType() string {
	return TypeNotificationGroupTypeMentions
}

func (*NotificationGroupTypeMentions) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeMentions
}

// A group containing a notification of type notificationTypeNewSecretChat
type NotificationGroupTypeSecretChat struct {
	meta
}

func (entity *NotificationGroupTypeSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeSecretChat

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeSecretChat) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeSecretChat) GetType() string {
	return TypeNotificationGroupTypeSecretChat
}

func (*NotificationGroupTypeSecretChat) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeSecretChat
}

// A group containing notifications of type notificationTypeNewCall
type NotificationGroupTypeCalls struct {
	meta
}

func (entity *NotificationGroupTypeCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeCalls

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeCalls) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeCalls) GetType() string {
	return TypeNotificationGroupTypeCalls
}

func (*NotificationGroupTypeCalls) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeCalls
}

// Describes a notification sound in MP3 format
type NotificationSound struct {
	meta
	// Unique identifier of the notification sound
	Id JsonInt64 `json:"id"`
	// Duration of the sound, in seconds
	Duration int32 `json:"duration"`
	// Point in time (Unix timestamp) when the sound was created
	Date int32 `json:"date"`
	// Title of the notification sound
	Title string `json:"title"`
	// Arbitrary data, defined while the sound was uploaded
	Data string `json:"data"`
	// File containing the sound
	Sound *File `json:"sound"`
}

func (entity *NotificationSound) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSound

	return json.Marshal((*stub)(entity))
}

func (*NotificationSound) GetClass() string {
	return ClassNotificationSound
}

func (*NotificationSound) GetType() string {
	return TypeNotificationSound
}

// Contains a list of notification sounds
type NotificationSounds struct {
	meta
	// A list of notification sounds
	NotificationSounds []*NotificationSound `json:"notification_sounds"`
}

func (entity *NotificationSounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSounds

	return json.Marshal((*stub)(entity))
}

func (*NotificationSounds) GetClass() string {
	return ClassNotificationSounds
}

func (*NotificationSounds) GetType() string {
	return TypeNotificationSounds
}

// Contains information about a notification
type Notification struct {
	meta
	// Unique persistent identifier of this notification
	Id int32 `json:"id"`
	// Notification date
	Date int32 `json:"date"`
	// True, if the notification was explicitly sent without sound
	IsSilent bool `json:"is_silent"`
	// Notification type
	Type NotificationType `json:"type"`
}

func (entity *Notification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Notification

	return json.Marshal((*stub)(entity))
}

func (*Notification) GetClass() string {
	return ClassNotification
}

func (*Notification) GetType() string {
	return TypeNotification
}

func (notification *Notification) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id       int32           `json:"id"`
		Date     int32           `json:"date"`
		IsSilent bool            `json:"is_silent"`
		Type     json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notification.Id = tmp.Id
	notification.Date = tmp.Date
	notification.IsSilent = tmp.IsSilent

	fieldType, _ := UnmarshalNotificationType(tmp.Type)
	notification.Type = fieldType

	return nil
}

// Describes a group of notifications
type NotificationGroup struct {
	meta
	// Unique persistent auto-incremented from 1 identifier of the notification group
	Id int32 `json:"id"`
	// Type of the group
	Type NotificationGroupType `json:"type"`
	// Identifier of a chat to which all notifications in the group belong
	ChatId int64 `json:"chat_id"`
	// Total number of active notifications in the group
	TotalCount int32 `json:"total_count"`
	// The list of active notifications
	Notifications []*Notification `json:"notifications"`
}

func (entity *NotificationGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroup

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroup) GetClass() string {
	return ClassNotificationGroup
}

func (*NotificationGroup) GetType() string {
	return TypeNotificationGroup
}

func (notificationGroup *NotificationGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id            int32           `json:"id"`
		Type          json.RawMessage `json:"type"`
		ChatId        int64           `json:"chat_id"`
		TotalCount    int32           `json:"total_count"`
		Notifications []*Notification `json:"notifications"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notificationGroup.Id = tmp.Id
	notificationGroup.ChatId = tmp.ChatId
	notificationGroup.TotalCount = tmp.TotalCount
	notificationGroup.Notifications = tmp.Notifications

	fieldType, _ := UnmarshalNotificationGroupType(tmp.Type)
	notificationGroup.Type = fieldType

	return nil
}

// Represents a boolean option
type OptionValueBoolean struct {
	meta
	// The value of the option
	Value bool `json:"value"`
}

func (entity *OptionValueBoolean) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueBoolean

	return json.Marshal((*stub)(entity))
}

func (*OptionValueBoolean) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueBoolean) GetType() string {
	return TypeOptionValueBoolean
}

func (*OptionValueBoolean) OptionValueType() string {
	return TypeOptionValueBoolean
}

// Represents an unknown option or an option which has a default value
type OptionValueEmpty struct {
	meta
}

func (entity *OptionValueEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueEmpty

	return json.Marshal((*stub)(entity))
}

func (*OptionValueEmpty) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueEmpty) GetType() string {
	return TypeOptionValueEmpty
}

func (*OptionValueEmpty) OptionValueType() string {
	return TypeOptionValueEmpty
}

// Represents an integer option
type OptionValueInteger struct {
	meta
	// The value of the option
	Value JsonInt64 `json:"value"`
}

func (entity *OptionValueInteger) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueInteger

	return json.Marshal((*stub)(entity))
}

func (*OptionValueInteger) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueInteger) GetType() string {
	return TypeOptionValueInteger
}

func (*OptionValueInteger) OptionValueType() string {
	return TypeOptionValueInteger
}

// Represents a string option
type OptionValueString struct {
	meta
	// The value of the option
	Value string `json:"value"`
}

func (entity *OptionValueString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueString

	return json.Marshal((*stub)(entity))
}

func (*OptionValueString) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueString) GetType() string {
	return TypeOptionValueString
}

func (*OptionValueString) OptionValueType() string {
	return TypeOptionValueString
}

// Represents one member of a JSON object
type JsonObjectMember struct {
	meta
	// Member's key
	Key string `json:"key"`
	// Member's value
	Value JsonValue `json:"value"`
}

func (entity *JsonObjectMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonObjectMember

	return json.Marshal((*stub)(entity))
}

func (*JsonObjectMember) GetClass() string {
	return ClassJsonObjectMember
}

func (*JsonObjectMember) GetType() string {
	return TypeJsonObjectMember
}

func (jsonObjectMember *JsonObjectMember) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Key   string          `json:"key"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	jsonObjectMember.Key = tmp.Key

	fieldValue, _ := UnmarshalJsonValue(tmp.Value)
	jsonObjectMember.Value = fieldValue

	return nil
}

// Represents a null JSON value
type JsonValueNull struct {
	meta
}

func (entity *JsonValueNull) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueNull

	return json.Marshal((*stub)(entity))
}

func (*JsonValueNull) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueNull) GetType() string {
	return TypeJsonValueNull
}

func (*JsonValueNull) JsonValueType() string {
	return TypeJsonValueNull
}

// Represents a boolean JSON value
type JsonValueBoolean struct {
	meta
	// The value
	Value bool `json:"value"`
}

func (entity *JsonValueBoolean) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueBoolean

	return json.Marshal((*stub)(entity))
}

func (*JsonValueBoolean) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueBoolean) GetType() string {
	return TypeJsonValueBoolean
}

func (*JsonValueBoolean) JsonValueType() string {
	return TypeJsonValueBoolean
}

// Represents a numeric JSON value
type JsonValueNumber struct {
	meta
	// The value
	Value float64 `json:"value"`
}

func (entity *JsonValueNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueNumber

	return json.Marshal((*stub)(entity))
}

func (*JsonValueNumber) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueNumber) GetType() string {
	return TypeJsonValueNumber
}

func (*JsonValueNumber) JsonValueType() string {
	return TypeJsonValueNumber
}

// Represents a string JSON value
type JsonValueString struct {
	meta
	// The value
	Value string `json:"value"`
}

func (entity *JsonValueString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueString

	return json.Marshal((*stub)(entity))
}

func (*JsonValueString) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueString) GetType() string {
	return TypeJsonValueString
}

func (*JsonValueString) JsonValueType() string {
	return TypeJsonValueString
}

// Represents a JSON array
type JsonValueArray struct {
	meta
	// The list of array elements
	Values []JsonValue `json:"values"`
}

func (entity *JsonValueArray) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueArray

	return json.Marshal((*stub)(entity))
}

func (*JsonValueArray) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueArray) GetType() string {
	return TypeJsonValueArray
}

func (*JsonValueArray) JsonValueType() string {
	return TypeJsonValueArray
}

func (jsonValueArray *JsonValueArray) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Values []json.RawMessage `json:"values"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldValues, _ := UnmarshalListOfJsonValue(tmp.Values)
	jsonValueArray.Values = fieldValues

	return nil
}

// Represents a JSON object
type JsonValueObject struct {
	meta
	// The list of object members
	Members []*JsonObjectMember `json:"members"`
}

func (entity *JsonValueObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueObject

	return json.Marshal((*stub)(entity))
}

func (*JsonValueObject) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueObject) GetType() string {
	return TypeJsonValueObject
}

func (*JsonValueObject) JsonValueType() string {
	return TypeJsonValueObject
}

// The story can be viewed by everyone
type StoryPrivacySettingsEveryone struct {
	meta
	// Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
	ExceptUserIds []int64 `json:"except_user_ids"`
}

func (entity *StoryPrivacySettingsEveryone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryPrivacySettingsEveryone

	return json.Marshal((*stub)(entity))
}

func (*StoryPrivacySettingsEveryone) GetClass() string {
	return ClassStoryPrivacySettings
}

func (*StoryPrivacySettingsEveryone) GetType() string {
	return TypeStoryPrivacySettingsEveryone
}

func (*StoryPrivacySettingsEveryone) StoryPrivacySettingsType() string {
	return TypeStoryPrivacySettingsEveryone
}

// The story can be viewed by all contacts except chosen users
type StoryPrivacySettingsContacts struct {
	meta
	// User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
	ExceptUserIds []int64 `json:"except_user_ids"`
}

func (entity *StoryPrivacySettingsContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryPrivacySettingsContacts

	return json.Marshal((*stub)(entity))
}

func (*StoryPrivacySettingsContacts) GetClass() string {
	return ClassStoryPrivacySettings
}

func (*StoryPrivacySettingsContacts) GetType() string {
	return TypeStoryPrivacySettingsContacts
}

func (*StoryPrivacySettingsContacts) StoryPrivacySettingsType() string {
	return TypeStoryPrivacySettingsContacts
}

// The story can be viewed by all close friends
type StoryPrivacySettingsCloseFriends struct {
	meta
}

func (entity *StoryPrivacySettingsCloseFriends) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryPrivacySettingsCloseFriends

	return json.Marshal((*stub)(entity))
}

func (*StoryPrivacySettingsCloseFriends) GetClass() string {
	return ClassStoryPrivacySettings
}

func (*StoryPrivacySettingsCloseFriends) GetType() string {
	return TypeStoryPrivacySettingsCloseFriends
}

func (*StoryPrivacySettingsCloseFriends) StoryPrivacySettingsType() string {
	return TypeStoryPrivacySettingsCloseFriends
}

// The story can be viewed by certain specified users
type StoryPrivacySettingsSelectedUsers struct {
	meta
	// Identifiers of the users; always unknown and empty for non-owned stories
	UserIds []int64 `json:"user_ids"`
}

func (entity *StoryPrivacySettingsSelectedUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryPrivacySettingsSelectedUsers

	return json.Marshal((*stub)(entity))
}

func (*StoryPrivacySettingsSelectedUsers) GetClass() string {
	return ClassStoryPrivacySettings
}

func (*StoryPrivacySettingsSelectedUsers) GetType() string {
	return TypeStoryPrivacySettingsSelectedUsers
}

func (*StoryPrivacySettingsSelectedUsers) StoryPrivacySettingsType() string {
	return TypeStoryPrivacySettingsSelectedUsers
}

// A rule to allow all users to do something
type UserPrivacySettingRuleAllowAll struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowAll

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowAll) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowAll) GetType() string {
	return TypeUserPrivacySettingRuleAllowAll
}

func (*UserPrivacySettingRuleAllowAll) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowAll
}

// A rule to allow all contacts of the user to do something
type UserPrivacySettingRuleAllowContacts struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowContacts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowContacts) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowContacts) GetType() string {
	return TypeUserPrivacySettingRuleAllowContacts
}

func (*UserPrivacySettingRuleAllowContacts) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowContacts
}

// A rule to allow all bots to do something
type UserPrivacySettingRuleAllowBots struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowBots

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowBots) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowBots) GetType() string {
	return TypeUserPrivacySettingRuleAllowBots
}

func (*UserPrivacySettingRuleAllowBots) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowBots
}

// A rule to allow all Premium Users to do something; currently, allowed only for userPrivacySettingAllowChatInvites
type UserPrivacySettingRuleAllowPremiumUsers struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowPremiumUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowPremiumUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowPremiumUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowPremiumUsers) GetType() string {
	return TypeUserPrivacySettingRuleAllowPremiumUsers
}

func (*UserPrivacySettingRuleAllowPremiumUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowPremiumUsers
}

// A rule to allow certain specified users to do something
type UserPrivacySettingRuleAllowUsers struct {
	meta
	// The user identifiers, total number of users in all rules must not exceed 1000
	UserIds []int64 `json:"user_ids"`
}

func (entity *UserPrivacySettingRuleAllowUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowUsers) GetType() string {
	return TypeUserPrivacySettingRuleAllowUsers
}

func (*UserPrivacySettingRuleAllowUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowUsers
}

// A rule to allow all members of certain specified basic groups and supergroups to doing something
type UserPrivacySettingRuleAllowChatMembers struct {
	meta
	// The chat identifiers, total number of chats in all rules must not exceed 20
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *UserPrivacySettingRuleAllowChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowChatMembers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowChatMembers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowChatMembers) GetType() string {
	return TypeUserPrivacySettingRuleAllowChatMembers
}

func (*UserPrivacySettingRuleAllowChatMembers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowChatMembers
}

// A rule to restrict all users from doing something
type UserPrivacySettingRuleRestrictAll struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictAll

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictAll) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictAll) GetType() string {
	return TypeUserPrivacySettingRuleRestrictAll
}

func (*UserPrivacySettingRuleRestrictAll) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictAll
}

// A rule to restrict all contacts of the user from doing something
type UserPrivacySettingRuleRestrictContacts struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictContacts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictContacts) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictContacts) GetType() string {
	return TypeUserPrivacySettingRuleRestrictContacts
}

func (*UserPrivacySettingRuleRestrictContacts) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictContacts
}

// A rule to restrict all bots from doing something
type UserPrivacySettingRuleRestrictBots struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictBots

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictBots) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictBots) GetType() string {
	return TypeUserPrivacySettingRuleRestrictBots
}

func (*UserPrivacySettingRuleRestrictBots) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictBots
}

// A rule to restrict all specified users from doing something
type UserPrivacySettingRuleRestrictUsers struct {
	meta
	// The user identifiers, total number of users in all rules must not exceed 1000
	UserIds []int64 `json:"user_ids"`
}

func (entity *UserPrivacySettingRuleRestrictUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictUsers) GetType() string {
	return TypeUserPrivacySettingRuleRestrictUsers
}

func (*UserPrivacySettingRuleRestrictUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictUsers
}

// A rule to restrict all members of specified basic groups and supergroups from doing something
type UserPrivacySettingRuleRestrictChatMembers struct {
	meta
	// The chat identifiers, total number of chats in all rules must not exceed 20
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *UserPrivacySettingRuleRestrictChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictChatMembers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictChatMembers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictChatMembers) GetType() string {
	return TypeUserPrivacySettingRuleRestrictChatMembers
}

func (*UserPrivacySettingRuleRestrictChatMembers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictChatMembers
}

// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
type UserPrivacySettingRules struct {
	meta
	// A list of rules
	Rules []UserPrivacySettingRule `json:"rules"`
}

func (entity *UserPrivacySettingRules) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRules

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRules) GetClass() string {
	return ClassUserPrivacySettingRules
}

func (*UserPrivacySettingRules) GetType() string {
	return TypeUserPrivacySettingRules
}

func (userPrivacySettingRules *UserPrivacySettingRules) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Rules []json.RawMessage `json:"rules"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldRules, _ := UnmarshalListOfUserPrivacySettingRule(tmp.Rules)
	userPrivacySettingRules.Rules = fieldRules

	return nil
}

// A privacy setting for managing whether the user's online status is visible
type UserPrivacySettingShowStatus struct {
	meta
}

func (entity *UserPrivacySettingShowStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowStatus

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowStatus) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowStatus) GetType() string {
	return TypeUserPrivacySettingShowStatus
}

func (*UserPrivacySettingShowStatus) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowStatus
}

// A privacy setting for managing whether the user's profile photo is visible
type UserPrivacySettingShowProfilePhoto struct {
	meta
}

func (entity *UserPrivacySettingShowProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowProfilePhoto) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowProfilePhoto) GetType() string {
	return TypeUserPrivacySettingShowProfilePhoto
}

func (*UserPrivacySettingShowProfilePhoto) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowProfilePhoto
}

// A privacy setting for managing whether a link to the user's account is included in forwarded messages
type UserPrivacySettingShowLinkInForwardedMessages struct {
	meta
}

func (entity *UserPrivacySettingShowLinkInForwardedMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowLinkInForwardedMessages

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowLinkInForwardedMessages) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowLinkInForwardedMessages) GetType() string {
	return TypeUserPrivacySettingShowLinkInForwardedMessages
}

func (*UserPrivacySettingShowLinkInForwardedMessages) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowLinkInForwardedMessages
}

// A privacy setting for managing whether the user's phone number is visible
type UserPrivacySettingShowPhoneNumber struct {
	meta
}

func (entity *UserPrivacySettingShowPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowPhoneNumber) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowPhoneNumber) GetType() string {
	return TypeUserPrivacySettingShowPhoneNumber
}

func (*UserPrivacySettingShowPhoneNumber) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowPhoneNumber
}

// A privacy setting for managing whether the user's bio is visible
type UserPrivacySettingShowBio struct {
	meta
}

func (entity *UserPrivacySettingShowBio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowBio

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowBio) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowBio) GetType() string {
	return TypeUserPrivacySettingShowBio
}

func (*UserPrivacySettingShowBio) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowBio
}

// A privacy setting for managing whether the user's birthdate is visible
type UserPrivacySettingShowBirthdate struct {
	meta
}

func (entity *UserPrivacySettingShowBirthdate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowBirthdate

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowBirthdate) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowBirthdate) GetType() string {
	return TypeUserPrivacySettingShowBirthdate
}

func (*UserPrivacySettingShowBirthdate) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowBirthdate
}

// A privacy setting for managing whether the user can be invited to chats
type UserPrivacySettingAllowChatInvites struct {
	meta
}

func (entity *UserPrivacySettingAllowChatInvites) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowChatInvites

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowChatInvites) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowChatInvites) GetType() string {
	return TypeUserPrivacySettingAllowChatInvites
}

func (*UserPrivacySettingAllowChatInvites) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowChatInvites
}

// A privacy setting for managing whether the user can be called
type UserPrivacySettingAllowCalls struct {
	meta
}

func (entity *UserPrivacySettingAllowCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowCalls

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowCalls) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowCalls) GetType() string {
	return TypeUserPrivacySettingAllowCalls
}

func (*UserPrivacySettingAllowCalls) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowCalls
}

// A privacy setting for managing whether peer-to-peer connections can be used for calls
type UserPrivacySettingAllowPeerToPeerCalls struct {
	meta
}

func (entity *UserPrivacySettingAllowPeerToPeerCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowPeerToPeerCalls

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowPeerToPeerCalls) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowPeerToPeerCalls) GetType() string {
	return TypeUserPrivacySettingAllowPeerToPeerCalls
}

func (*UserPrivacySettingAllowPeerToPeerCalls) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowPeerToPeerCalls
}

// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
type UserPrivacySettingAllowFindingByPhoneNumber struct {
	meta
}

func (entity *UserPrivacySettingAllowFindingByPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowFindingByPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) GetType() string {
	return TypeUserPrivacySettingAllowFindingByPhoneNumber
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowFindingByPhoneNumber
}

// A privacy setting for managing whether the user can receive voice and video messages in private chats; for Telegram Premium users only
type UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages struct {
	meta
}

func (entity *UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) GetType() string {
	return TypeUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
}

func (*UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
}

// A privacy setting for managing whether received gifts are automatically shown on the user's profile page
type UserPrivacySettingAutosaveGifts struct {
	meta
}

func (entity *UserPrivacySettingAutosaveGifts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAutosaveGifts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAutosaveGifts) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAutosaveGifts) GetType() string {
	return TypeUserPrivacySettingAutosaveGifts
}

func (*UserPrivacySettingAutosaveGifts) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAutosaveGifts
}

// Contains privacy settings for message read date in private chats. Read dates are always shown to the users that can see online status of the current user regardless of this setting
type ReadDatePrivacySettings struct {
	meta
	// True, if message read date is shown to other users in private chats. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date
	ShowReadDate bool `json:"show_read_date"`
}

func (entity *ReadDatePrivacySettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReadDatePrivacySettings

	return json.Marshal((*stub)(entity))
}

func (*ReadDatePrivacySettings) GetClass() string {
	return ClassReadDatePrivacySettings
}

func (*ReadDatePrivacySettings) GetType() string {
	return TypeReadDatePrivacySettings
}

// Contains privacy settings for new chats with non-contacts
type NewChatPrivacySettings struct {
	meta
	// True, if non-contacts users are able to write first to the current user. Telegram Premium subscribers are able to write first regardless of this setting
	AllowNewChatsFromUnknownUsers bool `json:"allow_new_chats_from_unknown_users"`
}

func (entity *NewChatPrivacySettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NewChatPrivacySettings

	return json.Marshal((*stub)(entity))
}

func (*NewChatPrivacySettings) GetClass() string {
	return ClassNewChatPrivacySettings
}

func (*NewChatPrivacySettings) GetType() string {
	return TypeNewChatPrivacySettings
}

// The user can be messaged
type CanSendMessageToUserResultOk struct {
	meta
}

func (entity *CanSendMessageToUserResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendMessageToUserResultOk

	return json.Marshal((*stub)(entity))
}

func (*CanSendMessageToUserResultOk) GetClass() string {
	return ClassCanSendMessageToUserResult
}

func (*CanSendMessageToUserResultOk) GetType() string {
	return TypeCanSendMessageToUserResultOk
}

func (*CanSendMessageToUserResultOk) CanSendMessageToUserResultType() string {
	return TypeCanSendMessageToUserResultOk
}

// The user can't be messaged, because they are deleted or unknown
type CanSendMessageToUserResultUserIsDeleted struct {
	meta
}

func (entity *CanSendMessageToUserResultUserIsDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendMessageToUserResultUserIsDeleted

	return json.Marshal((*stub)(entity))
}

func (*CanSendMessageToUserResultUserIsDeleted) GetClass() string {
	return ClassCanSendMessageToUserResult
}

func (*CanSendMessageToUserResultUserIsDeleted) GetType() string {
	return TypeCanSendMessageToUserResultUserIsDeleted
}

func (*CanSendMessageToUserResultUserIsDeleted) CanSendMessageToUserResultType() string {
	return TypeCanSendMessageToUserResultUserIsDeleted
}

// The user can't be messaged, because they restrict new chats with non-contacts
type CanSendMessageToUserResultUserRestrictsNewChats struct {
	meta
}

func (entity *CanSendMessageToUserResultUserRestrictsNewChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanSendMessageToUserResultUserRestrictsNewChats

	return json.Marshal((*stub)(entity))
}

func (*CanSendMessageToUserResultUserRestrictsNewChats) GetClass() string {
	return ClassCanSendMessageToUserResult
}

func (*CanSendMessageToUserResultUserRestrictsNewChats) GetType() string {
	return TypeCanSendMessageToUserResultUserRestrictsNewChats
}

func (*CanSendMessageToUserResultUserRestrictsNewChats) CanSendMessageToUserResultType() string {
	return TypeCanSendMessageToUserResultUserRestrictsNewChats
}

// Contains information about the period of inactivity after which the current user's account will automatically be deleted
type AccountTtl struct {
	meta
	// Number of days of inactivity before the account will be flagged for deletion; 30-730 days
	Days int32 `json:"days"`
}

func (entity *AccountTtl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AccountTtl

	return json.Marshal((*stub)(entity))
}

func (*AccountTtl) GetClass() string {
	return ClassAccountTtl
}

func (*AccountTtl) GetType() string {
	return TypeAccountTtl
}

// Contains default auto-delete timer setting for new chats
type MessageAutoDeleteTime struct {
	meta
	// Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
	Time int32 `json:"time"`
}

func (entity *MessageAutoDeleteTime) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAutoDeleteTime

	return json.Marshal((*stub)(entity))
}

func (*MessageAutoDeleteTime) GetClass() string {
	return ClassMessageAutoDeleteTime
}

func (*MessageAutoDeleteTime) GetType() string {
	return TypeMessageAutoDeleteTime
}

// The session is running on an Android device
type SessionTypeAndroid struct {
	meta
}

func (entity *SessionTypeAndroid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeAndroid

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeAndroid) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeAndroid) GetType() string {
	return TypeSessionTypeAndroid
}

func (*SessionTypeAndroid) SessionTypeType() string {
	return TypeSessionTypeAndroid
}

// The session is running on a generic Apple device
type SessionTypeApple struct {
	meta
}

func (entity *SessionTypeApple) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeApple

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeApple) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeApple) GetType() string {
	return TypeSessionTypeApple
}

func (*SessionTypeApple) SessionTypeType() string {
	return TypeSessionTypeApple
}

// The session is running on the Brave browser
type SessionTypeBrave struct {
	meta
}

func (entity *SessionTypeBrave) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeBrave

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeBrave) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeBrave) GetType() string {
	return TypeSessionTypeBrave
}

func (*SessionTypeBrave) SessionTypeType() string {
	return TypeSessionTypeBrave
}

// The session is running on the Chrome browser
type SessionTypeChrome struct {
	meta
}

func (entity *SessionTypeChrome) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeChrome

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeChrome) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeChrome) GetType() string {
	return TypeSessionTypeChrome
}

func (*SessionTypeChrome) SessionTypeType() string {
	return TypeSessionTypeChrome
}

// The session is running on the Edge browser
type SessionTypeEdge struct {
	meta
}

func (entity *SessionTypeEdge) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeEdge

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeEdge) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeEdge) GetType() string {
	return TypeSessionTypeEdge
}

func (*SessionTypeEdge) SessionTypeType() string {
	return TypeSessionTypeEdge
}

// The session is running on the Firefox browser
type SessionTypeFirefox struct {
	meta
}

func (entity *SessionTypeFirefox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeFirefox

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeFirefox) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeFirefox) GetType() string {
	return TypeSessionTypeFirefox
}

func (*SessionTypeFirefox) SessionTypeType() string {
	return TypeSessionTypeFirefox
}

// The session is running on an iPad device
type SessionTypeIpad struct {
	meta
}

func (entity *SessionTypeIpad) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeIpad

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeIpad) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeIpad) GetType() string {
	return TypeSessionTypeIpad
}

func (*SessionTypeIpad) SessionTypeType() string {
	return TypeSessionTypeIpad
}

// The session is running on an iPhone device
type SessionTypeIphone struct {
	meta
}

func (entity *SessionTypeIphone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeIphone

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeIphone) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeIphone) GetType() string {
	return TypeSessionTypeIphone
}

func (*SessionTypeIphone) SessionTypeType() string {
	return TypeSessionTypeIphone
}

// The session is running on a Linux device
type SessionTypeLinux struct {
	meta
}

func (entity *SessionTypeLinux) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeLinux

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeLinux) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeLinux) GetType() string {
	return TypeSessionTypeLinux
}

func (*SessionTypeLinux) SessionTypeType() string {
	return TypeSessionTypeLinux
}

// The session is running on a Mac device
type SessionTypeMac struct {
	meta
}

func (entity *SessionTypeMac) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeMac

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeMac) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeMac) GetType() string {
	return TypeSessionTypeMac
}

func (*SessionTypeMac) SessionTypeType() string {
	return TypeSessionTypeMac
}

// The session is running on the Opera browser
type SessionTypeOpera struct {
	meta
}

func (entity *SessionTypeOpera) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeOpera

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeOpera) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeOpera) GetType() string {
	return TypeSessionTypeOpera
}

func (*SessionTypeOpera) SessionTypeType() string {
	return TypeSessionTypeOpera
}

// The session is running on the Safari browser
type SessionTypeSafari struct {
	meta
}

func (entity *SessionTypeSafari) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeSafari

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeSafari) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeSafari) GetType() string {
	return TypeSessionTypeSafari
}

func (*SessionTypeSafari) SessionTypeType() string {
	return TypeSessionTypeSafari
}

// The session is running on an Ubuntu device
type SessionTypeUbuntu struct {
	meta
}

func (entity *SessionTypeUbuntu) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeUbuntu

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeUbuntu) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeUbuntu) GetType() string {
	return TypeSessionTypeUbuntu
}

func (*SessionTypeUbuntu) SessionTypeType() string {
	return TypeSessionTypeUbuntu
}

// The session is running on an unknown type of device
type SessionTypeUnknown struct {
	meta
}

func (entity *SessionTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeUnknown) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeUnknown) GetType() string {
	return TypeSessionTypeUnknown
}

func (*SessionTypeUnknown) SessionTypeType() string {
	return TypeSessionTypeUnknown
}

// The session is running on the Vivaldi browser
type SessionTypeVivaldi struct {
	meta
}

func (entity *SessionTypeVivaldi) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeVivaldi

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeVivaldi) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeVivaldi) GetType() string {
	return TypeSessionTypeVivaldi
}

func (*SessionTypeVivaldi) SessionTypeType() string {
	return TypeSessionTypeVivaldi
}

// The session is running on a Windows device
type SessionTypeWindows struct {
	meta
}

func (entity *SessionTypeWindows) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeWindows

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeWindows) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeWindows) GetType() string {
	return TypeSessionTypeWindows
}

func (*SessionTypeWindows) SessionTypeType() string {
	return TypeSessionTypeWindows
}

// The session is running on an Xbox console
type SessionTypeXbox struct {
	meta
}

func (entity *SessionTypeXbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SessionTypeXbox

	return json.Marshal((*stub)(entity))
}

func (*SessionTypeXbox) GetClass() string {
	return ClassSessionType
}

func (*SessionTypeXbox) GetType() string {
	return TypeSessionTypeXbox
}

func (*SessionTypeXbox) SessionTypeType() string {
	return TypeSessionTypeXbox
}

// Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
type Session struct {
	meta
	// Session identifier
	Id JsonInt64 `json:"id"`
	// True, if this session is the current session
	IsCurrent bool `json:"is_current"`
	// True, if a 2-step verification password is needed to complete authorization of the session
	IsPasswordPending bool `json:"is_password_pending"`
	// True, if the session wasn't confirmed from another session
	IsUnconfirmed bool `json:"is_unconfirmed"`
	// True, if incoming secret chats can be accepted by the session
	CanAcceptSecretChats bool `json:"can_accept_secret_chats"`
	// True, if incoming calls can be accepted by the session
	CanAcceptCalls bool `json:"can_accept_calls"`
	// Session type based on the system and application version, which can be used to display a corresponding icon
	Type SessionType `json:"type"`
	// Telegram API identifier, as provided by the application
	ApiId int32 `json:"api_id"`
	// Name of the application, as provided by the application
	ApplicationName string `json:"application_name"`
	// The version of the application, as provided by the application
	ApplicationVersion string `json:"application_version"`
	// True, if the application is an official application or uses the api_id of an official application
	IsOfficialApplication bool `json:"is_official_application"`
	// Model of the device the application has been run or is running on, as provided by the application
	DeviceModel string `json:"device_model"`
	// Operating system the application has been run or is running on, as provided by the application
	Platform string `json:"platform"`
	// Version of the operating system the application has been run or is running on, as provided by the application
	SystemVersion string `json:"system_version"`
	// Point in time (Unix timestamp) when the user has logged in
	LogInDate int32 `json:"log_in_date"`
	// Point in time (Unix timestamp) when the session was last used
	LastActiveDate int32 `json:"last_active_date"`
	// IP address from which the session was created, in human-readable format
	IpAddress string `json:"ip_address"`
	// A human-readable description of the location from which the session was created, based on the IP address
	Location string `json:"location"`
}

func (entity *Session) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Session

	return json.Marshal((*stub)(entity))
}

func (*Session) GetClass() string {
	return ClassSession
}

func (*Session) GetType() string {
	return TypeSession
}

func (session *Session) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                    JsonInt64       `json:"id"`
		IsCurrent             bool            `json:"is_current"`
		IsPasswordPending     bool            `json:"is_password_pending"`
		IsUnconfirmed         bool            `json:"is_unconfirmed"`
		CanAcceptSecretChats  bool            `json:"can_accept_secret_chats"`
		CanAcceptCalls        bool            `json:"can_accept_calls"`
		Type                  json.RawMessage `json:"type"`
		ApiId                 int32           `json:"api_id"`
		ApplicationName       string          `json:"application_name"`
		ApplicationVersion    string          `json:"application_version"`
		IsOfficialApplication bool            `json:"is_official_application"`
		DeviceModel           string          `json:"device_model"`
		Platform              string          `json:"platform"`
		SystemVersion         string          `json:"system_version"`
		LogInDate             int32           `json:"log_in_date"`
		LastActiveDate        int32           `json:"last_active_date"`
		IpAddress             string          `json:"ip_address"`
		Location              string          `json:"location"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	session.Id = tmp.Id
	session.IsCurrent = tmp.IsCurrent
	session.IsPasswordPending = tmp.IsPasswordPending
	session.IsUnconfirmed = tmp.IsUnconfirmed
	session.CanAcceptSecretChats = tmp.CanAcceptSecretChats
	session.CanAcceptCalls = tmp.CanAcceptCalls
	session.ApiId = tmp.ApiId
	session.ApplicationName = tmp.ApplicationName
	session.ApplicationVersion = tmp.ApplicationVersion
	session.IsOfficialApplication = tmp.IsOfficialApplication
	session.DeviceModel = tmp.DeviceModel
	session.Platform = tmp.Platform
	session.SystemVersion = tmp.SystemVersion
	session.LogInDate = tmp.LogInDate
	session.LastActiveDate = tmp.LastActiveDate
	session.IpAddress = tmp.IpAddress
	session.Location = tmp.Location

	fieldType, _ := UnmarshalSessionType(tmp.Type)
	session.Type = fieldType

	return nil
}

// Contains a list of sessions
type Sessions struct {
	meta
	// List of sessions
	Sessions []*Session `json:"sessions"`
	// Number of days of inactivity before sessions will automatically be terminated; 1-366 days
	InactiveSessionTtlDays int32 `json:"inactive_session_ttl_days"`
}

func (entity *Sessions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Sessions

	return json.Marshal((*stub)(entity))
}

func (*Sessions) GetClass() string {
	return ClassSessions
}

func (*Sessions) GetType() string {
	return TypeSessions
}

// Contains information about an unconfirmed session
type UnconfirmedSession struct {
	meta
	// Session identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the user has logged in
	LogInDate int32 `json:"log_in_date"`
	// Model of the device that was used for the session creation, as provided by the application
	DeviceModel string `json:"device_model"`
	// A human-readable description of the location from which the session was created, based on the IP address
	Location string `json:"location"`
}

func (entity *UnconfirmedSession) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UnconfirmedSession

	return json.Marshal((*stub)(entity))
}

func (*UnconfirmedSession) GetClass() string {
	return ClassUnconfirmedSession
}

func (*UnconfirmedSession) GetType() string {
	return TypeUnconfirmedSession
}

// Contains information about one website the current user is logged in with Telegram
type ConnectedWebsite struct {
	meta
	// Website identifier
	Id JsonInt64 `json:"id"`
	// The domain name of the website
	DomainName string `json:"domain_name"`
	// User identifier of a bot linked with the website
	BotUserId int64 `json:"bot_user_id"`
	// The version of a browser used to log in
	Browser string `json:"browser"`
	// Operating system the browser is running on
	Platform string `json:"platform"`
	// Point in time (Unix timestamp) when the user was logged in
	LogInDate int32 `json:"log_in_date"`
	// Point in time (Unix timestamp) when obtained authorization was last used
	LastActiveDate int32 `json:"last_active_date"`
	// IP address from which the user was logged in, in human-readable format
	IpAddress string `json:"ip_address"`
	// Human-readable description of a country and a region from which the user was logged in, based on the IP address
	Location string `json:"location"`
}

func (entity *ConnectedWebsite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectedWebsite

	return json.Marshal((*stub)(entity))
}

func (*ConnectedWebsite) GetClass() string {
	return ClassConnectedWebsite
}

func (*ConnectedWebsite) GetType() string {
	return TypeConnectedWebsite
}

// Contains a list of websites the current user is logged in with Telegram
type ConnectedWebsites struct {
	meta
	// List of connected websites
	Websites []*ConnectedWebsite `json:"websites"`
}

func (entity *ConnectedWebsites) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectedWebsites

	return json.Marshal((*stub)(entity))
}

func (*ConnectedWebsites) GetClass() string {
	return ClassConnectedWebsites
}

func (*ConnectedWebsites) GetType() string {
	return TypeConnectedWebsites
}

// The chat contains spam messages
type ReportReasonSpam struct {
	meta
}

func (entity *ReportReasonSpam) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonSpam

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonSpam) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonSpam) GetType() string {
	return TypeReportReasonSpam
}

func (*ReportReasonSpam) ReportReasonType() string {
	return TypeReportReasonSpam
}

// The chat promotes violence
type ReportReasonViolence struct {
	meta
}

func (entity *ReportReasonViolence) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonViolence

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonViolence) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonViolence) GetType() string {
	return TypeReportReasonViolence
}

func (*ReportReasonViolence) ReportReasonType() string {
	return TypeReportReasonViolence
}

// The chat contains pornographic messages
type ReportReasonPornography struct {
	meta
}

func (entity *ReportReasonPornography) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonPornography

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonPornography) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonPornography) GetType() string {
	return TypeReportReasonPornography
}

func (*ReportReasonPornography) ReportReasonType() string {
	return TypeReportReasonPornography
}

// The chat has child abuse related content
type ReportReasonChildAbuse struct {
	meta
}

func (entity *ReportReasonChildAbuse) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonChildAbuse

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonChildAbuse) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonChildAbuse) GetType() string {
	return TypeReportReasonChildAbuse
}

func (*ReportReasonChildAbuse) ReportReasonType() string {
	return TypeReportReasonChildAbuse
}

// The chat contains copyrighted content
type ReportReasonCopyright struct {
	meta
}

func (entity *ReportReasonCopyright) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonCopyright

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonCopyright) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonCopyright) GetType() string {
	return TypeReportReasonCopyright
}

func (*ReportReasonCopyright) ReportReasonType() string {
	return TypeReportReasonCopyright
}

// The location-based chat is unrelated to its stated location
type ReportReasonUnrelatedLocation struct {
	meta
}

func (entity *ReportReasonUnrelatedLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonUnrelatedLocation

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonUnrelatedLocation) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonUnrelatedLocation) GetType() string {
	return TypeReportReasonUnrelatedLocation
}

func (*ReportReasonUnrelatedLocation) ReportReasonType() string {
	return TypeReportReasonUnrelatedLocation
}

// The chat represents a fake account
type ReportReasonFake struct {
	meta
}

func (entity *ReportReasonFake) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonFake

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonFake) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonFake) GetType() string {
	return TypeReportReasonFake
}

func (*ReportReasonFake) ReportReasonType() string {
	return TypeReportReasonFake
}

// The chat has illegal drugs related content
type ReportReasonIllegalDrugs struct {
	meta
}

func (entity *ReportReasonIllegalDrugs) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonIllegalDrugs

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonIllegalDrugs) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonIllegalDrugs) GetType() string {
	return TypeReportReasonIllegalDrugs
}

func (*ReportReasonIllegalDrugs) ReportReasonType() string {
	return TypeReportReasonIllegalDrugs
}

// The chat contains messages with personal details
type ReportReasonPersonalDetails struct {
	meta
}

func (entity *ReportReasonPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonPersonalDetails) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonPersonalDetails) GetType() string {
	return TypeReportReasonPersonalDetails
}

func (*ReportReasonPersonalDetails) ReportReasonType() string {
	return TypeReportReasonPersonalDetails
}

// A custom reason provided by the user
type ReportReasonCustom struct {
	meta
}

func (entity *ReportReasonCustom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportReasonCustom

	return json.Marshal((*stub)(entity))
}

func (*ReportReasonCustom) GetClass() string {
	return ClassReportReason
}

func (*ReportReasonCustom) GetType() string {
	return TypeReportReasonCustom
}

func (*ReportReasonCustom) ReportReasonType() string {
	return TypeReportReasonCustom
}

// The chat was reported successfully
type ReportChatResultOk struct {
	meta
}

func (entity *ReportChatResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatResultOk

	return json.Marshal((*stub)(entity))
}

func (*ReportChatResultOk) GetClass() string {
	return ClassReportChatResult
}

func (*ReportChatResultOk) GetType() string {
	return TypeReportChatResultOk
}

func (*ReportChatResultOk) ReportChatResultType() string {
	return TypeReportChatResultOk
}

// The user must choose an option to report the chat and repeat request with the chosen option
type ReportChatResultOptionRequired struct {
	meta
	// Title for the option choice
	Title string `json:"title"`
	// List of available options
	Options []*ReportOption `json:"options"`
}

func (entity *ReportChatResultOptionRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatResultOptionRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportChatResultOptionRequired) GetClass() string {
	return ClassReportChatResult
}

func (*ReportChatResultOptionRequired) GetType() string {
	return TypeReportChatResultOptionRequired
}

func (*ReportChatResultOptionRequired) ReportChatResultType() string {
	return TypeReportChatResultOptionRequired
}

// The user must add additional text details to the report
type ReportChatResultTextRequired struct {
	meta
	// Option identifier for the next reportChat request
	OptionId []byte `json:"option_id"`
	// True, if the user can skip text adding
	IsOptional bool `json:"is_optional"`
}

func (entity *ReportChatResultTextRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatResultTextRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportChatResultTextRequired) GetClass() string {
	return ClassReportChatResult
}

func (*ReportChatResultTextRequired) GetType() string {
	return TypeReportChatResultTextRequired
}

func (*ReportChatResultTextRequired) ReportChatResultType() string {
	return TypeReportChatResultTextRequired
}

// The user must choose messages to report and repeat the reportChat request with the chosen messages
type ReportChatResultMessagesRequired struct {
	meta
}

func (entity *ReportChatResultMessagesRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportChatResultMessagesRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportChatResultMessagesRequired) GetClass() string {
	return ClassReportChatResult
}

func (*ReportChatResultMessagesRequired) GetType() string {
	return TypeReportChatResultMessagesRequired
}

func (*ReportChatResultMessagesRequired) ReportChatResultType() string {
	return TypeReportChatResultMessagesRequired
}

// The story was reported successfully
type ReportStoryResultOk struct {
	meta
}

func (entity *ReportStoryResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportStoryResultOk

	return json.Marshal((*stub)(entity))
}

func (*ReportStoryResultOk) GetClass() string {
	return ClassReportStoryResult
}

func (*ReportStoryResultOk) GetType() string {
	return TypeReportStoryResultOk
}

func (*ReportStoryResultOk) ReportStoryResultType() string {
	return TypeReportStoryResultOk
}

// The user must choose an option to report the story and repeat request with the chosen option
type ReportStoryResultOptionRequired struct {
	meta
	// Title for the option choice
	Title string `json:"title"`
	// List of available options
	Options []*ReportOption `json:"options"`
}

func (entity *ReportStoryResultOptionRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportStoryResultOptionRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportStoryResultOptionRequired) GetClass() string {
	return ClassReportStoryResult
}

func (*ReportStoryResultOptionRequired) GetType() string {
	return TypeReportStoryResultOptionRequired
}

func (*ReportStoryResultOptionRequired) ReportStoryResultType() string {
	return TypeReportStoryResultOptionRequired
}

// The user must add additional text details to the report
type ReportStoryResultTextRequired struct {
	meta
	// Option identifier for the next reportStory request
	OptionId []byte `json:"option_id"`
	// True, if the user can skip text adding
	IsOptional bool `json:"is_optional"`
}

func (entity *ReportStoryResultTextRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReportStoryResultTextRequired

	return json.Marshal((*stub)(entity))
}

func (*ReportStoryResultTextRequired) GetClass() string {
	return ClassReportStoryResult
}

func (*ReportStoryResultTextRequired) GetType() string {
	return TypeReportStoryResultTextRequired
}

func (*ReportStoryResultTextRequired) ReportStoryResultType() string {
	return TypeReportStoryResultTextRequired
}

// The link is a link to the Devices section of the application. Use getActiveSessions to get the list of active sessions and show them to the user
type InternalLinkTypeActiveSessions struct {
	meta
}

func (entity *InternalLinkTypeActiveSessions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeActiveSessions

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeActiveSessions) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeActiveSessions) GetType() string {
	return TypeInternalLinkTypeActiveSessions
}

func (*InternalLinkTypeActiveSessions) InternalLinkTypeType() string {
	return TypeInternalLinkTypeActiveSessions
}

// The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then, use getAttachmentMenuBot to receive information about the bot. If the bot isn't added to attachment menu, then show a disclaimer about Mini Apps being third-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot. If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL
type InternalLinkTypeAttachmentMenuBot struct {
	meta
	// Target chat to be opened
	TargetChat TargetChat `json:"target_chat"`
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// URL to be passed to openWebApp
	Url string `json:"url"`
}

func (entity *InternalLinkTypeAttachmentMenuBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeAttachmentMenuBot

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeAttachmentMenuBot) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeAttachmentMenuBot) GetType() string {
	return TypeInternalLinkTypeAttachmentMenuBot
}

func (*InternalLinkTypeAttachmentMenuBot) InternalLinkTypeType() string {
	return TypeInternalLinkTypeAttachmentMenuBot
}

func (internalLinkTypeAttachmentMenuBot *InternalLinkTypeAttachmentMenuBot) UnmarshalJSON(data []byte) error {
	var tmp struct {
		TargetChat  json.RawMessage `json:"target_chat"`
		BotUsername string          `json:"bot_username"`
		Url         string          `json:"url"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	internalLinkTypeAttachmentMenuBot.BotUsername = tmp.BotUsername
	internalLinkTypeAttachmentMenuBot.Url = tmp.Url

	fieldTargetChat, _ := UnmarshalTargetChat(tmp.TargetChat)
	internalLinkTypeAttachmentMenuBot.TargetChat = fieldTargetChat

	return nil
}

// The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
type InternalLinkTypeAuthenticationCode struct {
	meta
	// The authentication code
	Code string `json:"code"`
}

func (entity *InternalLinkTypeAuthenticationCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeAuthenticationCode

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeAuthenticationCode) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeAuthenticationCode) GetType() string {
	return TypeInternalLinkTypeAuthenticationCode
}

func (*InternalLinkTypeAuthenticationCode) InternalLinkTypeType() string {
	return TypeInternalLinkTypeAuthenticationCode
}

// The link is a link to a background. Call searchBackground with the given background name to process the link. If background is found and the user wants to apply it, then call setDefaultBackground
type InternalLinkTypeBackground struct {
	meta
	// Name of the background
	BackgroundName string `json:"background_name"`
}

func (entity *InternalLinkTypeBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBackground

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBackground) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBackground) GetType() string {
	return TypeInternalLinkTypeBackground
}

func (*InternalLinkTypeBackground) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBackground
}

// The link is a link to a Telegram bot, which is expected to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot, ask the current user to select a channel chat to add the bot to as an administrator. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights
type InternalLinkTypeBotAddToChannel struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// Expected administrator rights for the bot
	AdministratorRights *ChatAdministratorRights `json:"administrator_rights"`
}

func (entity *InternalLinkTypeBotAddToChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBotAddToChannel

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBotAddToChannel) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBotAddToChannel) GetType() string {
	return TypeInternalLinkTypeBotAddToChannel
}

func (*InternalLinkTypeBotAddToChannel) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBotAddToChannel
}

// The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot, and then call sendBotStartMessage with the given start parameter after the button is pressed
type InternalLinkTypeBotStart struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// The parameter to be passed to sendBotStartMessage
	StartParameter string `json:"start_parameter"`
	// True, if sendBotStartMessage must be called automatically without showing the START button
	Autostart bool `json:"autostart"`
}

func (entity *InternalLinkTypeBotStart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBotStart

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBotStart) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBotStart) GetType() string {
	return TypeInternalLinkTypeBotStart
}

func (*InternalLinkTypeBotStart) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBotStart
}

// The link is a link to a Telegram bot, which is expected to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups, ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup. If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat. Then, if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat
type InternalLinkTypeBotStartInGroup struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// The parameter to be passed to sendBotStartMessage
	StartParameter string `json:"start_parameter"`
	// Expected administrator rights for the bot; may be null
	AdministratorRights *ChatAdministratorRights `json:"administrator_rights"`
}

func (entity *InternalLinkTypeBotStartInGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBotStartInGroup

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBotStartInGroup) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBotStartInGroup) GetType() string {
	return TypeInternalLinkTypeBotStartInGroup
}

func (*InternalLinkTypeBotStartInGroup) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBotStartInGroup
}

// The link is a link to a business chat. Use getBusinessChatLinkInfo with the provided link name to get information about the link, then open received private chat and replace chat draft with the provided text
type InternalLinkTypeBusinessChat struct {
	meta
	// Name of the link
	LinkName string `json:"link_name"`
}

func (entity *InternalLinkTypeBusinessChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBusinessChat

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBusinessChat) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBusinessChat) GetType() string {
	return TypeInternalLinkTypeBusinessChat
}

func (*InternalLinkTypeBusinessChat) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBusinessChat
}

// The link is a link to the Telegram Star purchase section of the application
type InternalLinkTypeBuyStars struct {
	meta
	// The number of Telegram Stars that must be owned by the user
	StarCount int64 `json:"star_count"`
	// Purpose of Telegram Star purchase. Arbitrary string specified by the server, for example, "subs" if the Telegram Stars are required to extend channel subscriptions
	Purpose string `json:"purpose"`
}

func (entity *InternalLinkTypeBuyStars) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeBuyStars

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeBuyStars) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeBuyStars) GetType() string {
	return TypeInternalLinkTypeBuyStars
}

func (*InternalLinkTypeBuyStars) InternalLinkTypeType() string {
	return TypeInternalLinkTypeBuyStars
}

// The link is a link to the change phone number section of the application
type InternalLinkTypeChangePhoneNumber struct {
	meta
}

func (entity *InternalLinkTypeChangePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChangePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChangePhoneNumber) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChangePhoneNumber) GetType() string {
	return TypeInternalLinkTypeChangePhoneNumber
}

func (*InternalLinkTypeChangePhoneNumber) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChangePhoneNumber
}

// The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link. If the chat is found, then call getChatBoostStatus and getAvailableChatBoostSlots to get the current boost status and check whether the chat can be boosted. If the user wants to boost the chat and the chat can be boosted, then call boostChat
type InternalLinkTypeChatBoost struct {
	meta
	// URL to be passed to getChatBoostLinkInfo
	Url string `json:"url"`
}

func (entity *InternalLinkTypeChatBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChatBoost

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChatBoost) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChatBoost) GetType() string {
	return TypeInternalLinkTypeChatBoost
}

func (*InternalLinkTypeChatBoost) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChatBoost
}

// The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link. If the link is valid and the user wants to join the chat folder, then call addChatFolderByInviteLink
type InternalLinkTypeChatFolderInvite struct {
	meta
	// Internal representation of the invite link
	InviteLink string `json:"invite_link"`
}

func (entity *InternalLinkTypeChatFolderInvite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChatFolderInvite

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChatFolderInvite) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChatFolderInvite) GetType() string {
	return TypeInternalLinkTypeChatFolderInvite
}

func (*InternalLinkTypeChatFolderInvite) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChatFolderInvite
}

// The link is a link to the folder section of the application settings
type InternalLinkTypeChatFolderSettings struct {
	meta
}

func (entity *InternalLinkTypeChatFolderSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChatFolderSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChatFolderSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChatFolderSettings) GetType() string {
	return TypeInternalLinkTypeChatFolderSettings
}

func (*InternalLinkTypeChatFolderSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChatFolderSettings
}

// The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link. If the link is valid and the user wants to join the chat, then call joinChatByInviteLink
type InternalLinkTypeChatInvite struct {
	meta
	// Internal representation of the invite link
	InviteLink string `json:"invite_link"`
}

func (entity *InternalLinkTypeChatInvite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeChatInvite

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeChatInvite) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeChatInvite) GetType() string {
	return TypeInternalLinkTypeChatInvite
}

func (*InternalLinkTypeChatInvite) InternalLinkTypeType() string {
	return TypeInternalLinkTypeChatInvite
}

// The link is a link to the default message auto-delete timer settings section of the application settings
type InternalLinkTypeDefaultMessageAutoDeleteTimerSettings struct {
	meta
}

func (entity *InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeDefaultMessageAutoDeleteTimerSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) GetType() string {
	return TypeInternalLinkTypeDefaultMessageAutoDeleteTimerSettings
}

func (*InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeDefaultMessageAutoDeleteTimerSettings
}

// The link is a link to the edit profile section of the application settings
type InternalLinkTypeEditProfileSettings struct {
	meta
}

func (entity *InternalLinkTypeEditProfileSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeEditProfileSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeEditProfileSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeEditProfileSettings) GetType() string {
	return TypeInternalLinkTypeEditProfileSettings
}

func (*InternalLinkTypeEditProfileSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeEditProfileSettings
}

// The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
type InternalLinkTypeGame struct {
	meta
	// Username of the bot that owns the game
	BotUsername string `json:"bot_username"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
}

func (entity *InternalLinkTypeGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeGame

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeGame) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeGame) GetType() string {
	return TypeInternalLinkTypeGame
}

func (*InternalLinkTypeGame) InternalLinkTypeType() string {
	return TypeInternalLinkTypeGame
}

// The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link. If Instant View is found, then show it, otherwise, open the fallback URL in an external browser
type InternalLinkTypeInstantView struct {
	meta
	// URL to be passed to getWebPageInstantView
	Url string `json:"url"`
	// An URL to open if getWebPageInstantView fails
	FallbackUrl string `json:"fallback_url"`
}

func (entity *InternalLinkTypeInstantView) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeInstantView

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeInstantView) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeInstantView) GetType() string {
	return TypeInternalLinkTypeInstantView
}

func (*InternalLinkTypeInstantView) InternalLinkTypeType() string {
	return TypeInternalLinkTypeInstantView
}

// The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link
type InternalLinkTypeInvoice struct {
	meta
	// Name of the invoice
	InvoiceName string `json:"invoice_name"`
}

func (entity *InternalLinkTypeInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeInvoice

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeInvoice) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeInvoice) GetType() string {
	return TypeInternalLinkTypeInvoice
}

func (*InternalLinkTypeInvoice) InternalLinkTypeType() string {
	return TypeInternalLinkTypeInvoice
}

// The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link. If the language pack is found and the user wants to apply it, then call setOption for the option "language_pack_id"
type InternalLinkTypeLanguagePack struct {
	meta
	// Language pack identifier
	LanguagePackId string `json:"language_pack_id"`
}

func (entity *InternalLinkTypeLanguagePack) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeLanguagePack

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeLanguagePack) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeLanguagePack) GetType() string {
	return TypeInternalLinkTypeLanguagePack
}

func (*InternalLinkTypeLanguagePack) InternalLinkTypeType() string {
	return TypeInternalLinkTypeLanguagePack
}

// The link is a link to the language section of the application settings
type InternalLinkTypeLanguageSettings struct {
	meta
}

func (entity *InternalLinkTypeLanguageSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeLanguageSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeLanguageSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeLanguageSettings) GetType() string {
	return TypeInternalLinkTypeLanguageSettings
}

func (*InternalLinkTypeLanguageSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeLanguageSettings
}

// The link is a link to the main Web App of a bot. Call searchPublicChat with the given bot username, check that the user is a bot and has the main Web App. If the bot can be added to attachment menu, then use getAttachmentMenuBot to receive information about the bot, then if the bot isn't added to side menu, show a disclaimer about Mini Apps being third-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu to add the bot. Then, use getMainWebApp with the given start parameter and mode and open the returned URL as a Web App
type InternalLinkTypeMainWebApp struct {
	meta
	// Username of the bot
	BotUsername string `json:"bot_username"`
	// Start parameter to be passed to getMainWebApp
	StartParameter string `json:"start_parameter"`
	// The mode to be passed to getMainWebApp
	Mode WebAppOpenMode `json:"mode"`
}

func (entity *InternalLinkTypeMainWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeMainWebApp

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeMainWebApp) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeMainWebApp) GetType() string {
	return TypeInternalLinkTypeMainWebApp
}

func (*InternalLinkTypeMainWebApp) InternalLinkTypeType() string {
	return TypeInternalLinkTypeMainWebApp
}

func (internalLinkTypeMainWebApp *InternalLinkTypeMainWebApp) UnmarshalJSON(data []byte) error {
	var tmp struct {
		BotUsername    string          `json:"bot_username"`
		StartParameter string          `json:"start_parameter"`
		Mode           json.RawMessage `json:"mode"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	internalLinkTypeMainWebApp.BotUsername = tmp.BotUsername
	internalLinkTypeMainWebApp.StartParameter = tmp.StartParameter

	fieldMode, _ := UnmarshalWebAppOpenMode(tmp.Mode)
	internalLinkTypeMainWebApp.Mode = fieldMode

	return nil
}

// The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link, and then open received forum topic or chat and show the message there
type InternalLinkTypeMessage struct {
	meta
	// URL to be passed to getMessageLinkInfo
	Url string `json:"url"`
}

func (entity *InternalLinkTypeMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeMessage

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeMessage) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeMessage) GetType() string {
	return TypeInternalLinkTypeMessage
}

func (*InternalLinkTypeMessage) InternalLinkTypeType() string {
	return TypeInternalLinkTypeMessage
}

// The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
type InternalLinkTypeMessageDraft struct {
	meta
	// Message draft text
	Text *FormattedText `json:"text"`
	// True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
	ContainsLink bool `json:"contains_link"`
}

func (entity *InternalLinkTypeMessageDraft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeMessageDraft

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeMessageDraft) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeMessageDraft) GetType() string {
	return TypeInternalLinkTypeMessageDraft
}

func (*InternalLinkTypeMessageDraft) InternalLinkTypeType() string {
	return TypeInternalLinkTypeMessageDraft
}

// The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it
type InternalLinkTypePassportDataRequest struct {
	meta
	// User identifier of the service's bot; the corresponding user may be unknown yet
	BotUserId int64 `json:"bot_user_id"`
	// Telegram Passport element types requested by the service
	Scope string `json:"scope"`
	// Service's public key
	PublicKey string `json:"public_key"`
	// Unique request identifier provided by the service
	Nonce string `json:"nonce"`
	// An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
	CallbackUrl string `json:"callback_url"`
}

func (entity *InternalLinkTypePassportDataRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePassportDataRequest

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePassportDataRequest) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePassportDataRequest) GetType() string {
	return TypeInternalLinkTypePassportDataRequest
}

func (*InternalLinkTypePassportDataRequest) InternalLinkTypeType() string {
	return TypeInternalLinkTypePassportDataRequest
}

// The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership with the given hash to process the link. If succeeded, call checkPhoneNumberCode to check entered by the user code, or resendPhoneNumberCode to resend it
type InternalLinkTypePhoneNumberConfirmation struct {
	meta
	// Hash value from the link
	Hash string `json:"hash"`
	// Phone number value from the link
	PhoneNumber string `json:"phone_number"`
}

func (entity *InternalLinkTypePhoneNumberConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePhoneNumberConfirmation

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePhoneNumberConfirmation) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePhoneNumberConfirmation) GetType() string {
	return TypeInternalLinkTypePhoneNumberConfirmation
}

func (*InternalLinkTypePhoneNumberConfirmation) InternalLinkTypeType() string {
	return TypeInternalLinkTypePhoneNumberConfirmation
}

// The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link
type InternalLinkTypePremiumFeatures struct {
	meta
	// Referrer specified in the link
	Referrer string `json:"referrer"`
}

func (entity *InternalLinkTypePremiumFeatures) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePremiumFeatures

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePremiumFeatures) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePremiumFeatures) GetType() string {
	return TypeInternalLinkTypePremiumFeatures
}

func (*InternalLinkTypePremiumFeatures) InternalLinkTypeType() string {
	return TypeInternalLinkTypePremiumFeatures
}

// The link is a link to the screen for gifting Telegram Premium subscriptions to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGiftCodes payments or in-store purchases
type InternalLinkTypePremiumGift struct {
	meta
	// Referrer specified in the link
	Referrer string `json:"referrer"`
}

func (entity *InternalLinkTypePremiumGift) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePremiumGift

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePremiumGift) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePremiumGift) GetType() string {
	return TypeInternalLinkTypePremiumGift
}

func (*InternalLinkTypePremiumGift) InternalLinkTypeType() string {
	return TypeInternalLinkTypePremiumGift
}

// The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode with the given code to process the link. If the code is valid and the user wants to apply it, then call applyPremiumGiftCode
type InternalLinkTypePremiumGiftCode struct {
	meta
	// The Telegram Premium gift code
	Code string `json:"code"`
}

func (entity *InternalLinkTypePremiumGiftCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePremiumGiftCode

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePremiumGiftCode) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePremiumGiftCode) GetType() string {
	return TypeInternalLinkTypePremiumGiftCode
}

func (*InternalLinkTypePremiumGiftCode) InternalLinkTypeType() string {
	return TypeInternalLinkTypePremiumGiftCode
}

// The link is a link to the privacy and security section of the application settings
type InternalLinkTypePrivacyAndSecuritySettings struct {
	meta
}

func (entity *InternalLinkTypePrivacyAndSecuritySettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePrivacyAndSecuritySettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePrivacyAndSecuritySettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePrivacyAndSecuritySettings) GetType() string {
	return TypeInternalLinkTypePrivacyAndSecuritySettings
}

func (*InternalLinkTypePrivacyAndSecuritySettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypePrivacyAndSecuritySettings
}

// The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
type InternalLinkTypeProxy struct {
	meta
	// Proxy server domain or IP address
	Server string `json:"server"`
	// Proxy server port
	Port int32 `json:"port"`
	// Type of the proxy
	Type ProxyType `json:"type"`
}

func (entity *InternalLinkTypeProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeProxy

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeProxy) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeProxy) GetType() string {
	return TypeInternalLinkTypeProxy
}

func (*InternalLinkTypeProxy) InternalLinkTypeType() string {
	return TypeInternalLinkTypeProxy
}

func (internalLinkTypeProxy *InternalLinkTypeProxy) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Server string          `json:"server"`
		Port   int32           `json:"port"`
		Type   json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	internalLinkTypeProxy.Server = tmp.Server
	internalLinkTypeProxy.Port = tmp.Port

	fieldType, _ := UnmarshalProxyType(tmp.Type)
	internalLinkTypeProxy.Type = fieldType

	return nil
}

// The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link. If the chat is found, open its profile information screen or the chat itself. If draft text isn't empty and the chat is a private chat with a regular user, then put the draft text in the input field
type InternalLinkTypePublicChat struct {
	meta
	// Username of the chat
	ChatUsername string `json:"chat_username"`
	// Draft text for message to send in the chat
	DraftText string `json:"draft_text"`
	// True, if chat profile information screen must be opened; otherwise, the chat itself must be opened
	OpenProfile bool `json:"open_profile"`
}

func (entity *InternalLinkTypePublicChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypePublicChat

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypePublicChat) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypePublicChat) GetType() string {
	return TypeInternalLinkTypePublicChat
}

func (*InternalLinkTypePublicChat) InternalLinkTypeType() string {
	return TypeInternalLinkTypePublicChat
}

// The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to "This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown
type InternalLinkTypeQrCodeAuthentication struct {
	meta
}

func (entity *InternalLinkTypeQrCodeAuthentication) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeQrCodeAuthentication

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeQrCodeAuthentication) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeQrCodeAuthentication) GetType() string {
	return TypeInternalLinkTypeQrCodeAuthentication
}

func (*InternalLinkTypeQrCodeAuthentication) InternalLinkTypeType() string {
	return TypeInternalLinkTypeQrCodeAuthentication
}

// The link forces restore of App Store purchases when opened. For official iOS application only
type InternalLinkTypeRestorePurchases struct {
	meta
}

func (entity *InternalLinkTypeRestorePurchases) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeRestorePurchases

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeRestorePurchases) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeRestorePurchases) GetType() string {
	return TypeInternalLinkTypeRestorePurchases
}

func (*InternalLinkTypeRestorePurchases) InternalLinkTypeType() string {
	return TypeInternalLinkTypeRestorePurchases
}

// The link is a link to application settings
type InternalLinkTypeSettings struct {
	meta
}

func (entity *InternalLinkTypeSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeSettings) GetType() string {
	return TypeInternalLinkTypeSettings
}

func (*InternalLinkTypeSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeSettings
}

// The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set. If the sticker set is found and the user wants to add it, then call changeStickerSet
type InternalLinkTypeStickerSet struct {
	meta
	// Name of the sticker set
	StickerSetName string `json:"sticker_set_name"`
	// True, if the sticker set is expected to contain custom emoji
	ExpectCustomEmoji bool `json:"expect_custom_emoji"`
}

func (entity *InternalLinkTypeStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeStickerSet

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeStickerSet) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeStickerSet) GetType() string {
	return TypeInternalLinkTypeStickerSet
}

func (*InternalLinkTypeStickerSet) InternalLinkTypeType() string {
	return TypeInternalLinkTypeStickerSet
}

// The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier, then show the story if received
type InternalLinkTypeStory struct {
	meta
	// Username of the sender of the story
	StorySenderUsername string `json:"story_sender_username"`
	// Story identifier
	StoryId int32 `json:"story_id"`
}

func (entity *InternalLinkTypeStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeStory

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeStory) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeStory) GetType() string {
	return TypeInternalLinkTypeStory
}

func (*InternalLinkTypeStory) InternalLinkTypeType() string {
	return TypeInternalLinkTypeStory
}

// The link is a link to a cloud theme. TDLib has no theme support yet
type InternalLinkTypeTheme struct {
	meta
	// Name of the theme
	ThemeName string `json:"theme_name"`
}

func (entity *InternalLinkTypeTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeTheme

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeTheme) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeTheme) GetType() string {
	return TypeInternalLinkTypeTheme
}

func (*InternalLinkTypeTheme) InternalLinkTypeType() string {
	return TypeInternalLinkTypeTheme
}

// The link is a link to the theme section of the application settings
type InternalLinkTypeThemeSettings struct {
	meta
}

func (entity *InternalLinkTypeThemeSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeThemeSettings

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeThemeSettings) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeThemeSettings) GetType() string {
	return TypeInternalLinkTypeThemeSettings
}

func (*InternalLinkTypeThemeSettings) InternalLinkTypeType() string {
	return TypeInternalLinkTypeThemeSettings
}

// The link is an unknown tg: link. Call getDeepLinkInfo to process the link
type InternalLinkTypeUnknownDeepLink struct {
	meta
	// Link to be passed to getDeepLinkInfo
	Link string `json:"link"`
}

func (entity *InternalLinkTypeUnknownDeepLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUnknownDeepLink

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUnknownDeepLink) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUnknownDeepLink) GetType() string {
	return TypeInternalLinkTypeUnknownDeepLink
}

func (*InternalLinkTypeUnknownDeepLink) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUnknownDeepLink
}

// The link is a link to an unsupported proxy. An alert can be shown to the user
type InternalLinkTypeUnsupportedProxy struct {
	meta
}

func (entity *InternalLinkTypeUnsupportedProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUnsupportedProxy

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUnsupportedProxy) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUnsupportedProxy) GetType() string {
	return TypeInternalLinkTypeUnsupportedProxy
}

func (*InternalLinkTypeUnsupportedProxy) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUnsupportedProxy
}

// The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link. If the user is found, then call createPrivateChat and open user's profile information screen or the chat itself. If draft text isn't empty, then put the draft text in the input field
type InternalLinkTypeUserPhoneNumber struct {
	meta
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Draft text for message to send in the chat
	DraftText string `json:"draft_text"`
	// True, if user's profile information screen must be opened; otherwise, the chat itself must be opened
	OpenProfile bool `json:"open_profile"`
}

func (entity *InternalLinkTypeUserPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUserPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUserPhoneNumber) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUserPhoneNumber) GetType() string {
	return TypeInternalLinkTypeUserPhoneNumber
}

func (*InternalLinkTypeUserPhoneNumber) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUserPhoneNumber
}

// The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link. If the user is found, then call createPrivateChat and open the chat
type InternalLinkTypeUserToken struct {
	meta
	// The token
	Token string `json:"token"`
}

func (entity *InternalLinkTypeUserToken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeUserToken

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeUserToken) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeUserToken) GetType() string {
	return TypeInternalLinkTypeUserToken
}

func (*InternalLinkTypeUserToken) InternalLinkTypeType() string {
	return TypeInternalLinkTypeUserToken
}

// The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link
type InternalLinkTypeVideoChat struct {
	meta
	// Username of the chat with the video chat
	ChatUsername string `json:"chat_username"`
	// If non-empty, invite hash to be used to join the video chat without being muted by administrators
	InviteHash string `json:"invite_hash"`
	// True, if the video chat is expected to be a live stream in a channel or a broadcast group
	IsLiveStream bool `json:"is_live_stream"`
}

func (entity *InternalLinkTypeVideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeVideoChat

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeVideoChat) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeVideoChat) GetType() string {
	return TypeInternalLinkTypeVideoChat
}

func (*InternalLinkTypeVideoChat) InternalLinkTypeType() string {
	return TypeInternalLinkTypeVideoChat
}

// The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name. Process received foundWebApp by showing a confirmation dialog if needed. If the bot can be added to attachment or side menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party applications instead of the dialog and ask the user to accept their Terms of service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web App
type InternalLinkTypeWebApp struct {
	meta
	// Username of the bot that owns the Web App
	BotUsername string `json:"bot_username"`
	// Short name of the Web App
	WebAppShortName string `json:"web_app_short_name"`
	// Start parameter to be passed to getWebAppLinkUrl
	StartParameter string `json:"start_parameter"`
	// The mode in which the Web App must be opened
	Mode WebAppOpenMode `json:"mode"`
}

func (entity *InternalLinkTypeWebApp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InternalLinkTypeWebApp

	return json.Marshal((*stub)(entity))
}

func (*InternalLinkTypeWebApp) GetClass() string {
	return ClassInternalLinkType
}

func (*InternalLinkTypeWebApp) GetType() string {
	return TypeInternalLinkTypeWebApp
}

func (*InternalLinkTypeWebApp) InternalLinkTypeType() string {
	return TypeInternalLinkTypeWebApp
}

func (internalLinkTypeWebApp *InternalLinkTypeWebApp) UnmarshalJSON(data []byte) error {
	var tmp struct {
		BotUsername     string          `json:"bot_username"`
		WebAppShortName string          `json:"web_app_short_name"`
		StartParameter  string          `json:"start_parameter"`
		Mode            json.RawMessage `json:"mode"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	internalLinkTypeWebApp.BotUsername = tmp.BotUsername
	internalLinkTypeWebApp.WebAppShortName = tmp.WebAppShortName
	internalLinkTypeWebApp.StartParameter = tmp.StartParameter

	fieldMode, _ := UnmarshalWebAppOpenMode(tmp.Mode)
	internalLinkTypeWebApp.Mode = fieldMode

	return nil
}

// Contains an HTTPS link to a message in a supergroup or channel, or a forum topic
type MessageLink struct {
	meta
	// The link
	Link string `json:"link"`
	// True, if the link will work for non-members of the chat
	IsPublic bool `json:"is_public"`
}

func (entity *MessageLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLink

	return json.Marshal((*stub)(entity))
}

func (*MessageLink) GetClass() string {
	return ClassMessageLink
}

func (*MessageLink) GetType() string {
	return TypeMessageLink
}

// Contains information about a link to a message or a forum topic in a chat
type MessageLinkInfo struct {
	meta
	// True, if the link is a public link for a message or a forum topic in a chat
	IsPublic bool `json:"is_public"`
	// If found, identifier of the chat to which the link points, 0 otherwise
	ChatId int64 `json:"chat_id"`
	// If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
	MessageThreadId int64 `json:"message_thread_id"`
	// If found, the linked message; may be null
	Message *Message `json:"message"`
	// Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its link preview
	MediaTimestamp int32 `json:"media_timestamp"`
	// True, if the whole media album to which the message belongs is linked
	ForAlbum bool `json:"for_album"`
}

func (entity *MessageLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageLinkInfo) GetClass() string {
	return ClassMessageLinkInfo
}

func (*MessageLinkInfo) GetType() string {
	return TypeMessageLinkInfo
}

// Contains an HTTPS link to boost a chat
type ChatBoostLink struct {
	meta
	// The link
	Link string `json:"link"`
	// True, if the link will work for non-members of the chat
	IsPublic bool `json:"is_public"`
}

func (entity *ChatBoostLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostLink

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostLink) GetClass() string {
	return ClassChatBoostLink
}

func (*ChatBoostLink) GetType() string {
	return TypeChatBoostLink
}

// Contains information about a link to boost a chat
type ChatBoostLinkInfo struct {
	meta
	// True, if the link will work for non-members of the chat
	IsPublic bool `json:"is_public"`
	// Identifier of the chat to which the link points; 0 if the chat isn't found
	ChatId int64 `json:"chat_id"`
}

func (entity *ChatBoostLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatBoostLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatBoostLinkInfo) GetClass() string {
	return ClassChatBoostLinkInfo
}

func (*ChatBoostLinkInfo) GetType() string {
	return TypeChatBoostLinkInfo
}

// The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions
type BlockListMain struct {
	meta
}

func (entity *BlockListMain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BlockListMain

	return json.Marshal((*stub)(entity))
}

func (*BlockListMain) GetClass() string {
	return ClassBlockList
}

func (*BlockListMain) GetType() string {
	return TypeBlockListMain
}

func (*BlockListMain) BlockListType() string {
	return TypeBlockListMain
}

// The block list that disallows viewing of stories of the current user
type BlockListStories struct {
	meta
}

func (entity *BlockListStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BlockListStories

	return json.Marshal((*stub)(entity))
}

func (*BlockListStories) GetClass() string {
	return ClassBlockList
}

func (*BlockListStories) GetType() string {
	return TypeBlockListStories
}

func (*BlockListStories) BlockListType() string {
	return TypeBlockListStories
}

// Contains a part of a file
type FilePart struct {
	meta
	// File bytes
	Data []byte `json:"data"`
}

func (entity *FilePart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FilePart

	return json.Marshal((*stub)(entity))
}

func (*FilePart) GetClass() string {
	return ClassFilePart
}

func (*FilePart) GetType() string {
	return TypeFilePart
}

// The data is not a file
type FileTypeNone struct {
	meta
}

func (entity *FileTypeNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeNone

	return json.Marshal((*stub)(entity))
}

func (*FileTypeNone) GetClass() string {
	return ClassFileType
}

func (*FileTypeNone) GetType() string {
	return TypeFileTypeNone
}

func (*FileTypeNone) FileTypeType() string {
	return TypeFileTypeNone
}

// The file is an animation
type FileTypeAnimation struct {
	meta
}

func (entity *FileTypeAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeAnimation

	return json.Marshal((*stub)(entity))
}

func (*FileTypeAnimation) GetClass() string {
	return ClassFileType
}

func (*FileTypeAnimation) GetType() string {
	return TypeFileTypeAnimation
}

func (*FileTypeAnimation) FileTypeType() string {
	return TypeFileTypeAnimation
}

// The file is an audio file
type FileTypeAudio struct {
	meta
}

func (entity *FileTypeAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeAudio

	return json.Marshal((*stub)(entity))
}

func (*FileTypeAudio) GetClass() string {
	return ClassFileType
}

func (*FileTypeAudio) GetType() string {
	return TypeFileTypeAudio
}

func (*FileTypeAudio) FileTypeType() string {
	return TypeFileTypeAudio
}

// The file is a document
type FileTypeDocument struct {
	meta
}

func (entity *FileTypeDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeDocument

	return json.Marshal((*stub)(entity))
}

func (*FileTypeDocument) GetClass() string {
	return ClassFileType
}

func (*FileTypeDocument) GetType() string {
	return TypeFileTypeDocument
}

func (*FileTypeDocument) FileTypeType() string {
	return TypeFileTypeDocument
}

// The file is a notification sound
type FileTypeNotificationSound struct {
	meta
}

func (entity *FileTypeNotificationSound) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeNotificationSound

	return json.Marshal((*stub)(entity))
}

func (*FileTypeNotificationSound) GetClass() string {
	return ClassFileType
}

func (*FileTypeNotificationSound) GetType() string {
	return TypeFileTypeNotificationSound
}

func (*FileTypeNotificationSound) FileTypeType() string {
	return TypeFileTypeNotificationSound
}

// The file is a photo
type FileTypePhoto struct {
	meta
}

func (entity *FileTypePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypePhoto

	return json.Marshal((*stub)(entity))
}

func (*FileTypePhoto) GetClass() string {
	return ClassFileType
}

func (*FileTypePhoto) GetType() string {
	return TypeFileTypePhoto
}

func (*FileTypePhoto) FileTypeType() string {
	return TypeFileTypePhoto
}

// The file is a photo published as a story
type FileTypePhotoStory struct {
	meta
}

func (entity *FileTypePhotoStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypePhotoStory

	return json.Marshal((*stub)(entity))
}

func (*FileTypePhotoStory) GetClass() string {
	return ClassFileType
}

func (*FileTypePhotoStory) GetType() string {
	return TypeFileTypePhotoStory
}

func (*FileTypePhotoStory) FileTypeType() string {
	return TypeFileTypePhotoStory
}

// The file is a profile photo
type FileTypeProfilePhoto struct {
	meta
}

func (entity *FileTypeProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*FileTypeProfilePhoto) GetClass() string {
	return ClassFileType
}

func (*FileTypeProfilePhoto) GetType() string {
	return TypeFileTypeProfilePhoto
}

func (*FileTypeProfilePhoto) FileTypeType() string {
	return TypeFileTypeProfilePhoto
}

// The file was sent to a secret chat (the file type is not known to the server)
type FileTypeSecret struct {
	meta
}

func (entity *FileTypeSecret) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecret

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecret) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecret) GetType() string {
	return TypeFileTypeSecret
}

func (*FileTypeSecret) FileTypeType() string {
	return TypeFileTypeSecret
}

// The file is a thumbnail of a file from a secret chat
type FileTypeSecretThumbnail struct {
	meta
}

func (entity *FileTypeSecretThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecretThumbnail

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecretThumbnail) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecretThumbnail) GetType() string {
	return TypeFileTypeSecretThumbnail
}

func (*FileTypeSecretThumbnail) FileTypeType() string {
	return TypeFileTypeSecretThumbnail
}

// The file is a file from Secure storage used for storing Telegram Passport files
type FileTypeSecure struct {
	meta
}

func (entity *FileTypeSecure) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecure

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecure) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecure) GetType() string {
	return TypeFileTypeSecure
}

func (*FileTypeSecure) FileTypeType() string {
	return TypeFileTypeSecure
}

// The file is a sticker
type FileTypeSticker struct {
	meta
}

func (entity *FileTypeSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSticker

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSticker) GetClass() string {
	return ClassFileType
}

func (*FileTypeSticker) GetType() string {
	return TypeFileTypeSticker
}

func (*FileTypeSticker) FileTypeType() string {
	return TypeFileTypeSticker
}

// The file is a thumbnail of another file
type FileTypeThumbnail struct {
	meta
}

func (entity *FileTypeThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeThumbnail

	return json.Marshal((*stub)(entity))
}

func (*FileTypeThumbnail) GetClass() string {
	return ClassFileType
}

func (*FileTypeThumbnail) GetType() string {
	return TypeFileTypeThumbnail
}

func (*FileTypeThumbnail) FileTypeType() string {
	return TypeFileTypeThumbnail
}

// The file type is not yet known
type FileTypeUnknown struct {
	meta
}

func (entity *FileTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*FileTypeUnknown) GetClass() string {
	return ClassFileType
}

func (*FileTypeUnknown) GetType() string {
	return TypeFileTypeUnknown
}

func (*FileTypeUnknown) FileTypeType() string {
	return TypeFileTypeUnknown
}

// The file is a video
type FileTypeVideo struct {
	meta
}

func (entity *FileTypeVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideo

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideo) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideo) GetType() string {
	return TypeFileTypeVideo
}

func (*FileTypeVideo) FileTypeType() string {
	return TypeFileTypeVideo
}

// The file is a video note
type FileTypeVideoNote struct {
	meta
}

func (entity *FileTypeVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideoNote

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideoNote) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideoNote) GetType() string {
	return TypeFileTypeVideoNote
}

func (*FileTypeVideoNote) FileTypeType() string {
	return TypeFileTypeVideoNote
}

// The file is a video published as a story
type FileTypeVideoStory struct {
	meta
}

func (entity *FileTypeVideoStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideoStory

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideoStory) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideoStory) GetType() string {
	return TypeFileTypeVideoStory
}

func (*FileTypeVideoStory) FileTypeType() string {
	return TypeFileTypeVideoStory
}

// The file is a voice note
type FileTypeVoiceNote struct {
	meta
}

func (entity *FileTypeVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVoiceNote) GetClass() string {
	return ClassFileType
}

func (*FileTypeVoiceNote) GetType() string {
	return TypeFileTypeVoiceNote
}

func (*FileTypeVoiceNote) FileTypeType() string {
	return TypeFileTypeVoiceNote
}

// The file is a wallpaper or a background pattern
type FileTypeWallpaper struct {
	meta
}

func (entity *FileTypeWallpaper) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeWallpaper

	return json.Marshal((*stub)(entity))
}

func (*FileTypeWallpaper) GetClass() string {
	return ClassFileType
}

func (*FileTypeWallpaper) GetType() string {
	return TypeFileTypeWallpaper
}

func (*FileTypeWallpaper) FileTypeType() string {
	return TypeFileTypeWallpaper
}

// Contains the storage usage statistics for a specific file type
type StorageStatisticsByFileType struct {
	meta
	// File type
	FileType FileType `json:"file_type"`
	// Total size of the files, in bytes
	Size int64 `json:"size"`
	// Total number of files
	Count int32 `json:"count"`
}

func (entity *StorageStatisticsByFileType) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsByFileType

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsByFileType) GetClass() string {
	return ClassStorageStatisticsByFileType
}

func (*StorageStatisticsByFileType) GetType() string {
	return TypeStorageStatisticsByFileType
}

func (storageStatisticsByFileType *StorageStatisticsByFileType) UnmarshalJSON(data []byte) error {
	var tmp struct {
		FileType json.RawMessage `json:"file_type"`
		Size     int64           `json:"size"`
		Count    int32           `json:"count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storageStatisticsByFileType.Size = tmp.Size
	storageStatisticsByFileType.Count = tmp.Count

	fieldFileType, _ := UnmarshalFileType(tmp.FileType)
	storageStatisticsByFileType.FileType = fieldFileType

	return nil
}

// Contains the storage usage statistics for a specific chat
type StorageStatisticsByChat struct {
	meta
	// Chat identifier; 0 if none
	ChatId int64 `json:"chat_id"`
	// Total size of the files in the chat, in bytes
	Size int64 `json:"size"`
	// Total number of files in the chat
	Count int32 `json:"count"`
	// Statistics split by file types
	ByFileType []*StorageStatisticsByFileType `json:"by_file_type"`
}

func (entity *StorageStatisticsByChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsByChat

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsByChat) GetClass() string {
	return ClassStorageStatisticsByChat
}

func (*StorageStatisticsByChat) GetType() string {
	return TypeStorageStatisticsByChat
}

// Contains the exact storage usage statistics split by chats and file type
type StorageStatistics struct {
	meta
	// Total size of files, in bytes
	Size int64 `json:"size"`
	// Total number of files
	Count int32 `json:"count"`
	// Statistics split by chats
	ByChat []*StorageStatisticsByChat `json:"by_chat"`
}

func (entity *StorageStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatistics

	return json.Marshal((*stub)(entity))
}

func (*StorageStatistics) GetClass() string {
	return ClassStorageStatistics
}

func (*StorageStatistics) GetType() string {
	return TypeStorageStatistics
}

// Contains approximate storage usage statistics, excluding files of unknown file type
type StorageStatisticsFast struct {
	meta
	// Approximate total size of files, in bytes
	FilesSize int64 `json:"files_size"`
	// Approximate number of files
	FileCount int32 `json:"file_count"`
	// Size of the database
	DatabaseSize int64 `json:"database_size"`
	// Size of the language pack database
	LanguagePackDatabaseSize int64 `json:"language_pack_database_size"`
	// Size of the TDLib internal log
	LogSize int64 `json:"log_size"`
}

func (entity *StorageStatisticsFast) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsFast

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsFast) GetClass() string {
	return ClassStorageStatisticsFast
}

func (*StorageStatisticsFast) GetType() string {
	return TypeStorageStatisticsFast
}

// Contains database statistics
type DatabaseStatistics struct {
	meta
	// Database statistics in an unspecified human-readable format
	Statistics string `json:"statistics"`
}

func (entity *DatabaseStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DatabaseStatistics

	return json.Marshal((*stub)(entity))
}

func (*DatabaseStatistics) GetClass() string {
	return ClassDatabaseStatistics
}

func (*DatabaseStatistics) GetType() string {
	return TypeDatabaseStatistics
}

// The network is not available
type NetworkTypeNone struct {
	meta
}

func (entity *NetworkTypeNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeNone

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeNone) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeNone) GetType() string {
	return TypeNetworkTypeNone
}

func (*NetworkTypeNone) NetworkTypeType() string {
	return TypeNetworkTypeNone
}

// A mobile network
type NetworkTypeMobile struct {
	meta
}

func (entity *NetworkTypeMobile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeMobile

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeMobile) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeMobile) GetType() string {
	return TypeNetworkTypeMobile
}

func (*NetworkTypeMobile) NetworkTypeType() string {
	return TypeNetworkTypeMobile
}

// A mobile roaming network
type NetworkTypeMobileRoaming struct {
	meta
}

func (entity *NetworkTypeMobileRoaming) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeMobileRoaming

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeMobileRoaming) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeMobileRoaming) GetType() string {
	return TypeNetworkTypeMobileRoaming
}

func (*NetworkTypeMobileRoaming) NetworkTypeType() string {
	return TypeNetworkTypeMobileRoaming
}

// A Wi-Fi network
type NetworkTypeWiFi struct {
	meta
}

func (entity *NetworkTypeWiFi) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeWiFi

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeWiFi) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeWiFi) GetType() string {
	return TypeNetworkTypeWiFi
}

func (*NetworkTypeWiFi) NetworkTypeType() string {
	return TypeNetworkTypeWiFi
}

// A different network type (e.g., Ethernet network)
type NetworkTypeOther struct {
	meta
}

func (entity *NetworkTypeOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeOther

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeOther) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeOther) GetType() string {
	return TypeNetworkTypeOther
}

func (*NetworkTypeOther) NetworkTypeType() string {
	return TypeNetworkTypeOther
}

// Contains information about the total amount of data that was used to send and receive files
type NetworkStatisticsEntryFile struct {
	meta
	// Type of the file the data is part of; pass null if the data isn't related to files
	FileType FileType `json:"file_type"`
	// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	NetworkType NetworkType `json:"network_type"`
	// Total number of bytes sent
	SentBytes int64 `json:"sent_bytes"`
	// Total number of bytes received
	ReceivedBytes int64 `json:"received_bytes"`
}

func (entity *NetworkStatisticsEntryFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatisticsEntryFile

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatisticsEntryFile) GetClass() string {
	return ClassNetworkStatisticsEntry
}

func (*NetworkStatisticsEntryFile) GetType() string {
	return TypeNetworkStatisticsEntryFile
}

func (*NetworkStatisticsEntryFile) NetworkStatisticsEntryType() string {
	return TypeNetworkStatisticsEntryFile
}

func (networkStatisticsEntryFile *NetworkStatisticsEntryFile) UnmarshalJSON(data []byte) error {
	var tmp struct {
		FileType      json.RawMessage `json:"file_type"`
		NetworkType   json.RawMessage `json:"network_type"`
		SentBytes     int64           `json:"sent_bytes"`
		ReceivedBytes int64           `json:"received_bytes"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatisticsEntryFile.SentBytes = tmp.SentBytes
	networkStatisticsEntryFile.ReceivedBytes = tmp.ReceivedBytes

	fieldFileType, _ := UnmarshalFileType(tmp.FileType)
	networkStatisticsEntryFile.FileType = fieldFileType

	fieldNetworkType, _ := UnmarshalNetworkType(tmp.NetworkType)
	networkStatisticsEntryFile.NetworkType = fieldNetworkType

	return nil
}

// Contains information about the total amount of data that was used for calls
type NetworkStatisticsEntryCall struct {
	meta
	// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	NetworkType NetworkType `json:"network_type"`
	// Total number of bytes sent
	SentBytes int64 `json:"sent_bytes"`
	// Total number of bytes received
	ReceivedBytes int64 `json:"received_bytes"`
	// Total call duration, in seconds
	Duration float64 `json:"duration"`
}

func (entity *NetworkStatisticsEntryCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatisticsEntryCall

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatisticsEntryCall) GetClass() string {
	return ClassNetworkStatisticsEntry
}

func (*NetworkStatisticsEntryCall) GetType() string {
	return TypeNetworkStatisticsEntryCall
}

func (*NetworkStatisticsEntryCall) NetworkStatisticsEntryType() string {
	return TypeNetworkStatisticsEntryCall
}

func (networkStatisticsEntryCall *NetworkStatisticsEntryCall) UnmarshalJSON(data []byte) error {
	var tmp struct {
		NetworkType   json.RawMessage `json:"network_type"`
		SentBytes     int64           `json:"sent_bytes"`
		ReceivedBytes int64           `json:"received_bytes"`
		Duration      float64         `json:"duration"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatisticsEntryCall.SentBytes = tmp.SentBytes
	networkStatisticsEntryCall.ReceivedBytes = tmp.ReceivedBytes
	networkStatisticsEntryCall.Duration = tmp.Duration

	fieldNetworkType, _ := UnmarshalNetworkType(tmp.NetworkType)
	networkStatisticsEntryCall.NetworkType = fieldNetworkType

	return nil
}

// A full list of available network statistic entries
type NetworkStatistics struct {
	meta
	// Point in time (Unix timestamp) from which the statistics are collected
	SinceDate int32 `json:"since_date"`
	// Network statistics entries
	Entries []NetworkStatisticsEntry `json:"entries"`
}

func (entity *NetworkStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatistics

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatistics) GetClass() string {
	return ClassNetworkStatistics
}

func (*NetworkStatistics) GetType() string {
	return TypeNetworkStatistics
}

func (networkStatistics *NetworkStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		SinceDate int32             `json:"since_date"`
		Entries   []json.RawMessage `json:"entries"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatistics.SinceDate = tmp.SinceDate

	fieldEntries, _ := UnmarshalListOfNetworkStatisticsEntry(tmp.Entries)
	networkStatistics.Entries = fieldEntries

	return nil
}

// Contains auto-download settings
type AutoDownloadSettings struct {
	meta
	// True, if the auto-download is enabled
	IsAutoDownloadEnabled bool `json:"is_auto_download_enabled"`
	// The maximum size of a photo file to be auto-downloaded, in bytes
	MaxPhotoFileSize int32 `json:"max_photo_file_size"`
	// The maximum size of a video file to be auto-downloaded, in bytes
	MaxVideoFileSize int64 `json:"max_video_file_size"`
	// The maximum size of other file types to be auto-downloaded, in bytes
	MaxOtherFileSize int64 `json:"max_other_file_size"`
	// The maximum suggested bitrate for uploaded videos, in kbit/s
	VideoUploadBitrate int32 `json:"video_upload_bitrate"`
	// True, if the beginning of video files needs to be preloaded for instant playback
	PreloadLargeVideos bool `json:"preload_large_videos"`
	// True, if the next audio track needs to be preloaded while the user is listening to an audio file
	PreloadNextAudio bool `json:"preload_next_audio"`
	// True, if stories needs to be preloaded
	PreloadStories bool `json:"preload_stories"`
	// True, if "use less data for calls" option needs to be enabled
	UseLessDataForCalls bool `json:"use_less_data_for_calls"`
}

func (entity *AutoDownloadSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutoDownloadSettings

	return json.Marshal((*stub)(entity))
}

func (*AutoDownloadSettings) GetClass() string {
	return ClassAutoDownloadSettings
}

func (*AutoDownloadSettings) GetType() string {
	return TypeAutoDownloadSettings
}

// Contains auto-download settings presets for the current user
type AutoDownloadSettingsPresets struct {
	meta
	// Preset with lowest settings; expected to be used by default when roaming
	Low *AutoDownloadSettings `json:"low"`
	// Preset with medium settings; expected to be used by default when using mobile data
	Medium *AutoDownloadSettings `json:"medium"`
	// Preset with highest settings; expected to be used by default when connected on Wi-Fi
	High *AutoDownloadSettings `json:"high"`
}

func (entity *AutoDownloadSettingsPresets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutoDownloadSettingsPresets

	return json.Marshal((*stub)(entity))
}

func (*AutoDownloadSettingsPresets) GetClass() string {
	return ClassAutoDownloadSettingsPresets
}

func (*AutoDownloadSettingsPresets) GetType() string {
	return TypeAutoDownloadSettingsPresets
}

// Autosave settings applied to all private chats without chat-specific settings
type AutosaveSettingsScopePrivateChats struct {
	meta
}

func (entity *AutosaveSettingsScopePrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopePrivateChats

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopePrivateChats) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopePrivateChats) GetType() string {
	return TypeAutosaveSettingsScopePrivateChats
}

func (*AutosaveSettingsScopePrivateChats) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopePrivateChats
}

// Autosave settings applied to all basic group and supergroup chats without chat-specific settings
type AutosaveSettingsScopeGroupChats struct {
	meta
}

func (entity *AutosaveSettingsScopeGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopeGroupChats

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopeGroupChats) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopeGroupChats) GetType() string {
	return TypeAutosaveSettingsScopeGroupChats
}

func (*AutosaveSettingsScopeGroupChats) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopeGroupChats
}

// Autosave settings applied to all channel chats without chat-specific settings
type AutosaveSettingsScopeChannelChats struct {
	meta
}

func (entity *AutosaveSettingsScopeChannelChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopeChannelChats

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopeChannelChats) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopeChannelChats) GetType() string {
	return TypeAutosaveSettingsScopeChannelChats
}

func (*AutosaveSettingsScopeChannelChats) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopeChannelChats
}

// Autosave settings applied to a chat
type AutosaveSettingsScopeChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
}

func (entity *AutosaveSettingsScopeChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsScopeChat

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsScopeChat) GetClass() string {
	return ClassAutosaveSettingsScope
}

func (*AutosaveSettingsScopeChat) GetType() string {
	return TypeAutosaveSettingsScopeChat
}

func (*AutosaveSettingsScopeChat) AutosaveSettingsScopeType() string {
	return TypeAutosaveSettingsScopeChat
}

// Contains autosave settings for an autosave settings scope
type ScopeAutosaveSettings struct {
	meta
	// True, if photo autosave is enabled
	AutosavePhotos bool `json:"autosave_photos"`
	// True, if video autosave is enabled
	AutosaveVideos bool `json:"autosave_videos"`
	// The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
	MaxVideoFileSize int64 `json:"max_video_file_size"`
}

func (entity *ScopeAutosaveSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ScopeAutosaveSettings

	return json.Marshal((*stub)(entity))
}

func (*ScopeAutosaveSettings) GetClass() string {
	return ClassScopeAutosaveSettings
}

func (*ScopeAutosaveSettings) GetType() string {
	return TypeScopeAutosaveSettings
}

// Contains autosave settings for a chat, which overrides default settings for the corresponding scope
type AutosaveSettingsException struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Autosave settings for the chat
	Settings *ScopeAutosaveSettings `json:"settings"`
}

func (entity *AutosaveSettingsException) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettingsException

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettingsException) GetClass() string {
	return ClassAutosaveSettingsException
}

func (*AutosaveSettingsException) GetType() string {
	return TypeAutosaveSettingsException
}

// Describes autosave settings
type AutosaveSettings struct {
	meta
	// Default autosave settings for private chats
	PrivateChatSettings *ScopeAutosaveSettings `json:"private_chat_settings"`
	// Default autosave settings for basic group and supergroup chats
	GroupSettings *ScopeAutosaveSettings `json:"group_settings"`
	// Default autosave settings for channel chats
	ChannelSettings *ScopeAutosaveSettings `json:"channel_settings"`
	// Autosave settings for specific chats
	Exceptions []*AutosaveSettingsException `json:"exceptions"`
}

func (entity *AutosaveSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutosaveSettings

	return json.Marshal((*stub)(entity))
}

func (*AutosaveSettings) GetClass() string {
	return ClassAutosaveSettings
}

func (*AutosaveSettings) GetType() string {
	return TypeAutosaveSettings
}

// Waiting for the network to become available. Use setNetworkType to change the available network type
type ConnectionStateWaitingForNetwork struct {
	meta
}

func (entity *ConnectionStateWaitingForNetwork) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateWaitingForNetwork

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateWaitingForNetwork) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateWaitingForNetwork) GetType() string {
	return TypeConnectionStateWaitingForNetwork
}

func (*ConnectionStateWaitingForNetwork) ConnectionStateType() string {
	return TypeConnectionStateWaitingForNetwork
}

// Establishing a connection with a proxy server
type ConnectionStateConnectingToProxy struct {
	meta
}

func (entity *ConnectionStateConnectingToProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateConnectingToProxy

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateConnectingToProxy) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateConnectingToProxy) GetType() string {
	return TypeConnectionStateConnectingToProxy
}

func (*ConnectionStateConnectingToProxy) ConnectionStateType() string {
	return TypeConnectionStateConnectingToProxy
}

// Establishing a connection to the Telegram servers
type ConnectionStateConnecting struct {
	meta
}

func (entity *ConnectionStateConnecting) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateConnecting

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateConnecting) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateConnecting) GetType() string {
	return TypeConnectionStateConnecting
}

func (*ConnectionStateConnecting) ConnectionStateType() string {
	return TypeConnectionStateConnecting
}

// Downloading data expected to be received while the application was offline
type ConnectionStateUpdating struct {
	meta
}

func (entity *ConnectionStateUpdating) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateUpdating

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateUpdating) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateUpdating) GetType() string {
	return TypeConnectionStateUpdating
}

func (*ConnectionStateUpdating) ConnectionStateType() string {
	return TypeConnectionStateUpdating
}

// There is a working connection to the Telegram servers
type ConnectionStateReady struct {
	meta
}

func (entity *ConnectionStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateReady

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateReady) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateReady) GetType() string {
	return TypeConnectionStateReady
}

func (*ConnectionStateReady) ConnectionStateType() string {
	return TypeConnectionStateReady
}

// A category containing frequently used private chats with non-bot users
type TopChatCategoryUsers struct {
	meta
}

func (entity *TopChatCategoryUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryUsers

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryUsers) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryUsers) GetType() string {
	return TypeTopChatCategoryUsers
}

func (*TopChatCategoryUsers) TopChatCategoryType() string {
	return TypeTopChatCategoryUsers
}

// A category containing frequently used private chats with bot users
type TopChatCategoryBots struct {
	meta
}

func (entity *TopChatCategoryBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryBots) GetType() string {
	return TypeTopChatCategoryBots
}

func (*TopChatCategoryBots) TopChatCategoryType() string {
	return TypeTopChatCategoryBots
}

// A category containing frequently used basic groups and supergroups
type TopChatCategoryGroups struct {
	meta
}

func (entity *TopChatCategoryGroups) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryGroups

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryGroups) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryGroups) GetType() string {
	return TypeTopChatCategoryGroups
}

func (*TopChatCategoryGroups) TopChatCategoryType() string {
	return TypeTopChatCategoryGroups
}

// A category containing frequently used channels
type TopChatCategoryChannels struct {
	meta
}

func (entity *TopChatCategoryChannels) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryChannels

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryChannels) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryChannels) GetType() string {
	return TypeTopChatCategoryChannels
}

func (*TopChatCategoryChannels) TopChatCategoryType() string {
	return TypeTopChatCategoryChannels
}

// A category containing frequently used chats with inline bots sorted by their usage in inline mode
type TopChatCategoryInlineBots struct {
	meta
}

func (entity *TopChatCategoryInlineBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryInlineBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryInlineBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryInlineBots) GetType() string {
	return TypeTopChatCategoryInlineBots
}

func (*TopChatCategoryInlineBots) TopChatCategoryType() string {
	return TypeTopChatCategoryInlineBots
}

// A category containing frequently used chats with bots, which Web Apps were opened
type TopChatCategoryWebAppBots struct {
	meta
}

func (entity *TopChatCategoryWebAppBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryWebAppBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryWebAppBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryWebAppBots) GetType() string {
	return TypeTopChatCategoryWebAppBots
}

func (*TopChatCategoryWebAppBots) TopChatCategoryType() string {
	return TypeTopChatCategoryWebAppBots
}

// A category containing frequently used chats used for calls
type TopChatCategoryCalls struct {
	meta
}

func (entity *TopChatCategoryCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryCalls

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryCalls) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryCalls) GetType() string {
	return TypeTopChatCategoryCalls
}

func (*TopChatCategoryCalls) TopChatCategoryType() string {
	return TypeTopChatCategoryCalls
}

// A category containing frequently used chats used to forward messages
type TopChatCategoryForwardChats struct {
	meta
}

func (entity *TopChatCategoryForwardChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryForwardChats

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryForwardChats) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryForwardChats) GetType() string {
	return TypeTopChatCategoryForwardChats
}

func (*TopChatCategoryForwardChats) TopChatCategoryType() string {
	return TypeTopChatCategoryForwardChats
}

// Contains 0-based match position
type FoundPosition struct {
	meta
	// The position of the match
	Position int32 `json:"position"`
}

func (entity *FoundPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundPosition

	return json.Marshal((*stub)(entity))
}

func (*FoundPosition) GetClass() string {
	return ClassFoundPosition
}

func (*FoundPosition) GetType() string {
	return TypeFoundPosition
}

// Contains 0-based positions of matched objects
type FoundPositions struct {
	meta
	// Total number of matched objects
	TotalCount int32 `json:"total_count"`
	// The positions of the matched objects
	Positions []int32 `json:"positions"`
}

func (entity *FoundPositions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundPositions

	return json.Marshal((*stub)(entity))
}

func (*FoundPositions) GetClass() string {
	return ClassFoundPositions
}

func (*FoundPositions) GetType() string {
	return TypeFoundPositions
}

// A URL linking to a user
type TMeUrlTypeUser struct {
	meta
	// Identifier of the user
	UserId int64 `json:"user_id"`
}

func (entity *TMeUrlTypeUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeUser

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeUser) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeUser) GetType() string {
	return TypeTMeUrlTypeUser
}

func (*TMeUrlTypeUser) TMeUrlTypeType() string {
	return TypeTMeUrlTypeUser
}

// A URL linking to a public supergroup or channel
type TMeUrlTypeSupergroup struct {
	meta
	// Identifier of the supergroup or channel
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *TMeUrlTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeSupergroup) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeSupergroup) GetType() string {
	return TypeTMeUrlTypeSupergroup
}

func (*TMeUrlTypeSupergroup) TMeUrlTypeType() string {
	return TypeTMeUrlTypeSupergroup
}

// A chat invite link
type TMeUrlTypeChatInvite struct {
	meta
	// Information about the chat invite link
	Info *ChatInviteLinkInfo `json:"info"`
}

func (entity *TMeUrlTypeChatInvite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeChatInvite

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeChatInvite) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeChatInvite) GetType() string {
	return TypeTMeUrlTypeChatInvite
}

func (*TMeUrlTypeChatInvite) TMeUrlTypeType() string {
	return TypeTMeUrlTypeChatInvite
}

// A URL linking to a sticker set
type TMeUrlTypeStickerSet struct {
	meta
	// Identifier of the sticker set
	StickerSetId JsonInt64 `json:"sticker_set_id"`
}

func (entity *TMeUrlTypeStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeStickerSet

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeStickerSet) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeStickerSet) GetType() string {
	return TypeTMeUrlTypeStickerSet
}

func (*TMeUrlTypeStickerSet) TMeUrlTypeType() string {
	return TypeTMeUrlTypeStickerSet
}

// Represents a URL linking to an internal Telegram entity
type TMeUrl struct {
	meta
	// URL
	Url string `json:"url"`
	// Type of the URL
	Type TMeUrlType `json:"type"`
}

func (entity *TMeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrl

	return json.Marshal((*stub)(entity))
}

func (*TMeUrl) GetClass() string {
	return ClassTMeUrl
}

func (*TMeUrl) GetType() string {
	return TypeTMeUrl
}

func (tMeUrl *TMeUrl) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url  string          `json:"url"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	tMeUrl.Url = tmp.Url

	fieldType, _ := UnmarshalTMeUrlType(tmp.Type)
	tMeUrl.Type = fieldType

	return nil
}

// Contains a list of t.me URLs
type TMeUrls struct {
	meta
	// List of URLs
	Urls []*TMeUrl `json:"urls"`
}

func (entity *TMeUrls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrls

	return json.Marshal((*stub)(entity))
}

func (*TMeUrls) GetClass() string {
	return ClassTMeUrls
}

func (*TMeUrls) GetType() string {
	return TypeTMeUrls
}

// Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings
type SuggestedActionEnableArchiveAndMuteNewChats struct {
	meta
}

func (entity *SuggestedActionEnableArchiveAndMuteNewChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionEnableArchiveAndMuteNewChats

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionEnableArchiveAndMuteNewChats) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionEnableArchiveAndMuteNewChats) GetType() string {
	return TypeSuggestedActionEnableArchiveAndMuteNewChats
}

func (*SuggestedActionEnableArchiveAndMuteNewChats) SuggestedActionType() string {
	return TypeSuggestedActionEnableArchiveAndMuteNewChats
}

// Suggests the user to check whether they still remember their 2-step verification password
type SuggestedActionCheckPassword struct {
	meta
}

func (entity *SuggestedActionCheckPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionCheckPassword

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionCheckPassword) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionCheckPassword) GetType() string {
	return TypeSuggestedActionCheckPassword
}

func (*SuggestedActionCheckPassword) SuggestedActionType() string {
	return TypeSuggestedActionCheckPassword
}

// Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
type SuggestedActionCheckPhoneNumber struct {
	meta
}

func (entity *SuggestedActionCheckPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionCheckPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionCheckPhoneNumber) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionCheckPhoneNumber) GetType() string {
	return TypeSuggestedActionCheckPhoneNumber
}

func (*SuggestedActionCheckPhoneNumber) SuggestedActionType() string {
	return TypeSuggestedActionCheckPhoneNumber
}

// Suggests the user to view a hint about the meaning of one and two check marks on sent messages
type SuggestedActionViewChecksHint struct {
	meta
}

func (entity *SuggestedActionViewChecksHint) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionViewChecksHint

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionViewChecksHint) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionViewChecksHint) GetType() string {
	return TypeSuggestedActionViewChecksHint
}

func (*SuggestedActionViewChecksHint) SuggestedActionType() string {
	return TypeSuggestedActionViewChecksHint
}

// Suggests the user to convert specified supergroup to a broadcast group
type SuggestedActionConvertToBroadcastGroup struct {
	meta
	// Supergroup identifier
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *SuggestedActionConvertToBroadcastGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionConvertToBroadcastGroup

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionConvertToBroadcastGroup) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionConvertToBroadcastGroup) GetType() string {
	return TypeSuggestedActionConvertToBroadcastGroup
}

func (*SuggestedActionConvertToBroadcastGroup) SuggestedActionType() string {
	return TypeSuggestedActionConvertToBroadcastGroup
}

// Suggests the user to set a 2-step verification password to be able to log in again
type SuggestedActionSetPassword struct {
	meta
	// The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
	AuthorizationDelay int32 `json:"authorization_delay"`
}

func (entity *SuggestedActionSetPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionSetPassword

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionSetPassword) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionSetPassword) GetType() string {
	return TypeSuggestedActionSetPassword
}

func (*SuggestedActionSetPassword) SuggestedActionType() string {
	return TypeSuggestedActionSetPassword
}

// Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
type SuggestedActionUpgradePremium struct {
	meta
}

func (entity *SuggestedActionUpgradePremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionUpgradePremium

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionUpgradePremium) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionUpgradePremium) GetType() string {
	return TypeSuggestedActionUpgradePremium
}

func (*SuggestedActionUpgradePremium) SuggestedActionType() string {
	return TypeSuggestedActionUpgradePremium
}

// Suggests the user to restore a recently expired Premium subscription
type SuggestedActionRestorePremium struct {
	meta
}

func (entity *SuggestedActionRestorePremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionRestorePremium

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionRestorePremium) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionRestorePremium) GetType() string {
	return TypeSuggestedActionRestorePremium
}

func (*SuggestedActionRestorePremium) SuggestedActionType() string {
	return TypeSuggestedActionRestorePremium
}

// Suggests the user to subscribe to the Premium subscription with annual payments
type SuggestedActionSubscribeToAnnualPremium struct {
	meta
}

func (entity *SuggestedActionSubscribeToAnnualPremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionSubscribeToAnnualPremium

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionSubscribeToAnnualPremium) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionSubscribeToAnnualPremium) GetType() string {
	return TypeSuggestedActionSubscribeToAnnualPremium
}

func (*SuggestedActionSubscribeToAnnualPremium) SuggestedActionType() string {
	return TypeSuggestedActionSubscribeToAnnualPremium
}

// Suggests the user to gift Telegram Premium to friends for Christmas
type SuggestedActionGiftPremiumForChristmas struct {
	meta
}

func (entity *SuggestedActionGiftPremiumForChristmas) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionGiftPremiumForChristmas

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionGiftPremiumForChristmas) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionGiftPremiumForChristmas) GetType() string {
	return TypeSuggestedActionGiftPremiumForChristmas
}

func (*SuggestedActionGiftPremiumForChristmas) SuggestedActionType() string {
	return TypeSuggestedActionGiftPremiumForChristmas
}

// Suggests the user to set birthdate
type SuggestedActionSetBirthdate struct {
	meta
}

func (entity *SuggestedActionSetBirthdate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionSetBirthdate

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionSetBirthdate) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionSetBirthdate) GetType() string {
	return TypeSuggestedActionSetBirthdate
}

func (*SuggestedActionSetBirthdate) SuggestedActionType() string {
	return TypeSuggestedActionSetBirthdate
}

// Suggests the user to extend their expiring Telegram Premium subscription
type SuggestedActionExtendPremium struct {
	meta
	// A URL for managing Telegram Premium subscription
	ManagePremiumSubscriptionUrl string `json:"manage_premium_subscription_url"`
}

func (entity *SuggestedActionExtendPremium) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionExtendPremium

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionExtendPremium) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionExtendPremium) GetType() string {
	return TypeSuggestedActionExtendPremium
}

func (*SuggestedActionExtendPremium) SuggestedActionType() string {
	return TypeSuggestedActionExtendPremium
}

// Suggests the user to extend their expiring Telegram Star subscriptions. Call getStarSubscriptions with only_expiring == true to get the number of expiring subscriptions and the number of required to buy Telegram Stars
type SuggestedActionExtendStarSubscriptions struct {
	meta
}

func (entity *SuggestedActionExtendStarSubscriptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SuggestedActionExtendStarSubscriptions

	return json.Marshal((*stub)(entity))
}

func (*SuggestedActionExtendStarSubscriptions) GetClass() string {
	return ClassSuggestedAction
}

func (*SuggestedActionExtendStarSubscriptions) GetType() string {
	return TypeSuggestedActionExtendStarSubscriptions
}

func (*SuggestedActionExtendStarSubscriptions) SuggestedActionType() string {
	return TypeSuggestedActionExtendStarSubscriptions
}

// Contains a counter
type Count struct {
	meta
	// Count
	Count int32 `json:"count"`
}

func (entity *Count) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Count

	return json.Marshal((*stub)(entity))
}

func (*Count) GetClass() string {
	return ClassCount
}

func (*Count) GetType() string {
	return TypeCount
}

// Contains some text
type Text struct {
	meta
	// Text
	Text string `json:"text"`
}

func (entity *Text) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Text

	return json.Marshal((*stub)(entity))
}

func (*Text) GetClass() string {
	return ClassText
}

func (*Text) GetType() string {
	return TypeText
}

// Contains a value representing a number of seconds
type Seconds struct {
	meta
	// Number of seconds
	Seconds float64 `json:"seconds"`
}

func (entity *Seconds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Seconds

	return json.Marshal((*stub)(entity))
}

func (*Seconds) GetClass() string {
	return ClassSeconds
}

func (*Seconds) GetType() string {
	return TypeSeconds
}

// Contains size of downloaded prefix of a file
type FileDownloadedPrefixSize struct {
	meta
	// The prefix size, in bytes
	Size int64 `json:"size"`
}

func (entity *FileDownloadedPrefixSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileDownloadedPrefixSize

	return json.Marshal((*stub)(entity))
}

func (*FileDownloadedPrefixSize) GetClass() string {
	return ClassFileDownloadedPrefixSize
}

func (*FileDownloadedPrefixSize) GetType() string {
	return TypeFileDownloadedPrefixSize
}

// Contains information about a tg: deep link
type DeepLinkInfo struct {
	meta
	// Text to be shown to the user
	Text *FormattedText `json:"text"`
	// True, if the user must be asked to update the application
	NeedUpdateApplication bool `json:"need_update_application"`
}

func (entity *DeepLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeepLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*DeepLinkInfo) GetClass() string {
	return ClassDeepLinkInfo
}

func (*DeepLinkInfo) GetType() string {
	return TypeDeepLinkInfo
}

// The text uses Markdown-style formatting
type TextParseModeMarkdown struct {
	meta
	// Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
	Version int32 `json:"version"`
}

func (entity *TextParseModeMarkdown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextParseModeMarkdown

	return json.Marshal((*stub)(entity))
}

func (*TextParseModeMarkdown) GetClass() string {
	return ClassTextParseMode
}

func (*TextParseModeMarkdown) GetType() string {
	return TypeTextParseModeMarkdown
}

func (*TextParseModeMarkdown) TextParseModeType() string {
	return TypeTextParseModeMarkdown
}

// The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
type TextParseModeHTML struct {
	meta
}

func (entity *TextParseModeHTML) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextParseModeHTML

	return json.Marshal((*stub)(entity))
}

func (*TextParseModeHTML) GetClass() string {
	return ClassTextParseMode
}

func (*TextParseModeHTML) GetType() string {
	return TypeTextParseModeHTML
}

func (*TextParseModeHTML) TextParseModeType() string {
	return TypeTextParseModeHTML
}

// A SOCKS5 proxy server
type ProxyTypeSocks5 struct {
	meta
	// Username for logging in; may be empty
	Username string `json:"username"`
	// Password for logging in; may be empty
	Password string `json:"password"`
}

func (entity *ProxyTypeSocks5) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeSocks5

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeSocks5) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeSocks5) GetType() string {
	return TypeProxyTypeSocks5
}

func (*ProxyTypeSocks5) ProxyTypeType() string {
	return TypeProxyTypeSocks5
}

// A HTTP transparent proxy server
type ProxyTypeHttp struct {
	meta
	// Username for logging in; may be empty
	Username string `json:"username"`
	// Password for logging in; may be empty
	Password string `json:"password"`
	// Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
	HttpOnly bool `json:"http_only"`
}

func (entity *ProxyTypeHttp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeHttp

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeHttp) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeHttp) GetType() string {
	return TypeProxyTypeHttp
}

func (*ProxyTypeHttp) ProxyTypeType() string {
	return TypeProxyTypeHttp
}

// An MTProto proxy server
type ProxyTypeMtproto struct {
	meta
	// The proxy's secret in hexadecimal encoding
	Secret string `json:"secret"`
}

func (entity *ProxyTypeMtproto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeMtproto

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeMtproto) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeMtproto) GetType() string {
	return TypeProxyTypeMtproto
}

func (*ProxyTypeMtproto) ProxyTypeType() string {
	return TypeProxyTypeMtproto
}

// Contains information about a proxy server
type Proxy struct {
	meta
	// Unique identifier of the proxy
	Id int32 `json:"id"`
	// Proxy server domain or IP address
	Server string `json:"server"`
	// Proxy server port
	Port int32 `json:"port"`
	// Point in time (Unix timestamp) when the proxy was last used; 0 if never
	LastUsedDate int32 `json:"last_used_date"`
	// True, if the proxy is enabled now
	IsEnabled bool `json:"is_enabled"`
	// Type of the proxy
	Type ProxyType `json:"type"`
}

func (entity *Proxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Proxy

	return json.Marshal((*stub)(entity))
}

func (*Proxy) GetClass() string {
	return ClassProxy
}

func (*Proxy) GetType() string {
	return TypeProxy
}

func (proxy *Proxy) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           int32           `json:"id"`
		Server       string          `json:"server"`
		Port         int32           `json:"port"`
		LastUsedDate int32           `json:"last_used_date"`
		IsEnabled    bool            `json:"is_enabled"`
		Type         json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	proxy.Id = tmp.Id
	proxy.Server = tmp.Server
	proxy.Port = tmp.Port
	proxy.LastUsedDate = tmp.LastUsedDate
	proxy.IsEnabled = tmp.IsEnabled

	fieldType, _ := UnmarshalProxyType(tmp.Type)
	proxy.Type = fieldType

	return nil
}

// Represents a list of proxy servers
type Proxies struct {
	meta
	// List of proxy servers
	Proxies []*Proxy `json:"proxies"`
}

func (entity *Proxies) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Proxies

	return json.Marshal((*stub)(entity))
}

func (*Proxies) GetClass() string {
	return ClassProxies
}

func (*Proxies) GetType() string {
	return TypeProxies
}

// A sticker to be added to a sticker set
type InputSticker struct {
	meta
	// File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
	Sticker InputFile `json:"sticker"`
	// Format of the sticker
	Format StickerFormat `json:"format"`
	// String with 1-20 emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// Position where the mask is placed; pass null if not specified
	MaskPosition *MaskPosition `json:"mask_position"`
	// List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
	Keywords []string `json:"keywords"`
}

func (entity *InputSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputSticker

	return json.Marshal((*stub)(entity))
}

func (*InputSticker) GetClass() string {
	return ClassInputSticker
}

func (*InputSticker) GetType() string {
	return TypeInputSticker
}

func (inputSticker *InputSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sticker      json.RawMessage `json:"sticker"`
		Format       json.RawMessage `json:"format"`
		Emojis       string          `json:"emojis"`
		MaskPosition *MaskPosition   `json:"mask_position"`
		Keywords     []string        `json:"keywords"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputSticker.Emojis = tmp.Emojis
	inputSticker.MaskPosition = tmp.MaskPosition
	inputSticker.Keywords = tmp.Keywords

	fieldSticker, _ := UnmarshalInputFile(tmp.Sticker)
	inputSticker.Sticker = fieldSticker

	fieldFormat, _ := UnmarshalStickerFormat(tmp.Format)
	inputSticker.Format = fieldFormat

	return nil
}

// Represents a date range
type DateRange struct {
	meta
	// Point in time (Unix timestamp) at which the date range begins
	StartDate int32 `json:"start_date"`
	// Point in time (Unix timestamp) at which the date range ends
	EndDate int32 `json:"end_date"`
}

func (entity *DateRange) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DateRange

	return json.Marshal((*stub)(entity))
}

func (*DateRange) GetClass() string {
	return ClassDateRange
}

func (*DateRange) GetType() string {
	return TypeDateRange
}

// A value with information about its recent changes
type StatisticalValue struct {
	meta
	// The current value
	Value float64 `json:"value"`
	// The value for the previous day
	PreviousValue float64 `json:"previous_value"`
	// The growth rate of the value, as a percentage
	GrowthRatePercentage float64 `json:"growth_rate_percentage"`
}

func (entity *StatisticalValue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalValue

	return json.Marshal((*stub)(entity))
}

func (*StatisticalValue) GetClass() string {
	return ClassStatisticalValue
}

func (*StatisticalValue) GetType() string {
	return TypeStatisticalValue
}

// A graph data
type StatisticalGraphData struct {
	meta
	// Graph data in JSON format
	JsonData string `json:"json_data"`
	// If non-empty, a token which can be used to receive a zoomed in graph
	ZoomToken string `json:"zoom_token"`
}

func (entity *StatisticalGraphData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalGraphData

	return json.Marshal((*stub)(entity))
}

func (*StatisticalGraphData) GetClass() string {
	return ClassStatisticalGraph
}

func (*StatisticalGraphData) GetType() string {
	return TypeStatisticalGraphData
}

func (*StatisticalGraphData) StatisticalGraphType() string {
	return TypeStatisticalGraphData
}

// The graph data to be asynchronously loaded through getStatisticalGraph
type StatisticalGraphAsync struct {
	meta
	// The token to use for data loading
	Token string `json:"token"`
}

func (entity *StatisticalGraphAsync) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalGraphAsync

	return json.Marshal((*stub)(entity))
}

func (*StatisticalGraphAsync) GetClass() string {
	return ClassStatisticalGraph
}

func (*StatisticalGraphAsync) GetType() string {
	return TypeStatisticalGraphAsync
}

func (*StatisticalGraphAsync) StatisticalGraphType() string {
	return TypeStatisticalGraphAsync
}

// An error message to be shown to the user instead of the graph
type StatisticalGraphError struct {
	meta
	// The error message
	ErrorMessage string `json:"error_message"`
}

func (entity *StatisticalGraphError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StatisticalGraphError

	return json.Marshal((*stub)(entity))
}

func (*StatisticalGraphError) GetClass() string {
	return ClassStatisticalGraph
}

func (*StatisticalGraphError) GetType() string {
	return TypeStatisticalGraphError
}

func (*StatisticalGraphError) StatisticalGraphType() string {
	return TypeStatisticalGraphError
}

// Describes a message sent in the chat
type ChatStatisticsObjectTypeMessage struct {
	meta
	// Message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *ChatStatisticsObjectTypeMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsObjectTypeMessage

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsObjectTypeMessage) GetClass() string {
	return ClassChatStatisticsObjectType
}

func (*ChatStatisticsObjectTypeMessage) GetType() string {
	return TypeChatStatisticsObjectTypeMessage
}

func (*ChatStatisticsObjectTypeMessage) ChatStatisticsObjectTypeType() string {
	return TypeChatStatisticsObjectTypeMessage
}

// Describes a story sent by the chat
type ChatStatisticsObjectTypeStory struct {
	meta
	// Story identifier
	StoryId int32 `json:"story_id"`
}

func (entity *ChatStatisticsObjectTypeStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsObjectTypeStory

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsObjectTypeStory) GetClass() string {
	return ClassChatStatisticsObjectType
}

func (*ChatStatisticsObjectTypeStory) GetType() string {
	return TypeChatStatisticsObjectTypeStory
}

func (*ChatStatisticsObjectTypeStory) ChatStatisticsObjectTypeType() string {
	return TypeChatStatisticsObjectTypeStory
}

// Contains statistics about interactions with a message sent in the chat or a story sent by the chat
type ChatStatisticsInteractionInfo struct {
	meta
	// Type of the object
	ObjectType ChatStatisticsObjectType `json:"object_type"`
	// Number of times the object was viewed
	ViewCount int32 `json:"view_count"`
	// Number of times the object was forwarded
	ForwardCount int32 `json:"forward_count"`
	// Number of times reactions were added to the object
	ReactionCount int32 `json:"reaction_count"`
}

func (entity *ChatStatisticsInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsInteractionInfo) GetClass() string {
	return ClassChatStatisticsInteractionInfo
}

func (*ChatStatisticsInteractionInfo) GetType() string {
	return TypeChatStatisticsInteractionInfo
}

func (chatStatisticsInteractionInfo *ChatStatisticsInteractionInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ObjectType    json.RawMessage `json:"object_type"`
		ViewCount     int32           `json:"view_count"`
		ForwardCount  int32           `json:"forward_count"`
		ReactionCount int32           `json:"reaction_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatStatisticsInteractionInfo.ViewCount = tmp.ViewCount
	chatStatisticsInteractionInfo.ForwardCount = tmp.ForwardCount
	chatStatisticsInteractionInfo.ReactionCount = tmp.ReactionCount

	fieldObjectType, _ := UnmarshalChatStatisticsObjectType(tmp.ObjectType)
	chatStatisticsInteractionInfo.ObjectType = fieldObjectType

	return nil
}

// Contains statistics about messages sent by a user
type ChatStatisticsMessageSenderInfo struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Number of sent messages
	SentMessageCount int32 `json:"sent_message_count"`
	// Average number of characters in sent messages; 0 if unknown
	AverageCharacterCount int32 `json:"average_character_count"`
}

func (entity *ChatStatisticsMessageSenderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsMessageSenderInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsMessageSenderInfo) GetClass() string {
	return ClassChatStatisticsMessageSenderInfo
}

func (*ChatStatisticsMessageSenderInfo) GetType() string {
	return TypeChatStatisticsMessageSenderInfo
}

// Contains statistics about administrator actions done by a user
type ChatStatisticsAdministratorActionsInfo struct {
	meta
	// Administrator user identifier
	UserId int64 `json:"user_id"`
	// Number of messages deleted by the administrator
	DeletedMessageCount int32 `json:"deleted_message_count"`
	// Number of users banned by the administrator
	BannedUserCount int32 `json:"banned_user_count"`
	// Number of users restricted by the administrator
	RestrictedUserCount int32 `json:"restricted_user_count"`
}

func (entity *ChatStatisticsAdministratorActionsInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsAdministratorActionsInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsAdministratorActionsInfo) GetClass() string {
	return ClassChatStatisticsAdministratorActionsInfo
}

func (*ChatStatisticsAdministratorActionsInfo) GetType() string {
	return TypeChatStatisticsAdministratorActionsInfo
}

// Contains statistics about number of new members invited by a user
type ChatStatisticsInviterInfo struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Number of new members invited by the user
	AddedMemberCount int32 `json:"added_member_count"`
}

func (entity *ChatStatisticsInviterInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsInviterInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsInviterInfo) GetClass() string {
	return ClassChatStatisticsInviterInfo
}

func (*ChatStatisticsInviterInfo) GetType() string {
	return TypeChatStatisticsInviterInfo
}

// A detailed statistics about a supergroup chat
type ChatStatisticsSupergroup struct {
	meta
	// A period to which the statistics applies
	Period *DateRange `json:"period"`
	// Number of members in the chat
	MemberCount *StatisticalValue `json:"member_count"`
	// Number of messages sent to the chat
	MessageCount *StatisticalValue `json:"message_count"`
	// Number of users who viewed messages in the chat
	ViewerCount *StatisticalValue `json:"viewer_count"`
	// Number of users who sent messages to the chat
	SenderCount *StatisticalValue `json:"sender_count"`
	// A graph containing number of members in the chat
	MemberCountGraph StatisticalGraph `json:"member_count_graph"`
	// A graph containing number of members joined and left the chat
	JoinGraph StatisticalGraph `json:"join_graph"`
	// A graph containing number of new member joins per source
	JoinBySourceGraph StatisticalGraph `json:"join_by_source_graph"`
	// A graph containing distribution of active users per language
	LanguageGraph StatisticalGraph `json:"language_graph"`
	// A graph containing distribution of sent messages by content type
	MessageContentGraph StatisticalGraph `json:"message_content_graph"`
	// A graph containing number of different actions in the chat
	ActionGraph StatisticalGraph `json:"action_graph"`
	// A graph containing distribution of message views per hour
	DayGraph StatisticalGraph `json:"day_graph"`
	// A graph containing distribution of message views per day of week
	WeekGraph StatisticalGraph `json:"week_graph"`
	// List of users sent most messages in the last week
	TopSenders []*ChatStatisticsMessageSenderInfo `json:"top_senders"`
	// List of most active administrators in the last week
	TopAdministrators []*ChatStatisticsAdministratorActionsInfo `json:"top_administrators"`
	// List of most active inviters of new members in the last week
	TopInviters []*ChatStatisticsInviterInfo `json:"top_inviters"`
}

func (entity *ChatStatisticsSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsSupergroup

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsSupergroup) GetClass() string {
	return ClassChatStatistics
}

func (*ChatStatisticsSupergroup) GetType() string {
	return TypeChatStatisticsSupergroup
}

func (*ChatStatisticsSupergroup) ChatStatisticsType() string {
	return TypeChatStatisticsSupergroup
}

func (chatStatisticsSupergroup *ChatStatisticsSupergroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Period              *DateRange                                `json:"period"`
		MemberCount         *StatisticalValue                         `json:"member_count"`
		MessageCount        *StatisticalValue                         `json:"message_count"`
		ViewerCount         *StatisticalValue                         `json:"viewer_count"`
		SenderCount         *StatisticalValue                         `json:"sender_count"`
		MemberCountGraph    json.RawMessage                           `json:"member_count_graph"`
		JoinGraph           json.RawMessage                           `json:"join_graph"`
		JoinBySourceGraph   json.RawMessage                           `json:"join_by_source_graph"`
		LanguageGraph       json.RawMessage                           `json:"language_graph"`
		MessageContentGraph json.RawMessage                           `json:"message_content_graph"`
		ActionGraph         json.RawMessage                           `json:"action_graph"`
		DayGraph            json.RawMessage                           `json:"day_graph"`
		WeekGraph           json.RawMessage                           `json:"week_graph"`
		TopSenders          []*ChatStatisticsMessageSenderInfo        `json:"top_senders"`
		TopAdministrators   []*ChatStatisticsAdministratorActionsInfo `json:"top_administrators"`
		TopInviters         []*ChatStatisticsInviterInfo              `json:"top_inviters"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatStatisticsSupergroup.Period = tmp.Period
	chatStatisticsSupergroup.MemberCount = tmp.MemberCount
	chatStatisticsSupergroup.MessageCount = tmp.MessageCount
	chatStatisticsSupergroup.ViewerCount = tmp.ViewerCount
	chatStatisticsSupergroup.SenderCount = tmp.SenderCount
	chatStatisticsSupergroup.TopSenders = tmp.TopSenders
	chatStatisticsSupergroup.TopAdministrators = tmp.TopAdministrators
	chatStatisticsSupergroup.TopInviters = tmp.TopInviters

	fieldMemberCountGraph, _ := UnmarshalStatisticalGraph(tmp.MemberCountGraph)
	chatStatisticsSupergroup.MemberCountGraph = fieldMemberCountGraph

	fieldJoinGraph, _ := UnmarshalStatisticalGraph(tmp.JoinGraph)
	chatStatisticsSupergroup.JoinGraph = fieldJoinGraph

	fieldJoinBySourceGraph, _ := UnmarshalStatisticalGraph(tmp.JoinBySourceGraph)
	chatStatisticsSupergroup.JoinBySourceGraph = fieldJoinBySourceGraph

	fieldLanguageGraph, _ := UnmarshalStatisticalGraph(tmp.LanguageGraph)
	chatStatisticsSupergroup.LanguageGraph = fieldLanguageGraph

	fieldMessageContentGraph, _ := UnmarshalStatisticalGraph(tmp.MessageContentGraph)
	chatStatisticsSupergroup.MessageContentGraph = fieldMessageContentGraph

	fieldActionGraph, _ := UnmarshalStatisticalGraph(tmp.ActionGraph)
	chatStatisticsSupergroup.ActionGraph = fieldActionGraph

	fieldDayGraph, _ := UnmarshalStatisticalGraph(tmp.DayGraph)
	chatStatisticsSupergroup.DayGraph = fieldDayGraph

	fieldWeekGraph, _ := UnmarshalStatisticalGraph(tmp.WeekGraph)
	chatStatisticsSupergroup.WeekGraph = fieldWeekGraph

	return nil
}

// A detailed statistics about a channel chat
type ChatStatisticsChannel struct {
	meta
	// A period to which the statistics applies
	Period *DateRange `json:"period"`
	// Number of members in the chat
	MemberCount *StatisticalValue `json:"member_count"`
	// Mean number of times the recently sent messages were viewed
	MeanMessageViewCount *StatisticalValue `json:"mean_message_view_count"`
	// Mean number of times the recently sent messages were shared
	MeanMessageShareCount *StatisticalValue `json:"mean_message_share_count"`
	// Mean number of times reactions were added to the recently sent messages
	MeanMessageReactionCount *StatisticalValue `json:"mean_message_reaction_count"`
	// Mean number of times the recently sent stories were viewed
	MeanStoryViewCount *StatisticalValue `json:"mean_story_view_count"`
	// Mean number of times the recently sent stories were shared
	MeanStoryShareCount *StatisticalValue `json:"mean_story_share_count"`
	// Mean number of times reactions were added to the recently sent stories
	MeanStoryReactionCount *StatisticalValue `json:"mean_story_reaction_count"`
	// A percentage of users with enabled notifications for the chat; 0-100
	EnabledNotificationsPercentage float64 `json:"enabled_notifications_percentage"`
	// A graph containing number of members in the chat
	MemberCountGraph StatisticalGraph `json:"member_count_graph"`
	// A graph containing number of members joined and left the chat
	JoinGraph StatisticalGraph `json:"join_graph"`
	// A graph containing number of members muted and unmuted the chat
	MuteGraph StatisticalGraph `json:"mute_graph"`
	// A graph containing number of message views in a given hour in the last two weeks
	ViewCountByHourGraph StatisticalGraph `json:"view_count_by_hour_graph"`
	// A graph containing number of message views per source
	ViewCountBySourceGraph StatisticalGraph `json:"view_count_by_source_graph"`
	// A graph containing number of new member joins per source
	JoinBySourceGraph StatisticalGraph `json:"join_by_source_graph"`
	// A graph containing number of users viewed chat messages per language
	LanguageGraph StatisticalGraph `json:"language_graph"`
	// A graph containing number of chat message views and shares
	MessageInteractionGraph StatisticalGraph `json:"message_interaction_graph"`
	// A graph containing number of reactions on messages
	MessageReactionGraph StatisticalGraph `json:"message_reaction_graph"`
	// A graph containing number of story views and shares
	StoryInteractionGraph StatisticalGraph `json:"story_interaction_graph"`
	// A graph containing number of reactions on stories
	StoryReactionGraph StatisticalGraph `json:"story_reaction_graph"`
	// A graph containing number of views of associated with the chat instant views
	InstantViewInteractionGraph StatisticalGraph `json:"instant_view_interaction_graph"`
	// Detailed statistics about number of views and shares of recently sent messages and stories
	RecentInteractions []*ChatStatisticsInteractionInfo `json:"recent_interactions"`
}

func (entity *ChatStatisticsChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatStatisticsChannel

	return json.Marshal((*stub)(entity))
}

func (*ChatStatisticsChannel) GetClass() string {
	return ClassChatStatistics
}

func (*ChatStatisticsChannel) GetType() string {
	return TypeChatStatisticsChannel
}

func (*ChatStatisticsChannel) ChatStatisticsType() string {
	return TypeChatStatisticsChannel
}

func (chatStatisticsChannel *ChatStatisticsChannel) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Period                         *DateRange                       `json:"period"`
		MemberCount                    *StatisticalValue                `json:"member_count"`
		MeanMessageViewCount           *StatisticalValue                `json:"mean_message_view_count"`
		MeanMessageShareCount          *StatisticalValue                `json:"mean_message_share_count"`
		MeanMessageReactionCount       *StatisticalValue                `json:"mean_message_reaction_count"`
		MeanStoryViewCount             *StatisticalValue                `json:"mean_story_view_count"`
		MeanStoryShareCount            *StatisticalValue                `json:"mean_story_share_count"`
		MeanStoryReactionCount         *StatisticalValue                `json:"mean_story_reaction_count"`
		EnabledNotificationsPercentage float64                          `json:"enabled_notifications_percentage"`
		MemberCountGraph               json.RawMessage                  `json:"member_count_graph"`
		JoinGraph                      json.RawMessage                  `json:"join_graph"`
		MuteGraph                      json.RawMessage                  `json:"mute_graph"`
		ViewCountByHourGraph           json.RawMessage                  `json:"view_count_by_hour_graph"`
		ViewCountBySourceGraph         json.RawMessage                  `json:"view_count_by_source_graph"`
		JoinBySourceGraph              json.RawMessage                  `json:"join_by_source_graph"`
		LanguageGraph                  json.RawMessage                  `json:"language_graph"`
		MessageInteractionGraph        json.RawMessage                  `json:"message_interaction_graph"`
		MessageReactionGraph           json.RawMessage                  `json:"message_reaction_graph"`
		StoryInteractionGraph          json.RawMessage                  `json:"story_interaction_graph"`
		StoryReactionGraph             json.RawMessage                  `json:"story_reaction_graph"`
		InstantViewInteractionGraph    json.RawMessage                  `json:"instant_view_interaction_graph"`
		RecentInteractions             []*ChatStatisticsInteractionInfo `json:"recent_interactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatStatisticsChannel.Period = tmp.Period
	chatStatisticsChannel.MemberCount = tmp.MemberCount
	chatStatisticsChannel.MeanMessageViewCount = tmp.MeanMessageViewCount
	chatStatisticsChannel.MeanMessageShareCount = tmp.MeanMessageShareCount
	chatStatisticsChannel.MeanMessageReactionCount = tmp.MeanMessageReactionCount
	chatStatisticsChannel.MeanStoryViewCount = tmp.MeanStoryViewCount
	chatStatisticsChannel.MeanStoryShareCount = tmp.MeanStoryShareCount
	chatStatisticsChannel.MeanStoryReactionCount = tmp.MeanStoryReactionCount
	chatStatisticsChannel.EnabledNotificationsPercentage = tmp.EnabledNotificationsPercentage
	chatStatisticsChannel.RecentInteractions = tmp.RecentInteractions

	fieldMemberCountGraph, _ := UnmarshalStatisticalGraph(tmp.MemberCountGraph)
	chatStatisticsChannel.MemberCountGraph = fieldMemberCountGraph

	fieldJoinGraph, _ := UnmarshalStatisticalGraph(tmp.JoinGraph)
	chatStatisticsChannel.JoinGraph = fieldJoinGraph

	fieldMuteGraph, _ := UnmarshalStatisticalGraph(tmp.MuteGraph)
	chatStatisticsChannel.MuteGraph = fieldMuteGraph

	fieldViewCountByHourGraph, _ := UnmarshalStatisticalGraph(tmp.ViewCountByHourGraph)
	chatStatisticsChannel.ViewCountByHourGraph = fieldViewCountByHourGraph

	fieldViewCountBySourceGraph, _ := UnmarshalStatisticalGraph(tmp.ViewCountBySourceGraph)
	chatStatisticsChannel.ViewCountBySourceGraph = fieldViewCountBySourceGraph

	fieldJoinBySourceGraph, _ := UnmarshalStatisticalGraph(tmp.JoinBySourceGraph)
	chatStatisticsChannel.JoinBySourceGraph = fieldJoinBySourceGraph

	fieldLanguageGraph, _ := UnmarshalStatisticalGraph(tmp.LanguageGraph)
	chatStatisticsChannel.LanguageGraph = fieldLanguageGraph

	fieldMessageInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.MessageInteractionGraph)
	chatStatisticsChannel.MessageInteractionGraph = fieldMessageInteractionGraph

	fieldMessageReactionGraph, _ := UnmarshalStatisticalGraph(tmp.MessageReactionGraph)
	chatStatisticsChannel.MessageReactionGraph = fieldMessageReactionGraph

	fieldStoryInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.StoryInteractionGraph)
	chatStatisticsChannel.StoryInteractionGraph = fieldStoryInteractionGraph

	fieldStoryReactionGraph, _ := UnmarshalStatisticalGraph(tmp.StoryReactionGraph)
	chatStatisticsChannel.StoryReactionGraph = fieldStoryReactionGraph

	fieldInstantViewInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.InstantViewInteractionGraph)
	chatStatisticsChannel.InstantViewInteractionGraph = fieldInstantViewInteractionGraph

	return nil
}

// Contains information about revenue earned from sponsored messages in a chat
type ChatRevenueAmount struct {
	meta
	// Cryptocurrency in which revenue is calculated
	Cryptocurrency string `json:"cryptocurrency"`
	// Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency
	TotalAmount JsonInt64 `json:"total_amount"`
	// Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency
	BalanceAmount JsonInt64 `json:"balance_amount"`
	// Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency
	AvailableAmount JsonInt64 `json:"available_amount"`
	// True, if Telegram Stars can be withdrawn now or later
	WithdrawalEnabled bool `json:"withdrawal_enabled"`
}

func (entity *ChatRevenueAmount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueAmount

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueAmount) GetClass() string {
	return ClassChatRevenueAmount
}

func (*ChatRevenueAmount) GetType() string {
	return TypeChatRevenueAmount
}

// A detailed statistics about revenue earned from sponsored messages in a chat
type ChatRevenueStatistics struct {
	meta
	// A graph containing amount of revenue in a given hour
	RevenueByHourGraph StatisticalGraph `json:"revenue_by_hour_graph"`
	// A graph containing amount of revenue
	RevenueGraph StatisticalGraph `json:"revenue_graph"`
	// Amount of earned revenue
	RevenueAmount *ChatRevenueAmount `json:"revenue_amount"`
	// Current conversion rate of the cryptocurrency in which revenue is calculated to USD
	UsdRate float64 `json:"usd_rate"`
}

func (entity *ChatRevenueStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueStatistics

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueStatistics) GetClass() string {
	return ClassChatRevenueStatistics
}

func (*ChatRevenueStatistics) GetType() string {
	return TypeChatRevenueStatistics
}

func (chatRevenueStatistics *ChatRevenueStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		RevenueByHourGraph json.RawMessage    `json:"revenue_by_hour_graph"`
		RevenueGraph       json.RawMessage    `json:"revenue_graph"`
		RevenueAmount      *ChatRevenueAmount `json:"revenue_amount"`
		UsdRate            float64            `json:"usd_rate"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatRevenueStatistics.RevenueAmount = tmp.RevenueAmount
	chatRevenueStatistics.UsdRate = tmp.UsdRate

	fieldRevenueByHourGraph, _ := UnmarshalStatisticalGraph(tmp.RevenueByHourGraph)
	chatRevenueStatistics.RevenueByHourGraph = fieldRevenueByHourGraph

	fieldRevenueGraph, _ := UnmarshalStatisticalGraph(tmp.RevenueGraph)
	chatRevenueStatistics.RevenueGraph = fieldRevenueGraph

	return nil
}

// A detailed statistics about a message
type MessageStatistics struct {
	meta
	// A graph containing number of message views and shares
	MessageInteractionGraph StatisticalGraph `json:"message_interaction_graph"`
	// A graph containing number of message reactions
	MessageReactionGraph StatisticalGraph `json:"message_reaction_graph"`
}

func (entity *MessageStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageStatistics

	return json.Marshal((*stub)(entity))
}

func (*MessageStatistics) GetClass() string {
	return ClassMessageStatistics
}

func (*MessageStatistics) GetType() string {
	return TypeMessageStatistics
}

func (messageStatistics *MessageStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageInteractionGraph json.RawMessage `json:"message_interaction_graph"`
		MessageReactionGraph    json.RawMessage `json:"message_reaction_graph"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldMessageInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.MessageInteractionGraph)
	messageStatistics.MessageInteractionGraph = fieldMessageInteractionGraph

	fieldMessageReactionGraph, _ := UnmarshalStatisticalGraph(tmp.MessageReactionGraph)
	messageStatistics.MessageReactionGraph = fieldMessageReactionGraph

	return nil
}

// A detailed statistics about a story
type StoryStatistics struct {
	meta
	// A graph containing number of story views and shares
	StoryInteractionGraph StatisticalGraph `json:"story_interaction_graph"`
	// A graph containing number of story reactions
	StoryReactionGraph StatisticalGraph `json:"story_reaction_graph"`
}

func (entity *StoryStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StoryStatistics

	return json.Marshal((*stub)(entity))
}

func (*StoryStatistics) GetClass() string {
	return ClassStoryStatistics
}

func (*StoryStatistics) GetType() string {
	return TypeStoryStatistics
}

func (storyStatistics *StoryStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StoryInteractionGraph json.RawMessage `json:"story_interaction_graph"`
		StoryReactionGraph    json.RawMessage `json:"story_reaction_graph"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldStoryInteractionGraph, _ := UnmarshalStatisticalGraph(tmp.StoryInteractionGraph)
	storyStatistics.StoryInteractionGraph = fieldStoryInteractionGraph

	fieldStoryReactionGraph, _ := UnmarshalStatisticalGraph(tmp.StoryReactionGraph)
	storyStatistics.StoryReactionGraph = fieldStoryReactionGraph

	return nil
}

// Withdrawal is pending
type RevenueWithdrawalStatePending struct {
	meta
}

func (entity *RevenueWithdrawalStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RevenueWithdrawalStatePending

	return json.Marshal((*stub)(entity))
}

func (*RevenueWithdrawalStatePending) GetClass() string {
	return ClassRevenueWithdrawalState
}

func (*RevenueWithdrawalStatePending) GetType() string {
	return TypeRevenueWithdrawalStatePending
}

func (*RevenueWithdrawalStatePending) RevenueWithdrawalStateType() string {
	return TypeRevenueWithdrawalStatePending
}

// Withdrawal succeeded
type RevenueWithdrawalStateSucceeded struct {
	meta
	// Point in time (Unix timestamp) when the withdrawal was completed
	Date int32 `json:"date"`
	// The URL where the withdrawal transaction can be viewed
	Url string `json:"url"`
}

func (entity *RevenueWithdrawalStateSucceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RevenueWithdrawalStateSucceeded

	return json.Marshal((*stub)(entity))
}

func (*RevenueWithdrawalStateSucceeded) GetClass() string {
	return ClassRevenueWithdrawalState
}

func (*RevenueWithdrawalStateSucceeded) GetType() string {
	return TypeRevenueWithdrawalStateSucceeded
}

func (*RevenueWithdrawalStateSucceeded) RevenueWithdrawalStateType() string {
	return TypeRevenueWithdrawalStateSucceeded
}

// Withdrawal failed
type RevenueWithdrawalStateFailed struct {
	meta
}

func (entity *RevenueWithdrawalStateFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RevenueWithdrawalStateFailed

	return json.Marshal((*stub)(entity))
}

func (*RevenueWithdrawalStateFailed) GetClass() string {
	return ClassRevenueWithdrawalState
}

func (*RevenueWithdrawalStateFailed) GetType() string {
	return TypeRevenueWithdrawalStateFailed
}

func (*RevenueWithdrawalStateFailed) RevenueWithdrawalStateType() string {
	return TypeRevenueWithdrawalStateFailed
}

// Describes earnings from sponsored messages in a chat in some time frame
type ChatRevenueTransactionTypeEarnings struct {
	meta
	// Point in time (Unix timestamp) when the earnings started
	StartDate int32 `json:"start_date"`
	// Point in time (Unix timestamp) when the earnings ended
	EndDate int32 `json:"end_date"`
}

func (entity *ChatRevenueTransactionTypeEarnings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueTransactionTypeEarnings

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueTransactionTypeEarnings) GetClass() string {
	return ClassChatRevenueTransactionType
}

func (*ChatRevenueTransactionTypeEarnings) GetType() string {
	return TypeChatRevenueTransactionTypeEarnings
}

func (*ChatRevenueTransactionTypeEarnings) ChatRevenueTransactionTypeType() string {
	return TypeChatRevenueTransactionTypeEarnings
}

// Describes a withdrawal of earnings
type ChatRevenueTransactionTypeWithdrawal struct {
	meta
	// Point in time (Unix timestamp) when the earnings withdrawal started
	WithdrawalDate int32 `json:"withdrawal_date"`
	// Name of the payment provider
	Provider string `json:"provider"`
	// State of the withdrawal
	State RevenueWithdrawalState `json:"state"`
}

func (entity *ChatRevenueTransactionTypeWithdrawal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueTransactionTypeWithdrawal

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueTransactionTypeWithdrawal) GetClass() string {
	return ClassChatRevenueTransactionType
}

func (*ChatRevenueTransactionTypeWithdrawal) GetType() string {
	return TypeChatRevenueTransactionTypeWithdrawal
}

func (*ChatRevenueTransactionTypeWithdrawal) ChatRevenueTransactionTypeType() string {
	return TypeChatRevenueTransactionTypeWithdrawal
}

func (chatRevenueTransactionTypeWithdrawal *ChatRevenueTransactionTypeWithdrawal) UnmarshalJSON(data []byte) error {
	var tmp struct {
		WithdrawalDate int32           `json:"withdrawal_date"`
		Provider       string          `json:"provider"`
		State          json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatRevenueTransactionTypeWithdrawal.WithdrawalDate = tmp.WithdrawalDate
	chatRevenueTransactionTypeWithdrawal.Provider = tmp.Provider

	fieldState, _ := UnmarshalRevenueWithdrawalState(tmp.State)
	chatRevenueTransactionTypeWithdrawal.State = fieldState

	return nil
}

// Describes a refund for failed withdrawal of earnings
type ChatRevenueTransactionTypeRefund struct {
	meta
	// Point in time (Unix timestamp) when the transaction was refunded
	RefundDate int32 `json:"refund_date"`
	// Name of the payment provider
	Provider string `json:"provider"`
}

func (entity *ChatRevenueTransactionTypeRefund) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueTransactionTypeRefund

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueTransactionTypeRefund) GetClass() string {
	return ClassChatRevenueTransactionType
}

func (*ChatRevenueTransactionTypeRefund) GetType() string {
	return TypeChatRevenueTransactionTypeRefund
}

func (*ChatRevenueTransactionTypeRefund) ChatRevenueTransactionTypeType() string {
	return TypeChatRevenueTransactionTypeRefund
}

// Contains a chat revenue transactions
type ChatRevenueTransaction struct {
	meta
	// Cryptocurrency in which revenue is calculated
	Cryptocurrency string `json:"cryptocurrency"`
	// The withdrawn amount, in the smallest units of the cryptocurrency
	CryptocurrencyAmount JsonInt64 `json:"cryptocurrency_amount"`
	// Type of the transaction
	Type ChatRevenueTransactionType `json:"type"`
}

func (entity *ChatRevenueTransaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueTransaction

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueTransaction) GetClass() string {
	return ClassChatRevenueTransaction
}

func (*ChatRevenueTransaction) GetType() string {
	return TypeChatRevenueTransaction
}

func (chatRevenueTransaction *ChatRevenueTransaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Cryptocurrency       string          `json:"cryptocurrency"`
		CryptocurrencyAmount JsonInt64       `json:"cryptocurrency_amount"`
		Type                 json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatRevenueTransaction.Cryptocurrency = tmp.Cryptocurrency
	chatRevenueTransaction.CryptocurrencyAmount = tmp.CryptocurrencyAmount

	fieldType, _ := UnmarshalChatRevenueTransactionType(tmp.Type)
	chatRevenueTransaction.Type = fieldType

	return nil
}

// Contains a list of chat revenue transactions
type ChatRevenueTransactions struct {
	meta
	// Total number of transactions
	TotalCount int32 `json:"total_count"`
	// List of transactions
	Transactions []*ChatRevenueTransaction `json:"transactions"`
}

func (entity *ChatRevenueTransactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatRevenueTransactions

	return json.Marshal((*stub)(entity))
}

func (*ChatRevenueTransactions) GetClass() string {
	return ClassChatRevenueTransactions
}

func (*ChatRevenueTransactions) GetType() string {
	return TypeChatRevenueTransactions
}

// Contains information about Telegram Stars earned by a bot or a chat
type StarRevenueStatus struct {
	meta
	// Total number of Telegram Stars earned
	TotalCount int64 `json:"total_count"`
	// The number of Telegram Stars that aren't withdrawn yet
	CurrentCount int64 `json:"current_count"`
	// The number of Telegram Stars that are available for withdrawal
	AvailableCount int64 `json:"available_count"`
	// True, if Telegram Stars can be withdrawn now or later
	WithdrawalEnabled bool `json:"withdrawal_enabled"`
	// Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now
	NextWithdrawalIn int32 `json:"next_withdrawal_in"`
}

func (entity *StarRevenueStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarRevenueStatus

	return json.Marshal((*stub)(entity))
}

func (*StarRevenueStatus) GetClass() string {
	return ClassStarRevenueStatus
}

func (*StarRevenueStatus) GetType() string {
	return TypeStarRevenueStatus
}

// A detailed statistics about Telegram Stars earned by a bot or a chat
type StarRevenueStatistics struct {
	meta
	// A graph containing amount of revenue in a given day
	RevenueByDayGraph StatisticalGraph `json:"revenue_by_day_graph"`
	// Telegram Star revenue status
	Status *StarRevenueStatus `json:"status"`
	// Current conversion rate of a Telegram Star to USD
	UsdRate float64 `json:"usd_rate"`
}

func (entity *StarRevenueStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StarRevenueStatistics

	return json.Marshal((*stub)(entity))
}

func (*StarRevenueStatistics) GetClass() string {
	return ClassStarRevenueStatistics
}

func (*StarRevenueStatistics) GetType() string {
	return TypeStarRevenueStatistics
}

func (starRevenueStatistics *StarRevenueStatistics) UnmarshalJSON(data []byte) error {
	var tmp struct {
		RevenueByDayGraph json.RawMessage    `json:"revenue_by_day_graph"`
		Status            *StarRevenueStatus `json:"status"`
		UsdRate           float64            `json:"usd_rate"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	starRevenueStatistics.Status = tmp.Status
	starRevenueStatistics.UsdRate = tmp.UsdRate

	fieldRevenueByDayGraph, _ := UnmarshalStatisticalGraph(tmp.RevenueByDayGraph)
	starRevenueStatistics.RevenueByDayGraph = fieldRevenueByDayGraph

	return nil
}

// A point on a Cartesian plane
type Point struct {
	meta
	// The point's first coordinate
	X float64 `json:"x"`
	// The point's second coordinate
	Y float64 `json:"y"`
}

func (entity *Point) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Point

	return json.Marshal((*stub)(entity))
}

func (*Point) GetClass() string {
	return ClassPoint
}

func (*Point) GetType() string {
	return TypePoint
}

// A straight line to a given point
type VectorPathCommandLine struct {
	meta
	// The end point of the straight line
	EndPoint *Point `json:"end_point"`
}

func (entity *VectorPathCommandLine) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VectorPathCommandLine

	return json.Marshal((*stub)(entity))
}

func (*VectorPathCommandLine) GetClass() string {
	return ClassVectorPathCommand
}

func (*VectorPathCommandLine) GetType() string {
	return TypeVectorPathCommandLine
}

func (*VectorPathCommandLine) VectorPathCommandType() string {
	return TypeVectorPathCommandLine
}

// A cubic Bzier curve to a given point
type VectorPathCommandCubicBezierCurve struct {
	meta
	// The start control point of the curve
	StartControlPoint *Point `json:"start_control_point"`
	// The end control point of the curve
	EndControlPoint *Point `json:"end_control_point"`
	// The end point of the curve
	EndPoint *Point `json:"end_point"`
}

func (entity *VectorPathCommandCubicBezierCurve) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VectorPathCommandCubicBezierCurve

	return json.Marshal((*stub)(entity))
}

func (*VectorPathCommandCubicBezierCurve) GetClass() string {
	return ClassVectorPathCommand
}

func (*VectorPathCommandCubicBezierCurve) GetType() string {
	return TypeVectorPathCommandCubicBezierCurve
}

func (*VectorPathCommandCubicBezierCurve) VectorPathCommandType() string {
	return TypeVectorPathCommandCubicBezierCurve
}

// A scope covering all users
type BotCommandScopeDefault struct {
	meta
}

func (entity *BotCommandScopeDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeDefault

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeDefault) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeDefault) GetType() string {
	return TypeBotCommandScopeDefault
}

func (*BotCommandScopeDefault) BotCommandScopeType() string {
	return TypeBotCommandScopeDefault
}

// A scope covering all private chats
type BotCommandScopeAllPrivateChats struct {
	meta
}

func (entity *BotCommandScopeAllPrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeAllPrivateChats

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeAllPrivateChats) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeAllPrivateChats) GetType() string {
	return TypeBotCommandScopeAllPrivateChats
}

func (*BotCommandScopeAllPrivateChats) BotCommandScopeType() string {
	return TypeBotCommandScopeAllPrivateChats
}

// A scope covering all group and supergroup chats
type BotCommandScopeAllGroupChats struct {
	meta
}

func (entity *BotCommandScopeAllGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeAllGroupChats

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeAllGroupChats) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeAllGroupChats) GetType() string {
	return TypeBotCommandScopeAllGroupChats
}

func (*BotCommandScopeAllGroupChats) BotCommandScopeType() string {
	return TypeBotCommandScopeAllGroupChats
}

// A scope covering all group and supergroup chat administrators
type BotCommandScopeAllChatAdministrators struct {
	meta
}

func (entity *BotCommandScopeAllChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeAllChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeAllChatAdministrators) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeAllChatAdministrators) GetType() string {
	return TypeBotCommandScopeAllChatAdministrators
}

func (*BotCommandScopeAllChatAdministrators) BotCommandScopeType() string {
	return TypeBotCommandScopeAllChatAdministrators
}

// A scope covering all members of a chat
type BotCommandScopeChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
}

func (entity *BotCommandScopeChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeChat

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeChat) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeChat) GetType() string {
	return TypeBotCommandScopeChat
}

func (*BotCommandScopeChat) BotCommandScopeType() string {
	return TypeBotCommandScopeChat
}

// A scope covering all administrators of a chat
type BotCommandScopeChatAdministrators struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
}

func (entity *BotCommandScopeChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeChatAdministrators) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeChatAdministrators) GetType() string {
	return TypeBotCommandScopeChatAdministrators
}

func (*BotCommandScopeChatAdministrators) BotCommandScopeType() string {
	return TypeBotCommandScopeChatAdministrators
}

// A scope covering a member of a chat
type BotCommandScopeChatMember struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// User identifier
	UserId int64 `json:"user_id"`
}

func (entity *BotCommandScopeChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommandScopeChatMember

	return json.Marshal((*stub)(entity))
}

func (*BotCommandScopeChatMember) GetClass() string {
	return ClassBotCommandScope
}

func (*BotCommandScopeChatMember) GetType() string {
	return TypeBotCommandScopeChatMember
}

func (*BotCommandScopeChatMember) BotCommandScopeType() string {
	return TypeBotCommandScopeChatMember
}

// Checks ownership of a new phone number to change the user's authentication phone number; for official Android and iOS applications only
type PhoneNumberCodeTypeChange struct {
	meta
}

func (entity *PhoneNumberCodeTypeChange) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberCodeTypeChange

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberCodeTypeChange) GetClass() string {
	return ClassPhoneNumberCodeType
}

func (*PhoneNumberCodeTypeChange) GetType() string {
	return TypePhoneNumberCodeTypeChange
}

func (*PhoneNumberCodeTypeChange) PhoneNumberCodeTypeType() string {
	return TypePhoneNumberCodeTypeChange
}

// Verifies ownership of a phone number to be added to the user's Telegram Passport
type PhoneNumberCodeTypeVerify struct {
	meta
}

func (entity *PhoneNumberCodeTypeVerify) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberCodeTypeVerify

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberCodeTypeVerify) GetClass() string {
	return ClassPhoneNumberCodeType
}

func (*PhoneNumberCodeTypeVerify) GetType() string {
	return TypePhoneNumberCodeTypeVerify
}

func (*PhoneNumberCodeTypeVerify) PhoneNumberCodeTypeType() string {
	return TypePhoneNumberCodeTypeVerify
}

// Confirms ownership of a phone number to prevent account deletion while handling links of the type internalLinkTypePhoneNumberConfirmation
type PhoneNumberCodeTypeConfirmOwnership struct {
	meta
	// Hash value from the link
	Hash string `json:"hash"`
}

func (entity *PhoneNumberCodeTypeConfirmOwnership) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberCodeTypeConfirmOwnership

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberCodeTypeConfirmOwnership) GetClass() string {
	return ClassPhoneNumberCodeType
}

func (*PhoneNumberCodeTypeConfirmOwnership) GetType() string {
	return TypePhoneNumberCodeTypeConfirmOwnership
}

func (*PhoneNumberCodeTypeConfirmOwnership) PhoneNumberCodeTypeType() string {
	return TypePhoneNumberCodeTypeConfirmOwnership
}

// The user authorization state has changed
type UpdateAuthorizationState struct {
	meta
	// New authorization state
	AuthorizationState AuthorizationState `json:"authorization_state"`
}

func (entity *UpdateAuthorizationState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAuthorizationState

	return json.Marshal((*stub)(entity))
}

func (*UpdateAuthorizationState) GetClass() string {
	return ClassUpdate
}

func (*UpdateAuthorizationState) GetType() string {
	return TypeUpdateAuthorizationState
}

func (*UpdateAuthorizationState) UpdateType() string {
	return TypeUpdateAuthorizationState
}

func (updateAuthorizationState *UpdateAuthorizationState) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AuthorizationState json.RawMessage `json:"authorization_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldAuthorizationState, _ := UnmarshalAuthorizationState(tmp.AuthorizationState)
	updateAuthorizationState.AuthorizationState = fieldAuthorizationState

	return nil
}

// A new message was received; can also be an outgoing message
type UpdateNewMessage struct {
	meta
	// The new message
	Message *Message `json:"message"`
}

func (entity *UpdateNewMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewMessage) GetType() string {
	return TypeUpdateNewMessage
}

func (*UpdateNewMessage) UpdateType() string {
	return TypeUpdateNewMessage
}

// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully. This update is sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
type UpdateMessageSendAcknowledged struct {
	meta
	// The chat identifier of the sent message
	ChatId int64 `json:"chat_id"`
	// A temporary message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageSendAcknowledged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendAcknowledged

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendAcknowledged) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendAcknowledged) GetType() string {
	return TypeUpdateMessageSendAcknowledged
}

func (*UpdateMessageSendAcknowledged) UpdateType() string {
	return TypeUpdateMessageSendAcknowledged
}

// A message has been successfully sent
type UpdateMessageSendSucceeded struct {
	meta
	// The sent message. Almost any field of the new message can be different from the corresponding field of the original message. For example, the field scheduling_state may change, making the message scheduled, or non-scheduled
	Message *Message `json:"message"`
	// The previous temporary message identifier
	OldMessageId int64 `json:"old_message_id"`
}

func (entity *UpdateMessageSendSucceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendSucceeded

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendSucceeded) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendSucceeded) GetType() string {
	return TypeUpdateMessageSendSucceeded
}

func (*UpdateMessageSendSucceeded) UpdateType() string {
	return TypeUpdateMessageSendSucceeded
}

// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
type UpdateMessageSendFailed struct {
	meta
	// The failed to send message
	Message *Message `json:"message"`
	// The previous temporary message identifier
	OldMessageId int64 `json:"old_message_id"`
	// The cause of the message sending failure
	Error *Error `json:"error"`
}

func (entity *UpdateMessageSendFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendFailed

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendFailed) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendFailed) GetType() string {
	return TypeUpdateMessageSendFailed
}

func (*UpdateMessageSendFailed) UpdateType() string {
	return TypeUpdateMessageSendFailed
}

// The message content has changed
type UpdateMessageContent struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// New message content
	NewContent MessageContent `json:"new_content"`
}

func (entity *UpdateMessageContent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageContent

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageContent) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageContent) GetType() string {
	return TypeUpdateMessageContent
}

func (*UpdateMessageContent) UpdateType() string {
	return TypeUpdateMessageContent
}

func (updateMessageContent *UpdateMessageContent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId     int64           `json:"chat_id"`
		MessageId  int64           `json:"message_id"`
		NewContent json.RawMessage `json:"new_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageContent.ChatId = tmp.ChatId
	updateMessageContent.MessageId = tmp.MessageId

	fieldNewContent, _ := UnmarshalMessageContent(tmp.NewContent)
	updateMessageContent.NewContent = fieldNewContent

	return nil
}

// A message was edited. Changes in the message content will come in a separate updateMessageContent
type UpdateMessageEdited struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Point in time (Unix timestamp) when the message was edited
	EditDate int32 `json:"edit_date"`
	// New message reply markup; may be null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *UpdateMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageEdited) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageEdited) GetType() string {
	return TypeUpdateMessageEdited
}

func (*UpdateMessageEdited) UpdateType() string {
	return TypeUpdateMessageEdited
}

func (updateMessageEdited *UpdateMessageEdited) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId      int64           `json:"chat_id"`
		MessageId   int64           `json:"message_id"`
		EditDate    int32           `json:"edit_date"`
		ReplyMarkup json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageEdited.ChatId = tmp.ChatId
	updateMessageEdited.MessageId = tmp.MessageId
	updateMessageEdited.EditDate = tmp.EditDate

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	updateMessageEdited.ReplyMarkup = fieldReplyMarkup

	return nil
}

// The message pinned state was changed
type UpdateMessageIsPinned struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The message identifier
	MessageId int64 `json:"message_id"`
	// True, if the message is pinned
	IsPinned bool `json:"is_pinned"`
}

func (entity *UpdateMessageIsPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageIsPinned

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageIsPinned) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageIsPinned) GetType() string {
	return TypeUpdateMessageIsPinned
}

func (*UpdateMessageIsPinned) UpdateType() string {
	return TypeUpdateMessageIsPinned
}

// The information about interactions with a message has changed
type UpdateMessageInteractionInfo struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// New information about interactions with the message; may be null
	InteractionInfo *MessageInteractionInfo `json:"interaction_info"`
}

func (entity *UpdateMessageInteractionInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageInteractionInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageInteractionInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageInteractionInfo) GetType() string {
	return TypeUpdateMessageInteractionInfo
}

func (*UpdateMessageInteractionInfo) UpdateType() string {
	return TypeUpdateMessageInteractionInfo
}

// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer
type UpdateMessageContentOpened struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageContentOpened) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageContentOpened

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageContentOpened) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageContentOpened) GetType() string {
	return TypeUpdateMessageContentOpened
}

func (*UpdateMessageContentOpened) UpdateType() string {
	return TypeUpdateMessageContentOpened
}

// A message with an unread mention was read
type UpdateMessageMentionRead struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The new number of unread mention messages left in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
}

func (entity *UpdateMessageMentionRead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageMentionRead

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageMentionRead) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageMentionRead) GetType() string {
	return TypeUpdateMessageMentionRead
}

func (*UpdateMessageMentionRead) UpdateType() string {
	return TypeUpdateMessageMentionRead
}

// The list of unread reactions added to a message was changed
type UpdateMessageUnreadReactions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The new list of unread reactions
	UnreadReactions []*UnreadReaction `json:"unread_reactions"`
	// The new number of messages with unread reactions left in the chat
	UnreadReactionCount int32 `json:"unread_reaction_count"`
}

func (entity *UpdateMessageUnreadReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageUnreadReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageUnreadReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageUnreadReactions) GetType() string {
	return TypeUpdateMessageUnreadReactions
}

func (*UpdateMessageUnreadReactions) UpdateType() string {
	return TypeUpdateMessageUnreadReactions
}

// A fact-check added to a message was changed
type UpdateMessageFactCheck struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The new fact-check
	FactCheck *FactCheck `json:"fact_check"`
}

func (entity *UpdateMessageFactCheck) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageFactCheck

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageFactCheck) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageFactCheck) GetType() string {
	return TypeUpdateMessageFactCheck
}

func (*UpdateMessageFactCheck) UpdateType() string {
	return TypeUpdateMessageFactCheck
}

// A message with a live location was viewed. When the update is received, the application is expected to update the live location
type UpdateMessageLiveLocationViewed struct {
	meta
	// Identifier of the chat with the live location message
	ChatId int64 `json:"chat_id"`
	// Identifier of the message with live location
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageLiveLocationViewed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageLiveLocationViewed

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageLiveLocationViewed) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageLiveLocationViewed) GetType() string {
	return TypeUpdateMessageLiveLocationViewed
}

func (*UpdateMessageLiveLocationViewed) UpdateType() string {
	return TypeUpdateMessageLiveLocationViewed
}

// An automatically scheduled message with video has been successfully sent after conversion
type UpdateVideoPublished struct {
	meta
	// Identifier of the chat with the message
	ChatId int64 `json:"chat_id"`
	// Identifier of the sent message
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateVideoPublished) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateVideoPublished

	return json.Marshal((*stub)(entity))
}

func (*UpdateVideoPublished) GetClass() string {
	return ClassUpdate
}

func (*UpdateVideoPublished) GetType() string {
	return TypeUpdateVideoPublished
}

func (*UpdateVideoPublished) UpdateType() string {
	return TypeUpdateVideoPublished
}

// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
type UpdateNewChat struct {
	meta
	// The chat
	Chat *Chat `json:"chat"`
}

func (entity *UpdateNewChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChat) GetType() string {
	return TypeUpdateNewChat
}

func (*UpdateNewChat) UpdateType() string {
	return TypeUpdateNewChat
}

// The title of a chat was changed
type UpdateChatTitle struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat title
	Title string `json:"title"`
}

func (entity *UpdateChatTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatTitle

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatTitle) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatTitle) GetType() string {
	return TypeUpdateChatTitle
}

func (*UpdateChatTitle) UpdateType() string {
	return TypeUpdateChatTitle
}

// A chat photo was changed
type UpdateChatPhoto struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat photo; may be null
	Photo *ChatPhotoInfo `json:"photo"`
}

func (entity *UpdateChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPhoto) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPhoto) GetType() string {
	return TypeUpdateChatPhoto
}

func (*UpdateChatPhoto) UpdateType() string {
	return TypeUpdateChatPhoto
}

// Chat accent colors have changed
type UpdateChatAccentColors struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat accent color identifier
	AccentColorId int32 `json:"accent_color_id"`
	// The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
	BackgroundCustomEmojiId JsonInt64 `json:"background_custom_emoji_id"`
	// The new chat profile accent color identifier; -1 if none
	ProfileAccentColorId int32 `json:"profile_accent_color_id"`
	// The new identifier of a custom emoji to be shown on the profile background; 0 if none
	ProfileBackgroundCustomEmojiId JsonInt64 `json:"profile_background_custom_emoji_id"`
}

func (entity *UpdateChatAccentColors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatAccentColors

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatAccentColors) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatAccentColors) GetType() string {
	return TypeUpdateChatAccentColors
}

func (*UpdateChatAccentColors) UpdateType() string {
	return TypeUpdateChatAccentColors
}

// Chat permissions were changed
type UpdateChatPermissions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat permissions
	Permissions *ChatPermissions `json:"permissions"`
}

func (entity *UpdateChatPermissions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPermissions

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPermissions) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPermissions) GetType() string {
	return TypeUpdateChatPermissions
}

func (*UpdateChatPermissions) UpdateType() string {
	return TypeUpdateChatPermissions
}

// The last message of a chat was changed
type UpdateChatLastMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new last message in the chat; may be null if the last message became unknown. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update
	LastMessage *Message `json:"last_message"`
	// The new chat positions in the chat lists
	Positions []*ChatPosition `json:"positions"`
}

func (entity *UpdateChatLastMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatLastMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatLastMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatLastMessage) GetType() string {
	return TypeUpdateChatLastMessage
}

func (*UpdateChatLastMessage) UpdateType() string {
	return TypeUpdateChatLastMessage
}

// The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update
type UpdateChatPosition struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New chat position. If new order is 0, then the chat needs to be removed from the list
	Position *ChatPosition `json:"position"`
}

func (entity *UpdateChatPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPosition

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPosition) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPosition) GetType() string {
	return TypeUpdateChatPosition
}

func (*UpdateChatPosition) UpdateType() string {
	return TypeUpdateChatPosition
}

// A chat was added to a chat list
type UpdateChatAddedToList struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The chat list to which the chat was added
	ChatList ChatList `json:"chat_list"`
}

func (entity *UpdateChatAddedToList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatAddedToList

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatAddedToList) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatAddedToList) GetType() string {
	return TypeUpdateChatAddedToList
}

func (*UpdateChatAddedToList) UpdateType() string {
	return TypeUpdateChatAddedToList
}

func (updateChatAddedToList *UpdateChatAddedToList) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId   int64           `json:"chat_id"`
		ChatList json.RawMessage `json:"chat_list"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatAddedToList.ChatId = tmp.ChatId

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateChatAddedToList.ChatList = fieldChatList

	return nil
}

// A chat was removed from a chat list
type UpdateChatRemovedFromList struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The chat list from which the chat was removed
	ChatList ChatList `json:"chat_list"`
}

func (entity *UpdateChatRemovedFromList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatRemovedFromList

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatRemovedFromList) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatRemovedFromList) GetType() string {
	return TypeUpdateChatRemovedFromList
}

func (*UpdateChatRemovedFromList) UpdateType() string {
	return TypeUpdateChatRemovedFromList
}

func (updateChatRemovedFromList *UpdateChatRemovedFromList) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId   int64           `json:"chat_id"`
		ChatList json.RawMessage `json:"chat_list"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatRemovedFromList.ChatId = tmp.ChatId

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateChatRemovedFromList.ChatList = fieldChatList

	return nil
}

// Incoming messages were read or the number of unread messages has been changed
type UpdateChatReadInbox struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// The number of unread messages left in the chat
	UnreadCount int32 `json:"unread_count"`
}

func (entity *UpdateChatReadInbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReadInbox

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReadInbox) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReadInbox) GetType() string {
	return TypeUpdateChatReadInbox
}

func (*UpdateChatReadInbox) UpdateType() string {
	return TypeUpdateChatReadInbox
}

// Outgoing messages were read
type UpdateChatReadOutbox struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
}

func (entity *UpdateChatReadOutbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReadOutbox

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReadOutbox) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReadOutbox) GetType() string {
	return TypeUpdateChatReadOutbox
}

func (*UpdateChatReadOutbox) UpdateType() string {
	return TypeUpdateChatReadOutbox
}

// The chat action bar was changed
type UpdateChatActionBar struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new value of the action bar; may be null
	ActionBar ChatActionBar `json:"action_bar"`
}

func (entity *UpdateChatActionBar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatActionBar

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatActionBar) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatActionBar) GetType() string {
	return TypeUpdateChatActionBar
}

func (*UpdateChatActionBar) UpdateType() string {
	return TypeUpdateChatActionBar
}

func (updateChatActionBar *UpdateChatActionBar) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId    int64           `json:"chat_id"`
		ActionBar json.RawMessage `json:"action_bar"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatActionBar.ChatId = tmp.ChatId

	fieldActionBar, _ := UnmarshalChatActionBar(tmp.ActionBar)
	updateChatActionBar.ActionBar = fieldActionBar

	return nil
}

// The bar for managing business bot was changed in a chat
type UpdateChatBusinessBotManageBar struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new value of the business bot manage bar; may be null
	BusinessBotManageBar *BusinessBotManageBar `json:"business_bot_manage_bar"`
}

func (entity *UpdateChatBusinessBotManageBar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatBusinessBotManageBar

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatBusinessBotManageBar) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatBusinessBotManageBar) GetType() string {
	return TypeUpdateChatBusinessBotManageBar
}

func (*UpdateChatBusinessBotManageBar) UpdateType() string {
	return TypeUpdateChatBusinessBotManageBar
}

// The chat available reactions were changed
type UpdateChatAvailableReactions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new reactions, available in the chat
	AvailableReactions ChatAvailableReactions `json:"available_reactions"`
}

func (entity *UpdateChatAvailableReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatAvailableReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatAvailableReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatAvailableReactions) GetType() string {
	return TypeUpdateChatAvailableReactions
}

func (*UpdateChatAvailableReactions) UpdateType() string {
	return TypeUpdateChatAvailableReactions
}

func (updateChatAvailableReactions *UpdateChatAvailableReactions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId             int64           `json:"chat_id"`
		AvailableReactions json.RawMessage `json:"available_reactions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatAvailableReactions.ChatId = tmp.ChatId

	fieldAvailableReactions, _ := UnmarshalChatAvailableReactions(tmp.AvailableReactions)
	updateChatAvailableReactions.AvailableReactions = fieldAvailableReactions

	return nil
}

// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
type UpdateChatDraftMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new draft message; may be null if none
	DraftMessage *DraftMessage `json:"draft_message"`
	// The new chat positions in the chat lists
	Positions []*ChatPosition `json:"positions"`
}

func (entity *UpdateChatDraftMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatDraftMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatDraftMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatDraftMessage) GetType() string {
	return TypeUpdateChatDraftMessage
}

func (*UpdateChatDraftMessage) UpdateType() string {
	return TypeUpdateChatDraftMessage
}

// Chat emoji status has changed
type UpdateChatEmojiStatus struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat emoji status; may be null
	EmojiStatus *EmojiStatus `json:"emoji_status"`
}

func (entity *UpdateChatEmojiStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatEmojiStatus

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatEmojiStatus) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatEmojiStatus) GetType() string {
	return TypeUpdateChatEmojiStatus
}

func (*UpdateChatEmojiStatus) UpdateType() string {
	return TypeUpdateChatEmojiStatus
}

// The message sender that is selected to send messages in a chat has changed
type UpdateChatMessageSender struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of message_sender_id; may be null if the user can't change message sender
	MessageSenderId MessageSender `json:"message_sender_id"`
}

func (entity *UpdateChatMessageSender) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatMessageSender

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatMessageSender) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatMessageSender) GetType() string {
	return TypeUpdateChatMessageSender
}

func (*UpdateChatMessageSender) UpdateType() string {
	return TypeUpdateChatMessageSender
}

func (updateChatMessageSender *UpdateChatMessageSender) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId          int64           `json:"chat_id"`
		MessageSenderId json.RawMessage `json:"message_sender_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatMessageSender.ChatId = tmp.ChatId

	fieldMessageSenderId, _ := UnmarshalMessageSender(tmp.MessageSenderId)
	updateChatMessageSender.MessageSenderId = fieldMessageSenderId

	return nil
}

// The message auto-delete or self-destruct timer setting for a chat was changed
type UpdateChatMessageAutoDeleteTime struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of message_auto_delete_time
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"`
}

func (entity *UpdateChatMessageAutoDeleteTime) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatMessageAutoDeleteTime

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatMessageAutoDeleteTime) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatMessageAutoDeleteTime) GetType() string {
	return TypeUpdateChatMessageAutoDeleteTime
}

func (*UpdateChatMessageAutoDeleteTime) UpdateType() string {
	return TypeUpdateChatMessageAutoDeleteTime
}

// Notification settings for a chat were changed
type UpdateChatNotificationSettings struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new notification settings
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateChatNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatNotificationSettings) GetType() string {
	return TypeUpdateChatNotificationSettings
}

func (*UpdateChatNotificationSettings) UpdateType() string {
	return TypeUpdateChatNotificationSettings
}

// The chat pending join requests were changed
type UpdateChatPendingJoinRequests struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new data about pending join requests; may be null
	PendingJoinRequests *ChatJoinRequestsInfo `json:"pending_join_requests"`
}

func (entity *UpdateChatPendingJoinRequests) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPendingJoinRequests

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPendingJoinRequests) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPendingJoinRequests) GetType() string {
	return TypeUpdateChatPendingJoinRequests
}

func (*UpdateChatPendingJoinRequests) UpdateType() string {
	return TypeUpdateChatPendingJoinRequests
}

// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
type UpdateChatReplyMarkup struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	ReplyMarkupMessageId int64 `json:"reply_markup_message_id"`
}

func (entity *UpdateChatReplyMarkup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReplyMarkup

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReplyMarkup) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReplyMarkup) GetType() string {
	return TypeUpdateChatReplyMarkup
}

func (*UpdateChatReplyMarkup) UpdateType() string {
	return TypeUpdateChatReplyMarkup
}

// The chat background was changed
type UpdateChatBackground struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat background; may be null if background was reset to default
	Background *ChatBackground `json:"background"`
}

func (entity *UpdateChatBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatBackground

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatBackground) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatBackground) GetType() string {
	return TypeUpdateChatBackground
}

func (*UpdateChatBackground) UpdateType() string {
	return TypeUpdateChatBackground
}

// The chat theme was changed
type UpdateChatTheme struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new name of the chat theme; may be empty if theme was reset to default
	ThemeName string `json:"theme_name"`
}

func (entity *UpdateChatTheme) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatTheme

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatTheme) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatTheme) GetType() string {
	return TypeUpdateChatTheme
}

func (*UpdateChatTheme) UpdateType() string {
	return TypeUpdateChatTheme
}

// The chat unread_mention_count has changed
type UpdateChatUnreadMentionCount struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The number of unread mention messages left in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
}

func (entity *UpdateChatUnreadMentionCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatUnreadMentionCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatUnreadMentionCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatUnreadMentionCount) GetType() string {
	return TypeUpdateChatUnreadMentionCount
}

func (*UpdateChatUnreadMentionCount) UpdateType() string {
	return TypeUpdateChatUnreadMentionCount
}

// The chat unread_reaction_count has changed
type UpdateChatUnreadReactionCount struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The number of messages with unread reactions left in the chat
	UnreadReactionCount int32 `json:"unread_reaction_count"`
}

func (entity *UpdateChatUnreadReactionCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatUnreadReactionCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatUnreadReactionCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatUnreadReactionCount) GetType() string {
	return TypeUpdateChatUnreadReactionCount
}

func (*UpdateChatUnreadReactionCount) UpdateType() string {
	return TypeUpdateChatUnreadReactionCount
}

// A chat video chat state has changed
type UpdateChatVideoChat struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of video_chat
	VideoChat *VideoChat `json:"video_chat"`
}

func (entity *UpdateChatVideoChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatVideoChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatVideoChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatVideoChat) GetType() string {
	return TypeUpdateChatVideoChat
}

func (*UpdateChatVideoChat) UpdateType() string {
	return TypeUpdateChatVideoChat
}

// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
type UpdateChatDefaultDisableNotification struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new default_disable_notification value
	DefaultDisableNotification bool `json:"default_disable_notification"`
}

func (entity *UpdateChatDefaultDisableNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatDefaultDisableNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatDefaultDisableNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatDefaultDisableNotification) GetType() string {
	return TypeUpdateChatDefaultDisableNotification
}

func (*UpdateChatDefaultDisableNotification) UpdateType() string {
	return TypeUpdateChatDefaultDisableNotification
}

// A chat content was allowed or restricted for saving
type UpdateChatHasProtectedContent struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of has_protected_content
	HasProtectedContent bool `json:"has_protected_content"`
}

func (entity *UpdateChatHasProtectedContent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatHasProtectedContent

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatHasProtectedContent) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatHasProtectedContent) GetType() string {
	return TypeUpdateChatHasProtectedContent
}

func (*UpdateChatHasProtectedContent) UpdateType() string {
	return TypeUpdateChatHasProtectedContent
}

// Translation of chat messages was enabled or disabled
type UpdateChatIsTranslatable struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_translatable
	IsTranslatable bool `json:"is_translatable"`
}

func (entity *UpdateChatIsTranslatable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsTranslatable

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsTranslatable) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsTranslatable) GetType() string {
	return TypeUpdateChatIsTranslatable
}

func (*UpdateChatIsTranslatable) UpdateType() string {
	return TypeUpdateChatIsTranslatable
}

// A chat was marked as unread or was read
type UpdateChatIsMarkedAsUnread struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_marked_as_unread
	IsMarkedAsUnread bool `json:"is_marked_as_unread"`
}

func (entity *UpdateChatIsMarkedAsUnread) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsMarkedAsUnread

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsMarkedAsUnread) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsMarkedAsUnread) GetType() string {
	return TypeUpdateChatIsMarkedAsUnread
}

func (*UpdateChatIsMarkedAsUnread) UpdateType() string {
	return TypeUpdateChatIsMarkedAsUnread
}

// A chat default appearance has changed
type UpdateChatViewAsTopics struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of view_as_topics
	ViewAsTopics bool `json:"view_as_topics"`
}

func (entity *UpdateChatViewAsTopics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatViewAsTopics

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatViewAsTopics) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatViewAsTopics) GetType() string {
	return TypeUpdateChatViewAsTopics
}

func (*UpdateChatViewAsTopics) UpdateType() string {
	return TypeUpdateChatViewAsTopics
}

// A chat was blocked or unblocked
type UpdateChatBlockList struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Block list to which the chat is added; may be null if none
	BlockList BlockList `json:"block_list"`
}

func (entity *UpdateChatBlockList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatBlockList

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatBlockList) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatBlockList) GetType() string {
	return TypeUpdateChatBlockList
}

func (*UpdateChatBlockList) UpdateType() string {
	return TypeUpdateChatBlockList
}

func (updateChatBlockList *UpdateChatBlockList) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId    int64           `json:"chat_id"`
		BlockList json.RawMessage `json:"block_list"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatBlockList.ChatId = tmp.ChatId

	fieldBlockList, _ := UnmarshalBlockList(tmp.BlockList)
	updateChatBlockList.BlockList = fieldBlockList

	return nil
}

// A chat's has_scheduled_messages field has changed
type UpdateChatHasScheduledMessages struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of has_scheduled_messages
	HasScheduledMessages bool `json:"has_scheduled_messages"`
}

func (entity *UpdateChatHasScheduledMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatHasScheduledMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatHasScheduledMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatHasScheduledMessages) GetType() string {
	return TypeUpdateChatHasScheduledMessages
}

func (*UpdateChatHasScheduledMessages) UpdateType() string {
	return TypeUpdateChatHasScheduledMessages
}

// The list of chat folders or a chat folder has changed
type UpdateChatFolders struct {
	meta
	// The new list of chat folders
	ChatFolders []*ChatFolderInfo `json:"chat_folders"`
	// Position of the main chat list among chat folders, 0-based
	MainChatListPosition int32 `json:"main_chat_list_position"`
	// True, if folder tags are enabled
	AreTagsEnabled bool `json:"are_tags_enabled"`
}

func (entity *UpdateChatFolders) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatFolders

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatFolders) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatFolders) GetType() string {
	return TypeUpdateChatFolders
}

func (*UpdateChatFolders) UpdateType() string {
	return TypeUpdateChatFolders
}

// The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats. There is no guarantee that it is sent just after the number of online users has changed
type UpdateChatOnlineMemberCount struct {
	meta
	// Identifier of the chat
	ChatId int64 `json:"chat_id"`
	// New number of online members in the chat, or 0 if unknown
	OnlineMemberCount int32 `json:"online_member_count"`
}

func (entity *UpdateChatOnlineMemberCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatOnlineMemberCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatOnlineMemberCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatOnlineMemberCount) GetType() string {
	return TypeUpdateChatOnlineMemberCount
}

func (*UpdateChatOnlineMemberCount) UpdateType() string {
	return TypeUpdateChatOnlineMemberCount
}

// Basic information about a Saved Messages topic has changed. This update is guaranteed to come before the topic identifier is returned to the application
type UpdateSavedMessagesTopic struct {
	meta
	// New data about the topic
	Topic *SavedMessagesTopic `json:"topic"`
}

func (entity *UpdateSavedMessagesTopic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedMessagesTopic

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedMessagesTopic) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedMessagesTopic) GetType() string {
	return TypeUpdateSavedMessagesTopic
}

func (*UpdateSavedMessagesTopic) UpdateType() string {
	return TypeUpdateSavedMessagesTopic
}

// Number of Saved Messages topics has changed
type UpdateSavedMessagesTopicCount struct {
	meta
	// Approximate total number of Saved Messages topics
	TopicCount int32 `json:"topic_count"`
}

func (entity *UpdateSavedMessagesTopicCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedMessagesTopicCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedMessagesTopicCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedMessagesTopicCount) GetType() string {
	return TypeUpdateSavedMessagesTopicCount
}

func (*UpdateSavedMessagesTopicCount) UpdateType() string {
	return TypeUpdateSavedMessagesTopicCount
}

// Basic information about a quick reply shortcut has changed. This update is guaranteed to come before the quick shortcut name is returned to the application
type UpdateQuickReplyShortcut struct {
	meta
	// New data about the shortcut
	Shortcut *QuickReplyShortcut `json:"shortcut"`
}

func (entity *UpdateQuickReplyShortcut) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateQuickReplyShortcut

	return json.Marshal((*stub)(entity))
}

func (*UpdateQuickReplyShortcut) GetClass() string {
	return ClassUpdate
}

func (*UpdateQuickReplyShortcut) GetType() string {
	return TypeUpdateQuickReplyShortcut
}

func (*UpdateQuickReplyShortcut) UpdateType() string {
	return TypeUpdateQuickReplyShortcut
}

// A quick reply shortcut and all its messages were deleted
type UpdateQuickReplyShortcutDeleted struct {
	meta
	// The identifier of the deleted shortcut
	ShortcutId int32 `json:"shortcut_id"`
}

func (entity *UpdateQuickReplyShortcutDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateQuickReplyShortcutDeleted

	return json.Marshal((*stub)(entity))
}

func (*UpdateQuickReplyShortcutDeleted) GetClass() string {
	return ClassUpdate
}

func (*UpdateQuickReplyShortcutDeleted) GetType() string {
	return TypeUpdateQuickReplyShortcutDeleted
}

func (*UpdateQuickReplyShortcutDeleted) UpdateType() string {
	return TypeUpdateQuickReplyShortcutDeleted
}

// The list of quick reply shortcuts has changed
type UpdateQuickReplyShortcuts struct {
	meta
	// The new list of identifiers of quick reply shortcuts
	ShortcutIds []int32 `json:"shortcut_ids"`
}

func (entity *UpdateQuickReplyShortcuts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateQuickReplyShortcuts

	return json.Marshal((*stub)(entity))
}

func (*UpdateQuickReplyShortcuts) GetClass() string {
	return ClassUpdate
}

func (*UpdateQuickReplyShortcuts) GetType() string {
	return TypeUpdateQuickReplyShortcuts
}

func (*UpdateQuickReplyShortcuts) UpdateType() string {
	return TypeUpdateQuickReplyShortcuts
}

// The list of quick reply shortcut messages has changed
type UpdateQuickReplyShortcutMessages struct {
	meta
	// The identifier of the shortcut
	ShortcutId int32 `json:"shortcut_id"`
	// The new list of quick reply messages for the shortcut in order from the first to the last sent
	Messages []*QuickReplyMessage `json:"messages"`
}

func (entity *UpdateQuickReplyShortcutMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateQuickReplyShortcutMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateQuickReplyShortcutMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateQuickReplyShortcutMessages) GetType() string {
	return TypeUpdateQuickReplyShortcutMessages
}

func (*UpdateQuickReplyShortcutMessages) UpdateType() string {
	return TypeUpdateQuickReplyShortcutMessages
}

// Basic information about a topic in a forum chat was changed
type UpdateForumTopicInfo struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New information about the topic
	Info *ForumTopicInfo `json:"info"`
}

func (entity *UpdateForumTopicInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateForumTopicInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateForumTopicInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateForumTopicInfo) GetType() string {
	return TypeUpdateForumTopicInfo
}

func (*UpdateForumTopicInfo) UpdateType() string {
	return TypeUpdateForumTopicInfo
}

// Notification settings for some type of chats were updated
type UpdateScopeNotificationSettings struct {
	meta
	// Types of chats for which notification settings were updated
	Scope NotificationSettingsScope `json:"scope"`
	// The new notification settings
	NotificationSettings *ScopeNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateScopeNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateScopeNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateScopeNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateScopeNotificationSettings) GetType() string {
	return TypeUpdateScopeNotificationSettings
}

func (*UpdateScopeNotificationSettings) UpdateType() string {
	return TypeUpdateScopeNotificationSettings
}

func (updateScopeNotificationSettings *UpdateScopeNotificationSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Scope                json.RawMessage            `json:"scope"`
		NotificationSettings *ScopeNotificationSettings `json:"notification_settings"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateScopeNotificationSettings.NotificationSettings = tmp.NotificationSettings

	fieldScope, _ := UnmarshalNotificationSettingsScope(tmp.Scope)
	updateScopeNotificationSettings.Scope = fieldScope

	return nil
}

// Notification settings for reactions were updated
type UpdateReactionNotificationSettings struct {
	meta
	// The new notification settings
	NotificationSettings *ReactionNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateReactionNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateReactionNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateReactionNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateReactionNotificationSettings) GetType() string {
	return TypeUpdateReactionNotificationSettings
}

func (*UpdateReactionNotificationSettings) UpdateType() string {
	return TypeUpdateReactionNotificationSettings
}

// A notification was changed
type UpdateNotification struct {
	meta
	// Unique notification group identifier
	NotificationGroupId int32 `json:"notification_group_id"`
	// Changed notification
	Notification *Notification `json:"notification"`
}

func (entity *UpdateNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateNotification) GetType() string {
	return TypeUpdateNotification
}

func (*UpdateNotification) UpdateType() string {
	return TypeUpdateNotification
}

// A list of active notifications in a notification group has changed
type UpdateNotificationGroup struct {
	meta
	// Unique notification group identifier
	NotificationGroupId int32 `json:"notification_group_id"`
	// New type of the notification group
	Type NotificationGroupType `json:"type"`
	// Identifier of a chat to which all notifications in the group belong
	ChatId int64 `json:"chat_id"`
	// Chat identifier, which notification settings must be applied to the added notifications
	NotificationSettingsChatId int64 `json:"notification_settings_chat_id"`
	// Identifier of the notification sound to be played; 0 if sound is disabled
	NotificationSoundId JsonInt64 `json:"notification_sound_id"`
	// Total number of unread notifications in the group, can be bigger than number of active notifications
	TotalCount int32 `json:"total_count"`
	// List of added group notifications, sorted by notification identifier
	AddedNotifications []*Notification `json:"added_notifications"`
	// Identifiers of removed group notifications, sorted by notification identifier
	RemovedNotificationIds []int32 `json:"removed_notification_ids"`
}

func (entity *UpdateNotificationGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNotificationGroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateNotificationGroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateNotificationGroup) GetType() string {
	return TypeUpdateNotificationGroup
}

func (*UpdateNotificationGroup) UpdateType() string {
	return TypeUpdateNotificationGroup
}

func (updateNotificationGroup *UpdateNotificationGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		NotificationGroupId        int32           `json:"notification_group_id"`
		Type                       json.RawMessage `json:"type"`
		ChatId                     int64           `json:"chat_id"`
		NotificationSettingsChatId int64           `json:"notification_settings_chat_id"`
		NotificationSoundId        JsonInt64       `json:"notification_sound_id"`
		TotalCount                 int32           `json:"total_count"`
		AddedNotifications         []*Notification `json:"added_notifications"`
		RemovedNotificationIds     []int32         `json:"removed_notification_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNotificationGroup.NotificationGroupId = tmp.NotificationGroupId
	updateNotificationGroup.ChatId = tmp.ChatId
	updateNotificationGroup.NotificationSettingsChatId = tmp.NotificationSettingsChatId
	updateNotificationGroup.NotificationSoundId = tmp.NotificationSoundId
	updateNotificationGroup.TotalCount = tmp.TotalCount
	updateNotificationGroup.AddedNotifications = tmp.AddedNotifications
	updateNotificationGroup.RemovedNotificationIds = tmp.RemovedNotificationIds

	fieldType, _ := UnmarshalNotificationGroupType(tmp.Type)
	updateNotificationGroup.Type = fieldType

	return nil
}

// Contains active notifications that were shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
type UpdateActiveNotifications struct {
	meta
	// Lists of active notification groups
	Groups []*NotificationGroup `json:"groups"`
}

func (entity *UpdateActiveNotifications) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateActiveNotifications

	return json.Marshal((*stub)(entity))
}

func (*UpdateActiveNotifications) GetClass() string {
	return ClassUpdate
}

func (*UpdateActiveNotifications) GetType() string {
	return TypeUpdateActiveNotifications
}

func (*UpdateActiveNotifications) UpdateType() string {
	return TypeUpdateActiveNotifications
}

// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
type UpdateHavePendingNotifications struct {
	meta
	// True, if there are some delayed notification updates, which will be sent soon
	HaveDelayedNotifications bool `json:"have_delayed_notifications"`
	// True, if there can be some yet unreceived notifications, which are being fetched from the server
	HaveUnreceivedNotifications bool `json:"have_unreceived_notifications"`
}

func (entity *UpdateHavePendingNotifications) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateHavePendingNotifications

	return json.Marshal((*stub)(entity))
}

func (*UpdateHavePendingNotifications) GetClass() string {
	return ClassUpdate
}

func (*UpdateHavePendingNotifications) GetType() string {
	return TypeUpdateHavePendingNotifications
}

func (*UpdateHavePendingNotifications) UpdateType() string {
	return TypeUpdateHavePendingNotifications
}

// Some messages were deleted
type UpdateDeleteMessages struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifiers of the deleted messages
	MessageIds []int64 `json:"message_ids"`
	// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
	IsPermanent bool `json:"is_permanent"`
	// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
	FromCache bool `json:"from_cache"`
}

func (entity *UpdateDeleteMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDeleteMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateDeleteMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateDeleteMessages) GetType() string {
	return TypeUpdateDeleteMessages
}

func (*UpdateDeleteMessages) UpdateType() string {
	return TypeUpdateDeleteMessages
}

// A message sender activity in the chat has changed
type UpdateChatAction struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// If not 0, the message thread identifier in which the action was performed
	MessageThreadId int64 `json:"message_thread_id"`
	// Identifier of a message sender performing the action
	SenderId MessageSender `json:"sender_id"`
	// The action
	Action ChatAction `json:"action"`
}

func (entity *UpdateChatAction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatAction

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatAction) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatAction) GetType() string {
	return TypeUpdateChatAction
}

func (*UpdateChatAction) UpdateType() string {
	return TypeUpdateChatAction
}

func (updateChatAction *UpdateChatAction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId          int64           `json:"chat_id"`
		MessageThreadId int64           `json:"message_thread_id"`
		SenderId        json.RawMessage `json:"sender_id"`
		Action          json.RawMessage `json:"action"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatAction.ChatId = tmp.ChatId
	updateChatAction.MessageThreadId = tmp.MessageThreadId

	fieldSenderId, _ := UnmarshalMessageSender(tmp.SenderId)
	updateChatAction.SenderId = fieldSenderId

	fieldAction, _ := UnmarshalChatAction(tmp.Action)
	updateChatAction.Action = fieldAction

	return nil
}

// The user went online or offline
type UpdateUserStatus struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// New status of the user
	Status UserStatus `json:"status"`
}

func (entity *UpdateUserStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserStatus

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserStatus) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserStatus) GetType() string {
	return TypeUpdateUserStatus
}

func (*UpdateUserStatus) UpdateType() string {
	return TypeUpdateUserStatus
}

func (updateUserStatus *UpdateUserStatus) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int64           `json:"user_id"`
		Status json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserStatus.UserId = tmp.UserId

	fieldStatus, _ := UnmarshalUserStatus(tmp.Status)
	updateUserStatus.Status = fieldStatus

	return nil
}

// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
type UpdateUser struct {
	meta
	// New data about the user
	User *User `json:"user"`
}

func (entity *UpdateUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUser

	return json.Marshal((*stub)(entity))
}

func (*UpdateUser) GetClass() string {
	return ClassUpdate
}

func (*UpdateUser) GetType() string {
	return TypeUpdateUser
}

func (*UpdateUser) UpdateType() string {
	return TypeUpdateUser
}

// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
type UpdateBasicGroup struct {
	meta
	// New data about the group
	BasicGroup *BasicGroup `json:"basic_group"`
}

func (entity *UpdateBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateBasicGroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateBasicGroup) GetType() string {
	return TypeUpdateBasicGroup
}

func (*UpdateBasicGroup) UpdateType() string {
	return TypeUpdateBasicGroup
}

// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
type UpdateSupergroup struct {
	meta
	// New data about the supergroup
	Supergroup *Supergroup `json:"supergroup"`
}

func (entity *UpdateSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSupergroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateSupergroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateSupergroup) GetType() string {
	return TypeUpdateSupergroup
}

func (*UpdateSupergroup) UpdateType() string {
	return TypeUpdateSupergroup
}

// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
type UpdateSecretChat struct {
	meta
	// New data about the secret chat
	SecretChat *SecretChat `json:"secret_chat"`
}

func (entity *UpdateSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSecretChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateSecretChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateSecretChat) GetType() string {
	return TypeUpdateSecretChat
}

func (*UpdateSecretChat) UpdateType() string {
	return TypeUpdateSecretChat
}

// Some data in userFullInfo has been changed
type UpdateUserFullInfo struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// New full information about the user
	UserFullInfo *UserFullInfo `json:"user_full_info"`
}

func (entity *UpdateUserFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserFullInfo) GetType() string {
	return TypeUpdateUserFullInfo
}

func (*UpdateUserFullInfo) UpdateType() string {
	return TypeUpdateUserFullInfo
}

// Some data in basicGroupFullInfo has been changed
type UpdateBasicGroupFullInfo struct {
	meta
	// Identifier of a basic group
	BasicGroupId int64 `json:"basic_group_id"`
	// New full information about the group
	BasicGroupFullInfo *BasicGroupFullInfo `json:"basic_group_full_info"`
}

func (entity *UpdateBasicGroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBasicGroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateBasicGroupFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateBasicGroupFullInfo) GetType() string {
	return TypeUpdateBasicGroupFullInfo
}

func (*UpdateBasicGroupFullInfo) UpdateType() string {
	return TypeUpdateBasicGroupFullInfo
}

// Some data in supergroupFullInfo has been changed
type UpdateSupergroupFullInfo struct {
	meta
	// Identifier of the supergroup or channel
	SupergroupId int64 `json:"supergroup_id"`
	// New full information about the supergroup
	SupergroupFullInfo *SupergroupFullInfo `json:"supergroup_full_info"`
}

func (entity *UpdateSupergroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSupergroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateSupergroupFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateSupergroupFullInfo) GetType() string {
	return TypeUpdateSupergroupFullInfo
}

func (*UpdateSupergroupFullInfo) UpdateType() string {
	return TypeUpdateSupergroupFullInfo
}

// A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification
type UpdateServiceNotification struct {
	meta
	// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
	Type string `json:"type"`
	// Notification content
	Content MessageContent `json:"content"`
}

func (entity *UpdateServiceNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateServiceNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateServiceNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateServiceNotification) GetType() string {
	return TypeUpdateServiceNotification
}

func (*UpdateServiceNotification) UpdateType() string {
	return TypeUpdateServiceNotification
}

func (updateServiceNotification *UpdateServiceNotification) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    string          `json:"type"`
		Content json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateServiceNotification.Type = tmp.Type

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	updateServiceNotification.Content = fieldContent

	return nil
}

// Information about a file was updated
type UpdateFile struct {
	meta
	// New data about the file
	File *File `json:"file"`
}

func (entity *UpdateFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFile

	return json.Marshal((*stub)(entity))
}

func (*UpdateFile) GetClass() string {
	return ClassUpdate
}

func (*UpdateFile) GetType() string {
	return TypeUpdateFile
}

func (*UpdateFile) UpdateType() string {
	return TypeUpdateFile
}

// The file generation process needs to be started by the application. Use setFileGenerationProgress and finishFileGeneration to generate the file
type UpdateFileGenerationStart struct {
	meta
	// Unique identifier for the generation process
	GenerationId JsonInt64 `json:"generation_id"`
	// The original path specified by the application in inputFileGenerated
	OriginalPath string `json:"original_path"`
	// The path to a file that must be created and where the new file must be generated by the application. If the application has no access to the path, it can use writeGeneratedFilePart to generate the file
	DestinationPath string `json:"destination_path"`
	// If the conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file that must be downloaded by the application. Otherwise, this is the conversion specified by the application in inputFileGenerated
	Conversion string `json:"conversion"`
}

func (entity *UpdateFileGenerationStart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileGenerationStart

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileGenerationStart) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileGenerationStart) GetType() string {
	return TypeUpdateFileGenerationStart
}

func (*UpdateFileGenerationStart) UpdateType() string {
	return TypeUpdateFileGenerationStart
}

// File generation is no longer needed
type UpdateFileGenerationStop struct {
	meta
	// Unique identifier for the generation process
	GenerationId JsonInt64 `json:"generation_id"`
}

func (entity *UpdateFileGenerationStop) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileGenerationStop

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileGenerationStop) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileGenerationStop) GetType() string {
	return TypeUpdateFileGenerationStop
}

func (*UpdateFileGenerationStop) UpdateType() string {
	return TypeUpdateFileGenerationStop
}

// The state of the file download list has changed
type UpdateFileDownloads struct {
	meta
	// Total size of files in the file download list, in bytes
	TotalSize int64 `json:"total_size"`
	// Total number of files in the file download list
	TotalCount int32 `json:"total_count"`
	// Total downloaded size of files in the file download list, in bytes
	DownloadedSize int64 `json:"downloaded_size"`
}

func (entity *UpdateFileDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileDownloads

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileDownloads) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileDownloads) GetType() string {
	return TypeUpdateFileDownloads
}

func (*UpdateFileDownloads) UpdateType() string {
	return TypeUpdateFileDownloads
}

// A file was added to the file download list. This update is sent only after file download list is loaded for the first time
type UpdateFileAddedToDownloads struct {
	meta
	// The added file download
	FileDownload *FileDownload `json:"file_download"`
	// New number of being downloaded and recently downloaded files found
	Counts *DownloadedFileCounts `json:"counts"`
}

func (entity *UpdateFileAddedToDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileAddedToDownloads

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileAddedToDownloads) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileAddedToDownloads) GetType() string {
	return TypeUpdateFileAddedToDownloads
}

func (*UpdateFileAddedToDownloads) UpdateType() string {
	return TypeUpdateFileAddedToDownloads
}

// A file download was changed. This update is sent only after file download list is loaded for the first time
type UpdateFileDownload struct {
	meta
	// File identifier
	FileId int32 `json:"file_id"`
	// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
	CompleteDate int32 `json:"complete_date"`
	// True, if downloading of the file is paused
	IsPaused bool `json:"is_paused"`
	// New number of being downloaded and recently downloaded files found
	Counts *DownloadedFileCounts `json:"counts"`
}

func (entity *UpdateFileDownload) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileDownload

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileDownload) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileDownload) GetType() string {
	return TypeUpdateFileDownload
}

func (*UpdateFileDownload) UpdateType() string {
	return TypeUpdateFileDownload
}

// A file was removed from the file download list. This update is sent only after file download list is loaded for the first time
type UpdateFileRemovedFromDownloads struct {
	meta
	// File identifier
	FileId int32 `json:"file_id"`
	// New number of being downloaded and recently downloaded files found
	Counts *DownloadedFileCounts `json:"counts"`
}

func (entity *UpdateFileRemovedFromDownloads) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileRemovedFromDownloads

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileRemovedFromDownloads) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileRemovedFromDownloads) GetType() string {
	return TypeUpdateFileRemovedFromDownloads
}

func (*UpdateFileRemovedFromDownloads) UpdateType() string {
	return TypeUpdateFileRemovedFromDownloads
}

// A request can't be completed unless application verification is performed; for official mobile applications only. The method setApplicationVerificationToken must be called once the verification is completed or failed
type UpdateApplicationVerificationRequired struct {
	meta
	// Unique identifier for the verification process
	VerificationId int64 `json:"verification_id"`
	// Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic) for Android, or a unique string to compare with verify_nonce field from a push notification for iOS
	Nonce string `json:"nonce"`
	// Cloud project number to pass to the Play Integrity API on Android
	CloudProjectNumber JsonInt64 `json:"cloud_project_number"`
}

func (entity *UpdateApplicationVerificationRequired) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateApplicationVerificationRequired

	return json.Marshal((*stub)(entity))
}

func (*UpdateApplicationVerificationRequired) GetClass() string {
	return ClassUpdate
}

func (*UpdateApplicationVerificationRequired) GetType() string {
	return TypeUpdateApplicationVerificationRequired
}

func (*UpdateApplicationVerificationRequired) UpdateType() string {
	return TypeUpdateApplicationVerificationRequired
}

// New call was created or information about a call was updated
type UpdateCall struct {
	meta
	// New data about a call
	Call *Call `json:"call"`
}

func (entity *UpdateCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateCall

	return json.Marshal((*stub)(entity))
}

func (*UpdateCall) GetClass() string {
	return ClassUpdate
}

func (*UpdateCall) GetType() string {
	return TypeUpdateCall
}

func (*UpdateCall) UpdateType() string {
	return TypeUpdateCall
}

// Information about a group call was updated
type UpdateGroupCall struct {
	meta
	// New data about a group call
	GroupCall *GroupCall `json:"group_call"`
}

func (entity *UpdateGroupCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateGroupCall

	return json.Marshal((*stub)(entity))
}

func (*UpdateGroupCall) GetClass() string {
	return ClassUpdate
}

func (*UpdateGroupCall) GetType() string {
	return TypeUpdateGroupCall
}

func (*UpdateGroupCall) UpdateType() string {
	return TypeUpdateGroupCall
}

// Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
type UpdateGroupCallParticipant struct {
	meta
	// Identifier of group call
	GroupCallId int32 `json:"group_call_id"`
	// New data about a participant
	Participant *GroupCallParticipant `json:"participant"`
}

func (entity *UpdateGroupCallParticipant) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateGroupCallParticipant

	return json.Marshal((*stub)(entity))
}

func (*UpdateGroupCallParticipant) GetClass() string {
	return ClassUpdate
}

func (*UpdateGroupCallParticipant) GetType() string {
	return TypeUpdateGroupCallParticipant
}

func (*UpdateGroupCallParticipant) UpdateType() string {
	return TypeUpdateGroupCallParticipant
}

// New call signaling data arrived
type UpdateNewCallSignalingData struct {
	meta
	// The call identifier
	CallId int32 `json:"call_id"`
	// The data
	Data []byte `json:"data"`
}

func (entity *UpdateNewCallSignalingData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCallSignalingData

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCallSignalingData) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCallSignalingData) GetType() string {
	return TypeUpdateNewCallSignalingData
}

func (*UpdateNewCallSignalingData) UpdateType() string {
	return TypeUpdateNewCallSignalingData
}

// Some privacy setting rules have been changed
type UpdateUserPrivacySettingRules struct {
	meta
	// The privacy setting
	Setting UserPrivacySetting `json:"setting"`
	// New privacy rules
	Rules *UserPrivacySettingRules `json:"rules"`
}

func (entity *UpdateUserPrivacySettingRules) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserPrivacySettingRules

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserPrivacySettingRules) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserPrivacySettingRules) GetType() string {
	return TypeUpdateUserPrivacySettingRules
}

func (*UpdateUserPrivacySettingRules) UpdateType() string {
	return TypeUpdateUserPrivacySettingRules
}

func (updateUserPrivacySettingRules *UpdateUserPrivacySettingRules) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Setting json.RawMessage          `json:"setting"`
		Rules   *UserPrivacySettingRules `json:"rules"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserPrivacySettingRules.Rules = tmp.Rules

	fieldSetting, _ := UnmarshalUserPrivacySetting(tmp.Setting)
	updateUserPrivacySettingRules.Setting = fieldSetting

	return nil
}

// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
type UpdateUnreadMessageCount struct {
	meta
	// The chat list with changed number of unread messages
	ChatList ChatList `json:"chat_list"`
	// Total number of unread messages
	UnreadCount int32 `json:"unread_count"`
	// Total number of unread messages in unmuted chats
	UnreadUnmutedCount int32 `json:"unread_unmuted_count"`
}

func (entity *UpdateUnreadMessageCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnreadMessageCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnreadMessageCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnreadMessageCount) GetType() string {
	return TypeUpdateUnreadMessageCount
}

func (*UpdateUnreadMessageCount) UpdateType() string {
	return TypeUpdateUnreadMessageCount
}

func (updateUnreadMessageCount *UpdateUnreadMessageCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatList           json.RawMessage `json:"chat_list"`
		UnreadCount        int32           `json:"unread_count"`
		UnreadUnmutedCount int32           `json:"unread_unmuted_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUnreadMessageCount.UnreadCount = tmp.UnreadCount
	updateUnreadMessageCount.UnreadUnmutedCount = tmp.UnreadUnmutedCount

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateUnreadMessageCount.ChatList = fieldChatList

	return nil
}

// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
type UpdateUnreadChatCount struct {
	meta
	// The chat list with changed number of unread messages
	ChatList ChatList `json:"chat_list"`
	// Approximate total number of chats in the chat list
	TotalCount int32 `json:"total_count"`
	// Total number of unread chats
	UnreadCount int32 `json:"unread_count"`
	// Total number of unread unmuted chats
	UnreadUnmutedCount int32 `json:"unread_unmuted_count"`
	// Total number of chats marked as unread
	MarkedAsUnreadCount int32 `json:"marked_as_unread_count"`
	// Total number of unmuted chats marked as unread
	MarkedAsUnreadUnmutedCount int32 `json:"marked_as_unread_unmuted_count"`
}

func (entity *UpdateUnreadChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnreadChatCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnreadChatCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnreadChatCount) GetType() string {
	return TypeUpdateUnreadChatCount
}

func (*UpdateUnreadChatCount) UpdateType() string {
	return TypeUpdateUnreadChatCount
}

func (updateUnreadChatCount *UpdateUnreadChatCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatList                   json.RawMessage `json:"chat_list"`
		TotalCount                 int32           `json:"total_count"`
		UnreadCount                int32           `json:"unread_count"`
		UnreadUnmutedCount         int32           `json:"unread_unmuted_count"`
		MarkedAsUnreadCount        int32           `json:"marked_as_unread_count"`
		MarkedAsUnreadUnmutedCount int32           `json:"marked_as_unread_unmuted_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUnreadChatCount.TotalCount = tmp.TotalCount
	updateUnreadChatCount.UnreadCount = tmp.UnreadCount
	updateUnreadChatCount.UnreadUnmutedCount = tmp.UnreadUnmutedCount
	updateUnreadChatCount.MarkedAsUnreadCount = tmp.MarkedAsUnreadCount
	updateUnreadChatCount.MarkedAsUnreadUnmutedCount = tmp.MarkedAsUnreadUnmutedCount

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateUnreadChatCount.ChatList = fieldChatList

	return nil
}

// A story was changed
type UpdateStory struct {
	meta
	// The new information about the story
	Story *Story `json:"story"`
}

func (entity *UpdateStory) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStory

	return json.Marshal((*stub)(entity))
}

func (*UpdateStory) GetClass() string {
	return ClassUpdate
}

func (*UpdateStory) GetType() string {
	return TypeUpdateStory
}

func (*UpdateStory) UpdateType() string {
	return TypeUpdateStory
}

// A story became inaccessible
type UpdateStoryDeleted struct {
	meta
	// Identifier of the chat that posted the story
	StorySenderChatId int64 `json:"story_sender_chat_id"`
	// Story identifier
	StoryId int32 `json:"story_id"`
}

func (entity *UpdateStoryDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStoryDeleted

	return json.Marshal((*stub)(entity))
}

func (*UpdateStoryDeleted) GetClass() string {
	return ClassUpdate
}

func (*UpdateStoryDeleted) GetType() string {
	return TypeUpdateStoryDeleted
}

func (*UpdateStoryDeleted) UpdateType() string {
	return TypeUpdateStoryDeleted
}

// A story has been successfully sent
type UpdateStorySendSucceeded struct {
	meta
	// The sent story
	Story *Story `json:"story"`
	// The previous temporary story identifier
	OldStoryId int32 `json:"old_story_id"`
}

func (entity *UpdateStorySendSucceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStorySendSucceeded

	return json.Marshal((*stub)(entity))
}

func (*UpdateStorySendSucceeded) GetClass() string {
	return ClassUpdate
}

func (*UpdateStorySendSucceeded) GetType() string {
	return TypeUpdateStorySendSucceeded
}

func (*UpdateStorySendSucceeded) UpdateType() string {
	return TypeUpdateStorySendSucceeded
}

// A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update
type UpdateStorySendFailed struct {
	meta
	// The failed to send story
	Story *Story `json:"story"`
	// The cause of the story sending failure
	Error *Error `json:"error"`
	// Type of the error; may be null if unknown
	ErrorType CanSendStoryResult `json:"error_type"`
}

func (entity *UpdateStorySendFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStorySendFailed

	return json.Marshal((*stub)(entity))
}

func (*UpdateStorySendFailed) GetClass() string {
	return ClassUpdate
}

func (*UpdateStorySendFailed) GetType() string {
	return TypeUpdateStorySendFailed
}

func (*UpdateStorySendFailed) UpdateType() string {
	return TypeUpdateStorySendFailed
}

func (updateStorySendFailed *UpdateStorySendFailed) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Story     *Story          `json:"story"`
		Error     *Error          `json:"error"`
		ErrorType json.RawMessage `json:"error_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateStorySendFailed.Story = tmp.Story
	updateStorySendFailed.Error = tmp.Error

	fieldErrorType, _ := UnmarshalCanSendStoryResult(tmp.ErrorType)
	updateStorySendFailed.ErrorType = fieldErrorType

	return nil
}

// The list of active stories posted by a specific chat has changed
type UpdateChatActiveStories struct {
	meta
	// The new list of active stories
	ActiveStories *ChatActiveStories `json:"active_stories"`
}

func (entity *UpdateChatActiveStories) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatActiveStories

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatActiveStories) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatActiveStories) GetType() string {
	return TypeUpdateChatActiveStories
}

func (*UpdateChatActiveStories) UpdateType() string {
	return TypeUpdateChatActiveStories
}

// Number of chats in a story list has changed
type UpdateStoryListChatCount struct {
	meta
	// The story list
	StoryList StoryList `json:"story_list"`
	// Approximate total number of chats with active stories in the list
	ChatCount int32 `json:"chat_count"`
}

func (entity *UpdateStoryListChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStoryListChatCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateStoryListChatCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateStoryListChatCount) GetType() string {
	return TypeUpdateStoryListChatCount
}

func (*UpdateStoryListChatCount) UpdateType() string {
	return TypeUpdateStoryListChatCount
}

func (updateStoryListChatCount *UpdateStoryListChatCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StoryList json.RawMessage `json:"story_list"`
		ChatCount int32           `json:"chat_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateStoryListChatCount.ChatCount = tmp.ChatCount

	fieldStoryList, _ := UnmarshalStoryList(tmp.StoryList)
	updateStoryListChatCount.StoryList = fieldStoryList

	return nil
}

// Story stealth mode settings have changed
type UpdateStoryStealthMode struct {
	meta
	// Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
	ActiveUntilDate int32 `json:"active_until_date"`
	// Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
	CooldownUntilDate int32 `json:"cooldown_until_date"`
}

func (entity *UpdateStoryStealthMode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStoryStealthMode

	return json.Marshal((*stub)(entity))
}

func (*UpdateStoryStealthMode) GetClass() string {
	return ClassUpdate
}

func (*UpdateStoryStealthMode) GetType() string {
	return TypeUpdateStoryStealthMode
}

func (*UpdateStoryStealthMode) UpdateType() string {
	return TypeUpdateStoryStealthMode
}

// An option changed its value
type UpdateOption struct {
	meta
	// The option name
	Name string `json:"name"`
	// The new option value
	Value OptionValue `json:"value"`
}

func (entity *UpdateOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateOption

	return json.Marshal((*stub)(entity))
}

func (*UpdateOption) GetClass() string {
	return ClassUpdate
}

func (*UpdateOption) GetType() string {
	return TypeUpdateOption
}

func (*UpdateOption) UpdateType() string {
	return TypeUpdateOption
}

func (updateOption *UpdateOption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Name  string          `json:"name"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateOption.Name = tmp.Name

	fieldValue, _ := UnmarshalOptionValue(tmp.Value)
	updateOption.Value = fieldValue

	return nil
}

// A sticker set has changed
type UpdateStickerSet struct {
	meta
	// The sticker set
	StickerSet *StickerSet `json:"sticker_set"`
}

func (entity *UpdateStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStickerSet

	return json.Marshal((*stub)(entity))
}

func (*UpdateStickerSet) GetClass() string {
	return ClassUpdate
}

func (*UpdateStickerSet) GetType() string {
	return TypeUpdateStickerSet
}

func (*UpdateStickerSet) UpdateType() string {
	return TypeUpdateStickerSet
}

// The list of installed sticker sets was updated
type UpdateInstalledStickerSets struct {
	meta
	// Type of the affected stickers
	StickerType StickerType `json:"sticker_type"`
	// The new list of installed ordinary sticker sets
	StickerSetIds []JsonInt64 `json:"sticker_set_ids"`
}

func (entity *UpdateInstalledStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateInstalledStickerSets

	return json.Marshal((*stub)(entity))
}

func (*UpdateInstalledStickerSets) GetClass() string {
	return ClassUpdate
}

func (*UpdateInstalledStickerSets) GetType() string {
	return TypeUpdateInstalledStickerSets
}

func (*UpdateInstalledStickerSets) UpdateType() string {
	return TypeUpdateInstalledStickerSets
}

func (updateInstalledStickerSets *UpdateInstalledStickerSets) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StickerType   json.RawMessage `json:"sticker_type"`
		StickerSetIds []JsonInt64     `json:"sticker_set_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateInstalledStickerSets.StickerSetIds = tmp.StickerSetIds

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	updateInstalledStickerSets.StickerType = fieldStickerType

	return nil
}

// The list of trending sticker sets was updated or some of them were viewed
type UpdateTrendingStickerSets struct {
	meta
	// Type of the affected stickers
	StickerType StickerType `json:"sticker_type"`
	// The prefix of the list of trending sticker sets with the newest trending sticker sets
	StickerSets *TrendingStickerSets `json:"sticker_sets"`
}

func (entity *UpdateTrendingStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateTrendingStickerSets

	return json.Marshal((*stub)(entity))
}

func (*UpdateTrendingStickerSets) GetClass() string {
	return ClassUpdate
}

func (*UpdateTrendingStickerSets) GetType() string {
	return TypeUpdateTrendingStickerSets
}

func (*UpdateTrendingStickerSets) UpdateType() string {
	return TypeUpdateTrendingStickerSets
}

func (updateTrendingStickerSets *UpdateTrendingStickerSets) UnmarshalJSON(data []byte) error {
	var tmp struct {
		StickerType json.RawMessage      `json:"sticker_type"`
		StickerSets *TrendingStickerSets `json:"sticker_sets"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateTrendingStickerSets.StickerSets = tmp.StickerSets

	fieldStickerType, _ := UnmarshalStickerType(tmp.StickerType)
	updateTrendingStickerSets.StickerType = fieldStickerType

	return nil
}

// The list of recently used stickers was updated
type UpdateRecentStickers struct {
	meta
	// True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
	IsAttached bool `json:"is_attached"`
	// The new list of file identifiers of recently used stickers
	StickerIds []int32 `json:"sticker_ids"`
}

func (entity *UpdateRecentStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateRecentStickers

	return json.Marshal((*stub)(entity))
}

func (*UpdateRecentStickers) GetClass() string {
	return ClassUpdate
}

func (*UpdateRecentStickers) GetType() string {
	return TypeUpdateRecentStickers
}

func (*UpdateRecentStickers) UpdateType() string {
	return TypeUpdateRecentStickers
}

// The list of favorite stickers was updated
type UpdateFavoriteStickers struct {
	meta
	// The new list of file identifiers of favorite stickers
	StickerIds []int32 `json:"sticker_ids"`
}

func (entity *UpdateFavoriteStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFavoriteStickers

	return json.Marshal((*stub)(entity))
}

func (*UpdateFavoriteStickers) GetClass() string {
	return ClassUpdate
}

func (*UpdateFavoriteStickers) GetType() string {
	return TypeUpdateFavoriteStickers
}

func (*UpdateFavoriteStickers) UpdateType() string {
	return TypeUpdateFavoriteStickers
}

// The list of saved animations was updated
type UpdateSavedAnimations struct {
	meta
	// The new list of file identifiers of saved animations
	AnimationIds []int32 `json:"animation_ids"`
}

func (entity *UpdateSavedAnimations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedAnimations

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedAnimations) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedAnimations) GetType() string {
	return TypeUpdateSavedAnimations
}

func (*UpdateSavedAnimations) UpdateType() string {
	return TypeUpdateSavedAnimations
}

// The list of saved notification sounds was updated. This update may not be sent until information about a notification sound was requested for the first time
type UpdateSavedNotificationSounds struct {
	meta
	// The new list of identifiers of saved notification sounds
	NotificationSoundIds []JsonInt64 `json:"notification_sound_ids"`
}

func (entity *UpdateSavedNotificationSounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedNotificationSounds

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedNotificationSounds) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedNotificationSounds) GetType() string {
	return TypeUpdateSavedNotificationSounds
}

func (*UpdateSavedNotificationSounds) UpdateType() string {
	return TypeUpdateSavedNotificationSounds
}

// The default background has changed
type UpdateDefaultBackground struct {
	meta
	// True, if default background for dark theme has changed
	ForDarkTheme bool `json:"for_dark_theme"`
	// The new default background; may be null
	Background *Background `json:"background"`
}

func (entity *UpdateDefaultBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDefaultBackground

	return json.Marshal((*stub)(entity))
}

func (*UpdateDefaultBackground) GetClass() string {
	return ClassUpdate
}

func (*UpdateDefaultBackground) GetType() string {
	return TypeUpdateDefaultBackground
}

func (*UpdateDefaultBackground) UpdateType() string {
	return TypeUpdateDefaultBackground
}

// The list of available chat themes has changed
type UpdateChatThemes struct {
	meta
	// The new list of chat themes
	ChatThemes []*ChatTheme `json:"chat_themes"`
}

func (entity *UpdateChatThemes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatThemes

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatThemes) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatThemes) GetType() string {
	return TypeUpdateChatThemes
}

func (*UpdateChatThemes) UpdateType() string {
	return TypeUpdateChatThemes
}

// The list of supported accent colors has changed
type UpdateAccentColors struct {
	meta
	// Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
	Colors []*AccentColor `json:"colors"`
	// The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specififed order
	AvailableAccentColorIds []int32 `json:"available_accent_color_ids"`
}

func (entity *UpdateAccentColors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAccentColors

	return json.Marshal((*stub)(entity))
}

func (*UpdateAccentColors) GetClass() string {
	return ClassUpdate
}

func (*UpdateAccentColors) GetType() string {
	return TypeUpdateAccentColors
}

func (*UpdateAccentColors) UpdateType() string {
	return TypeUpdateAccentColors
}

// The list of supported accent colors for user profiles has changed
type UpdateProfileAccentColors struct {
	meta
	// Information about supported colors
	Colors []*ProfileAccentColor `json:"colors"`
	// The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specififed order
	AvailableAccentColorIds []int32 `json:"available_accent_color_ids"`
}

func (entity *UpdateProfileAccentColors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateProfileAccentColors

	return json.Marshal((*stub)(entity))
}

func (*UpdateProfileAccentColors) GetClass() string {
	return ClassUpdate
}

func (*UpdateProfileAccentColors) GetType() string {
	return TypeUpdateProfileAccentColors
}

func (*UpdateProfileAccentColors) UpdateType() string {
	return TypeUpdateProfileAccentColors
}

// Some language pack strings have been updated
type UpdateLanguagePackStrings struct {
	meta
	// Localization target to which the language pack belongs
	LocalizationTarget string `json:"localization_target"`
	// Identifier of the updated language pack
	LanguagePackId string `json:"language_pack_id"`
	// List of changed language pack strings; empty if all strings have changed
	Strings []*LanguagePackString `json:"strings"`
}

func (entity *UpdateLanguagePackStrings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateLanguagePackStrings

	return json.Marshal((*stub)(entity))
}

func (*UpdateLanguagePackStrings) GetClass() string {
	return ClassUpdate
}

func (*UpdateLanguagePackStrings) GetType() string {
	return TypeUpdateLanguagePackStrings
}

func (*UpdateLanguagePackStrings) UpdateType() string {
	return TypeUpdateLanguagePackStrings
}

// The connection state has changed. This update must be used only to show a human-readable description of the connection state
type UpdateConnectionState struct {
	meta
	// The new connection state
	State ConnectionState `json:"state"`
}

func (entity *UpdateConnectionState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateConnectionState

	return json.Marshal((*stub)(entity))
}

func (*UpdateConnectionState) GetClass() string {
	return ClassUpdate
}

func (*UpdateConnectionState) GetType() string {
	return TypeUpdateConnectionState
}

func (*UpdateConnectionState) UpdateType() string {
	return TypeUpdateConnectionState
}

func (updateConnectionState *UpdateConnectionState) UnmarshalJSON(data []byte) error {
	var tmp struct {
		State json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldState, _ := UnmarshalConnectionState(tmp.State)
	updateConnectionState.State = fieldState

	return nil
}

// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
type UpdateTermsOfService struct {
	meta
	// Identifier of the terms of service
	TermsOfServiceId string `json:"terms_of_service_id"`
	// The new terms of service
	TermsOfService *TermsOfService `json:"terms_of_service"`
}

func (entity *UpdateTermsOfService) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateTermsOfService

	return json.Marshal((*stub)(entity))
}

func (*UpdateTermsOfService) GetClass() string {
	return ClassUpdate
}

func (*UpdateTermsOfService) GetType() string {
	return TypeUpdateTermsOfService
}

func (*UpdateTermsOfService) UpdateType() string {
	return TypeUpdateTermsOfService
}

// The first unconfirmed session has changed
type UpdateUnconfirmedSession struct {
	meta
	// The unconfirmed session; may be null if none
	Session *UnconfirmedSession `json:"session"`
}

func (entity *UpdateUnconfirmedSession) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnconfirmedSession

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnconfirmedSession) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnconfirmedSession) GetType() string {
	return TypeUpdateUnconfirmedSession
}

func (*UpdateUnconfirmedSession) UpdateType() string {
	return TypeUpdateUnconfirmedSession
}

// The list of bots added to attachment or side menu has changed
type UpdateAttachmentMenuBots struct {
	meta
	// The new list of bots. The bots must not be shown on scheduled messages screen
	Bots []*AttachmentMenuBot `json:"bots"`
}

func (entity *UpdateAttachmentMenuBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAttachmentMenuBots

	return json.Marshal((*stub)(entity))
}

func (*UpdateAttachmentMenuBots) GetClass() string {
	return ClassUpdate
}

func (*UpdateAttachmentMenuBots) GetType() string {
	return TypeUpdateAttachmentMenuBots
}

func (*UpdateAttachmentMenuBots) UpdateType() string {
	return TypeUpdateAttachmentMenuBots
}

// A message was sent by an opened Web App, so the Web App needs to be closed
type UpdateWebAppMessageSent struct {
	meta
	// Identifier of Web App launch
	WebAppLaunchId JsonInt64 `json:"web_app_launch_id"`
}

func (entity *UpdateWebAppMessageSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateWebAppMessageSent

	return json.Marshal((*stub)(entity))
}

func (*UpdateWebAppMessageSent) GetClass() string {
	return ClassUpdate
}

func (*UpdateWebAppMessageSent) GetType() string {
	return TypeUpdateWebAppMessageSent
}

func (*UpdateWebAppMessageSent) UpdateType() string {
	return TypeUpdateWebAppMessageSent
}

// The list of active emoji reactions has changed
type UpdateActiveEmojiReactions struct {
	meta
	// The new list of active emoji reactions
	Emojis []string `json:"emojis"`
}

func (entity *UpdateActiveEmojiReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateActiveEmojiReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateActiveEmojiReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateActiveEmojiReactions) GetType() string {
	return TypeUpdateActiveEmojiReactions
}

func (*UpdateActiveEmojiReactions) UpdateType() string {
	return TypeUpdateActiveEmojiReactions
}

// The list of available message effects has changed
type UpdateAvailableMessageEffects struct {
	meta
	// The new list of available message effects from emoji reactions
	ReactionEffectIds []JsonInt64 `json:"reaction_effect_ids"`
	// The new list of available message effects from Premium stickers
	StickerEffectIds []JsonInt64 `json:"sticker_effect_ids"`
}

func (entity *UpdateAvailableMessageEffects) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAvailableMessageEffects

	return json.Marshal((*stub)(entity))
}

func (*UpdateAvailableMessageEffects) GetClass() string {
	return ClassUpdate
}

func (*UpdateAvailableMessageEffects) GetType() string {
	return TypeUpdateAvailableMessageEffects
}

func (*UpdateAvailableMessageEffects) UpdateType() string {
	return TypeUpdateAvailableMessageEffects
}

// The type of default reaction has changed
type UpdateDefaultReactionType struct {
	meta
	// The new type of the default reaction
	ReactionType ReactionType `json:"reaction_type"`
}

func (entity *UpdateDefaultReactionType) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDefaultReactionType

	return json.Marshal((*stub)(entity))
}

func (*UpdateDefaultReactionType) GetClass() string {
	return ClassUpdate
}

func (*UpdateDefaultReactionType) GetType() string {
	return TypeUpdateDefaultReactionType
}

func (*UpdateDefaultReactionType) UpdateType() string {
	return TypeUpdateDefaultReactionType
}

func (updateDefaultReactionType *UpdateDefaultReactionType) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReactionType json.RawMessage `json:"reaction_type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldReactionType, _ := UnmarshalReactionType(tmp.ReactionType)
	updateDefaultReactionType.ReactionType = fieldReactionType

	return nil
}

// Tags used in Saved Messages or a Saved Messages topic have changed
type UpdateSavedMessagesTags struct {
	meta
	// Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed
	SavedMessagesTopicId int64 `json:"saved_messages_topic_id"`
	// The new tags
	Tags *SavedMessagesTags `json:"tags"`
}

func (entity *UpdateSavedMessagesTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedMessagesTags

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedMessagesTags) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedMessagesTags) GetType() string {
	return TypeUpdateSavedMessagesTags
}

func (*UpdateSavedMessagesTags) UpdateType() string {
	return TypeUpdateSavedMessagesTags
}

// The list of messages with active live location that need to be updated by the application has changed. The list is persistent across application restarts only if the message database is used
type UpdateActiveLiveLocationMessages struct {
	meta
	// The list of messages with active live locations
	Messages []*Message `json:"messages"`
}

func (entity *UpdateActiveLiveLocationMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateActiveLiveLocationMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateActiveLiveLocationMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateActiveLiveLocationMessages) GetType() string {
	return TypeUpdateActiveLiveLocationMessages
}

func (*UpdateActiveLiveLocationMessages) UpdateType() string {
	return TypeUpdateActiveLiveLocationMessages
}

// The number of Telegram Stars owned by the current user has changed
type UpdateOwnedStarCount struct {
	meta
	// The new number of Telegram Stars owned
	StarCount int64 `json:"star_count"`
}

func (entity *UpdateOwnedStarCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateOwnedStarCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateOwnedStarCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateOwnedStarCount) GetType() string {
	return TypeUpdateOwnedStarCount
}

func (*UpdateOwnedStarCount) UpdateType() string {
	return TypeUpdateOwnedStarCount
}

// The revenue earned from sponsored messages in a chat has changed. If chat revenue screen is opened, then getChatRevenueTransactions may be called to fetch new transactions
type UpdateChatRevenueAmount struct {
	meta
	// Identifier of the chat
	ChatId int64 `json:"chat_id"`
	// New amount of earned revenue
	RevenueAmount *ChatRevenueAmount `json:"revenue_amount"`
}

func (entity *UpdateChatRevenueAmount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatRevenueAmount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatRevenueAmount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatRevenueAmount) GetType() string {
	return TypeUpdateChatRevenueAmount
}

func (*UpdateChatRevenueAmount) UpdateType() string {
	return TypeUpdateChatRevenueAmount
}

// The Telegram Star revenue earned by a bot or a chat has changed. If Telegram Star transaction screen of the chat is opened, then getStarTransactions may be called to fetch new transactions
type UpdateStarRevenueStatus struct {
	meta
	// Identifier of the owner of the Telegram Stars
	OwnerId MessageSender `json:"owner_id"`
	// New Telegram Star revenue status
	Status *StarRevenueStatus `json:"status"`
}

func (entity *UpdateStarRevenueStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateStarRevenueStatus

	return json.Marshal((*stub)(entity))
}

func (*UpdateStarRevenueStatus) GetClass() string {
	return ClassUpdate
}

func (*UpdateStarRevenueStatus) GetType() string {
	return TypeUpdateStarRevenueStatus
}

func (*UpdateStarRevenueStatus) UpdateType() string {
	return TypeUpdateStarRevenueStatus
}

func (updateStarRevenueStatus *UpdateStarRevenueStatus) UnmarshalJSON(data []byte) error {
	var tmp struct {
		OwnerId json.RawMessage    `json:"owner_id"`
		Status  *StarRevenueStatus `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateStarRevenueStatus.Status = tmp.Status

	fieldOwnerId, _ := UnmarshalMessageSender(tmp.OwnerId)
	updateStarRevenueStatus.OwnerId = fieldOwnerId

	return nil
}

// The parameters of speech recognition without Telegram Premium subscription has changed
type UpdateSpeechRecognitionTrial struct {
	meta
	// The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds
	MaxMediaDuration int32 `json:"max_media_duration"`
	// The total number of allowed speech recognitions per week; 0 if none
	WeeklyCount int32 `json:"weekly_count"`
	// Number of left speech recognition attempts this week
	LeftCount int32 `json:"left_count"`
	// Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown
	NextResetDate int32 `json:"next_reset_date"`
}

func (entity *UpdateSpeechRecognitionTrial) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSpeechRecognitionTrial

	return json.Marshal((*stub)(entity))
}

func (*UpdateSpeechRecognitionTrial) GetClass() string {
	return ClassUpdate
}

func (*UpdateSpeechRecognitionTrial) GetType() string {
	return TypeUpdateSpeechRecognitionTrial
}

func (*UpdateSpeechRecognitionTrial) UpdateType() string {
	return TypeUpdateSpeechRecognitionTrial
}

// The list of supported dice emojis has changed
type UpdateDiceEmojis struct {
	meta
	// The new list of supported dice emojis
	Emojis []string `json:"emojis"`
}

func (entity *UpdateDiceEmojis) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDiceEmojis

	return json.Marshal((*stub)(entity))
}

func (*UpdateDiceEmojis) GetClass() string {
	return ClassUpdate
}

func (*UpdateDiceEmojis) GetType() string {
	return TypeUpdateDiceEmojis
}

func (*UpdateDiceEmojis) UpdateType() string {
	return TypeUpdateDiceEmojis
}

// Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
type UpdateAnimatedEmojiMessageClicked struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The animated sticker to be played
	Sticker *Sticker `json:"sticker"`
}

func (entity *UpdateAnimatedEmojiMessageClicked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAnimatedEmojiMessageClicked

	return json.Marshal((*stub)(entity))
}

func (*UpdateAnimatedEmojiMessageClicked) GetClass() string {
	return ClassUpdate
}

func (*UpdateAnimatedEmojiMessageClicked) GetType() string {
	return TypeUpdateAnimatedEmojiMessageClicked
}

func (*UpdateAnimatedEmojiMessageClicked) UpdateType() string {
	return TypeUpdateAnimatedEmojiMessageClicked
}

// The parameters of animation search through getOption("animation_search_bot_username") bot has changed
type UpdateAnimationSearchParameters struct {
	meta
	// Name of the animation search provider
	Provider string `json:"provider"`
	// The new list of emojis suggested for searching
	Emojis []string `json:"emojis"`
}

func (entity *UpdateAnimationSearchParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAnimationSearchParameters

	return json.Marshal((*stub)(entity))
}

func (*UpdateAnimationSearchParameters) GetClass() string {
	return ClassUpdate
}

func (*UpdateAnimationSearchParameters) GetType() string {
	return TypeUpdateAnimationSearchParameters
}

func (*UpdateAnimationSearchParameters) UpdateType() string {
	return TypeUpdateAnimationSearchParameters
}

// The list of suggested to the user actions has changed
type UpdateSuggestedActions struct {
	meta
	// Added suggested actions
	AddedActions []SuggestedAction `json:"added_actions"`
	// Removed suggested actions
	RemovedActions []SuggestedAction `json:"removed_actions"`
}

func (entity *UpdateSuggestedActions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSuggestedActions

	return json.Marshal((*stub)(entity))
}

func (*UpdateSuggestedActions) GetClass() string {
	return ClassUpdate
}

func (*UpdateSuggestedActions) GetType() string {
	return TypeUpdateSuggestedActions
}

func (*UpdateSuggestedActions) UpdateType() string {
	return TypeUpdateSuggestedActions
}

func (updateSuggestedActions *UpdateSuggestedActions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AddedActions   []json.RawMessage `json:"added_actions"`
		RemovedActions []json.RawMessage `json:"removed_actions"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldAddedActions, _ := UnmarshalListOfSuggestedAction(tmp.AddedActions)
	updateSuggestedActions.AddedActions = fieldAddedActions

	fieldRemovedActions, _ := UnmarshalListOfSuggestedAction(tmp.RemovedActions)
	updateSuggestedActions.RemovedActions = fieldRemovedActions

	return nil
}

// Download or upload file speed for the user was limited, but it can be restored by subscription to Telegram Premium. The notification can be postponed until a being downloaded or uploaded file is visible to the user. Use getOption("premium_download_speedup") or getOption("premium_upload_speedup") to get expected speedup after subscription to Telegram Premium
type UpdateSpeedLimitNotification struct {
	meta
	// True, if upload speed was limited; false, if download speed was limited
	IsUpload bool `json:"is_upload"`
}

func (entity *UpdateSpeedLimitNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSpeedLimitNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateSpeedLimitNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateSpeedLimitNotification) GetType() string {
	return TypeUpdateSpeedLimitNotification
}

func (*UpdateSpeedLimitNotification) UpdateType() string {
	return TypeUpdateSpeedLimitNotification
}

// The list of contacts that had birthdays recently or will have birthday soon has changed
type UpdateContactCloseBirthdays struct {
	meta
	// List of contact users with close birthday
	CloseBirthdayUsers []*CloseBirthdayUser `json:"close_birthday_users"`
}

func (entity *UpdateContactCloseBirthdays) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateContactCloseBirthdays

	return json.Marshal((*stub)(entity))
}

func (*UpdateContactCloseBirthdays) GetClass() string {
	return ClassUpdate
}

func (*UpdateContactCloseBirthdays) GetType() string {
	return TypeUpdateContactCloseBirthdays
}

func (*UpdateContactCloseBirthdays) UpdateType() string {
	return TypeUpdateContactCloseBirthdays
}

// Autosave settings for some type of chats were updated
type UpdateAutosaveSettings struct {
	meta
	// Type of chats for which autosave settings were updated
	Scope AutosaveSettingsScope `json:"scope"`
	// The new autosave settings; may be null if the settings are reset to default
	Settings *ScopeAutosaveSettings `json:"settings"`
}

func (entity *UpdateAutosaveSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAutosaveSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateAutosaveSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateAutosaveSettings) GetType() string {
	return TypeUpdateAutosaveSettings
}

func (*UpdateAutosaveSettings) UpdateType() string {
	return TypeUpdateAutosaveSettings
}

func (updateAutosaveSettings *UpdateAutosaveSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Scope    json.RawMessage        `json:"scope"`
		Settings *ScopeAutosaveSettings `json:"settings"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateAutosaveSettings.Settings = tmp.Settings

	fieldScope, _ := UnmarshalAutosaveSettingsScope(tmp.Scope)
	updateAutosaveSettings.Scope = fieldScope

	return nil
}

// A business connection has changed; for bots only
type UpdateBusinessConnection struct {
	meta
	// New data about the connection
	Connection *BusinessConnection `json:"connection"`
}

func (entity *UpdateBusinessConnection) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBusinessConnection

	return json.Marshal((*stub)(entity))
}

func (*UpdateBusinessConnection) GetClass() string {
	return ClassUpdate
}

func (*UpdateBusinessConnection) GetType() string {
	return TypeUpdateBusinessConnection
}

func (*UpdateBusinessConnection) UpdateType() string {
	return TypeUpdateBusinessConnection
}

// A new message was added to a business account; for bots only
type UpdateNewBusinessMessage struct {
	meta
	// Unique identifier of the business connection
	ConnectionId string `json:"connection_id"`
	// The new message
	Message *BusinessMessage `json:"message"`
}

func (entity *UpdateNewBusinessMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewBusinessMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewBusinessMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewBusinessMessage) GetType() string {
	return TypeUpdateNewBusinessMessage
}

func (*UpdateNewBusinessMessage) UpdateType() string {
	return TypeUpdateNewBusinessMessage
}

// A message in a business account was edited; for bots only
type UpdateBusinessMessageEdited struct {
	meta
	// Unique identifier of the business connection
	ConnectionId string `json:"connection_id"`
	// The edited message
	Message *BusinessMessage `json:"message"`
}

func (entity *UpdateBusinessMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBusinessMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*UpdateBusinessMessageEdited) GetClass() string {
	return ClassUpdate
}

func (*UpdateBusinessMessageEdited) GetType() string {
	return TypeUpdateBusinessMessageEdited
}

func (*UpdateBusinessMessageEdited) UpdateType() string {
	return TypeUpdateBusinessMessageEdited
}

// Messages in a business account were deleted; for bots only
type UpdateBusinessMessagesDeleted struct {
	meta
	// Unique identifier of the business connection
	ConnectionId string `json:"connection_id"`
	// Identifier of a chat in the business account in which messages were deleted
	ChatId int64 `json:"chat_id"`
	// Unique message identifiers of the deleted messages
	MessageIds []int64 `json:"message_ids"`
}

func (entity *UpdateBusinessMessagesDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBusinessMessagesDeleted

	return json.Marshal((*stub)(entity))
}

func (*UpdateBusinessMessagesDeleted) GetClass() string {
	return ClassUpdate
}

func (*UpdateBusinessMessagesDeleted) GetType() string {
	return TypeUpdateBusinessMessagesDeleted
}

func (*UpdateBusinessMessagesDeleted) UpdateType() string {
	return TypeUpdateBusinessMessagesDeleted
}

// A new incoming inline query; for bots only
type UpdateNewInlineQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// User location; may be null
	UserLocation *Location `json:"user_location"`
	// The type of the chat from which the query originated; may be null if unknown
	ChatType ChatType `json:"chat_type"`
	// Text of the query
	Query string `json:"query"`
	// Offset of the first entry to return
	Offset string `json:"offset"`
}

func (entity *UpdateNewInlineQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewInlineQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewInlineQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewInlineQuery) GetType() string {
	return TypeUpdateNewInlineQuery
}

func (*UpdateNewInlineQuery) UpdateType() string {
	return TypeUpdateNewInlineQuery
}

func (updateNewInlineQuery *UpdateNewInlineQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           JsonInt64       `json:"id"`
		SenderUserId int64           `json:"sender_user_id"`
		UserLocation *Location       `json:"user_location"`
		ChatType     json.RawMessage `json:"chat_type"`
		Query        string          `json:"query"`
		Offset       string          `json:"offset"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewInlineQuery.Id = tmp.Id
	updateNewInlineQuery.SenderUserId = tmp.SenderUserId
	updateNewInlineQuery.UserLocation = tmp.UserLocation
	updateNewInlineQuery.Query = tmp.Query
	updateNewInlineQuery.Offset = tmp.Offset

	fieldChatType, _ := UnmarshalChatType(tmp.ChatType)
	updateNewInlineQuery.ChatType = fieldChatType

	return nil
}

// The user has chosen a result of an inline query; for bots only
type UpdateNewChosenInlineResult struct {
	meta
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// User location; may be null
	UserLocation *Location `json:"user_location"`
	// Text of the query
	Query string `json:"query"`
	// Identifier of the chosen result
	ResultId string `json:"result_id"`
	// Identifier of the sent inline message, if known
	InlineMessageId string `json:"inline_message_id"`
}

func (entity *UpdateNewChosenInlineResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChosenInlineResult

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChosenInlineResult) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChosenInlineResult) GetType() string {
	return TypeUpdateNewChosenInlineResult
}

func (*UpdateNewChosenInlineResult) UpdateType() string {
	return TypeUpdateNewChosenInlineResult
}

// A new incoming callback query; for bots only
type UpdateNewCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Identifier of the chat where the query was sent
	ChatId int64 `json:"chat_id"`
	// Identifier of the message from which the query originated
	MessageId int64 `json:"message_id"`
	// Identifier that uniquely corresponds to the chat to which the message was sent
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCallbackQuery) GetType() string {
	return TypeUpdateNewCallbackQuery
}

func (*UpdateNewCallbackQuery) UpdateType() string {
	return TypeUpdateNewCallbackQuery
}

func (updateNewCallbackQuery *UpdateNewCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           JsonInt64       `json:"id"`
		SenderUserId int64           `json:"sender_user_id"`
		ChatId       int64           `json:"chat_id"`
		MessageId    int64           `json:"message_id"`
		ChatInstance JsonInt64       `json:"chat_instance"`
		Payload      json.RawMessage `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewCallbackQuery.Id = tmp.Id
	updateNewCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewCallbackQuery.ChatId = tmp.ChatId
	updateNewCallbackQuery.MessageId = tmp.MessageId
	updateNewCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming callback query from a message sent via a bot; for bots only
type UpdateNewInlineCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Identifier of the inline message from which the query originated
	InlineMessageId string `json:"inline_message_id"`
	// An identifier uniquely corresponding to the chat a message was sent to
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewInlineCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewInlineCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewInlineCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewInlineCallbackQuery) GetType() string {
	return TypeUpdateNewInlineCallbackQuery
}

func (*UpdateNewInlineCallbackQuery) UpdateType() string {
	return TypeUpdateNewInlineCallbackQuery
}

func (updateNewInlineCallbackQuery *UpdateNewInlineCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id              JsonInt64       `json:"id"`
		SenderUserId    int64           `json:"sender_user_id"`
		InlineMessageId string          `json:"inline_message_id"`
		ChatInstance    JsonInt64       `json:"chat_instance"`
		Payload         json.RawMessage `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewInlineCallbackQuery.Id = tmp.Id
	updateNewInlineCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewInlineCallbackQuery.InlineMessageId = tmp.InlineMessageId
	updateNewInlineCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewInlineCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming callback query from a business message; for bots only
type UpdateNewBusinessCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Unique identifier of the business connection
	ConnectionId string `json:"connection_id"`
	// The message from the business account from which the query originated
	Message *BusinessMessage `json:"message"`
	// An identifier uniquely corresponding to the chat a message was sent to
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewBusinessCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewBusinessCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewBusinessCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewBusinessCallbackQuery) GetType() string {
	return TypeUpdateNewBusinessCallbackQuery
}

func (*UpdateNewBusinessCallbackQuery) UpdateType() string {
	return TypeUpdateNewBusinessCallbackQuery
}

func (updateNewBusinessCallbackQuery *UpdateNewBusinessCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           JsonInt64        `json:"id"`
		SenderUserId int64            `json:"sender_user_id"`
		ConnectionId string           `json:"connection_id"`
		Message      *BusinessMessage `json:"message"`
		ChatInstance JsonInt64        `json:"chat_instance"`
		Payload      json.RawMessage  `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewBusinessCallbackQuery.Id = tmp.Id
	updateNewBusinessCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewBusinessCallbackQuery.ConnectionId = tmp.ConnectionId
	updateNewBusinessCallbackQuery.Message = tmp.Message
	updateNewBusinessCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewBusinessCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming shipping query; for bots only. Only for invoices with flexible price
type UpdateNewShippingQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// User shipping address
	ShippingAddress *Address `json:"shipping_address"`
}

func (entity *UpdateNewShippingQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewShippingQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewShippingQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewShippingQuery) GetType() string {
	return TypeUpdateNewShippingQuery
}

func (*UpdateNewShippingQuery) UpdateType() string {
	return TypeUpdateNewShippingQuery
}

// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
type UpdateNewPreCheckoutQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int64 `json:"sender_user_id"`
	// Currency for the product price
	Currency string `json:"currency"`
	// Total price for the product, in the smallest units of the currency
	TotalAmount int64 `json:"total_amount"`
	// Invoice payload
	InvoicePayload []byte `json:"invoice_payload"`
	// Identifier of a shipping option chosen by the user; may be empty if not applicable
	ShippingOptionId string `json:"shipping_option_id"`
	// Information about the order; may be null
	OrderInfo *OrderInfo `json:"order_info"`
}

func (entity *UpdateNewPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewPreCheckoutQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewPreCheckoutQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewPreCheckoutQuery) GetType() string {
	return TypeUpdateNewPreCheckoutQuery
}

func (*UpdateNewPreCheckoutQuery) UpdateType() string {
	return TypeUpdateNewPreCheckoutQuery
}

// A new incoming event; for bots only
type UpdateNewCustomEvent struct {
	meta
	// A JSON-serialized event
	Event string `json:"event"`
}

func (entity *UpdateNewCustomEvent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCustomEvent

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCustomEvent) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCustomEvent) GetType() string {
	return TypeUpdateNewCustomEvent
}

func (*UpdateNewCustomEvent) UpdateType() string {
	return TypeUpdateNewCustomEvent
}

// A new incoming query; for bots only
type UpdateNewCustomQuery struct {
	meta
	// The query identifier
	Id JsonInt64 `json:"id"`
	// JSON-serialized query data
	Data string `json:"data"`
	// Query timeout
	Timeout int32 `json:"timeout"`
}

func (entity *UpdateNewCustomQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCustomQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCustomQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCustomQuery) GetType() string {
	return TypeUpdateNewCustomQuery
}

func (*UpdateNewCustomQuery) UpdateType() string {
	return TypeUpdateNewCustomQuery
}

// A poll was updated; for bots only
type UpdatePoll struct {
	meta
	// New data about the poll
	Poll *Poll `json:"poll"`
}

func (entity *UpdatePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePoll

	return json.Marshal((*stub)(entity))
}

func (*UpdatePoll) GetClass() string {
	return ClassUpdate
}

func (*UpdatePoll) GetType() string {
	return TypeUpdatePoll
}

func (*UpdatePoll) UpdateType() string {
	return TypeUpdatePoll
}

// A user changed the answer to a poll; for bots only
type UpdatePollAnswer struct {
	meta
	// Unique poll identifier
	PollId JsonInt64 `json:"poll_id"`
	// Identifier of the message sender that changed the answer to the poll
	VoterId MessageSender `json:"voter_id"`
	// 0-based identifiers of answer options, chosen by the user
	OptionIds []int32 `json:"option_ids"`
}

func (entity *UpdatePollAnswer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePollAnswer

	return json.Marshal((*stub)(entity))
}

func (*UpdatePollAnswer) GetClass() string {
	return ClassUpdate
}

func (*UpdatePollAnswer) GetType() string {
	return TypeUpdatePollAnswer
}

func (*UpdatePollAnswer) UpdateType() string {
	return TypeUpdatePollAnswer
}

func (updatePollAnswer *UpdatePollAnswer) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PollId    JsonInt64       `json:"poll_id"`
		VoterId   json.RawMessage `json:"voter_id"`
		OptionIds []int32         `json:"option_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updatePollAnswer.PollId = tmp.PollId
	updatePollAnswer.OptionIds = tmp.OptionIds

	fieldVoterId, _ := UnmarshalMessageSender(tmp.VoterId)
	updatePollAnswer.VoterId = fieldVoterId

	return nil
}

// User rights changed in a chat; for bots only
type UpdateChatMember struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the user, changing the rights
	ActorUserId int64 `json:"actor_user_id"`
	// Point in time (Unix timestamp) when the user rights were changed
	Date int32 `json:"date"`
	// If user has joined the chat using an invite link, the invite link; may be null
	InviteLink *ChatInviteLink `json:"invite_link"`
	// True, if the user has joined the chat after sending a join request and being approved by an administrator
	ViaJoinRequest bool `json:"via_join_request"`
	// True, if the user has joined the chat using an invite link for a chat folder
	ViaChatFolderInviteLink bool `json:"via_chat_folder_invite_link"`
	// Previous chat member
	OldChatMember *ChatMember `json:"old_chat_member"`
	// New chat member
	NewChatMember *ChatMember `json:"new_chat_member"`
}

func (entity *UpdateChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatMember

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatMember) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatMember) GetType() string {
	return TypeUpdateChatMember
}

func (*UpdateChatMember) UpdateType() string {
	return TypeUpdateChatMember
}

// A user sent a join request to a chat; for bots only
type UpdateNewChatJoinRequest struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Join request
	Request *ChatJoinRequest `json:"request"`
	// Chat identifier of the private chat with the user
	UserChatId int64 `json:"user_chat_id"`
	// The invite link, which was used to send join request; may be null
	InviteLink *ChatInviteLink `json:"invite_link"`
}

func (entity *UpdateNewChatJoinRequest) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChatJoinRequest

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChatJoinRequest) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChatJoinRequest) GetType() string {
	return TypeUpdateNewChatJoinRequest
}

func (*UpdateNewChatJoinRequest) UpdateType() string {
	return TypeUpdateNewChatJoinRequest
}

// A chat boost has changed; for bots only
type UpdateChatBoost struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New information about the boost
	Boost *ChatBoost `json:"boost"`
}

func (entity *UpdateChatBoost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatBoost

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatBoost) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatBoost) GetType() string {
	return TypeUpdateChatBoost
}

func (*UpdateChatBoost) UpdateType() string {
	return TypeUpdateChatBoost
}

// User changed its reactions on a message with public reactions; for bots only
type UpdateMessageReaction struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Identifier of the user or chat that changed reactions
	ActorId MessageSender `json:"actor_id"`
	// Point in time (Unix timestamp) when the reactions were changed
	Date int32 `json:"date"`
	// Old list of chosen reactions
	OldReactionTypes []ReactionType `json:"old_reaction_types"`
	// New list of chosen reactions
	NewReactionTypes []ReactionType `json:"new_reaction_types"`
}

func (entity *UpdateMessageReaction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageReaction

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageReaction) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageReaction) GetType() string {
	return TypeUpdateMessageReaction
}

func (*UpdateMessageReaction) UpdateType() string {
	return TypeUpdateMessageReaction
}

func (updateMessageReaction *UpdateMessageReaction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId           int64             `json:"chat_id"`
		MessageId        int64             `json:"message_id"`
		ActorId          json.RawMessage   `json:"actor_id"`
		Date             int32             `json:"date"`
		OldReactionTypes []json.RawMessage `json:"old_reaction_types"`
		NewReactionTypes []json.RawMessage `json:"new_reaction_types"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageReaction.ChatId = tmp.ChatId
	updateMessageReaction.MessageId = tmp.MessageId
	updateMessageReaction.Date = tmp.Date

	fieldActorId, _ := UnmarshalMessageSender(tmp.ActorId)
	updateMessageReaction.ActorId = fieldActorId

	fieldOldReactionTypes, _ := UnmarshalListOfReactionType(tmp.OldReactionTypes)
	updateMessageReaction.OldReactionTypes = fieldOldReactionTypes

	fieldNewReactionTypes, _ := UnmarshalListOfReactionType(tmp.NewReactionTypes)
	updateMessageReaction.NewReactionTypes = fieldNewReactionTypes

	return nil
}

// Reactions added to a message with anonymous reactions have changed; for bots only
type UpdateMessageReactions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Point in time (Unix timestamp) when the reactions were changed
	Date int32 `json:"date"`
	// The list of reactions added to the message
	Reactions []*MessageReaction `json:"reactions"`
}

func (entity *UpdateMessageReactions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageReactions

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageReactions) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageReactions) GetType() string {
	return TypeUpdateMessageReactions
}

func (*UpdateMessageReactions) UpdateType() string {
	return TypeUpdateMessageReactions
}

// Paid media were purchased by a user; for bots only
type UpdatePaidMediaPurchased struct {
	meta
	// User identifier
	UserId int64 `json:"user_id"`
	// Bot-specified payload for the paid media
	Payload string `json:"payload"`
}

func (entity *UpdatePaidMediaPurchased) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePaidMediaPurchased

	return json.Marshal((*stub)(entity))
}

func (*UpdatePaidMediaPurchased) GetClass() string {
	return ClassUpdate
}

func (*UpdatePaidMediaPurchased) GetType() string {
	return TypeUpdatePaidMediaPurchased
}

func (*UpdatePaidMediaPurchased) UpdateType() string {
	return TypeUpdatePaidMediaPurchased
}

// Contains a list of updates
type Updates struct {
	meta
	// List of updates
	Updates []Update `json:"updates"`
}

func (entity *Updates) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Updates

	return json.Marshal((*stub)(entity))
}

func (*Updates) GetClass() string {
	return ClassUpdates
}

func (*Updates) GetType() string {
	return TypeUpdates
}

func (updates *Updates) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Updates []json.RawMessage `json:"updates"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldUpdates, _ := UnmarshalListOfUpdate(tmp.Updates)
	updates.Updates = fieldUpdates

	return nil
}

// The log is written to stderr or an OS specific log
type LogStreamDefault struct {
	meta
}

func (entity *LogStreamDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamDefault

	return json.Marshal((*stub)(entity))
}

func (*LogStreamDefault) GetClass() string {
	return ClassLogStream
}

func (*LogStreamDefault) GetType() string {
	return TypeLogStreamDefault
}

func (*LogStreamDefault) LogStreamType() string {
	return TypeLogStreamDefault
}

// The log is written to a file
type LogStreamFile struct {
	meta
	// Path to the file to where the internal TDLib log will be written
	Path string `json:"path"`
	// The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
	MaxFileSize int64 `json:"max_file_size"`
	// Pass true to additionally redirect stderr to the log file. Ignored on Windows
	RedirectStderr bool `json:"redirect_stderr"`
}

func (entity *LogStreamFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamFile

	return json.Marshal((*stub)(entity))
}

func (*LogStreamFile) GetClass() string {
	return ClassLogStream
}

func (*LogStreamFile) GetType() string {
	return TypeLogStreamFile
}

func (*LogStreamFile) LogStreamType() string {
	return TypeLogStreamFile
}

// The log is written nowhere
type LogStreamEmpty struct {
	meta
}

func (entity *LogStreamEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamEmpty

	return json.Marshal((*stub)(entity))
}

func (*LogStreamEmpty) GetClass() string {
	return ClassLogStream
}

func (*LogStreamEmpty) GetType() string {
	return TypeLogStreamEmpty
}

func (*LogStreamEmpty) LogStreamType() string {
	return TypeLogStreamEmpty
}

// Contains a TDLib internal log verbosity level
type LogVerbosityLevel struct {
	meta
	// Log verbosity level
	VerbosityLevel int32 `json:"verbosity_level"`
}

func (entity *LogVerbosityLevel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogVerbosityLevel

	return json.Marshal((*stub)(entity))
}

func (*LogVerbosityLevel) GetClass() string {
	return ClassLogVerbosityLevel
}

func (*LogVerbosityLevel) GetType() string {
	return TypeLogVerbosityLevel
}

// Contains a list of available TDLib internal log tags
type LogTags struct {
	meta
	// List of log tags
	Tags []string `json:"tags"`
}

func (entity *LogTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogTags

	return json.Marshal((*stub)(entity))
}

func (*LogTags) GetClass() string {
	return ClassLogTags
}

func (*LogTags) GetType() string {
	return TypeLogTags
}

// Contains custom information about the user
type UserSupportInfo struct {
	meta
	// Information message
	Message *FormattedText `json:"message"`
	// Information author
	Author string `json:"author"`
	// Information change date
	Date int32 `json:"date"`
}

func (entity *UserSupportInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserSupportInfo

	return json.Marshal((*stub)(entity))
}

func (*UserSupportInfo) GetClass() string {
	return ClassUserSupportInfo
}

func (*UserSupportInfo) GetType() string {
	return TypeUserSupportInfo
}

// A simple object containing a number; for testing only
type TestInt struct {
	meta
	// Number
	Value int32 `json:"value"`
}

func (entity *TestInt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestInt

	return json.Marshal((*stub)(entity))
}

func (*TestInt) GetClass() string {
	return ClassTestInt
}

func (*TestInt) GetType() string {
	return TypeTestInt
}

// A simple object containing a string; for testing only
type TestString struct {
	meta
	// String
	Value string `json:"value"`
}

func (entity *TestString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestString

	return json.Marshal((*stub)(entity))
}

func (*TestString) GetClass() string {
	return ClassTestString
}

func (*TestString) GetType() string {
	return TypeTestString
}

// A simple object containing a sequence of bytes; for testing only
type TestBytes struct {
	meta
	// Bytes
	Value []byte `json:"value"`
}

func (entity *TestBytes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestBytes

	return json.Marshal((*stub)(entity))
}

func (*TestBytes) GetClass() string {
	return ClassTestBytes
}

func (*TestBytes) GetType() string {
	return TypeTestBytes
}

// A simple object containing a vector of numbers; for testing only
type TestVectorInt struct {
	meta
	// Vector of numbers
	Value []int32 `json:"value"`
}

func (entity *TestVectorInt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorInt

	return json.Marshal((*stub)(entity))
}

func (*TestVectorInt) GetClass() string {
	return ClassTestVectorInt
}

func (*TestVectorInt) GetType() string {
	return TypeTestVectorInt
}

// A simple object containing a vector of objects that hold a number; for testing only
type TestVectorIntObject struct {
	meta
	// Vector of objects
	Value []*TestInt `json:"value"`
}

func (entity *TestVectorIntObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorIntObject

	return json.Marshal((*stub)(entity))
}

func (*TestVectorIntObject) GetClass() string {
	return ClassTestVectorIntObject
}

func (*TestVectorIntObject) GetType() string {
	return TypeTestVectorIntObject
}

// A simple object containing a vector of strings; for testing only
type TestVectorString struct {
	meta
	// Vector of strings
	Value []string `json:"value"`
}

func (entity *TestVectorString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorString

	return json.Marshal((*stub)(entity))
}

func (*TestVectorString) GetClass() string {
	return ClassTestVectorString
}

func (*TestVectorString) GetType() string {
	return TypeTestVectorString
}

// A simple object containing a vector of objects that hold a string; for testing only
type TestVectorStringObject struct {
	meta
	// Vector of objects
	Value []*TestString `json:"value"`
}

func (entity *TestVectorStringObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorStringObject

	return json.Marshal((*stub)(entity))
}

func (*TestVectorStringObject) GetClass() string {
	return ClassTestVectorStringObject
}

func (*TestVectorStringObject) GetType() string {
	return TypeTestVectorStringObject
}
