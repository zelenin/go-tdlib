// AUTOGENERATED

package client

import (
	"encoding/json"
)

const (
	ClassAuthenticationCodeType             = "AuthenticationCodeType"
	ClassAuthorizationState                 = "AuthorizationState"
	ClassInputFile                          = "InputFile"
	ClassMaskPoint                          = "MaskPoint"
	ClassPollType                           = "PollType"
	ClassUserType                           = "UserType"
	ClassChatMemberStatus                   = "ChatMemberStatus"
	ClassChatMembersFilter                  = "ChatMembersFilter"
	ClassSupergroupMembersFilter            = "SupergroupMembersFilter"
	ClassSecretChatState                    = "SecretChatState"
	ClassMessageForwardOrigin               = "MessageForwardOrigin"
	ClassMessageSendingState                = "MessageSendingState"
	ClassNotificationSettingsScope          = "NotificationSettingsScope"
	ClassChatType                           = "ChatType"
	ClassChatList                           = "ChatList"
	ClassPublicChatType                     = "PublicChatType"
	ClassChatActionBar                      = "ChatActionBar"
	ClassKeyboardButtonType                 = "KeyboardButtonType"
	ClassInlineKeyboardButtonType           = "InlineKeyboardButtonType"
	ClassReplyMarkup                        = "ReplyMarkup"
	ClassLoginUrlInfo                       = "LoginUrlInfo"
	ClassRichText                           = "RichText"
	ClassPageBlockHorizontalAlignment       = "PageBlockHorizontalAlignment"
	ClassPageBlockVerticalAlignment         = "PageBlockVerticalAlignment"
	ClassPageBlock                          = "PageBlock"
	ClassInputCredentials                   = "InputCredentials"
	ClassPassportElementType                = "PassportElementType"
	ClassPassportElement                    = "PassportElement"
	ClassInputPassportElement               = "InputPassportElement"
	ClassPassportElementErrorSource         = "PassportElementErrorSource"
	ClassInputPassportElementErrorSource    = "InputPassportElementErrorSource"
	ClassMessageContent                     = "MessageContent"
	ClassTextEntityType                     = "TextEntityType"
	ClassMessageSchedulingState             = "MessageSchedulingState"
	ClassInputMessageContent                = "InputMessageContent"
	ClassSearchMessagesFilter               = "SearchMessagesFilter"
	ClassChatAction                         = "ChatAction"
	ClassUserStatus                         = "UserStatus"
	ClassCallDiscardReason                  = "CallDiscardReason"
	ClassCallState                          = "CallState"
	ClassCallProblem                        = "CallProblem"
	ClassInputInlineQueryResult             = "InputInlineQueryResult"
	ClassInlineQueryResult                  = "InlineQueryResult"
	ClassCallbackQueryPayload               = "CallbackQueryPayload"
	ClassChatEventAction                    = "ChatEventAction"
	ClassLanguagePackStringValue            = "LanguagePackStringValue"
	ClassDeviceToken                        = "DeviceToken"
	ClassBackgroundFill                     = "BackgroundFill"
	ClassBackgroundType                     = "BackgroundType"
	ClassInputBackground                    = "InputBackground"
	ClassCanTransferOwnershipResult         = "CanTransferOwnershipResult"
	ClassCheckChatUsernameResult            = "CheckChatUsernameResult"
	ClassPushMessageContent                 = "PushMessageContent"
	ClassNotificationType                   = "NotificationType"
	ClassNotificationGroupType              = "NotificationGroupType"
	ClassOptionValue                        = "OptionValue"
	ClassJsonValue                          = "JsonValue"
	ClassUserPrivacySettingRule             = "UserPrivacySettingRule"
	ClassUserPrivacySetting                 = "UserPrivacySetting"
	ClassChatReportReason                   = "ChatReportReason"
	ClassFileType                           = "FileType"
	ClassNetworkType                        = "NetworkType"
	ClassNetworkStatisticsEntry             = "NetworkStatisticsEntry"
	ClassConnectionState                    = "ConnectionState"
	ClassTopChatCategory                    = "TopChatCategory"
	ClassTMeUrlType                         = "TMeUrlType"
	ClassTextParseMode                      = "TextParseMode"
	ClassProxyType                          = "ProxyType"
	ClassUpdate                             = "Update"
	ClassLogStream                          = "LogStream"
	ClassError                              = "Error"
	ClassOk                                 = "Ok"
	ClassTdlibParameters                    = "TdlibParameters"
	ClassAuthenticationCodeInfo             = "AuthenticationCodeInfo"
	ClassEmailAddressAuthenticationCodeInfo = "EmailAddressAuthenticationCodeInfo"
	ClassTextEntity                         = "TextEntity"
	ClassTextEntities                       = "TextEntities"
	ClassFormattedText                      = "FormattedText"
	ClassTermsOfService                     = "TermsOfService"
	ClassPasswordState                      = "PasswordState"
	ClassRecoveryEmailAddress               = "RecoveryEmailAddress"
	ClassTemporaryPasswordState             = "TemporaryPasswordState"
	ClassLocalFile                          = "LocalFile"
	ClassRemoteFile                         = "RemoteFile"
	ClassFile                               = "File"
	ClassPhotoSize                          = "PhotoSize"
	ClassMinithumbnail                      = "Minithumbnail"
	ClassMaskPosition                       = "MaskPosition"
	ClassPollOption                         = "PollOption"
	ClassAnimation                          = "Animation"
	ClassAudio                              = "Audio"
	ClassDocument                           = "Document"
	ClassPhoto                              = "Photo"
	ClassSticker                            = "Sticker"
	ClassVideo                              = "Video"
	ClassVideoNote                          = "VideoNote"
	ClassVoiceNote                          = "VoiceNote"
	ClassContact                            = "Contact"
	ClassLocation                           = "Location"
	ClassVenue                              = "Venue"
	ClassGame                               = "Game"
	ClassPoll                               = "Poll"
	ClassProfilePhoto                       = "ProfilePhoto"
	ClassChatPhoto                          = "ChatPhoto"
	ClassBotCommand                         = "BotCommand"
	ClassBotInfo                            = "BotInfo"
	ClassChatLocation                       = "ChatLocation"
	ClassUser                               = "User"
	ClassUserFullInfo                       = "UserFullInfo"
	ClassUserProfilePhoto                   = "UserProfilePhoto"
	ClassUserProfilePhotos                  = "UserProfilePhotos"
	ClassUsers                              = "Users"
	ClassChatAdministrator                  = "ChatAdministrator"
	ClassChatAdministrators                 = "ChatAdministrators"
	ClassChatPermissions                    = "ChatPermissions"
	ClassChatMember                         = "ChatMember"
	ClassChatMembers                        = "ChatMembers"
	ClassBasicGroup                         = "BasicGroup"
	ClassBasicGroupFullInfo                 = "BasicGroupFullInfo"
	ClassSupergroup                         = "Supergroup"
	ClassSupergroupFullInfo                 = "SupergroupFullInfo"
	ClassSecretChat                         = "SecretChat"
	ClassMessageForwardInfo                 = "MessageForwardInfo"
	ClassMessage                            = "Message"
	ClassMessages                           = "Messages"
	ClassFoundMessages                      = "FoundMessages"
	ClassChatNotificationSettings           = "ChatNotificationSettings"
	ClassScopeNotificationSettings          = "ScopeNotificationSettings"
	ClassDraftMessage                       = "DraftMessage"
	ClassChat                               = "Chat"
	ClassChats                              = "Chats"
	ClassChatNearby                         = "ChatNearby"
	ClassChatsNearby                        = "ChatsNearby"
	ClassChatInviteLink                     = "ChatInviteLink"
	ClassChatInviteLinkInfo                 = "ChatInviteLinkInfo"
	ClassKeyboardButton                     = "KeyboardButton"
	ClassInlineKeyboardButton               = "InlineKeyboardButton"
	ClassPageBlockCaption                   = "PageBlockCaption"
	ClassPageBlockListItem                  = "PageBlockListItem"
	ClassPageBlockTableCell                 = "PageBlockTableCell"
	ClassPageBlockRelatedArticle            = "PageBlockRelatedArticle"
	ClassWebPageInstantView                 = "WebPageInstantView"
	ClassWebPage                            = "WebPage"
	ClassAddress                            = "Address"
	ClassLabeledPricePart                   = "LabeledPricePart"
	ClassInvoice                            = "Invoice"
	ClassOrderInfo                          = "OrderInfo"
	ClassShippingOption                     = "ShippingOption"
	ClassSavedCredentials                   = "SavedCredentials"
	ClassPaymentsProviderStripe             = "PaymentsProviderStripe"
	ClassPaymentForm                        = "PaymentForm"
	ClassValidatedOrderInfo                 = "ValidatedOrderInfo"
	ClassPaymentResult                      = "PaymentResult"
	ClassPaymentReceipt                     = "PaymentReceipt"
	ClassDatedFile                          = "DatedFile"
	ClassDate                               = "Date"
	ClassPersonalDetails                    = "PersonalDetails"
	ClassIdentityDocument                   = "IdentityDocument"
	ClassInputIdentityDocument              = "InputIdentityDocument"
	ClassPersonalDocument                   = "PersonalDocument"
	ClassInputPersonalDocument              = "InputPersonalDocument"
	ClassPassportElements                   = "PassportElements"
	ClassPassportElementError               = "PassportElementError"
	ClassPassportSuitableElement            = "PassportSuitableElement"
	ClassPassportRequiredElement            = "PassportRequiredElement"
	ClassPassportAuthorizationForm          = "PassportAuthorizationForm"
	ClassPassportElementsWithErrors         = "PassportElementsWithErrors"
	ClassEncryptedCredentials               = "EncryptedCredentials"
	ClassEncryptedPassportElement           = "EncryptedPassportElement"
	ClassInputPassportElementError          = "InputPassportElementError"
	ClassInputThumbnail                     = "InputThumbnail"
	ClassSendMessageOptions                 = "SendMessageOptions"
	ClassStickers                           = "Stickers"
	ClassEmojis                             = "Emojis"
	ClassStickerSet                         = "StickerSet"
	ClassStickerSetInfo                     = "StickerSetInfo"
	ClassStickerSets                        = "StickerSets"
	ClassCallProtocol                       = "CallProtocol"
	ClassCallConnection                     = "CallConnection"
	ClassCallId                             = "CallId"
	ClassCall                               = "Call"
	ClassPhoneNumberAuthenticationSettings  = "PhoneNumberAuthenticationSettings"
	ClassAnimations                         = "Animations"
	ClassImportedContacts                   = "ImportedContacts"
	ClassHttpUrl                            = "HttpUrl"
	ClassInlineQueryResults                 = "InlineQueryResults"
	ClassCallbackQueryAnswer                = "CallbackQueryAnswer"
	ClassCustomRequestResult                = "CustomRequestResult"
	ClassGameHighScore                      = "GameHighScore"
	ClassGameHighScores                     = "GameHighScores"
	ClassChatEvent                          = "ChatEvent"
	ClassChatEvents                         = "ChatEvents"
	ClassChatEventLogFilters                = "ChatEventLogFilters"
	ClassLanguagePackString                 = "LanguagePackString"
	ClassLanguagePackStrings                = "LanguagePackStrings"
	ClassLanguagePackInfo                   = "LanguagePackInfo"
	ClassLocalizationTargetInfo             = "LocalizationTargetInfo"
	ClassPushReceiverId                     = "PushReceiverId"
	ClassBackground                         = "Background"
	ClassBackgrounds                        = "Backgrounds"
	ClassHashtags                           = "Hashtags"
	ClassNotification                       = "Notification"
	ClassNotificationGroup                  = "NotificationGroup"
	ClassJsonObjectMember                   = "JsonObjectMember"
	ClassUserPrivacySettingRules            = "UserPrivacySettingRules"
	ClassAccountTtl                         = "AccountTtl"
	ClassSession                            = "Session"
	ClassSessions                           = "Sessions"
	ClassConnectedWebsite                   = "ConnectedWebsite"
	ClassConnectedWebsites                  = "ConnectedWebsites"
	ClassPublicMessageLink                  = "PublicMessageLink"
	ClassMessageLinkInfo                    = "MessageLinkInfo"
	ClassFilePart                           = "FilePart"
	ClassStorageStatisticsByFileType        = "StorageStatisticsByFileType"
	ClassStorageStatisticsByChat            = "StorageStatisticsByChat"
	ClassStorageStatistics                  = "StorageStatistics"
	ClassStorageStatisticsFast              = "StorageStatisticsFast"
	ClassDatabaseStatistics                 = "DatabaseStatistics"
	ClassNetworkStatistics                  = "NetworkStatistics"
	ClassAutoDownloadSettings               = "AutoDownloadSettings"
	ClassAutoDownloadSettingsPresets        = "AutoDownloadSettingsPresets"
	ClassTMeUrl                             = "TMeUrl"
	ClassTMeUrls                            = "TMeUrls"
	ClassCount                              = "Count"
	ClassText                               = "Text"
	ClassSeconds                            = "Seconds"
	ClassDeepLinkInfo                       = "DeepLinkInfo"
	ClassProxy                              = "Proxy"
	ClassProxies                            = "Proxies"
	ClassInputSticker                       = "InputSticker"
	ClassUpdates                            = "Updates"
	ClassLogVerbosityLevel                  = "LogVerbosityLevel"
	ClassLogTags                            = "LogTags"
	ClassTestInt                            = "TestInt"
	ClassTestString                         = "TestString"
	ClassTestBytes                          = "TestBytes"
	ClassTestVectorInt                      = "TestVectorInt"
	ClassTestVectorIntObject                = "TestVectorIntObject"
	ClassTestVectorString                   = "TestVectorString"
	ClassTestVectorStringObject             = "TestVectorStringObject"
)

const (
	TypeError                                           = "error"
	TypeOk                                              = "ok"
	TypeTdlibParameters                                 = "tdlibParameters"
	TypeAuthenticationCodeTypeTelegramMessage           = "authenticationCodeTypeTelegramMessage"
	TypeAuthenticationCodeTypeSms                       = "authenticationCodeTypeSms"
	TypeAuthenticationCodeTypeCall                      = "authenticationCodeTypeCall"
	TypeAuthenticationCodeTypeFlashCall                 = "authenticationCodeTypeFlashCall"
	TypeAuthenticationCodeInfo                          = "authenticationCodeInfo"
	TypeEmailAddressAuthenticationCodeInfo              = "emailAddressAuthenticationCodeInfo"
	TypeTextEntity                                      = "textEntity"
	TypeTextEntities                                    = "textEntities"
	TypeFormattedText                                   = "formattedText"
	TypeTermsOfService                                  = "termsOfService"
	TypeAuthorizationStateWaitTdlibParameters           = "authorizationStateWaitTdlibParameters"
	TypeAuthorizationStateWaitEncryptionKey             = "authorizationStateWaitEncryptionKey"
	TypeAuthorizationStateWaitPhoneNumber               = "authorizationStateWaitPhoneNumber"
	TypeAuthorizationStateWaitCode                      = "authorizationStateWaitCode"
	TypeAuthorizationStateWaitOtherDeviceConfirmation   = "authorizationStateWaitOtherDeviceConfirmation"
	TypeAuthorizationStateWaitRegistration              = "authorizationStateWaitRegistration"
	TypeAuthorizationStateWaitPassword                  = "authorizationStateWaitPassword"
	TypeAuthorizationStateReady                         = "authorizationStateReady"
	TypeAuthorizationStateLoggingOut                    = "authorizationStateLoggingOut"
	TypeAuthorizationStateClosing                       = "authorizationStateClosing"
	TypeAuthorizationStateClosed                        = "authorizationStateClosed"
	TypePasswordState                                   = "passwordState"
	TypeRecoveryEmailAddress                            = "recoveryEmailAddress"
	TypeTemporaryPasswordState                          = "temporaryPasswordState"
	TypeLocalFile                                       = "localFile"
	TypeRemoteFile                                      = "remoteFile"
	TypeFile                                            = "file"
	TypeInputFileId                                     = "inputFileId"
	TypeInputFileRemote                                 = "inputFileRemote"
	TypeInputFileLocal                                  = "inputFileLocal"
	TypeInputFileGenerated                              = "inputFileGenerated"
	TypePhotoSize                                       = "photoSize"
	TypeMinithumbnail                                   = "minithumbnail"
	TypeMaskPointForehead                               = "maskPointForehead"
	TypeMaskPointEyes                                   = "maskPointEyes"
	TypeMaskPointMouth                                  = "maskPointMouth"
	TypeMaskPointChin                                   = "maskPointChin"
	TypeMaskPosition                                    = "maskPosition"
	TypePollOption                                      = "pollOption"
	TypePollTypeRegular                                 = "pollTypeRegular"
	TypePollTypeQuiz                                    = "pollTypeQuiz"
	TypeAnimation                                       = "animation"
	TypeAudio                                           = "audio"
	TypeDocument                                        = "document"
	TypePhoto                                           = "photo"
	TypeSticker                                         = "sticker"
	TypeVideo                                           = "video"
	TypeVideoNote                                       = "videoNote"
	TypeVoiceNote                                       = "voiceNote"
	TypeContact                                         = "contact"
	TypeLocation                                        = "location"
	TypeVenue                                           = "venue"
	TypeGame                                            = "game"
	TypePoll                                            = "poll"
	TypeProfilePhoto                                    = "profilePhoto"
	TypeChatPhoto                                       = "chatPhoto"
	TypeUserTypeRegular                                 = "userTypeRegular"
	TypeUserTypeDeleted                                 = "userTypeDeleted"
	TypeUserTypeBot                                     = "userTypeBot"
	TypeUserTypeUnknown                                 = "userTypeUnknown"
	TypeBotCommand                                      = "botCommand"
	TypeBotInfo                                         = "botInfo"
	TypeChatLocation                                    = "chatLocation"
	TypeUser                                            = "user"
	TypeUserFullInfo                                    = "userFullInfo"
	TypeUserProfilePhoto                                = "userProfilePhoto"
	TypeUserProfilePhotos                               = "userProfilePhotos"
	TypeUsers                                           = "users"
	TypeChatAdministrator                               = "chatAdministrator"
	TypeChatAdministrators                              = "chatAdministrators"
	TypeChatPermissions                                 = "chatPermissions"
	TypeChatMemberStatusCreator                         = "chatMemberStatusCreator"
	TypeChatMemberStatusAdministrator                   = "chatMemberStatusAdministrator"
	TypeChatMemberStatusMember                          = "chatMemberStatusMember"
	TypeChatMemberStatusRestricted                      = "chatMemberStatusRestricted"
	TypeChatMemberStatusLeft                            = "chatMemberStatusLeft"
	TypeChatMemberStatusBanned                          = "chatMemberStatusBanned"
	TypeChatMember                                      = "chatMember"
	TypeChatMembers                                     = "chatMembers"
	TypeChatMembersFilterContacts                       = "chatMembersFilterContacts"
	TypeChatMembersFilterAdministrators                 = "chatMembersFilterAdministrators"
	TypeChatMembersFilterMembers                        = "chatMembersFilterMembers"
	TypeChatMembersFilterRestricted                     = "chatMembersFilterRestricted"
	TypeChatMembersFilterBanned                         = "chatMembersFilterBanned"
	TypeChatMembersFilterBots                           = "chatMembersFilterBots"
	TypeSupergroupMembersFilterRecent                   = "supergroupMembersFilterRecent"
	TypeSupergroupMembersFilterContacts                 = "supergroupMembersFilterContacts"
	TypeSupergroupMembersFilterAdministrators           = "supergroupMembersFilterAdministrators"
	TypeSupergroupMembersFilterSearch                   = "supergroupMembersFilterSearch"
	TypeSupergroupMembersFilterRestricted               = "supergroupMembersFilterRestricted"
	TypeSupergroupMembersFilterBanned                   = "supergroupMembersFilterBanned"
	TypeSupergroupMembersFilterBots                     = "supergroupMembersFilterBots"
	TypeBasicGroup                                      = "basicGroup"
	TypeBasicGroupFullInfo                              = "basicGroupFullInfo"
	TypeSupergroup                                      = "supergroup"
	TypeSupergroupFullInfo                              = "supergroupFullInfo"
	TypeSecretChatStatePending                          = "secretChatStatePending"
	TypeSecretChatStateReady                            = "secretChatStateReady"
	TypeSecretChatStateClosed                           = "secretChatStateClosed"
	TypeSecretChat                                      = "secretChat"
	TypeMessageForwardOriginUser                        = "messageForwardOriginUser"
	TypeMessageForwardOriginHiddenUser                  = "messageForwardOriginHiddenUser"
	TypeMessageForwardOriginChannel                     = "messageForwardOriginChannel"
	TypeMessageForwardInfo                              = "messageForwardInfo"
	TypeMessageSendingStatePending                      = "messageSendingStatePending"
	TypeMessageSendingStateFailed                       = "messageSendingStateFailed"
	TypeMessage                                         = "message"
	TypeMessages                                        = "messages"
	TypeFoundMessages                                   = "foundMessages"
	TypeNotificationSettingsScopePrivateChats           = "notificationSettingsScopePrivateChats"
	TypeNotificationSettingsScopeGroupChats             = "notificationSettingsScopeGroupChats"
	TypeNotificationSettingsScopeChannelChats           = "notificationSettingsScopeChannelChats"
	TypeChatNotificationSettings                        = "chatNotificationSettings"
	TypeScopeNotificationSettings                       = "scopeNotificationSettings"
	TypeDraftMessage                                    = "draftMessage"
	TypeChatTypePrivate                                 = "chatTypePrivate"
	TypeChatTypeBasicGroup                              = "chatTypeBasicGroup"
	TypeChatTypeSupergroup                              = "chatTypeSupergroup"
	TypeChatTypeSecret                                  = "chatTypeSecret"
	TypeChatListMain                                    = "chatListMain"
	TypeChatListArchive                                 = "chatListArchive"
	TypeChat                                            = "chat"
	TypeChats                                           = "chats"
	TypeChatNearby                                      = "chatNearby"
	TypeChatsNearby                                     = "chatsNearby"
	TypeChatInviteLink                                  = "chatInviteLink"
	TypeChatInviteLinkInfo                              = "chatInviteLinkInfo"
	TypePublicChatTypeHasUsername                       = "publicChatTypeHasUsername"
	TypePublicChatTypeIsLocationBased                   = "publicChatTypeIsLocationBased"
	TypeChatActionBarReportSpam                         = "chatActionBarReportSpam"
	TypeChatActionBarReportUnrelatedLocation            = "chatActionBarReportUnrelatedLocation"
	TypeChatActionBarReportAddBlock                     = "chatActionBarReportAddBlock"
	TypeChatActionBarAddContact                         = "chatActionBarAddContact"
	TypeChatActionBarSharePhoneNumber                   = "chatActionBarSharePhoneNumber"
	TypeKeyboardButtonTypeText                          = "keyboardButtonTypeText"
	TypeKeyboardButtonTypeRequestPhoneNumber            = "keyboardButtonTypeRequestPhoneNumber"
	TypeKeyboardButtonTypeRequestLocation               = "keyboardButtonTypeRequestLocation"
	TypeKeyboardButtonTypeRequestPoll                   = "keyboardButtonTypeRequestPoll"
	TypeKeyboardButton                                  = "keyboardButton"
	TypeInlineKeyboardButtonTypeUrl                     = "inlineKeyboardButtonTypeUrl"
	TypeInlineKeyboardButtonTypeLoginUrl                = "inlineKeyboardButtonTypeLoginUrl"
	TypeInlineKeyboardButtonTypeCallback                = "inlineKeyboardButtonTypeCallback"
	TypeInlineKeyboardButtonTypeCallbackGame            = "inlineKeyboardButtonTypeCallbackGame"
	TypeInlineKeyboardButtonTypeSwitchInline            = "inlineKeyboardButtonTypeSwitchInline"
	TypeInlineKeyboardButtonTypeBuy                     = "inlineKeyboardButtonTypeBuy"
	TypeInlineKeyboardButton                            = "inlineKeyboardButton"
	TypeReplyMarkupRemoveKeyboard                       = "replyMarkupRemoveKeyboard"
	TypeReplyMarkupForceReply                           = "replyMarkupForceReply"
	TypeReplyMarkupShowKeyboard                         = "replyMarkupShowKeyboard"
	TypeReplyMarkupInlineKeyboard                       = "replyMarkupInlineKeyboard"
	TypeLoginUrlInfoOpen                                = "loginUrlInfoOpen"
	TypeLoginUrlInfoRequestConfirmation                 = "loginUrlInfoRequestConfirmation"
	TypeRichTextPlain                                   = "richTextPlain"
	TypeRichTextBold                                    = "richTextBold"
	TypeRichTextItalic                                  = "richTextItalic"
	TypeRichTextUnderline                               = "richTextUnderline"
	TypeRichTextStrikethrough                           = "richTextStrikethrough"
	TypeRichTextFixed                                   = "richTextFixed"
	TypeRichTextUrl                                     = "richTextUrl"
	TypeRichTextEmailAddress                            = "richTextEmailAddress"
	TypeRichTextSubscript                               = "richTextSubscript"
	TypeRichTextSuperscript                             = "richTextSuperscript"
	TypeRichTextMarked                                  = "richTextMarked"
	TypeRichTextPhoneNumber                             = "richTextPhoneNumber"
	TypeRichTextIcon                                    = "richTextIcon"
	TypeRichTextAnchor                                  = "richTextAnchor"
	TypeRichTexts                                       = "richTexts"
	TypePageBlockCaption                                = "pageBlockCaption"
	TypePageBlockListItem                               = "pageBlockListItem"
	TypePageBlockHorizontalAlignmentLeft                = "pageBlockHorizontalAlignmentLeft"
	TypePageBlockHorizontalAlignmentCenter              = "pageBlockHorizontalAlignmentCenter"
	TypePageBlockHorizontalAlignmentRight               = "pageBlockHorizontalAlignmentRight"
	TypePageBlockVerticalAlignmentTop                   = "pageBlockVerticalAlignmentTop"
	TypePageBlockVerticalAlignmentMiddle                = "pageBlockVerticalAlignmentMiddle"
	TypePageBlockVerticalAlignmentBottom                = "pageBlockVerticalAlignmentBottom"
	TypePageBlockTableCell                              = "pageBlockTableCell"
	TypePageBlockRelatedArticle                         = "pageBlockRelatedArticle"
	TypePageBlockTitle                                  = "pageBlockTitle"
	TypePageBlockSubtitle                               = "pageBlockSubtitle"
	TypePageBlockAuthorDate                             = "pageBlockAuthorDate"
	TypePageBlockHeader                                 = "pageBlockHeader"
	TypePageBlockSubheader                              = "pageBlockSubheader"
	TypePageBlockKicker                                 = "pageBlockKicker"
	TypePageBlockParagraph                              = "pageBlockParagraph"
	TypePageBlockPreformatted                           = "pageBlockPreformatted"
	TypePageBlockFooter                                 = "pageBlockFooter"
	TypePageBlockDivider                                = "pageBlockDivider"
	TypePageBlockAnchor                                 = "pageBlockAnchor"
	TypePageBlockList                                   = "pageBlockList"
	TypePageBlockBlockQuote                             = "pageBlockBlockQuote"
	TypePageBlockPullQuote                              = "pageBlockPullQuote"
	TypePageBlockAnimation                              = "pageBlockAnimation"
	TypePageBlockAudio                                  = "pageBlockAudio"
	TypePageBlockPhoto                                  = "pageBlockPhoto"
	TypePageBlockVideo                                  = "pageBlockVideo"
	TypePageBlockVoiceNote                              = "pageBlockVoiceNote"
	TypePageBlockCover                                  = "pageBlockCover"
	TypePageBlockEmbedded                               = "pageBlockEmbedded"
	TypePageBlockEmbeddedPost                           = "pageBlockEmbeddedPost"
	TypePageBlockCollage                                = "pageBlockCollage"
	TypePageBlockSlideshow                              = "pageBlockSlideshow"
	TypePageBlockChatLink                               = "pageBlockChatLink"
	TypePageBlockTable                                  = "pageBlockTable"
	TypePageBlockDetails                                = "pageBlockDetails"
	TypePageBlockRelatedArticles                        = "pageBlockRelatedArticles"
	TypePageBlockMap                                    = "pageBlockMap"
	TypeWebPageInstantView                              = "webPageInstantView"
	TypeWebPage                                         = "webPage"
	TypeAddress                                         = "address"
	TypeLabeledPricePart                                = "labeledPricePart"
	TypeInvoice                                         = "invoice"
	TypeOrderInfo                                       = "orderInfo"
	TypeShippingOption                                  = "shippingOption"
	TypeSavedCredentials                                = "savedCredentials"
	TypeInputCredentialsSaved                           = "inputCredentialsSaved"
	TypeInputCredentialsNew                             = "inputCredentialsNew"
	TypeInputCredentialsAndroidPay                      = "inputCredentialsAndroidPay"
	TypeInputCredentialsApplePay                        = "inputCredentialsApplePay"
	TypePaymentsProviderStripe                          = "paymentsProviderStripe"
	TypePaymentForm                                     = "paymentForm"
	TypeValidatedOrderInfo                              = "validatedOrderInfo"
	TypePaymentResult                                   = "paymentResult"
	TypePaymentReceipt                                  = "paymentReceipt"
	TypeDatedFile                                       = "datedFile"
	TypePassportElementTypePersonalDetails              = "passportElementTypePersonalDetails"
	TypePassportElementTypePassport                     = "passportElementTypePassport"
	TypePassportElementTypeDriverLicense                = "passportElementTypeDriverLicense"
	TypePassportElementTypeIdentityCard                 = "passportElementTypeIdentityCard"
	TypePassportElementTypeInternalPassport             = "passportElementTypeInternalPassport"
	TypePassportElementTypeAddress                      = "passportElementTypeAddress"
	TypePassportElementTypeUtilityBill                  = "passportElementTypeUtilityBill"
	TypePassportElementTypeBankStatement                = "passportElementTypeBankStatement"
	TypePassportElementTypeRentalAgreement              = "passportElementTypeRentalAgreement"
	TypePassportElementTypePassportRegistration         = "passportElementTypePassportRegistration"
	TypePassportElementTypeTemporaryRegistration        = "passportElementTypeTemporaryRegistration"
	TypePassportElementTypePhoneNumber                  = "passportElementTypePhoneNumber"
	TypePassportElementTypeEmailAddress                 = "passportElementTypeEmailAddress"
	TypeDate                                            = "date"
	TypePersonalDetails                                 = "personalDetails"
	TypeIdentityDocument                                = "identityDocument"
	TypeInputIdentityDocument                           = "inputIdentityDocument"
	TypePersonalDocument                                = "personalDocument"
	TypeInputPersonalDocument                           = "inputPersonalDocument"
	TypePassportElementPersonalDetails                  = "passportElementPersonalDetails"
	TypePassportElementPassport                         = "passportElementPassport"
	TypePassportElementDriverLicense                    = "passportElementDriverLicense"
	TypePassportElementIdentityCard                     = "passportElementIdentityCard"
	TypePassportElementInternalPassport                 = "passportElementInternalPassport"
	TypePassportElementAddress                          = "passportElementAddress"
	TypePassportElementUtilityBill                      = "passportElementUtilityBill"
	TypePassportElementBankStatement                    = "passportElementBankStatement"
	TypePassportElementRentalAgreement                  = "passportElementRentalAgreement"
	TypePassportElementPassportRegistration             = "passportElementPassportRegistration"
	TypePassportElementTemporaryRegistration            = "passportElementTemporaryRegistration"
	TypePassportElementPhoneNumber                      = "passportElementPhoneNumber"
	TypePassportElementEmailAddress                     = "passportElementEmailAddress"
	TypeInputPassportElementPersonalDetails             = "inputPassportElementPersonalDetails"
	TypeInputPassportElementPassport                    = "inputPassportElementPassport"
	TypeInputPassportElementDriverLicense               = "inputPassportElementDriverLicense"
	TypeInputPassportElementIdentityCard                = "inputPassportElementIdentityCard"
	TypeInputPassportElementInternalPassport            = "inputPassportElementInternalPassport"
	TypeInputPassportElementAddress                     = "inputPassportElementAddress"
	TypeInputPassportElementUtilityBill                 = "inputPassportElementUtilityBill"
	TypeInputPassportElementBankStatement               = "inputPassportElementBankStatement"
	TypeInputPassportElementRentalAgreement             = "inputPassportElementRentalAgreement"
	TypeInputPassportElementPassportRegistration        = "inputPassportElementPassportRegistration"
	TypeInputPassportElementTemporaryRegistration       = "inputPassportElementTemporaryRegistration"
	TypeInputPassportElementPhoneNumber                 = "inputPassportElementPhoneNumber"
	TypeInputPassportElementEmailAddress                = "inputPassportElementEmailAddress"
	TypePassportElements                                = "passportElements"
	TypePassportElementErrorSourceUnspecified           = "passportElementErrorSourceUnspecified"
	TypePassportElementErrorSourceDataField             = "passportElementErrorSourceDataField"
	TypePassportElementErrorSourceFrontSide             = "passportElementErrorSourceFrontSide"
	TypePassportElementErrorSourceReverseSide           = "passportElementErrorSourceReverseSide"
	TypePassportElementErrorSourceSelfie                = "passportElementErrorSourceSelfie"
	TypePassportElementErrorSourceTranslationFile       = "passportElementErrorSourceTranslationFile"
	TypePassportElementErrorSourceTranslationFiles      = "passportElementErrorSourceTranslationFiles"
	TypePassportElementErrorSourceFile                  = "passportElementErrorSourceFile"
	TypePassportElementErrorSourceFiles                 = "passportElementErrorSourceFiles"
	TypePassportElementError                            = "passportElementError"
	TypePassportSuitableElement                         = "passportSuitableElement"
	TypePassportRequiredElement                         = "passportRequiredElement"
	TypePassportAuthorizationForm                       = "passportAuthorizationForm"
	TypePassportElementsWithErrors                      = "passportElementsWithErrors"
	TypeEncryptedCredentials                            = "encryptedCredentials"
	TypeEncryptedPassportElement                        = "encryptedPassportElement"
	TypeInputPassportElementErrorSourceUnspecified      = "inputPassportElementErrorSourceUnspecified"
	TypeInputPassportElementErrorSourceDataField        = "inputPassportElementErrorSourceDataField"
	TypeInputPassportElementErrorSourceFrontSide        = "inputPassportElementErrorSourceFrontSide"
	TypeInputPassportElementErrorSourceReverseSide      = "inputPassportElementErrorSourceReverseSide"
	TypeInputPassportElementErrorSourceSelfie           = "inputPassportElementErrorSourceSelfie"
	TypeInputPassportElementErrorSourceTranslationFile  = "inputPassportElementErrorSourceTranslationFile"
	TypeInputPassportElementErrorSourceTranslationFiles = "inputPassportElementErrorSourceTranslationFiles"
	TypeInputPassportElementErrorSourceFile             = "inputPassportElementErrorSourceFile"
	TypeInputPassportElementErrorSourceFiles            = "inputPassportElementErrorSourceFiles"
	TypeInputPassportElementError                       = "inputPassportElementError"
	TypeMessageText                                     = "messageText"
	TypeMessageAnimation                                = "messageAnimation"
	TypeMessageAudio                                    = "messageAudio"
	TypeMessageDocument                                 = "messageDocument"
	TypeMessagePhoto                                    = "messagePhoto"
	TypeMessageExpiredPhoto                             = "messageExpiredPhoto"
	TypeMessageSticker                                  = "messageSticker"
	TypeMessageVideo                                    = "messageVideo"
	TypeMessageExpiredVideo                             = "messageExpiredVideo"
	TypeMessageVideoNote                                = "messageVideoNote"
	TypeMessageVoiceNote                                = "messageVoiceNote"
	TypeMessageLocation                                 = "messageLocation"
	TypeMessageVenue                                    = "messageVenue"
	TypeMessageContact                                  = "messageContact"
	TypeMessageGame                                     = "messageGame"
	TypeMessagePoll                                     = "messagePoll"
	TypeMessageInvoice                                  = "messageInvoice"
	TypeMessageCall                                     = "messageCall"
	TypeMessageBasicGroupChatCreate                     = "messageBasicGroupChatCreate"
	TypeMessageSupergroupChatCreate                     = "messageSupergroupChatCreate"
	TypeMessageChatChangeTitle                          = "messageChatChangeTitle"
	TypeMessageChatChangePhoto                          = "messageChatChangePhoto"
	TypeMessageChatDeletePhoto                          = "messageChatDeletePhoto"
	TypeMessageChatAddMembers                           = "messageChatAddMembers"
	TypeMessageChatJoinByLink                           = "messageChatJoinByLink"
	TypeMessageChatDeleteMember                         = "messageChatDeleteMember"
	TypeMessageChatUpgradeTo                            = "messageChatUpgradeTo"
	TypeMessageChatUpgradeFrom                          = "messageChatUpgradeFrom"
	TypeMessagePinMessage                               = "messagePinMessage"
	TypeMessageScreenshotTaken                          = "messageScreenshotTaken"
	TypeMessageChatSetTtl                               = "messageChatSetTtl"
	TypeMessageCustomServiceAction                      = "messageCustomServiceAction"
	TypeMessageGameScore                                = "messageGameScore"
	TypeMessagePaymentSuccessful                        = "messagePaymentSuccessful"
	TypeMessagePaymentSuccessfulBot                     = "messagePaymentSuccessfulBot"
	TypeMessageContactRegistered                        = "messageContactRegistered"
	TypeMessageWebsiteConnected                         = "messageWebsiteConnected"
	TypeMessagePassportDataSent                         = "messagePassportDataSent"
	TypeMessagePassportDataReceived                     = "messagePassportDataReceived"
	TypeMessageUnsupported                              = "messageUnsupported"
	TypeTextEntityTypeMention                           = "textEntityTypeMention"
	TypeTextEntityTypeHashtag                           = "textEntityTypeHashtag"
	TypeTextEntityTypeCashtag                           = "textEntityTypeCashtag"
	TypeTextEntityTypeBotCommand                        = "textEntityTypeBotCommand"
	TypeTextEntityTypeUrl                               = "textEntityTypeUrl"
	TypeTextEntityTypeEmailAddress                      = "textEntityTypeEmailAddress"
	TypeTextEntityTypePhoneNumber                       = "textEntityTypePhoneNumber"
	TypeTextEntityTypeBold                              = "textEntityTypeBold"
	TypeTextEntityTypeItalic                            = "textEntityTypeItalic"
	TypeTextEntityTypeUnderline                         = "textEntityTypeUnderline"
	TypeTextEntityTypeStrikethrough                     = "textEntityTypeStrikethrough"
	TypeTextEntityTypeCode                              = "textEntityTypeCode"
	TypeTextEntityTypePre                               = "textEntityTypePre"
	TypeTextEntityTypePreCode                           = "textEntityTypePreCode"
	TypeTextEntityTypeTextUrl                           = "textEntityTypeTextUrl"
	TypeTextEntityTypeMentionName                       = "textEntityTypeMentionName"
	TypeInputThumbnail                                  = "inputThumbnail"
	TypeMessageSchedulingStateSendAtDate                = "messageSchedulingStateSendAtDate"
	TypeMessageSchedulingStateSendWhenOnline            = "messageSchedulingStateSendWhenOnline"
	TypeSendMessageOptions                              = "sendMessageOptions"
	TypeInputMessageText                                = "inputMessageText"
	TypeInputMessageAnimation                           = "inputMessageAnimation"
	TypeInputMessageAudio                               = "inputMessageAudio"
	TypeInputMessageDocument                            = "inputMessageDocument"
	TypeInputMessagePhoto                               = "inputMessagePhoto"
	TypeInputMessageSticker                             = "inputMessageSticker"
	TypeInputMessageVideo                               = "inputMessageVideo"
	TypeInputMessageVideoNote                           = "inputMessageVideoNote"
	TypeInputMessageVoiceNote                           = "inputMessageVoiceNote"
	TypeInputMessageLocation                            = "inputMessageLocation"
	TypeInputMessageVenue                               = "inputMessageVenue"
	TypeInputMessageContact                             = "inputMessageContact"
	TypeInputMessageGame                                = "inputMessageGame"
	TypeInputMessageInvoice                             = "inputMessageInvoice"
	TypeInputMessagePoll                                = "inputMessagePoll"
	TypeInputMessageForwarded                           = "inputMessageForwarded"
	TypeSearchMessagesFilterEmpty                       = "searchMessagesFilterEmpty"
	TypeSearchMessagesFilterAnimation                   = "searchMessagesFilterAnimation"
	TypeSearchMessagesFilterAudio                       = "searchMessagesFilterAudio"
	TypeSearchMessagesFilterDocument                    = "searchMessagesFilterDocument"
	TypeSearchMessagesFilterPhoto                       = "searchMessagesFilterPhoto"
	TypeSearchMessagesFilterVideo                       = "searchMessagesFilterVideo"
	TypeSearchMessagesFilterVoiceNote                   = "searchMessagesFilterVoiceNote"
	TypeSearchMessagesFilterPhotoAndVideo               = "searchMessagesFilterPhotoAndVideo"
	TypeSearchMessagesFilterUrl                         = "searchMessagesFilterUrl"
	TypeSearchMessagesFilterChatPhoto                   = "searchMessagesFilterChatPhoto"
	TypeSearchMessagesFilterCall                        = "searchMessagesFilterCall"
	TypeSearchMessagesFilterMissedCall                  = "searchMessagesFilterMissedCall"
	TypeSearchMessagesFilterVideoNote                   = "searchMessagesFilterVideoNote"
	TypeSearchMessagesFilterVoiceAndVideoNote           = "searchMessagesFilterVoiceAndVideoNote"
	TypeSearchMessagesFilterMention                     = "searchMessagesFilterMention"
	TypeSearchMessagesFilterUnreadMention               = "searchMessagesFilterUnreadMention"
	TypeChatActionTyping                                = "chatActionTyping"
	TypeChatActionRecordingVideo                        = "chatActionRecordingVideo"
	TypeChatActionUploadingVideo                        = "chatActionUploadingVideo"
	TypeChatActionRecordingVoiceNote                    = "chatActionRecordingVoiceNote"
	TypeChatActionUploadingVoiceNote                    = "chatActionUploadingVoiceNote"
	TypeChatActionUploadingPhoto                        = "chatActionUploadingPhoto"
	TypeChatActionUploadingDocument                     = "chatActionUploadingDocument"
	TypeChatActionChoosingLocation                      = "chatActionChoosingLocation"
	TypeChatActionChoosingContact                       = "chatActionChoosingContact"
	TypeChatActionStartPlayingGame                      = "chatActionStartPlayingGame"
	TypeChatActionRecordingVideoNote                    = "chatActionRecordingVideoNote"
	TypeChatActionUploadingVideoNote                    = "chatActionUploadingVideoNote"
	TypeChatActionCancel                                = "chatActionCancel"
	TypeUserStatusEmpty                                 = "userStatusEmpty"
	TypeUserStatusOnline                                = "userStatusOnline"
	TypeUserStatusOffline                               = "userStatusOffline"
	TypeUserStatusRecently                              = "userStatusRecently"
	TypeUserStatusLastWeek                              = "userStatusLastWeek"
	TypeUserStatusLastMonth                             = "userStatusLastMonth"
	TypeStickers                                        = "stickers"
	TypeEmojis                                          = "emojis"
	TypeStickerSet                                      = "stickerSet"
	TypeStickerSetInfo                                  = "stickerSetInfo"
	TypeStickerSets                                     = "stickerSets"
	TypeCallDiscardReasonEmpty                          = "callDiscardReasonEmpty"
	TypeCallDiscardReasonMissed                         = "callDiscardReasonMissed"
	TypeCallDiscardReasonDeclined                       = "callDiscardReasonDeclined"
	TypeCallDiscardReasonDisconnected                   = "callDiscardReasonDisconnected"
	TypeCallDiscardReasonHungUp                         = "callDiscardReasonHungUp"
	TypeCallProtocol                                    = "callProtocol"
	TypeCallConnection                                  = "callConnection"
	TypeCallId                                          = "callId"
	TypeCallStatePending                                = "callStatePending"
	TypeCallStateExchangingKeys                         = "callStateExchangingKeys"
	TypeCallStateReady                                  = "callStateReady"
	TypeCallStateHangingUp                              = "callStateHangingUp"
	TypeCallStateDiscarded                              = "callStateDiscarded"
	TypeCallStateError                                  = "callStateError"
	TypeCallProblemEcho                                 = "callProblemEcho"
	TypeCallProblemNoise                                = "callProblemNoise"
	TypeCallProblemInterruptions                        = "callProblemInterruptions"
	TypeCallProblemDistortedSpeech                      = "callProblemDistortedSpeech"
	TypeCallProblemSilentLocal                          = "callProblemSilentLocal"
	TypeCallProblemSilentRemote                         = "callProblemSilentRemote"
	TypeCallProblemDropped                              = "callProblemDropped"
	TypeCall                                            = "call"
	TypePhoneNumberAuthenticationSettings               = "phoneNumberAuthenticationSettings"
	TypeAnimations                                      = "animations"
	TypeImportedContacts                                = "importedContacts"
	TypeHttpUrl                                         = "httpUrl"
	TypeInputInlineQueryResultAnimatedGif               = "inputInlineQueryResultAnimatedGif"
	TypeInputInlineQueryResultAnimatedMpeg4             = "inputInlineQueryResultAnimatedMpeg4"
	TypeInputInlineQueryResultArticle                   = "inputInlineQueryResultArticle"
	TypeInputInlineQueryResultAudio                     = "inputInlineQueryResultAudio"
	TypeInputInlineQueryResultContact                   = "inputInlineQueryResultContact"
	TypeInputInlineQueryResultDocument                  = "inputInlineQueryResultDocument"
	TypeInputInlineQueryResultGame                      = "inputInlineQueryResultGame"
	TypeInputInlineQueryResultLocation                  = "inputInlineQueryResultLocation"
	TypeInputInlineQueryResultPhoto                     = "inputInlineQueryResultPhoto"
	TypeInputInlineQueryResultSticker                   = "inputInlineQueryResultSticker"
	TypeInputInlineQueryResultVenue                     = "inputInlineQueryResultVenue"
	TypeInputInlineQueryResultVideo                     = "inputInlineQueryResultVideo"
	TypeInputInlineQueryResultVoiceNote                 = "inputInlineQueryResultVoiceNote"
	TypeInlineQueryResultArticle                        = "inlineQueryResultArticle"
	TypeInlineQueryResultContact                        = "inlineQueryResultContact"
	TypeInlineQueryResultLocation                       = "inlineQueryResultLocation"
	TypeInlineQueryResultVenue                          = "inlineQueryResultVenue"
	TypeInlineQueryResultGame                           = "inlineQueryResultGame"
	TypeInlineQueryResultAnimation                      = "inlineQueryResultAnimation"
	TypeInlineQueryResultAudio                          = "inlineQueryResultAudio"
	TypeInlineQueryResultDocument                       = "inlineQueryResultDocument"
	TypeInlineQueryResultPhoto                          = "inlineQueryResultPhoto"
	TypeInlineQueryResultSticker                        = "inlineQueryResultSticker"
	TypeInlineQueryResultVideo                          = "inlineQueryResultVideo"
	TypeInlineQueryResultVoiceNote                      = "inlineQueryResultVoiceNote"
	TypeInlineQueryResults                              = "inlineQueryResults"
	TypeCallbackQueryPayloadData                        = "callbackQueryPayloadData"
	TypeCallbackQueryPayloadGame                        = "callbackQueryPayloadGame"
	TypeCallbackQueryAnswer                             = "callbackQueryAnswer"
	TypeCustomRequestResult                             = "customRequestResult"
	TypeGameHighScore                                   = "gameHighScore"
	TypeGameHighScores                                  = "gameHighScores"
	TypeChatEventMessageEdited                          = "chatEventMessageEdited"
	TypeChatEventMessageDeleted                         = "chatEventMessageDeleted"
	TypeChatEventPollStopped                            = "chatEventPollStopped"
	TypeChatEventMessagePinned                          = "chatEventMessagePinned"
	TypeChatEventMessageUnpinned                        = "chatEventMessageUnpinned"
	TypeChatEventMemberJoined                           = "chatEventMemberJoined"
	TypeChatEventMemberLeft                             = "chatEventMemberLeft"
	TypeChatEventMemberInvited                          = "chatEventMemberInvited"
	TypeChatEventMemberPromoted                         = "chatEventMemberPromoted"
	TypeChatEventMemberRestricted                       = "chatEventMemberRestricted"
	TypeChatEventTitleChanged                           = "chatEventTitleChanged"
	TypeChatEventPermissionsChanged                     = "chatEventPermissionsChanged"
	TypeChatEventDescriptionChanged                     = "chatEventDescriptionChanged"
	TypeChatEventUsernameChanged                        = "chatEventUsernameChanged"
	TypeChatEventPhotoChanged                           = "chatEventPhotoChanged"
	TypeChatEventInvitesToggled                         = "chatEventInvitesToggled"
	TypeChatEventLinkedChatChanged                      = "chatEventLinkedChatChanged"
	TypeChatEventSlowModeDelayChanged                   = "chatEventSlowModeDelayChanged"
	TypeChatEventSignMessagesToggled                    = "chatEventSignMessagesToggled"
	TypeChatEventStickerSetChanged                      = "chatEventStickerSetChanged"
	TypeChatEventLocationChanged                        = "chatEventLocationChanged"
	TypeChatEventIsAllHistoryAvailableToggled           = "chatEventIsAllHistoryAvailableToggled"
	TypeChatEvent                                       = "chatEvent"
	TypeChatEvents                                      = "chatEvents"
	TypeChatEventLogFilters                             = "chatEventLogFilters"
	TypeLanguagePackStringValueOrdinary                 = "languagePackStringValueOrdinary"
	TypeLanguagePackStringValuePluralized               = "languagePackStringValuePluralized"
	TypeLanguagePackStringValueDeleted                  = "languagePackStringValueDeleted"
	TypeLanguagePackString                              = "languagePackString"
	TypeLanguagePackStrings                             = "languagePackStrings"
	TypeLanguagePackInfo                                = "languagePackInfo"
	TypeLocalizationTargetInfo                          = "localizationTargetInfo"
	TypeDeviceTokenFirebaseCloudMessaging               = "deviceTokenFirebaseCloudMessaging"
	TypeDeviceTokenApplePush                            = "deviceTokenApplePush"
	TypeDeviceTokenApplePushVoIP                        = "deviceTokenApplePushVoIP"
	TypeDeviceTokenWindowsPush                          = "deviceTokenWindowsPush"
	TypeDeviceTokenMicrosoftPush                        = "deviceTokenMicrosoftPush"
	TypeDeviceTokenMicrosoftPushVoIP                    = "deviceTokenMicrosoftPushVoIP"
	TypeDeviceTokenWebPush                              = "deviceTokenWebPush"
	TypeDeviceTokenSimplePush                           = "deviceTokenSimplePush"
	TypeDeviceTokenUbuntuPush                           = "deviceTokenUbuntuPush"
	TypeDeviceTokenBlackBerryPush                       = "deviceTokenBlackBerryPush"
	TypeDeviceTokenTizenPush                            = "deviceTokenTizenPush"
	TypePushReceiverId                                  = "pushReceiverId"
	TypeBackgroundFillSolid                             = "backgroundFillSolid"
	TypeBackgroundFillGradient                          = "backgroundFillGradient"
	TypeBackgroundTypeWallpaper                         = "backgroundTypeWallpaper"
	TypeBackgroundTypePattern                           = "backgroundTypePattern"
	TypeBackgroundTypeFill                              = "backgroundTypeFill"
	TypeBackground                                      = "background"
	TypeBackgrounds                                     = "backgrounds"
	TypeInputBackgroundLocal                            = "inputBackgroundLocal"
	TypeInputBackgroundRemote                           = "inputBackgroundRemote"
	TypeHashtags                                        = "hashtags"
	TypeCanTransferOwnershipResultOk                    = "canTransferOwnershipResultOk"
	TypeCanTransferOwnershipResultPasswordNeeded        = "canTransferOwnershipResultPasswordNeeded"
	TypeCanTransferOwnershipResultPasswordTooFresh      = "canTransferOwnershipResultPasswordTooFresh"
	TypeCanTransferOwnershipResultSessionTooFresh       = "canTransferOwnershipResultSessionTooFresh"
	TypeCheckChatUsernameResultOk                       = "checkChatUsernameResultOk"
	TypeCheckChatUsernameResultUsernameInvalid          = "checkChatUsernameResultUsernameInvalid"
	TypeCheckChatUsernameResultUsernameOccupied         = "checkChatUsernameResultUsernameOccupied"
	TypeCheckChatUsernameResultPublicChatsTooMuch       = "checkChatUsernameResultPublicChatsTooMuch"
	TypeCheckChatUsernameResultPublicGroupsUnavailable  = "checkChatUsernameResultPublicGroupsUnavailable"
	TypePushMessageContentHidden                        = "pushMessageContentHidden"
	TypePushMessageContentAnimation                     = "pushMessageContentAnimation"
	TypePushMessageContentAudio                         = "pushMessageContentAudio"
	TypePushMessageContentContact                       = "pushMessageContentContact"
	TypePushMessageContentContactRegistered             = "pushMessageContentContactRegistered"
	TypePushMessageContentDocument                      = "pushMessageContentDocument"
	TypePushMessageContentGame                          = "pushMessageContentGame"
	TypePushMessageContentGameScore                     = "pushMessageContentGameScore"
	TypePushMessageContentInvoice                       = "pushMessageContentInvoice"
	TypePushMessageContentLocation                      = "pushMessageContentLocation"
	TypePushMessageContentPhoto                         = "pushMessageContentPhoto"
	TypePushMessageContentPoll                          = "pushMessageContentPoll"
	TypePushMessageContentScreenshotTaken               = "pushMessageContentScreenshotTaken"
	TypePushMessageContentSticker                       = "pushMessageContentSticker"
	TypePushMessageContentText                          = "pushMessageContentText"
	TypePushMessageContentVideo                         = "pushMessageContentVideo"
	TypePushMessageContentVideoNote                     = "pushMessageContentVideoNote"
	TypePushMessageContentVoiceNote                     = "pushMessageContentVoiceNote"
	TypePushMessageContentBasicGroupChatCreate          = "pushMessageContentBasicGroupChatCreate"
	TypePushMessageContentChatAddMembers                = "pushMessageContentChatAddMembers"
	TypePushMessageContentChatChangePhoto               = "pushMessageContentChatChangePhoto"
	TypePushMessageContentChatChangeTitle               = "pushMessageContentChatChangeTitle"
	TypePushMessageContentChatDeleteMember              = "pushMessageContentChatDeleteMember"
	TypePushMessageContentChatJoinByLink                = "pushMessageContentChatJoinByLink"
	TypePushMessageContentMessageForwards               = "pushMessageContentMessageForwards"
	TypePushMessageContentMediaAlbum                    = "pushMessageContentMediaAlbum"
	TypeNotificationTypeNewMessage                      = "notificationTypeNewMessage"
	TypeNotificationTypeNewSecretChat                   = "notificationTypeNewSecretChat"
	TypeNotificationTypeNewCall                         = "notificationTypeNewCall"
	TypeNotificationTypeNewPushMessage                  = "notificationTypeNewPushMessage"
	TypeNotificationGroupTypeMessages                   = "notificationGroupTypeMessages"
	TypeNotificationGroupTypeMentions                   = "notificationGroupTypeMentions"
	TypeNotificationGroupTypeSecretChat                 = "notificationGroupTypeSecretChat"
	TypeNotificationGroupTypeCalls                      = "notificationGroupTypeCalls"
	TypeNotification                                    = "notification"
	TypeNotificationGroup                               = "notificationGroup"
	TypeOptionValueBoolean                              = "optionValueBoolean"
	TypeOptionValueEmpty                                = "optionValueEmpty"
	TypeOptionValueInteger                              = "optionValueInteger"
	TypeOptionValueString                               = "optionValueString"
	TypeJsonObjectMember                                = "jsonObjectMember"
	TypeJsonValueNull                                   = "jsonValueNull"
	TypeJsonValueBoolean                                = "jsonValueBoolean"
	TypeJsonValueNumber                                 = "jsonValueNumber"
	TypeJsonValueString                                 = "jsonValueString"
	TypeJsonValueArray                                  = "jsonValueArray"
	TypeJsonValueObject                                 = "jsonValueObject"
	TypeUserPrivacySettingRuleAllowAll                  = "userPrivacySettingRuleAllowAll"
	TypeUserPrivacySettingRuleAllowContacts             = "userPrivacySettingRuleAllowContacts"
	TypeUserPrivacySettingRuleAllowUsers                = "userPrivacySettingRuleAllowUsers"
	TypeUserPrivacySettingRuleAllowChatMembers          = "userPrivacySettingRuleAllowChatMembers"
	TypeUserPrivacySettingRuleRestrictAll               = "userPrivacySettingRuleRestrictAll"
	TypeUserPrivacySettingRuleRestrictContacts          = "userPrivacySettingRuleRestrictContacts"
	TypeUserPrivacySettingRuleRestrictUsers             = "userPrivacySettingRuleRestrictUsers"
	TypeUserPrivacySettingRuleRestrictChatMembers       = "userPrivacySettingRuleRestrictChatMembers"
	TypeUserPrivacySettingRules                         = "userPrivacySettingRules"
	TypeUserPrivacySettingShowStatus                    = "userPrivacySettingShowStatus"
	TypeUserPrivacySettingShowProfilePhoto              = "userPrivacySettingShowProfilePhoto"
	TypeUserPrivacySettingShowLinkInForwardedMessages   = "userPrivacySettingShowLinkInForwardedMessages"
	TypeUserPrivacySettingShowPhoneNumber               = "userPrivacySettingShowPhoneNumber"
	TypeUserPrivacySettingAllowChatInvites              = "userPrivacySettingAllowChatInvites"
	TypeUserPrivacySettingAllowCalls                    = "userPrivacySettingAllowCalls"
	TypeUserPrivacySettingAllowPeerToPeerCalls          = "userPrivacySettingAllowPeerToPeerCalls"
	TypeUserPrivacySettingAllowFindingByPhoneNumber     = "userPrivacySettingAllowFindingByPhoneNumber"
	TypeAccountTtl                                      = "accountTtl"
	TypeSession                                         = "session"
	TypeSessions                                        = "sessions"
	TypeConnectedWebsite                                = "connectedWebsite"
	TypeConnectedWebsites                               = "connectedWebsites"
	TypeChatReportReasonSpam                            = "chatReportReasonSpam"
	TypeChatReportReasonViolence                        = "chatReportReasonViolence"
	TypeChatReportReasonPornography                     = "chatReportReasonPornography"
	TypeChatReportReasonChildAbuse                      = "chatReportReasonChildAbuse"
	TypeChatReportReasonCopyright                       = "chatReportReasonCopyright"
	TypeChatReportReasonUnrelatedLocation               = "chatReportReasonUnrelatedLocation"
	TypeChatReportReasonCustom                          = "chatReportReasonCustom"
	TypePublicMessageLink                               = "publicMessageLink"
	TypeMessageLinkInfo                                 = "messageLinkInfo"
	TypeFilePart                                        = "filePart"
	TypeFileTypeNone                                    = "fileTypeNone"
	TypeFileTypeAnimation                               = "fileTypeAnimation"
	TypeFileTypeAudio                                   = "fileTypeAudio"
	TypeFileTypeDocument                                = "fileTypeDocument"
	TypeFileTypePhoto                                   = "fileTypePhoto"
	TypeFileTypeProfilePhoto                            = "fileTypeProfilePhoto"
	TypeFileTypeSecret                                  = "fileTypeSecret"
	TypeFileTypeSecretThumbnail                         = "fileTypeSecretThumbnail"
	TypeFileTypeSecure                                  = "fileTypeSecure"
	TypeFileTypeSticker                                 = "fileTypeSticker"
	TypeFileTypeThumbnail                               = "fileTypeThumbnail"
	TypeFileTypeUnknown                                 = "fileTypeUnknown"
	TypeFileTypeVideo                                   = "fileTypeVideo"
	TypeFileTypeVideoNote                               = "fileTypeVideoNote"
	TypeFileTypeVoiceNote                               = "fileTypeVoiceNote"
	TypeFileTypeWallpaper                               = "fileTypeWallpaper"
	TypeStorageStatisticsByFileType                     = "storageStatisticsByFileType"
	TypeStorageStatisticsByChat                         = "storageStatisticsByChat"
	TypeStorageStatistics                               = "storageStatistics"
	TypeStorageStatisticsFast                           = "storageStatisticsFast"
	TypeDatabaseStatistics                              = "databaseStatistics"
	TypeNetworkTypeNone                                 = "networkTypeNone"
	TypeNetworkTypeMobile                               = "networkTypeMobile"
	TypeNetworkTypeMobileRoaming                        = "networkTypeMobileRoaming"
	TypeNetworkTypeWiFi                                 = "networkTypeWiFi"
	TypeNetworkTypeOther                                = "networkTypeOther"
	TypeNetworkStatisticsEntryFile                      = "networkStatisticsEntryFile"
	TypeNetworkStatisticsEntryCall                      = "networkStatisticsEntryCall"
	TypeNetworkStatistics                               = "networkStatistics"
	TypeAutoDownloadSettings                            = "autoDownloadSettings"
	TypeAutoDownloadSettingsPresets                     = "autoDownloadSettingsPresets"
	TypeConnectionStateWaitingForNetwork                = "connectionStateWaitingForNetwork"
	TypeConnectionStateConnectingToProxy                = "connectionStateConnectingToProxy"
	TypeConnectionStateConnecting                       = "connectionStateConnecting"
	TypeConnectionStateUpdating                         = "connectionStateUpdating"
	TypeConnectionStateReady                            = "connectionStateReady"
	TypeTopChatCategoryUsers                            = "topChatCategoryUsers"
	TypeTopChatCategoryBots                             = "topChatCategoryBots"
	TypeTopChatCategoryGroups                           = "topChatCategoryGroups"
	TypeTopChatCategoryChannels                         = "topChatCategoryChannels"
	TypeTopChatCategoryInlineBots                       = "topChatCategoryInlineBots"
	TypeTopChatCategoryCalls                            = "topChatCategoryCalls"
	TypeTopChatCategoryForwardChats                     = "topChatCategoryForwardChats"
	TypeTMeUrlTypeUser                                  = "tMeUrlTypeUser"
	TypeTMeUrlTypeSupergroup                            = "tMeUrlTypeSupergroup"
	TypeTMeUrlTypeChatInvite                            = "tMeUrlTypeChatInvite"
	TypeTMeUrlTypeStickerSet                            = "tMeUrlTypeStickerSet"
	TypeTMeUrl                                          = "tMeUrl"
	TypeTMeUrls                                         = "tMeUrls"
	TypeCount                                           = "count"
	TypeText                                            = "text"
	TypeSeconds                                         = "seconds"
	TypeDeepLinkInfo                                    = "deepLinkInfo"
	TypeTextParseModeMarkdown                           = "textParseModeMarkdown"
	TypeTextParseModeHTML                               = "textParseModeHTML"
	TypeProxyTypeSocks5                                 = "proxyTypeSocks5"
	TypeProxyTypeHttp                                   = "proxyTypeHttp"
	TypeProxyTypeMtproto                                = "proxyTypeMtproto"
	TypeProxy                                           = "proxy"
	TypeProxies                                         = "proxies"
	TypeInputSticker                                    = "inputSticker"
	TypeUpdateAuthorizationState                        = "updateAuthorizationState"
	TypeUpdateNewMessage                                = "updateNewMessage"
	TypeUpdateMessageSendAcknowledged                   = "updateMessageSendAcknowledged"
	TypeUpdateMessageSendSucceeded                      = "updateMessageSendSucceeded"
	TypeUpdateMessageSendFailed                         = "updateMessageSendFailed"
	TypeUpdateMessageContent                            = "updateMessageContent"
	TypeUpdateMessageEdited                             = "updateMessageEdited"
	TypeUpdateMessageViews                              = "updateMessageViews"
	TypeUpdateMessageContentOpened                      = "updateMessageContentOpened"
	TypeUpdateMessageMentionRead                        = "updateMessageMentionRead"
	TypeUpdateMessageLiveLocationViewed                 = "updateMessageLiveLocationViewed"
	TypeUpdateNewChat                                   = "updateNewChat"
	TypeUpdateChatChatList                              = "updateChatChatList"
	TypeUpdateChatTitle                                 = "updateChatTitle"
	TypeUpdateChatPhoto                                 = "updateChatPhoto"
	TypeUpdateChatPermissions                           = "updateChatPermissions"
	TypeUpdateChatLastMessage                           = "updateChatLastMessage"
	TypeUpdateChatOrder                                 = "updateChatOrder"
	TypeUpdateChatIsPinned                              = "updateChatIsPinned"
	TypeUpdateChatIsMarkedAsUnread                      = "updateChatIsMarkedAsUnread"
	TypeUpdateChatIsSponsored                           = "updateChatIsSponsored"
	TypeUpdateChatHasScheduledMessages                  = "updateChatHasScheduledMessages"
	TypeUpdateChatDefaultDisableNotification            = "updateChatDefaultDisableNotification"
	TypeUpdateChatReadInbox                             = "updateChatReadInbox"
	TypeUpdateChatReadOutbox                            = "updateChatReadOutbox"
	TypeUpdateChatUnreadMentionCount                    = "updateChatUnreadMentionCount"
	TypeUpdateChatNotificationSettings                  = "updateChatNotificationSettings"
	TypeUpdateScopeNotificationSettings                 = "updateScopeNotificationSettings"
	TypeUpdateChatActionBar                             = "updateChatActionBar"
	TypeUpdateChatPinnedMessage                         = "updateChatPinnedMessage"
	TypeUpdateChatReplyMarkup                           = "updateChatReplyMarkup"
	TypeUpdateChatDraftMessage                          = "updateChatDraftMessage"
	TypeUpdateChatOnlineMemberCount                     = "updateChatOnlineMemberCount"
	TypeUpdateNotification                              = "updateNotification"
	TypeUpdateNotificationGroup                         = "updateNotificationGroup"
	TypeUpdateActiveNotifications                       = "updateActiveNotifications"
	TypeUpdateHavePendingNotifications                  = "updateHavePendingNotifications"
	TypeUpdateDeleteMessages                            = "updateDeleteMessages"
	TypeUpdateUserChatAction                            = "updateUserChatAction"
	TypeUpdateUserStatus                                = "updateUserStatus"
	TypeUpdateUser                                      = "updateUser"
	TypeUpdateBasicGroup                                = "updateBasicGroup"
	TypeUpdateSupergroup                                = "updateSupergroup"
	TypeUpdateSecretChat                                = "updateSecretChat"
	TypeUpdateUserFullInfo                              = "updateUserFullInfo"
	TypeUpdateBasicGroupFullInfo                        = "updateBasicGroupFullInfo"
	TypeUpdateSupergroupFullInfo                        = "updateSupergroupFullInfo"
	TypeUpdateServiceNotification                       = "updateServiceNotification"
	TypeUpdateFile                                      = "updateFile"
	TypeUpdateFileGenerationStart                       = "updateFileGenerationStart"
	TypeUpdateFileGenerationStop                        = "updateFileGenerationStop"
	TypeUpdateCall                                      = "updateCall"
	TypeUpdateUserPrivacySettingRules                   = "updateUserPrivacySettingRules"
	TypeUpdateUnreadMessageCount                        = "updateUnreadMessageCount"
	TypeUpdateUnreadChatCount                           = "updateUnreadChatCount"
	TypeUpdateOption                                    = "updateOption"
	TypeUpdateInstalledStickerSets                      = "updateInstalledStickerSets"
	TypeUpdateTrendingStickerSets                       = "updateTrendingStickerSets"
	TypeUpdateRecentStickers                            = "updateRecentStickers"
	TypeUpdateFavoriteStickers                          = "updateFavoriteStickers"
	TypeUpdateSavedAnimations                           = "updateSavedAnimations"
	TypeUpdateSelectedBackground                        = "updateSelectedBackground"
	TypeUpdateLanguagePackStrings                       = "updateLanguagePackStrings"
	TypeUpdateConnectionState                           = "updateConnectionState"
	TypeUpdateTermsOfService                            = "updateTermsOfService"
	TypeUpdateUsersNearby                               = "updateUsersNearby"
	TypeUpdateNewInlineQuery                            = "updateNewInlineQuery"
	TypeUpdateNewChosenInlineResult                     = "updateNewChosenInlineResult"
	TypeUpdateNewCallbackQuery                          = "updateNewCallbackQuery"
	TypeUpdateNewInlineCallbackQuery                    = "updateNewInlineCallbackQuery"
	TypeUpdateNewShippingQuery                          = "updateNewShippingQuery"
	TypeUpdateNewPreCheckoutQuery                       = "updateNewPreCheckoutQuery"
	TypeUpdateNewCustomEvent                            = "updateNewCustomEvent"
	TypeUpdateNewCustomQuery                            = "updateNewCustomQuery"
	TypeUpdatePoll                                      = "updatePoll"
	TypeUpdatePollAnswer                                = "updatePollAnswer"
	TypeUpdates                                         = "updates"
	TypeLogStreamDefault                                = "logStreamDefault"
	TypeLogStreamFile                                   = "logStreamFile"
	TypeLogStreamEmpty                                  = "logStreamEmpty"
	TypeLogVerbosityLevel                               = "logVerbosityLevel"
	TypeLogTags                                         = "logTags"
	TypeTestInt                                         = "testInt"
	TypeTestString                                      = "testString"
	TypeTestBytes                                       = "testBytes"
	TypeTestVectorInt                                   = "testVectorInt"
	TypeTestVectorIntObject                             = "testVectorIntObject"
	TypeTestVectorString                                = "testVectorString"
	TypeTestVectorStringObject                          = "testVectorStringObject"
)

// Provides information about the method by which an authentication code is delivered to the user
type AuthenticationCodeType interface {
	AuthenticationCodeTypeType() string
}

// Represents the current authorization state of the client
type AuthorizationState interface {
	AuthorizationStateType() string
}

// Points to a file
type InputFile interface {
	InputFileType() string
}

// Part of the face, relative to which a mask should be placed
type MaskPoint interface {
	MaskPointType() string
}

// Describes the type of a poll
type PollType interface {
	PollTypeType() string
}

// Represents the type of a user. The following types are possible: regular users, deleted users and bots
type UserType interface {
	UserTypeType() string
}

// Provides information about the status of a member in a chat
type ChatMemberStatus interface {
	ChatMemberStatusType() string
}

// Specifies the kind of chat members to return in searchChatMembers
type ChatMembersFilter interface {
	ChatMembersFilterType() string
}

// Specifies the kind of chat members to return in getSupergroupMembers
type SupergroupMembersFilter interface {
	SupergroupMembersFilterType() string
}

// Describes the current secret chat state
type SecretChatState interface {
	SecretChatStateType() string
}

// Contains information about the origin of a forwarded message
type MessageForwardOrigin interface {
	MessageForwardOriginType() string
}

// Contains information about the sending state of the message
type MessageSendingState interface {
	MessageSendingStateType() string
}

// Describes the types of chats to which notification settings are applied
type NotificationSettingsScope interface {
	NotificationSettingsScopeType() string
}

// Describes the type of a chat
type ChatType interface {
	ChatTypeType() string
}

// Describes a list of chats
type ChatList interface {
	ChatListType() string
}

// Describes a type of public chats
type PublicChatType interface {
	PublicChatTypeType() string
}

// Describes actions which should be possible to do through a chat action bar
type ChatActionBar interface {
	ChatActionBarType() string
}

// Describes a keyboard button type
type KeyboardButtonType interface {
	KeyboardButtonTypeType() string
}

// Describes the type of an inline keyboard button
type InlineKeyboardButtonType interface {
	InlineKeyboardButtonTypeType() string
}

// Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots
type ReplyMarkup interface {
	ReplyMarkupType() string
}

// Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl
type LoginUrlInfo interface {
	LoginUrlInfoType() string
}

// Describes a text object inside an instant-view web page
type RichText interface {
	RichTextType() string
}

// Describes a horizontal alignment of a table cell content
type PageBlockHorizontalAlignment interface {
	PageBlockHorizontalAlignmentType() string
}

// Describes a Vertical alignment of a table cell content
type PageBlockVerticalAlignment interface {
	PageBlockVerticalAlignmentType() string
}

// Describes a block of an instant view web page
type PageBlock interface {
	PageBlockType() string
}

// Contains information about the payment method chosen by the user
type InputCredentials interface {
	InputCredentialsType() string
}

// Contains the type of a Telegram Passport element
type PassportElementType interface {
	PassportElementTypeType() string
}

// Contains information about a Telegram Passport element
type PassportElement interface {
	PassportElementType() string
}

// Contains information about a Telegram Passport element to be saved
type InputPassportElement interface {
	InputPassportElementType() string
}

// Contains the description of an error in a Telegram Passport element
type PassportElementErrorSource interface {
	PassportElementErrorSourceType() string
}

// Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementErrorSource interface {
	InputPassportElementErrorSourceType() string
}

// Contains the content of a message
type MessageContent interface {
	MessageContentType() string
}

// Represents a part of the text which must be formatted differently
type TextEntityType interface {
	TextEntityTypeType() string
}

// Contains information about the time when a scheduled message will be sent
type MessageSchedulingState interface {
	MessageSchedulingStateType() string
}

// The content of a message to send
type InputMessageContent interface {
	InputMessageContentType() string
}

// Represents a filter for message search results
type SearchMessagesFilter interface {
	SearchMessagesFilterType() string
}

// Describes the different types of activity in a chat
type ChatAction interface {
	ChatActionType() string
}

// Describes the last time the user was online
type UserStatus interface {
	UserStatusType() string
}

// Describes the reason why a call was discarded
type CallDiscardReason interface {
	CallDiscardReasonType() string
}

// Describes the current call state
type CallState interface {
	CallStateType() string
}

// Describes the exact type of a problem with a call
type CallProblem interface {
	CallProblemType() string
}

// Represents a single result of an inline query; for bots only
type InputInlineQueryResult interface {
	InputInlineQueryResultType() string
}

// Represents a single result of an inline query
type InlineQueryResult interface {
	InlineQueryResultType() string
}

// Represents a payload of a callback query
type CallbackQueryPayload interface {
	CallbackQueryPayloadType() string
}

// Represents a chat event
type ChatEventAction interface {
	ChatEventActionType() string
}

// Represents the value of a string in a language pack
type LanguagePackStringValue interface {
	LanguagePackStringValueType() string
}

// Represents a data needed to subscribe for push notifications through registerDevice method. To use specific push notification service, you must specify the correct application platform and upload valid server authentication data at https://my.telegram.org
type DeviceToken interface {
	DeviceTokenType() string
}

// Describes a fill of a background
type BackgroundFill interface {
	BackgroundFillType() string
}

// Describes the type of a background
type BackgroundType interface {
	BackgroundTypeType() string
}

// Contains information about background to set
type InputBackground interface {
	InputBackgroundType() string
}

// Represents result of checking whether the current session can be used to transfer a chat ownership to another user
type CanTransferOwnershipResult interface {
	CanTransferOwnershipResultType() string
}

// Represents result of checking whether a username can be set for a chat
type CheckChatUsernameResult interface {
	CheckChatUsernameResultType() string
}

// Contains content of a push message notification
type PushMessageContent interface {
	PushMessageContentType() string
}

// Contains detailed information about a notification
type NotificationType interface {
	NotificationTypeType() string
}

// Describes the type of notifications in a notification group
type NotificationGroupType interface {
	NotificationGroupTypeType() string
}

// Represents the value of an option
type OptionValue interface {
	OptionValueType() string
}

// Represents a JSON value
type JsonValue interface {
	JsonValueType() string
}

// Represents a single rule for managing privacy settings
type UserPrivacySettingRule interface {
	UserPrivacySettingRuleType() string
}

// Describes available user privacy settings
type UserPrivacySetting interface {
	UserPrivacySettingType() string
}

// Describes the reason why a chat is reported
type ChatReportReason interface {
	ChatReportReasonType() string
}

// Represents the type of a file
type FileType interface {
	FileTypeType() string
}

// Represents the type of a network
type NetworkType interface {
	NetworkTypeType() string
}

// Contains statistics about network usage
type NetworkStatisticsEntry interface {
	NetworkStatisticsEntryType() string
}

// Describes the current state of the connection to Telegram servers
type ConnectionState interface {
	ConnectionStateType() string
}

// Represents the categories of chats for which a list of frequently used chats can be retrieved
type TopChatCategory interface {
	TopChatCategoryType() string
}

// Describes the type of a URL linking to an internal Telegram entity
type TMeUrlType interface {
	TMeUrlTypeType() string
}

// Describes the way the text should be parsed for TextEntities
type TextParseMode interface {
	TextParseModeType() string
}

// Describes the type of a proxy server
type ProxyType interface {
	ProxyTypeType() string
}

// Contains notifications about data changes
type Update interface {
	UpdateType() string
}

// Describes a stream to which TDLib internal log is written
type LogStream interface {
	LogStreamType() string
}

// An object of this type can be returned on every function call, in case of an error
type Error struct {
	meta
	// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
	Code int32 `json:"code"`
	// Error message; subject to future changes
	Message string `json:"message"`
}

func (entity *Error) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Error

	return json.Marshal((*stub)(entity))
}

func (*Error) GetClass() string {
	return ClassError
}

func (*Error) GetType() string {
	return TypeError
}

// An object of this type is returned on a successful function call for certain functions
type Ok struct {
	meta
}

func (entity *Ok) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Ok

	return json.Marshal((*stub)(entity))
}

func (*Ok) GetClass() string {
	return ClassOk
}

func (*Ok) GetType() string {
	return TypeOk
}

// Contains parameters for TDLib initialization
type TdlibParameters struct {
	meta
	// If set to true, the Telegram test environment will be used instead of the production environment
	UseTestDc bool `json:"use_test_dc"`
	// The path to the directory for the persistent database; if empty, the current working directory will be used
	DatabaseDirectory string `json:"database_directory"`
	// The path to the directory for storing files; if empty, database_directory will be used
	FilesDirectory string `json:"files_directory"`
	// If set to true, information about downloaded and uploaded files will be saved between application restarts
	UseFileDatabase bool `json:"use_file_database"`
	// If set to true, the library will maintain a cache of users, basic groups, supergroups, channels and secret chats. Implies use_file_database
	UseChatInfoDatabase bool `json:"use_chat_info_database"`
	// If set to true, the library will maintain a cache of chats and messages. Implies use_chat_info_database
	UseMessageDatabase bool `json:"use_message_database"`
	// If set to true, support for secret chats will be enabled
	UseSecretChats bool `json:"use_secret_chats"`
	// Application identifier for Telegram API access, which can be obtained at https://my.telegram.org
	ApiId int32 `json:"api_id"`
	// Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org
	ApiHash string `json:"api_hash"`
	// IETF language tag of the user's operating system language; must be non-empty
	SystemLanguageCode string `json:"system_language_code"`
	// Model of the device the application is being run on; must be non-empty
	DeviceModel string `json:"device_model"`
	// Version of the operating system the application is being run on; must be non-empty
	SystemVersion string `json:"system_version"`
	// Application version; must be non-empty
	ApplicationVersion string `json:"application_version"`
	// If set to true, old files will automatically be deleted
	EnableStorageOptimizer bool `json:"enable_storage_optimizer"`
	// If set to true, original file names will be ignored. Otherwise, downloaded files will be saved under names as close as possible to the original name
	IgnoreFileNames bool `json:"ignore_file_names"`
}

func (entity *TdlibParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TdlibParameters

	return json.Marshal((*stub)(entity))
}

func (*TdlibParameters) GetClass() string {
	return ClassTdlibParameters
}

func (*TdlibParameters) GetType() string {
	return TypeTdlibParameters
}

// An authentication code is delivered via a private Telegram message, which can be viewed in another client
type AuthenticationCodeTypeTelegramMessage struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeTelegramMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeTelegramMessage

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeTelegramMessage) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeTelegramMessage) GetType() string {
	return TypeAuthenticationCodeTypeTelegramMessage
}

func (*AuthenticationCodeTypeTelegramMessage) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeTelegramMessage
}

// An authentication code is delivered via an SMS message to the specified phone number
type AuthenticationCodeTypeSms struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeSms) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeSms

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeSms) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeSms) GetType() string {
	return TypeAuthenticationCodeTypeSms
}

func (*AuthenticationCodeTypeSms) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeSms
}

// An authentication code is delivered via a phone call to the specified phone number
type AuthenticationCodeTypeCall struct {
	meta
	// Length of the code
	Length int32 `json:"length"`
}

func (entity *AuthenticationCodeTypeCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeCall) GetType() string {
	return TypeAuthenticationCodeTypeCall
}

func (*AuthenticationCodeTypeCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeCall
}

// An authentication code is delivered by an immediately cancelled call to the specified phone number. The number from which the call was made is the code
type AuthenticationCodeTypeFlashCall struct {
	meta
	// Pattern of the phone number from which the call will be made
	Pattern string `json:"pattern"`
}

func (entity *AuthenticationCodeTypeFlashCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeTypeFlashCall

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeTypeFlashCall) GetClass() string {
	return ClassAuthenticationCodeType
}

func (*AuthenticationCodeTypeFlashCall) GetType() string {
	return TypeAuthenticationCodeTypeFlashCall
}

func (*AuthenticationCodeTypeFlashCall) AuthenticationCodeTypeType() string {
	return TypeAuthenticationCodeTypeFlashCall
}

// Information about the authentication code that was sent
type AuthenticationCodeInfo struct {
	meta
	// A phone number that is being authenticated
	PhoneNumber string `json:"phone_number"`
	// Describes the way the code was sent to the user
	Type AuthenticationCodeType `json:"type"`
	// Describes the way the next code will be sent to the user; may be null
	NextType AuthenticationCodeType `json:"next_type"`
	// Timeout before the code should be re-sent, in seconds
	Timeout int32 `json:"timeout"`
}

func (entity *AuthenticationCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthenticationCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*AuthenticationCodeInfo) GetClass() string {
	return ClassAuthenticationCodeInfo
}

func (*AuthenticationCodeInfo) GetType() string {
	return TypeAuthenticationCodeInfo
}

func (authenticationCodeInfo *AuthenticationCodeInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PhoneNumber string          `json:"phone_number"`
		Type        json.RawMessage `json:"type"`
		NextType    json.RawMessage `json:"next_type"`
		Timeout     int32           `json:"timeout"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	authenticationCodeInfo.PhoneNumber = tmp.PhoneNumber
	authenticationCodeInfo.Timeout = tmp.Timeout

	fieldType, _ := UnmarshalAuthenticationCodeType(tmp.Type)
	authenticationCodeInfo.Type = fieldType

	fieldNextType, _ := UnmarshalAuthenticationCodeType(tmp.NextType)
	authenticationCodeInfo.NextType = fieldNextType

	return nil
}

// Information about the email address authentication code that was sent
type EmailAddressAuthenticationCodeInfo struct {
	meta
	// Pattern of the email address to which an authentication code was sent
	EmailAddressPattern string `json:"email_address_pattern"`
	// Length of the code; 0 if unknown
	Length int32 `json:"length"`
}

func (entity *EmailAddressAuthenticationCodeInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EmailAddressAuthenticationCodeInfo

	return json.Marshal((*stub)(entity))
}

func (*EmailAddressAuthenticationCodeInfo) GetClass() string {
	return ClassEmailAddressAuthenticationCodeInfo
}

func (*EmailAddressAuthenticationCodeInfo) GetType() string {
	return TypeEmailAddressAuthenticationCodeInfo
}

// Represents a part of the text that needs to be formatted in some unusual way
type TextEntity struct {
	meta
	// Offset of the entity in UTF-16 code units
	Offset int32 `json:"offset"`
	// Length of the entity, in UTF-16 code units
	Length int32 `json:"length"`
	// Type of the entity
	Type TextEntityType `json:"type"`
}

func (entity *TextEntity) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntity

	return json.Marshal((*stub)(entity))
}

func (*TextEntity) GetClass() string {
	return ClassTextEntity
}

func (*TextEntity) GetType() string {
	return TypeTextEntity
}

func (textEntity *TextEntity) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Offset int32           `json:"offset"`
		Length int32           `json:"length"`
		Type   json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	textEntity.Offset = tmp.Offset
	textEntity.Length = tmp.Length

	fieldType, _ := UnmarshalTextEntityType(tmp.Type)
	textEntity.Type = fieldType

	return nil
}

// Contains a list of text entities
type TextEntities struct {
	meta
	// List of text entities
	Entities []*TextEntity `json:"entities"`
}

func (entity *TextEntities) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntities

	return json.Marshal((*stub)(entity))
}

func (*TextEntities) GetClass() string {
	return ClassTextEntities
}

func (*TextEntities) GetType() string {
	return TypeTextEntities
}

// A text with some entities
type FormattedText struct {
	meta
	// The text
	Text string `json:"text"`
	// Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. Bold, Italic, Underline and Strikethrough entities can contain and to be contained in all other entities. All other entities can't contain each other
	Entities []*TextEntity `json:"entities"`
}

func (entity *FormattedText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FormattedText

	return json.Marshal((*stub)(entity))
}

func (*FormattedText) GetClass() string {
	return ClassFormattedText
}

func (*FormattedText) GetType() string {
	return TypeFormattedText
}

// Contains Telegram terms of service
type TermsOfService struct {
	meta
	// Text of the terms of service
	Text *FormattedText `json:"text"`
	// The minimum age of a user to be able to accept the terms; 0 if any
	MinUserAge int32 `json:"min_user_age"`
	// True, if a blocking popup with terms of service must be shown to the user
	ShowPopup bool `json:"show_popup"`
}

func (entity *TermsOfService) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TermsOfService

	return json.Marshal((*stub)(entity))
}

func (*TermsOfService) GetClass() string {
	return ClassTermsOfService
}

func (*TermsOfService) GetType() string {
	return TypeTermsOfService
}

// TDLib needs TdlibParameters for initialization
type AuthorizationStateWaitTdlibParameters struct {
	meta
}

func (entity *AuthorizationStateWaitTdlibParameters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitTdlibParameters

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitTdlibParameters) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitTdlibParameters) GetType() string {
	return TypeAuthorizationStateWaitTdlibParameters
}

func (*AuthorizationStateWaitTdlibParameters) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitTdlibParameters
}

// TDLib needs an encryption key to decrypt the local database
type AuthorizationStateWaitEncryptionKey struct {
	meta
	// True, if the database is currently encrypted
	IsEncrypted bool `json:"is_encrypted"`
}

func (entity *AuthorizationStateWaitEncryptionKey) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitEncryptionKey

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitEncryptionKey) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitEncryptionKey) GetType() string {
	return TypeAuthorizationStateWaitEncryptionKey
}

func (*AuthorizationStateWaitEncryptionKey) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitEncryptionKey
}

// TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber` to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken` for other authentication options
type AuthorizationStateWaitPhoneNumber struct {
	meta
}

func (entity *AuthorizationStateWaitPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitPhoneNumber) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitPhoneNumber) GetType() string {
	return TypeAuthorizationStateWaitPhoneNumber
}

func (*AuthorizationStateWaitPhoneNumber) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitPhoneNumber
}

// TDLib needs the user's authentication code to authorize
type AuthorizationStateWaitCode struct {
	meta
	// Information about the authorization code that was sent
	CodeInfo *AuthenticationCodeInfo `json:"code_info"`
}

func (entity *AuthorizationStateWaitCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitCode

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitCode) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitCode) GetType() string {
	return TypeAuthorizationStateWaitCode
}

func (*AuthorizationStateWaitCode) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitCode
}

// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
type AuthorizationStateWaitOtherDeviceConfirmation struct {
	meta
	// A tg:// URL for the QR code. The link will be updated frequently
	Link string `json:"link"`
}

func (entity *AuthorizationStateWaitOtherDeviceConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitOtherDeviceConfirmation

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) GetType() string {
	return TypeAuthorizationStateWaitOtherDeviceConfirmation
}

func (*AuthorizationStateWaitOtherDeviceConfirmation) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitOtherDeviceConfirmation
}

// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration
type AuthorizationStateWaitRegistration struct {
	meta
	// Telegram terms of service
	TermsOfService *TermsOfService `json:"terms_of_service"`
}

func (entity *AuthorizationStateWaitRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitRegistration

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitRegistration) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitRegistration) GetType() string {
	return TypeAuthorizationStateWaitRegistration
}

func (*AuthorizationStateWaitRegistration) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitRegistration
}

// The user has been authorized, but needs to enter a password to start using the application
type AuthorizationStateWaitPassword struct {
	meta
	// Hint for the password; may be empty
	PasswordHint string `json:"password_hint"`
	// True, if a recovery email address has been set up
	HasRecoveryEmailAddress bool `json:"has_recovery_email_address"`
	// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
	RecoveryEmailAddressPattern string `json:"recovery_email_address_pattern"`
}

func (entity *AuthorizationStateWaitPassword) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateWaitPassword

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateWaitPassword) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateWaitPassword) GetType() string {
	return TypeAuthorizationStateWaitPassword
}

func (*AuthorizationStateWaitPassword) AuthorizationStateType() string {
	return TypeAuthorizationStateWaitPassword
}

// The user has been successfully authorized. TDLib is now ready to answer queries
type AuthorizationStateReady struct {
	meta
}

func (entity *AuthorizationStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateReady

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateReady) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateReady) GetType() string {
	return TypeAuthorizationStateReady
}

func (*AuthorizationStateReady) AuthorizationStateType() string {
	return TypeAuthorizationStateReady
}

// The user is currently logging out
type AuthorizationStateLoggingOut struct {
	meta
}

func (entity *AuthorizationStateLoggingOut) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateLoggingOut

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateLoggingOut) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateLoggingOut) GetType() string {
	return TypeAuthorizationStateLoggingOut
}

func (*AuthorizationStateLoggingOut) AuthorizationStateType() string {
	return TypeAuthorizationStateLoggingOut
}

// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
type AuthorizationStateClosing struct {
	meta
}

func (entity *AuthorizationStateClosing) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateClosing

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateClosing) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateClosing) GetType() string {
	return TypeAuthorizationStateClosing
}

func (*AuthorizationStateClosing) AuthorizationStateType() string {
	return TypeAuthorizationStateClosing
}

// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one should create a new instance of the TDLib client
type AuthorizationStateClosed struct {
	meta
}

func (entity *AuthorizationStateClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AuthorizationStateClosed

	return json.Marshal((*stub)(entity))
}

func (*AuthorizationStateClosed) GetClass() string {
	return ClassAuthorizationState
}

func (*AuthorizationStateClosed) GetType() string {
	return TypeAuthorizationStateClosed
}

func (*AuthorizationStateClosed) AuthorizationStateType() string {
	return TypeAuthorizationStateClosed
}

// Represents the current state of 2-step verification
type PasswordState struct {
	meta
	// True, if a 2-step verification password is set
	HasPassword bool `json:"has_password"`
	// Hint for the password; may be empty
	PasswordHint string `json:"password_hint"`
	// True, if a recovery email is set
	HasRecoveryEmailAddress bool `json:"has_recovery_email_address"`
	// True, if some Telegram Passport elements were saved
	HasPassportData bool `json:"has_passport_data"`
	// Information about the recovery email address to which the confirmation email was sent; may be null
	RecoveryEmailAddressCodeInfo *EmailAddressAuthenticationCodeInfo `json:"recovery_email_address_code_info"`
}

func (entity *PasswordState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PasswordState

	return json.Marshal((*stub)(entity))
}

func (*PasswordState) GetClass() string {
	return ClassPasswordState
}

func (*PasswordState) GetType() string {
	return TypePasswordState
}

// Contains information about the current recovery email address
type RecoveryEmailAddress struct {
	meta
	// Recovery email address
	RecoveryEmailAddress string `json:"recovery_email_address"`
}

func (entity *RecoveryEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RecoveryEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*RecoveryEmailAddress) GetClass() string {
	return ClassRecoveryEmailAddress
}

func (*RecoveryEmailAddress) GetType() string {
	return TypeRecoveryEmailAddress
}

// Returns information about the availability of a temporary password, which can be used for payments
type TemporaryPasswordState struct {
	meta
	// True, if a temporary password is available
	HasPassword bool `json:"has_password"`
	// Time left before the temporary password expires, in seconds
	ValidFor int32 `json:"valid_for"`
}

func (entity *TemporaryPasswordState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TemporaryPasswordState

	return json.Marshal((*stub)(entity))
}

func (*TemporaryPasswordState) GetClass() string {
	return ClassTemporaryPasswordState
}

func (*TemporaryPasswordState) GetType() string {
	return TypeTemporaryPasswordState
}

// Represents a local file
type LocalFile struct {
	meta
	// Local path to the locally available file part; may be empty
	Path string `json:"path"`
	// True, if it is possible to try to download or generate the file
	CanBeDownloaded bool `json:"can_be_downloaded"`
	// True, if the file can be deleted
	CanBeDeleted bool `json:"can_be_deleted"`
	// True, if the file is currently being downloaded (or a local copy is being generated by some other means)
	IsDownloadingActive bool `json:"is_downloading_active"`
	// True, if the local copy is fully available
	IsDownloadingCompleted bool `json:"is_downloading_completed"`
	// Download will be started from this offset. downloaded_prefix_size is calculated from this offset
	DownloadOffset int32 `json:"download_offset"`
	// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix
	DownloadedPrefixSize int32 `json:"downloaded_prefix_size"`
	// Total downloaded file bytes. Should be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
	DownloadedSize int32 `json:"downloaded_size"`
}

func (entity *LocalFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocalFile

	return json.Marshal((*stub)(entity))
}

func (*LocalFile) GetClass() string {
	return ClassLocalFile
}

func (*LocalFile) GetType() string {
	return TypeLocalFile
}

// Represents a remote file
type RemoteFile struct {
	meta
	// Remote file identifier; may be empty. Can be used across application restarts or even from other devices for the current user. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the client with the HTTP URL in the original_path and "#url#" as the conversion string. Clients should generate the file by downloading it to the specified location
	Id string `json:"id"`
	// Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
	UniqueId string `json:"unique_id"`
	// True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
	IsUploadingActive bool `json:"is_uploading_active"`
	// True, if a remote copy is fully available
	IsUploadingCompleted bool `json:"is_uploading_completed"`
	// Size of the remote available part of the file; 0 if unknown
	UploadedSize int32 `json:"uploaded_size"`
}

func (entity *RemoteFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RemoteFile

	return json.Marshal((*stub)(entity))
}

func (*RemoteFile) GetClass() string {
	return ClassRemoteFile
}

func (*RemoteFile) GetType() string {
	return TypeRemoteFile
}

// Represents a file
type File struct {
	meta
	// Unique file identifier
	Id int32 `json:"id"`
	// File size; 0 if unknown
	Size int32 `json:"size"`
	// Expected file size in case the exact file size is unknown, but an approximate size is known. Can be used to show download/upload progress
	ExpectedSize int32 `json:"expected_size"`
	// Information about the local copy of the file
	Local *LocalFile `json:"local"`
	// Information about the remote copy of the file
	Remote *RemoteFile `json:"remote"`
}

func (entity *File) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub File

	return json.Marshal((*stub)(entity))
}

func (*File) GetClass() string {
	return ClassFile
}

func (*File) GetType() string {
	return TypeFile
}

// A file defined by its unique ID
type InputFileId struct {
	meta
	// Unique file identifier
	Id int32 `json:"id"`
}

func (entity *InputFileId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileId

	return json.Marshal((*stub)(entity))
}

func (*InputFileId) GetClass() string {
	return ClassInputFile
}

func (*InputFileId) GetType() string {
	return TypeInputFileId
}

func (*InputFileId) InputFileType() string {
	return TypeInputFileId
}

// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the client
type InputFileRemote struct {
	meta
	// Remote file identifier
	Id string `json:"id"`
}

func (entity *InputFileRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileRemote

	return json.Marshal((*stub)(entity))
}

func (*InputFileRemote) GetClass() string {
	return ClassInputFile
}

func (*InputFileRemote) GetType() string {
	return TypeInputFileRemote
}

func (*InputFileRemote) InputFileType() string {
	return TypeInputFileRemote
}

// A file defined by a local path
type InputFileLocal struct {
	meta
	// Local path to the file
	Path string `json:"path"`
}

func (entity *InputFileLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileLocal

	return json.Marshal((*stub)(entity))
}

func (*InputFileLocal) GetClass() string {
	return ClassInputFile
}

func (*InputFileLocal) GetType() string {
	return TypeInputFileLocal
}

func (*InputFileLocal) InputFileType() string {
	return TypeInputFileLocal
}

// A file generated by the client
type InputFileGenerated struct {
	meta
	// Local path to a file from which the file is generated; may be empty if there is no such file
	OriginalPath string `json:"original_path"`
	// String specifying the conversion applied to the original file; should be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
	Conversion string `json:"conversion"`
	// Expected size of the generated file; 0 if unknown
	ExpectedSize int32 `json:"expected_size"`
}

func (entity *InputFileGenerated) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputFileGenerated

	return json.Marshal((*stub)(entity))
}

func (*InputFileGenerated) GetClass() string {
	return ClassInputFile
}

func (*InputFileGenerated) GetType() string {
	return TypeInputFileGenerated
}

func (*InputFileGenerated) InputFileType() string {
	return TypeInputFileGenerated
}

// Photo description
type PhotoSize struct {
	meta
	// Thumbnail type (see https://core.telegram.org/constructor/photoSize)
	Type string `json:"type"`
	// Information about the photo file
	Photo *File `json:"photo"`
	// Photo width
	Width int32 `json:"width"`
	// Photo height
	Height int32 `json:"height"`
}

func (entity *PhotoSize) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhotoSize

	return json.Marshal((*stub)(entity))
}

func (*PhotoSize) GetClass() string {
	return ClassPhotoSize
}

func (*PhotoSize) GetType() string {
	return TypePhotoSize
}

// Thumbnail image of a very poor quality and low resolution
type Minithumbnail struct {
	meta
	// Thumbnail width, usually doesn't exceed 40
	Width int32 `json:"width"`
	// Thumbnail height, usually doesn't exceed 40
	Height int32 `json:"height"`
	// The thumbnail in JPEG format
	Data []byte `json:"data"`
}

func (entity *Minithumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Minithumbnail

	return json.Marshal((*stub)(entity))
}

func (*Minithumbnail) GetClass() string {
	return ClassMinithumbnail
}

func (*Minithumbnail) GetType() string {
	return TypeMinithumbnail
}

// A mask should be placed relatively to the forehead
type MaskPointForehead struct {
	meta
}

func (entity *MaskPointForehead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointForehead

	return json.Marshal((*stub)(entity))
}

func (*MaskPointForehead) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointForehead) GetType() string {
	return TypeMaskPointForehead
}

func (*MaskPointForehead) MaskPointType() string {
	return TypeMaskPointForehead
}

// A mask should be placed relatively to the eyes
type MaskPointEyes struct {
	meta
}

func (entity *MaskPointEyes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointEyes

	return json.Marshal((*stub)(entity))
}

func (*MaskPointEyes) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointEyes) GetType() string {
	return TypeMaskPointEyes
}

func (*MaskPointEyes) MaskPointType() string {
	return TypeMaskPointEyes
}

// A mask should be placed relatively to the mouth
type MaskPointMouth struct {
	meta
}

func (entity *MaskPointMouth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointMouth

	return json.Marshal((*stub)(entity))
}

func (*MaskPointMouth) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointMouth) GetType() string {
	return TypeMaskPointMouth
}

func (*MaskPointMouth) MaskPointType() string {
	return TypeMaskPointMouth
}

// A mask should be placed relatively to the chin
type MaskPointChin struct {
	meta
}

func (entity *MaskPointChin) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPointChin

	return json.Marshal((*stub)(entity))
}

func (*MaskPointChin) GetClass() string {
	return ClassMaskPoint
}

func (*MaskPointChin) GetType() string {
	return TypeMaskPointChin
}

func (*MaskPointChin) MaskPointType() string {
	return TypeMaskPointChin
}

// Position on a photo where a mask should be placed
type MaskPosition struct {
	meta
	// Part of the face, relative to which the mask should be placed
	Point MaskPoint `json:"point"`
	// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
	XShift float64 `json:"x_shift"`
	// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
	YShift float64 `json:"y_shift"`
	// Mask scaling coefficient. (For example, 2.0 means a doubled size)
	Scale float64 `json:"scale"`
}

func (entity *MaskPosition) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MaskPosition

	return json.Marshal((*stub)(entity))
}

func (*MaskPosition) GetClass() string {
	return ClassMaskPosition
}

func (*MaskPosition) GetType() string {
	return TypeMaskPosition
}

func (maskPosition *MaskPosition) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Point  json.RawMessage `json:"point"`
		XShift float64         `json:"x_shift"`
		YShift float64         `json:"y_shift"`
		Scale  float64         `json:"scale"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	maskPosition.XShift = tmp.XShift
	maskPosition.YShift = tmp.YShift
	maskPosition.Scale = tmp.Scale

	fieldPoint, _ := UnmarshalMaskPoint(tmp.Point)
	maskPosition.Point = fieldPoint

	return nil
}

// Describes one answer option of a poll
type PollOption struct {
	meta
	// Option text, 1-100 characters
	Text string `json:"text"`
	// Number of voters for this option, available only for closed or voted polls
	VoterCount int32 `json:"voter_count"`
	// The percentage of votes for this option, 0-100
	VotePercentage int32 `json:"vote_percentage"`
	// True, if the option was chosen by the user
	IsChosen bool `json:"is_chosen"`
	// True, if the option is being chosen by a pending setPollAnswer request
	IsBeingChosen bool `json:"is_being_chosen"`
}

func (entity *PollOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollOption

	return json.Marshal((*stub)(entity))
}

func (*PollOption) GetClass() string {
	return ClassPollOption
}

func (*PollOption) GetType() string {
	return TypePollOption
}

// A regular poll
type PollTypeRegular struct {
	meta
	// True, if multiple answer options can be chosen simultaneously
	AllowMultipleAnswers bool `json:"allow_multiple_answers"`
}

func (entity *PollTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*PollTypeRegular) GetClass() string {
	return ClassPollType
}

func (*PollTypeRegular) GetType() string {
	return TypePollTypeRegular
}

func (*PollTypeRegular) PollTypeType() string {
	return TypePollTypeRegular
}

// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
type PollTypeQuiz struct {
	meta
	// 0-based identifier of the correct answer option; -1 for a yet unanswered poll
	CorrectOptionId int32 `json:"correct_option_id"`
}

func (entity *PollTypeQuiz) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PollTypeQuiz

	return json.Marshal((*stub)(entity))
}

func (*PollTypeQuiz) GetClass() string {
	return ClassPollType
}

func (*PollTypeQuiz) GetType() string {
	return TypePollTypeQuiz
}

func (*PollTypeQuiz) PollTypeType() string {
	return TypePollTypeQuiz
}

// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
type Animation struct {
	meta
	// Duration of the animation, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Width of the animation
	Width int32 `json:"width"`
	// Height of the animation
	Height int32 `json:"height"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file, usually "image/gif" or "video/mp4"
	MimeType string `json:"mime_type"`
	// Animation minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Animation thumbnail; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
	// File containing the animation
	Animation *File `json:"animation"`
}

func (entity *Animation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Animation

	return json.Marshal((*stub)(entity))
}

func (*Animation) GetClass() string {
	return ClassAnimation
}

func (*Animation) GetType() string {
	return TypeAnimation
}

// Describes an audio file. Audio is usually in MP3 or M4A format
type Audio struct {
	meta
	// Duration of the audio, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Title of the audio; as defined by the sender
	Title string `json:"title"`
	// Performer of the audio; as defined by the sender
	Performer string `json:"performer"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// The MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// The minithumbnail of the album cover; may be null
	AlbumCoverMinithumbnail *Minithumbnail `json:"album_cover_minithumbnail"`
	// The thumbnail of the album cover; as defined by the sender. The full size thumbnail should be extracted from the downloaded file; may be null
	AlbumCoverThumbnail *PhotoSize `json:"album_cover_thumbnail"`
	// File containing the audio
	Audio *File `json:"audio"`
}

func (entity *Audio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Audio

	return json.Marshal((*stub)(entity))
}

func (*Audio) GetClass() string {
	return ClassAudio
}

func (*Audio) GetType() string {
	return TypeAudio
}

// Describes a document of any type
type Document struct {
	meta
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// Document minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
	// File containing the document
	Document *File `json:"document"`
}

func (entity *Document) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Document

	return json.Marshal((*stub)(entity))
}

func (*Document) GetClass() string {
	return ClassDocument
}

func (*Document) GetType() string {
	return TypeDocument
}

// Describes a photo
type Photo struct {
	meta
	// True, if stickers were added to the photo
	HasStickers bool `json:"has_stickers"`
	// Photo minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Available variants of the photo, in different sizes
	Sizes []*PhotoSize `json:"sizes"`
}

func (entity *Photo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Photo

	return json.Marshal((*stub)(entity))
}

func (*Photo) GetClass() string {
	return ClassPhoto
}

func (*Photo) GetType() string {
	return TypePhoto
}

// Describes a sticker
type Sticker struct {
	meta
	// The identifier of the sticker set to which the sticker belongs; 0 if none
	SetId JsonInt64 `json:"set_id"`
	// Sticker width; as defined by the sender
	Width int32 `json:"width"`
	// Sticker height; as defined by the sender
	Height int32 `json:"height"`
	// Emoji corresponding to the sticker
	Emoji string `json:"emoji"`
	// True, if the sticker is an animated sticker in TGS format
	IsAnimated bool `json:"is_animated"`
	// True, if the sticker is a mask
	IsMask bool `json:"is_mask"`
	// Position where the mask should be placed; may be null
	MaskPosition *MaskPosition `json:"mask_position"`
	// Sticker thumbnail in WEBP or JPEG format; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
	// File containing the sticker
	Sticker *File `json:"sticker"`
}

func (entity *Sticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Sticker

	return json.Marshal((*stub)(entity))
}

func (*Sticker) GetClass() string {
	return ClassSticker
}

func (*Sticker) GetType() string {
	return TypeSticker
}

// Describes a video file
type Video struct {
	meta
	// Duration of the video, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Video width; as defined by the sender
	Width int32 `json:"width"`
	// Video height; as defined by the sender
	Height int32 `json:"height"`
	// Original name of the file; as defined by the sender
	FileName string `json:"file_name"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// True, if stickers were added to the video
	HasStickers bool `json:"has_stickers"`
	// True, if the video should be tried to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail; as defined by the sender; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *Video) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Video

	return json.Marshal((*stub)(entity))
}

func (*Video) GetClass() string {
	return ClassVideo
}

func (*Video) GetType() string {
	return TypeVideo
}

// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
type VideoNote struct {
	meta
	// Duration of the video, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// Video width and height; as defined by the sender
	Length int32 `json:"length"`
	// Video minithumbnail; may be null
	Minithumbnail *Minithumbnail `json:"minithumbnail"`
	// Video thumbnail; as defined by the sender; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
	// File containing the video
	Video *File `json:"video"`
}

func (entity *VideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VideoNote

	return json.Marshal((*stub)(entity))
}

func (*VideoNote) GetClass() string {
	return ClassVideoNote
}

func (*VideoNote) GetType() string {
	return TypeVideoNote
}

// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
type VoiceNote struct {
	meta
	// Duration of the voice note, in seconds; as defined by the sender
	Duration int32 `json:"duration"`
	// A waveform representation of the voice note in 5-bit format
	Waveform []byte `json:"waveform"`
	// MIME type of the file; as defined by the sender
	MimeType string `json:"mime_type"`
	// File containing the voice note
	Voice *File `json:"voice"`
}

func (entity *VoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub VoiceNote

	return json.Marshal((*stub)(entity))
}

func (*VoiceNote) GetClass() string {
	return ClassVoiceNote
}

func (*VoiceNote) GetType() string {
	return TypeVoiceNote
}

// Describes a user contact
type Contact struct {
	meta
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// First name of the user; 1-255 characters in length
	FirstName string `json:"first_name"`
	// Last name of the user
	LastName string `json:"last_name"`
	// Additional data about the user in a form of vCard; 0-2048 bytes in length
	Vcard string `json:"vcard"`
	// Identifier of the user, if known; otherwise 0
	UserId int32 `json:"user_id"`
}

func (entity *Contact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Contact

	return json.Marshal((*stub)(entity))
}

func (*Contact) GetClass() string {
	return ClassContact
}

func (*Contact) GetType() string {
	return TypeContact
}

// Describes a location on planet Earth
type Location struct {
	meta
	// Latitude of the location in degrees; as defined by the sender
	Latitude float64 `json:"latitude"`
	// Longitude of the location, in degrees; as defined by the sender
	Longitude float64 `json:"longitude"`
}

func (entity *Location) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Location

	return json.Marshal((*stub)(entity))
}

func (*Location) GetClass() string {
	return ClassLocation
}

func (*Location) GetType() string {
	return TypeLocation
}

// Describes a venue
type Venue struct {
	meta
	// Venue location; as defined by the sender
	Location *Location `json:"location"`
	// Venue name; as defined by the sender
	Title string `json:"title"`
	// Venue address; as defined by the sender
	Address string `json:"address"`
	// Provider of the venue database; as defined by the sender. Currently only "foursquare" needs to be supported
	Provider string `json:"provider"`
	// Identifier of the venue in the provider database; as defined by the sender
	Id string `json:"id"`
	// Type of the venue in the provider database; as defined by the sender
	Type string `json:"type"`
}

func (entity *Venue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Venue

	return json.Marshal((*stub)(entity))
}

func (*Venue) GetClass() string {
	return ClassVenue
}

func (*Venue) GetType() string {
	return TypeVenue
}

// Describes a game
type Game struct {
	meta
	// Game ID
	Id JsonInt64 `json:"id"`
	// Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}
	ShortName string `json:"short_name"`
	// Game title
	Title string `json:"title"`
	// Game text, usually containing scoreboards for a game
	Text *FormattedText `json:"text"`
	// Game description
	Description string `json:"description"`
	// Game photo
	Photo *Photo `json:"photo"`
	// Game animation; may be null
	Animation *Animation `json:"animation"`
}

func (entity *Game) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Game

	return json.Marshal((*stub)(entity))
}

func (*Game) GetClass() string {
	return ClassGame
}

func (*Game) GetType() string {
	return TypeGame
}

// Describes a poll
type Poll struct {
	meta
	// Unique poll identifier
	Id JsonInt64 `json:"id"`
	// Poll question, 1-255 characters
	Question string `json:"question"`
	// List of poll answer options
	Options []*PollOption `json:"options"`
	// Total number of voters, participating in the poll
	TotalVoterCount int32 `json:"total_voter_count"`
	// User identifiers of recent voters, if the poll is non-anonymous
	RecentVoterUserIds []int32 `json:"recent_voter_user_ids"`
	// True, if the poll is anonymous
	IsAnonymous bool `json:"is_anonymous"`
	// Type of the poll
	Type PollType `json:"type"`
	// True, if the poll is closed
	IsClosed bool `json:"is_closed"`
}

func (entity *Poll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Poll

	return json.Marshal((*stub)(entity))
}

func (*Poll) GetClass() string {
	return ClassPoll
}

func (*Poll) GetType() string {
	return TypePoll
}

func (poll *Poll) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                 JsonInt64       `json:"id"`
		Question           string          `json:"question"`
		Options            []*PollOption   `json:"options"`
		TotalVoterCount    int32           `json:"total_voter_count"`
		RecentVoterUserIds []int32         `json:"recent_voter_user_ids"`
		IsAnonymous        bool            `json:"is_anonymous"`
		Type               json.RawMessage `json:"type"`
		IsClosed           bool            `json:"is_closed"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	poll.Id = tmp.Id
	poll.Question = tmp.Question
	poll.Options = tmp.Options
	poll.TotalVoterCount = tmp.TotalVoterCount
	poll.RecentVoterUserIds = tmp.RecentVoterUserIds
	poll.IsAnonymous = tmp.IsAnonymous
	poll.IsClosed = tmp.IsClosed

	fieldType, _ := UnmarshalPollType(tmp.Type)
	poll.Type = fieldType

	return nil
}

// Describes a user profile photo
type ProfilePhoto struct {
	meta
	// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of userProfilePhotos
	Id JsonInt64 `json:"id"`
	// A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
	Small *File `json:"small"`
	// A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
	Big *File `json:"big"`
}

func (entity *ProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*ProfilePhoto) GetClass() string {
	return ClassProfilePhoto
}

func (*ProfilePhoto) GetType() string {
	return TypeProfilePhoto
}

// Describes the photo of a chat
type ChatPhoto struct {
	meta
	// A small (160x160) chat photo. The file can be downloaded only before the photo is changed
	Small *File `json:"small"`
	// A big (640x640) chat photo. The file can be downloaded only before the photo is changed
	Big *File `json:"big"`
}

func (entity *ChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*ChatPhoto) GetClass() string {
	return ClassChatPhoto
}

func (*ChatPhoto) GetType() string {
	return TypeChatPhoto
}

// A regular user
type UserTypeRegular struct {
	meta
}

func (entity *UserTypeRegular) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeRegular

	return json.Marshal((*stub)(entity))
}

func (*UserTypeRegular) GetClass() string {
	return ClassUserType
}

func (*UserTypeRegular) GetType() string {
	return TypeUserTypeRegular
}

func (*UserTypeRegular) UserTypeType() string {
	return TypeUserTypeRegular
}

// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
type UserTypeDeleted struct {
	meta
}

func (entity *UserTypeDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeDeleted

	return json.Marshal((*stub)(entity))
}

func (*UserTypeDeleted) GetClass() string {
	return ClassUserType
}

func (*UserTypeDeleted) GetType() string {
	return TypeUserTypeDeleted
}

func (*UserTypeDeleted) UserTypeType() string {
	return TypeUserTypeDeleted
}

// A bot (see https://core.telegram.org/bots)
type UserTypeBot struct {
	meta
	// True, if the bot can be invited to basic group and supergroup chats
	CanJoinGroups bool `json:"can_join_groups"`
	// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
	CanReadAllGroupMessages bool `json:"can_read_all_group_messages"`
	// True, if the bot supports inline queries
	IsInline bool `json:"is_inline"`
	// Placeholder for inline queries (displayed on the client input field)
	InlineQueryPlaceholder string `json:"inline_query_placeholder"`
	// True, if the location of the user should be sent with every inline query to this bot
	NeedLocation bool `json:"need_location"`
}

func (entity *UserTypeBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeBot

	return json.Marshal((*stub)(entity))
}

func (*UserTypeBot) GetClass() string {
	return ClassUserType
}

func (*UserTypeBot) GetType() string {
	return TypeUserTypeBot
}

func (*UserTypeBot) UserTypeType() string {
	return TypeUserTypeBot
}

// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
type UserTypeUnknown struct {
	meta
}

func (entity *UserTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*UserTypeUnknown) GetClass() string {
	return ClassUserType
}

func (*UserTypeUnknown) GetType() string {
	return TypeUserTypeUnknown
}

func (*UserTypeUnknown) UserTypeType() string {
	return TypeUserTypeUnknown
}

// Represents commands supported by a bot
type BotCommand struct {
	meta
	// Text of the bot command
	Command string `json:"command"`
	// Description of the bot command
	Description string `json:"description"`
}

func (entity *BotCommand) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotCommand

	return json.Marshal((*stub)(entity))
}

func (*BotCommand) GetClass() string {
	return ClassBotCommand
}

func (*BotCommand) GetType() string {
	return TypeBotCommand
}

// Provides information about a bot and its supported commands
type BotInfo struct {
	meta
	// Long description shown on the user info page
	Description string `json:"description"`
	// A list of commands supported by the bot
	Commands []*BotCommand `json:"commands"`
}

func (entity *BotInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BotInfo

	return json.Marshal((*stub)(entity))
}

func (*BotInfo) GetClass() string {
	return ClassBotInfo
}

func (*BotInfo) GetType() string {
	return TypeBotInfo
}

// Represents a location to which a chat is connected
type ChatLocation struct {
	meta
	// The location
	Location *Location `json:"location"`
	// Location address; 1-64 characters, as defined by the chat owner
	Address string `json:"address"`
}

func (entity *ChatLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatLocation) GetClass() string {
	return ClassChatLocation
}

func (*ChatLocation) GetType() string {
	return TypeChatLocation
}

// Represents a user
type User struct {
	meta
	// User identifier
	Id int32 `json:"id"`
	// First name of the user
	FirstName string `json:"first_name"`
	// Last name of the user
	LastName string `json:"last_name"`
	// Username of the user
	Username string `json:"username"`
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Current online status of the user
	Status UserStatus `json:"status"`
	// Profile photo of the user; may be null
	ProfilePhoto *ProfilePhoto `json:"profile_photo"`
	// The user is a contact of the current user
	IsContact bool `json:"is_contact"`
	// The user is a contact of the current user and the current user is a contact of the user
	IsMutualContact bool `json:"is_mutual_contact"`
	// True, if the user is verified
	IsVerified bool `json:"is_verified"`
	// True, if the user is Telegram support account
	IsSupport bool `json:"is_support"`
	// If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// True, if many users reported this user as a scam
	IsScam bool `json:"is_scam"`
	// If false, the user is inaccessible, and the only information known about the user is inside this class. It can't be passed to any method except GetUser
	HaveAccess bool `json:"have_access"`
	// Type of the user
	Type UserType `json:"type"`
	// IETF language tag of the user's language; only available to bots
	LanguageCode string `json:"language_code"`
}

func (entity *User) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub User

	return json.Marshal((*stub)(entity))
}

func (*User) GetClass() string {
	return ClassUser
}

func (*User) GetType() string {
	return TypeUser
}

func (user *User) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                int32           `json:"id"`
		FirstName         string          `json:"first_name"`
		LastName          string          `json:"last_name"`
		Username          string          `json:"username"`
		PhoneNumber       string          `json:"phone_number"`
		Status            json.RawMessage `json:"status"`
		ProfilePhoto      *ProfilePhoto   `json:"profile_photo"`
		IsContact         bool            `json:"is_contact"`
		IsMutualContact   bool            `json:"is_mutual_contact"`
		IsVerified        bool            `json:"is_verified"`
		IsSupport         bool            `json:"is_support"`
		RestrictionReason string          `json:"restriction_reason"`
		IsScam            bool            `json:"is_scam"`
		HaveAccess        bool            `json:"have_access"`
		Type              json.RawMessage `json:"type"`
		LanguageCode      string          `json:"language_code"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	user.Id = tmp.Id
	user.FirstName = tmp.FirstName
	user.LastName = tmp.LastName
	user.Username = tmp.Username
	user.PhoneNumber = tmp.PhoneNumber
	user.ProfilePhoto = tmp.ProfilePhoto
	user.IsContact = tmp.IsContact
	user.IsMutualContact = tmp.IsMutualContact
	user.IsVerified = tmp.IsVerified
	user.IsSupport = tmp.IsSupport
	user.RestrictionReason = tmp.RestrictionReason
	user.IsScam = tmp.IsScam
	user.HaveAccess = tmp.HaveAccess
	user.LanguageCode = tmp.LanguageCode

	fieldStatus, _ := UnmarshalUserStatus(tmp.Status)
	user.Status = fieldStatus

	fieldType, _ := UnmarshalUserType(tmp.Type)
	user.Type = fieldType

	return nil
}

// Contains full information about a user (except the full list of profile photos)
type UserFullInfo struct {
	meta
	// True, if the user is blacklisted by the current user
	IsBlocked bool `json:"is_blocked"`
	// True, if the user can be called
	CanBeCalled bool `json:"can_be_called"`
	// True, if the user can't be called due to their privacy settings
	HasPrivateCalls bool `json:"has_private_calls"`
	// True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
	NeedPhoneNumberPrivacyException bool `json:"need_phone_number_privacy_exception"`
	// A short user bio
	Bio string `json:"bio"`
	// For bots, the text that is included with the link when users share the bot
	ShareText string `json:"share_text"`
	// Number of group chats where both the other user and the current user are a member; 0 for the current user
	GroupInCommonCount int32 `json:"group_in_common_count"`
	// If the user is a bot, information about the bot; may be null
	BotInfo *BotInfo `json:"bot_info"`
}

func (entity *UserFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UserFullInfo) GetClass() string {
	return ClassUserFullInfo
}

func (*UserFullInfo) GetType() string {
	return TypeUserFullInfo
}

// Contains full information about a user profile photo
type UserProfilePhoto struct {
	meta
	// Unique user profile photo identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the photo has been added
	AddedDate int32 `json:"added_date"`
	// Available variants of the user photo, in different sizes
	Sizes []*PhotoSize `json:"sizes"`
}

func (entity *UserProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*UserProfilePhoto) GetClass() string {
	return ClassUserProfilePhoto
}

func (*UserProfilePhoto) GetType() string {
	return TypeUserProfilePhoto
}

// Contains part of the list of user photos
type UserProfilePhotos struct {
	meta
	// Total number of user profile photos
	TotalCount int32 `json:"total_count"`
	// A list of photos
	Photos []*UserProfilePhoto `json:"photos"`
}

func (entity *UserProfilePhotos) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserProfilePhotos

	return json.Marshal((*stub)(entity))
}

func (*UserProfilePhotos) GetClass() string {
	return ClassUserProfilePhotos
}

func (*UserProfilePhotos) GetType() string {
	return TypeUserProfilePhotos
}

// Represents a list of users
type Users struct {
	meta
	// Approximate total count of users found
	TotalCount int32 `json:"total_count"`
	// A list of user identifiers
	UserIds []int32 `json:"user_ids"`
}

func (entity *Users) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Users

	return json.Marshal((*stub)(entity))
}

func (*Users) GetClass() string {
	return ClassUsers
}

func (*Users) GetType() string {
	return TypeUsers
}

// Contains information about a chat administrator
type ChatAdministrator struct {
	meta
	// User identifier of the administrator
	UserId int32 `json:"user_id"`
	// Custom title of the administrator
	CustomTitle string `json:"custom_title"`
	// True, if the user is the owner of the chat
	IsOwner bool `json:"is_owner"`
}

func (entity *ChatAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministrator) GetClass() string {
	return ClassChatAdministrator
}

func (*ChatAdministrator) GetType() string {
	return TypeChatAdministrator
}

// Represents a list of chat administrators
type ChatAdministrators struct {
	meta
	// A list of chat administrators
	Administrators []*ChatAdministrator `json:"administrators"`
}

func (entity *ChatAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatAdministrators

	return json.Marshal((*stub)(entity))
}

func (*ChatAdministrators) GetClass() string {
	return ClassChatAdministrators
}

func (*ChatAdministrators) GetType() string {
	return TypeChatAdministrators
}

// Describes actions that a user is allowed to take in a chat
type ChatPermissions struct {
	meta
	// True, if the user can send text messages, contacts, locations, and venues
	CanSendMessages bool `json:"can_send_messages"`
	// True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions
	CanSendMediaMessages bool `json:"can_send_media_messages"`
	// True, if the user can send polls. Implies can_send_messages permissions
	CanSendPolls bool `json:"can_send_polls"`
	// True, if the user can send animations, games, and stickers and use inline bots. Implies can_send_messages permissions
	CanSendOtherMessages bool `json:"can_send_other_messages"`
	// True, if the user may add a web page preview to their messages. Implies can_send_messages permissions
	CanAddWebPagePreviews bool `json:"can_add_web_page_previews"`
	// True, if the user can change the chat title, photo, and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// True, if the user can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// True, if the user can pin messages
	CanPinMessages bool `json:"can_pin_messages"`
}

func (entity *ChatPermissions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatPermissions

	return json.Marshal((*stub)(entity))
}

func (*ChatPermissions) GetClass() string {
	return ClassChatPermissions
}

func (*ChatPermissions) GetType() string {
	return TypeChatPermissions
}

// The user is the owner of a chat and has all the administrator privileges
type ChatMemberStatusCreator struct {
	meta
	// A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
	CustomTitle string `json:"custom_title"`
	// True, if the user is a member of the chat
	IsMember bool `json:"is_member"`
}

func (entity *ChatMemberStatusCreator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusCreator

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusCreator) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusCreator) GetType() string {
	return TypeChatMemberStatusCreator
}

func (*ChatMemberStatusCreator) ChatMemberStatusType() string {
	return TypeChatMemberStatusCreator
}

// The user is a member of a chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, and ban unprivileged members. In supergroups and channels, there are more detailed options for administrator privileges
type ChatMemberStatusAdministrator struct {
	meta
	// A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
	CustomTitle string `json:"custom_title"`
	// True, if the current user can edit the administrator privileges for the called user
	CanBeEdited bool `json:"can_be_edited"`
	// True, if the administrator can change the chat title, photo, and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// True, if the administrator can create channel posts; applicable to channels only
	CanPostMessages bool `json:"can_post_messages"`
	// True, if the administrator can edit messages of other users and pin messages; applicable to channels only
	CanEditMessages bool `json:"can_edit_messages"`
	// True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`
	// True, if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// True, if the administrator can restrict, ban, or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members"`
	// True, if the administrator can pin messages; applicable to groups only
	CanPinMessages bool `json:"can_pin_messages"`
	// True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
	CanPromoteMembers bool `json:"can_promote_members"`
}

func (entity *ChatMemberStatusAdministrator) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusAdministrator

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusAdministrator) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusAdministrator) GetType() string {
	return TypeChatMemberStatusAdministrator
}

func (*ChatMemberStatusAdministrator) ChatMemberStatusType() string {
	return TypeChatMemberStatusAdministrator
}

// The user is a member of a chat, without any additional privileges or restrictions
type ChatMemberStatusMember struct {
	meta
}

func (entity *ChatMemberStatusMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusMember

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusMember) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusMember) GetType() string {
	return TypeChatMemberStatusMember
}

func (*ChatMemberStatusMember) ChatMemberStatusType() string {
	return TypeChatMemberStatusMember
}

// The user is under certain restrictions in the chat. Not supported in basic groups and channels
type ChatMemberStatusRestricted struct {
	meta
	// True, if the user is a member of the chat
	IsMember bool `json:"is_member"`
	// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
	RestrictedUntilDate int32 `json:"restricted_until_date"`
	// User permissions in the chat
	Permissions *ChatPermissions `json:"permissions"`
}

func (entity *ChatMemberStatusRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusRestricted) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusRestricted) GetType() string {
	return TypeChatMemberStatusRestricted
}

func (*ChatMemberStatusRestricted) ChatMemberStatusType() string {
	return TypeChatMemberStatusRestricted
}

// The user is not a chat member
type ChatMemberStatusLeft struct {
	meta
}

func (entity *ChatMemberStatusLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusLeft

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusLeft) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusLeft) GetType() string {
	return TypeChatMemberStatusLeft
}

func (*ChatMemberStatusLeft) ChatMemberStatusType() string {
	return TypeChatMemberStatusLeft
}

// The user was banned (and hence is not a member of the chat). Implies the user can't return to the chat or view messages
type ChatMemberStatusBanned struct {
	meta
	// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever
	BannedUntilDate int32 `json:"banned_until_date"`
}

func (entity *ChatMemberStatusBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMemberStatusBanned

	return json.Marshal((*stub)(entity))
}

func (*ChatMemberStatusBanned) GetClass() string {
	return ClassChatMemberStatus
}

func (*ChatMemberStatusBanned) GetType() string {
	return TypeChatMemberStatusBanned
}

func (*ChatMemberStatusBanned) ChatMemberStatusType() string {
	return TypeChatMemberStatusBanned
}

// A user with information about joining/leaving a chat
type ChatMember struct {
	meta
	// User identifier of the chat member
	UserId int32 `json:"user_id"`
	// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
	InviterUserId int32 `json:"inviter_user_id"`
	// Point in time (Unix timestamp) when the user joined a chat
	JoinedChatDate int32 `json:"joined_chat_date"`
	// Status of the member in the chat
	Status ChatMemberStatus `json:"status"`
	// If the user is a bot, information about the bot; may be null. Can be null even for a bot if the bot is not a chat member
	BotInfo *BotInfo `json:"bot_info"`
}

func (entity *ChatMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMember

	return json.Marshal((*stub)(entity))
}

func (*ChatMember) GetClass() string {
	return ClassChatMember
}

func (*ChatMember) GetType() string {
	return TypeChatMember
}

func (chatMember *ChatMember) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId         int32           `json:"user_id"`
		InviterUserId  int32           `json:"inviter_user_id"`
		JoinedChatDate int32           `json:"joined_chat_date"`
		Status         json.RawMessage `json:"status"`
		BotInfo        *BotInfo        `json:"bot_info"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatMember.UserId = tmp.UserId
	chatMember.InviterUserId = tmp.InviterUserId
	chatMember.JoinedChatDate = tmp.JoinedChatDate
	chatMember.BotInfo = tmp.BotInfo

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	chatMember.Status = fieldStatus

	return nil
}

// Contains a list of chat members
type ChatMembers struct {
	meta
	// Approximate total count of chat members found
	TotalCount int32 `json:"total_count"`
	// A list of chat members
	Members []*ChatMember `json:"members"`
}

func (entity *ChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatMembers) GetClass() string {
	return ClassChatMembers
}

func (*ChatMembers) GetType() string {
	return TypeChatMembers
}

// Returns contacts of the user
type ChatMembersFilterContacts struct {
	meta
}

func (entity *ChatMembersFilterContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterContacts

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterContacts) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterContacts) GetType() string {
	return TypeChatMembersFilterContacts
}

func (*ChatMembersFilterContacts) ChatMembersFilterType() string {
	return TypeChatMembersFilterContacts
}

// Returns the owner and administrators
type ChatMembersFilterAdministrators struct {
	meta
}

func (entity *ChatMembersFilterAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterAdministrators

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterAdministrators) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterAdministrators) GetType() string {
	return TypeChatMembersFilterAdministrators
}

func (*ChatMembersFilterAdministrators) ChatMembersFilterType() string {
	return TypeChatMembersFilterAdministrators
}

// Returns all chat members, including restricted chat members
type ChatMembersFilterMembers struct {
	meta
}

func (entity *ChatMembersFilterMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterMembers

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterMembers) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterMembers) GetType() string {
	return TypeChatMembersFilterMembers
}

func (*ChatMembersFilterMembers) ChatMembersFilterType() string {
	return TypeChatMembersFilterMembers
}

// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
type ChatMembersFilterRestricted struct {
	meta
}

func (entity *ChatMembersFilterRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterRestricted) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterRestricted) GetType() string {
	return TypeChatMembersFilterRestricted
}

func (*ChatMembersFilterRestricted) ChatMembersFilterType() string {
	return TypeChatMembersFilterRestricted
}

// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
type ChatMembersFilterBanned struct {
	meta
}

func (entity *ChatMembersFilterBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterBanned

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterBanned) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterBanned) GetType() string {
	return TypeChatMembersFilterBanned
}

func (*ChatMembersFilterBanned) ChatMembersFilterType() string {
	return TypeChatMembersFilterBanned
}

// Returns bot members of the chat
type ChatMembersFilterBots struct {
	meta
}

func (entity *ChatMembersFilterBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatMembersFilterBots

	return json.Marshal((*stub)(entity))
}

func (*ChatMembersFilterBots) GetClass() string {
	return ClassChatMembersFilter
}

func (*ChatMembersFilterBots) GetType() string {
	return TypeChatMembersFilterBots
}

func (*ChatMembersFilterBots) ChatMembersFilterType() string {
	return TypeChatMembersFilterBots
}

// Returns recently active users in reverse chronological order
type SupergroupMembersFilterRecent struct {
	meta
}

func (entity *SupergroupMembersFilterRecent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterRecent

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterRecent) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterRecent) GetType() string {
	return TypeSupergroupMembersFilterRecent
}

func (*SupergroupMembersFilterRecent) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterRecent
}

// Returns contacts of the user, which are members of the supergroup or channel
type SupergroupMembersFilterContacts struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterContacts

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterContacts) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterContacts) GetType() string {
	return TypeSupergroupMembersFilterContacts
}

func (*SupergroupMembersFilterContacts) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterContacts
}

// Returns the owner and administrators
type SupergroupMembersFilterAdministrators struct {
	meta
}

func (entity *SupergroupMembersFilterAdministrators) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterAdministrators

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterAdministrators) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterAdministrators) GetType() string {
	return TypeSupergroupMembersFilterAdministrators
}

func (*SupergroupMembersFilterAdministrators) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterAdministrators
}

// Used to search for supergroup or channel members via a (string) query
type SupergroupMembersFilterSearch struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterSearch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterSearch

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterSearch) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterSearch) GetType() string {
	return TypeSupergroupMembersFilterSearch
}

func (*SupergroupMembersFilterSearch) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterSearch
}

// Returns restricted supergroup members; can be used only by administrators
type SupergroupMembersFilterRestricted struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterRestricted

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterRestricted) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterRestricted) GetType() string {
	return TypeSupergroupMembersFilterRestricted
}

func (*SupergroupMembersFilterRestricted) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterRestricted
}

// Returns users banned from the supergroup or channel; can be used only by administrators
type SupergroupMembersFilterBanned struct {
	meta
	// Query to search for
	Query string `json:"query"`
}

func (entity *SupergroupMembersFilterBanned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterBanned

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterBanned) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterBanned) GetType() string {
	return TypeSupergroupMembersFilterBanned
}

func (*SupergroupMembersFilterBanned) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterBanned
}

// Returns bot members of the supergroup or channel
type SupergroupMembersFilterBots struct {
	meta
}

func (entity *SupergroupMembersFilterBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupMembersFilterBots

	return json.Marshal((*stub)(entity))
}

func (*SupergroupMembersFilterBots) GetClass() string {
	return ClassSupergroupMembersFilter
}

func (*SupergroupMembersFilterBots) GetType() string {
	return TypeSupergroupMembersFilterBots
}

func (*SupergroupMembersFilterBots) SupergroupMembersFilterType() string {
	return TypeSupergroupMembersFilterBots
}

// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
type BasicGroup struct {
	meta
	// Group identifier
	Id int32 `json:"id"`
	// Number of members in the group
	MemberCount int32 `json:"member_count"`
	// Status of the current user in the group
	Status ChatMemberStatus `json:"status"`
	// True, if the group is active
	IsActive bool `json:"is_active"`
	// Identifier of the supergroup to which this group was upgraded; 0 if none
	UpgradedToSupergroupId int32 `json:"upgraded_to_supergroup_id"`
}

func (entity *BasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BasicGroup

	return json.Marshal((*stub)(entity))
}

func (*BasicGroup) GetClass() string {
	return ClassBasicGroup
}

func (*BasicGroup) GetType() string {
	return TypeBasicGroup
}

func (basicGroup *BasicGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                     int32           `json:"id"`
		MemberCount            int32           `json:"member_count"`
		Status                 json.RawMessage `json:"status"`
		IsActive               bool            `json:"is_active"`
		UpgradedToSupergroupId int32           `json:"upgraded_to_supergroup_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	basicGroup.Id = tmp.Id
	basicGroup.MemberCount = tmp.MemberCount
	basicGroup.IsActive = tmp.IsActive
	basicGroup.UpgradedToSupergroupId = tmp.UpgradedToSupergroupId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	basicGroup.Status = fieldStatus

	return nil
}

// Contains full information about a basic group
type BasicGroupFullInfo struct {
	meta
	// Group description
	Description string `json:"description"`
	// User identifier of the creator of the group; 0 if unknown
	CreatorUserId int32 `json:"creator_user_id"`
	// Group members
	Members []*ChatMember `json:"members"`
	// Invite link for this group; available only after it has been generated at least once and only for the group creator
	InviteLink string `json:"invite_link"`
}

func (entity *BasicGroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BasicGroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*BasicGroupFullInfo) GetClass() string {
	return ClassBasicGroupFullInfo
}

func (*BasicGroupFullInfo) GetType() string {
	return TypeBasicGroupFullInfo
}

// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
type Supergroup struct {
	meta
	// Supergroup or channel identifier
	Id int32 `json:"id"`
	// Username of the supergroup or channel; empty for private supergroups or channels
	Username string `json:"username"`
	// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
	Date int32 `json:"date"`
	// Status of the current user in the supergroup or channel; custom title will be always empty
	Status ChatMemberStatus `json:"status"`
	// Member count; 0 if unknown. Currently it is guaranteed to be known only if the supergroup or channel was found through SearchPublicChats
	MemberCount int32 `json:"member_count"`
	// True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
	HasLinkedChat bool `json:"has_linked_chat"`
	// True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
	HasLocation bool `json:"has_location"`
	// True, if messages sent to the channel should contain information about the sender. This field is only applicable to channels
	SignMessages bool `json:"sign_messages"`
	// True, if the slow mode is enabled in the supergroup
	IsSlowModeEnabled bool `json:"is_slow_mode_enabled"`
	// True, if the supergroup is a channel
	IsChannel bool `json:"is_channel"`
	// True, if the supergroup or channel is verified
	IsVerified bool `json:"is_verified"`
	// If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// True, if many users reported this supergroup as a scam
	IsScam bool `json:"is_scam"`
}

func (entity *Supergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Supergroup

	return json.Marshal((*stub)(entity))
}

func (*Supergroup) GetClass() string {
	return ClassSupergroup
}

func (*Supergroup) GetType() string {
	return TypeSupergroup
}

func (supergroup *Supergroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                int32           `json:"id"`
		Username          string          `json:"username"`
		Date              int32           `json:"date"`
		Status            json.RawMessage `json:"status"`
		MemberCount       int32           `json:"member_count"`
		HasLinkedChat     bool            `json:"has_linked_chat"`
		HasLocation       bool            `json:"has_location"`
		SignMessages      bool            `json:"sign_messages"`
		IsSlowModeEnabled bool            `json:"is_slow_mode_enabled"`
		IsChannel         bool            `json:"is_channel"`
		IsVerified        bool            `json:"is_verified"`
		RestrictionReason string          `json:"restriction_reason"`
		IsScam            bool            `json:"is_scam"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	supergroup.Id = tmp.Id
	supergroup.Username = tmp.Username
	supergroup.Date = tmp.Date
	supergroup.MemberCount = tmp.MemberCount
	supergroup.HasLinkedChat = tmp.HasLinkedChat
	supergroup.HasLocation = tmp.HasLocation
	supergroup.SignMessages = tmp.SignMessages
	supergroup.IsSlowModeEnabled = tmp.IsSlowModeEnabled
	supergroup.IsChannel = tmp.IsChannel
	supergroup.IsVerified = tmp.IsVerified
	supergroup.RestrictionReason = tmp.RestrictionReason
	supergroup.IsScam = tmp.IsScam

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	supergroup.Status = fieldStatus

	return nil
}

// Contains full information about a supergroup or channel
type SupergroupFullInfo struct {
	meta
	// Supergroup or channel description
	Description string `json:"description"`
	// Number of members in the supergroup or channel; 0 if unknown
	MemberCount int32 `json:"member_count"`
	// Number of privileged users in the supergroup or channel; 0 if unknown
	AdministratorCount int32 `json:"administrator_count"`
	// Number of restricted users in the supergroup; 0 if unknown
	RestrictedCount int32 `json:"restricted_count"`
	// Number of users banned from chat; 0 if unknown
	BannedCount int32 `json:"banned_count"`
	// Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
	LinkedChatId int64 `json:"linked_chat_id"`
	// Delay between consecutive sent messages for non-administrator supergroup members, in seconds
	SlowModeDelay int32 `json:"slow_mode_delay"`
	// Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
	SlowModeDelayExpiresIn float64 `json:"slow_mode_delay_expires_in"`
	// True, if members of the chat can be retrieved
	CanGetMembers bool `json:"can_get_members"`
	// True, if the chat username can be changed
	CanSetUsername bool `json:"can_set_username"`
	// True, if the supergroup sticker set can be changed
	CanSetStickerSet bool `json:"can_set_sticker_set"`
	// True, if the supergroup location can be changed
	CanSetLocation bool `json:"can_set_location"`
	// True, if the channel statistics is available through getChatStatisticsUrl
	CanViewStatistics bool `json:"can_view_statistics"`
	// True, if new chat members will have access to old messages. In public or discussion groups and both public and private channels, old messages are always available, so this option affects only private supergroups without a linked chat. The value of this field is only available for chat administrators
	IsAllHistoryAvailable bool `json:"is_all_history_available"`
	// Identifier of the supergroup sticker set; 0 if none
	StickerSetId JsonInt64 `json:"sticker_set_id"`
	// Location to which the supergroup is connected; may be null
	Location *ChatLocation `json:"location"`
	// Invite link for this chat
	InviteLink string `json:"invite_link"`
	// Identifier of the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromBasicGroupId int32 `json:"upgraded_from_basic_group_id"`
	// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromMaxMessageId int64 `json:"upgraded_from_max_message_id"`
}

func (entity *SupergroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SupergroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*SupergroupFullInfo) GetClass() string {
	return ClassSupergroupFullInfo
}

func (*SupergroupFullInfo) GetType() string {
	return TypeSupergroupFullInfo
}

// The secret chat is not yet created; waiting for the other user to get online
type SecretChatStatePending struct {
	meta
}

func (entity *SecretChatStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStatePending

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStatePending) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStatePending) GetType() string {
	return TypeSecretChatStatePending
}

func (*SecretChatStatePending) SecretChatStateType() string {
	return TypeSecretChatStatePending
}

// The secret chat is ready to use
type SecretChatStateReady struct {
	meta
}

func (entity *SecretChatStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStateReady

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStateReady) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStateReady) GetType() string {
	return TypeSecretChatStateReady
}

func (*SecretChatStateReady) SecretChatStateType() string {
	return TypeSecretChatStateReady
}

// The secret chat is closed
type SecretChatStateClosed struct {
	meta
}

func (entity *SecretChatStateClosed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChatStateClosed

	return json.Marshal((*stub)(entity))
}

func (*SecretChatStateClosed) GetClass() string {
	return ClassSecretChatState
}

func (*SecretChatStateClosed) GetType() string {
	return TypeSecretChatStateClosed
}

func (*SecretChatStateClosed) SecretChatStateType() string {
	return TypeSecretChatStateClosed
}

// Represents a secret chat
type SecretChat struct {
	meta
	// Secret chat identifier
	Id int32 `json:"id"`
	// Identifier of the chat partner
	UserId int32 `json:"user_id"`
	// State of the secret chat
	State SecretChatState `json:"state"`
	// True, if the chat was created by the current user; otherwise false
	IsOutbound bool `json:"is_outbound"`
	// Current message Time To Live setting (self-destruct timer) for the chat, in seconds
	Ttl int32 `json:"ttl"`
	// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
	KeyHash []byte `json:"key_hash"`
	// Secret chat layer; determines features supported by the other client. Video notes are supported if the layer >= 66; nested text entities and underline and strikethrough entities are supported if the layer >= 101
	Layer int32 `json:"layer"`
}

func (entity *SecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SecretChat

	return json.Marshal((*stub)(entity))
}

func (*SecretChat) GetClass() string {
	return ClassSecretChat
}

func (*SecretChat) GetType() string {
	return TypeSecretChat
}

func (secretChat *SecretChat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         int32           `json:"id"`
		UserId     int32           `json:"user_id"`
		State      json.RawMessage `json:"state"`
		IsOutbound bool            `json:"is_outbound"`
		Ttl        int32           `json:"ttl"`
		KeyHash    []byte          `json:"key_hash"`
		Layer      int32           `json:"layer"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	secretChat.Id = tmp.Id
	secretChat.UserId = tmp.UserId
	secretChat.IsOutbound = tmp.IsOutbound
	secretChat.Ttl = tmp.Ttl
	secretChat.KeyHash = tmp.KeyHash
	secretChat.Layer = tmp.Layer

	fieldState, _ := UnmarshalSecretChatState(tmp.State)
	secretChat.State = fieldState

	return nil
}

// The message was originally written by a known user
type MessageForwardOriginUser struct {
	meta
	// Identifier of the user that originally sent the message
	SenderUserId int32 `json:"sender_user_id"`
}

func (entity *MessageForwardOriginUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginUser

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginUser) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginUser) GetType() string {
	return TypeMessageForwardOriginUser
}

func (*MessageForwardOriginUser) MessageForwardOriginType() string {
	return TypeMessageForwardOriginUser
}

// The message was originally written by a user, which is hidden by their privacy settings
type MessageForwardOriginHiddenUser struct {
	meta
	// Name of the sender
	SenderName string `json:"sender_name"`
}

func (entity *MessageForwardOriginHiddenUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginHiddenUser

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginHiddenUser) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginHiddenUser) GetType() string {
	return TypeMessageForwardOriginHiddenUser
}

func (*MessageForwardOriginHiddenUser) MessageForwardOriginType() string {
	return TypeMessageForwardOriginHiddenUser
}

// The message was originally a post in a channel
type MessageForwardOriginChannel struct {
	meta
	// Identifier of the chat from which the message was originally forwarded
	ChatId int64 `json:"chat_id"`
	// Message identifier of the original message; 0 if unknown
	MessageId int64 `json:"message_id"`
	// Original post author signature
	AuthorSignature string `json:"author_signature"`
}

func (entity *MessageForwardOriginChannel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardOriginChannel

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardOriginChannel) GetClass() string {
	return ClassMessageForwardOrigin
}

func (*MessageForwardOriginChannel) GetType() string {
	return TypeMessageForwardOriginChannel
}

func (*MessageForwardOriginChannel) MessageForwardOriginType() string {
	return TypeMessageForwardOriginChannel
}

// Contains information about a forwarded message
type MessageForwardInfo struct {
	meta
	// Origin of a forwarded message
	Origin MessageForwardOrigin `json:"origin"`
	// Point in time (Unix timestamp) when the message was originally sent
	Date int32 `json:"date"`
	// For messages forwarded to the chat with the current user (Saved Messages) or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
	FromChatId int64 `json:"from_chat_id"`
	// For messages forwarded to the chat with the current user (Saved Messages) or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
	FromMessageId int64 `json:"from_message_id"`
}

func (entity *MessageForwardInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageForwardInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageForwardInfo) GetClass() string {
	return ClassMessageForwardInfo
}

func (*MessageForwardInfo) GetType() string {
	return TypeMessageForwardInfo
}

func (messageForwardInfo *MessageForwardInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Origin        json.RawMessage `json:"origin"`
		Date          int32           `json:"date"`
		FromChatId    int64           `json:"from_chat_id"`
		FromMessageId int64           `json:"from_message_id"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageForwardInfo.Date = tmp.Date
	messageForwardInfo.FromChatId = tmp.FromChatId
	messageForwardInfo.FromMessageId = tmp.FromMessageId

	fieldOrigin, _ := UnmarshalMessageForwardOrigin(tmp.Origin)
	messageForwardInfo.Origin = fieldOrigin

	return nil
}

// The message is being sent now, but has not yet been delivered to the server
type MessageSendingStatePending struct {
	meta
}

func (entity *MessageSendingStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendingStatePending

	return json.Marshal((*stub)(entity))
}

func (*MessageSendingStatePending) GetClass() string {
	return ClassMessageSendingState
}

func (*MessageSendingStatePending) GetType() string {
	return TypeMessageSendingStatePending
}

func (*MessageSendingStatePending) MessageSendingStateType() string {
	return TypeMessageSendingStatePending
}

// The message failed to be sent
type MessageSendingStateFailed struct {
	meta
	// An error code; 0 if unknown
	ErrorCode int32 `json:"error_code"`
	// Error message
	ErrorMessage string `json:"error_message"`
	// True, if the message can be re-sent
	CanRetry bool `json:"can_retry"`
	// Time left before the message can be re-sent, in seconds. No update is sent when this field changes
	RetryAfter float64 `json:"retry_after"`
}

func (entity *MessageSendingStateFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSendingStateFailed

	return json.Marshal((*stub)(entity))
}

func (*MessageSendingStateFailed) GetClass() string {
	return ClassMessageSendingState
}

func (*MessageSendingStateFailed) GetType() string {
	return TypeMessageSendingStateFailed
}

func (*MessageSendingStateFailed) MessageSendingStateType() string {
	return TypeMessageSendingStateFailed
}

// Describes a message
type Message struct {
	meta
	// Message identifier, unique for the chat to which the message belongs
	Id int64 `json:"id"`
	// Identifier of the user who sent the message; 0 if unknown. Currently, it is unknown for channel posts and for channel posts automatically forwarded to discussion group
	SenderUserId int32 `json:"sender_user_id"`
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Information about the sending state of the message; may be null
	SendingState MessageSendingState `json:"sending_state"`
	// Information about the scheduling state of the message; may be null
	SchedulingState MessageSchedulingState `json:"scheduling_state"`
	// True, if the message is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the client
	CanBeEdited bool `json:"can_be_edited"`
	// True, if the message can be forwarded
	CanBeForwarded bool `json:"can_be_forwarded"`
	// True, if the message can be deleted only for the current user while other users will continue to see it
	CanBeDeletedOnlyForSelf bool `json:"can_be_deleted_only_for_self"`
	// True, if the message can be deleted for all users
	CanBeDeletedForAllUsers bool `json:"can_be_deleted_for_all_users"`
	// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
	IsChannelPost bool `json:"is_channel_post"`
	// True, if the message contains an unread mention for the current user
	ContainsUnreadMention bool `json:"contains_unread_mention"`
	// Point in time (Unix timestamp) when the message was sent
	Date int32 `json:"date"`
	// Point in time (Unix timestamp) when the message was last edited
	EditDate int32 `json:"edit_date"`
	// Information about the initial message sender; may be null
	ForwardInfo *MessageForwardInfo `json:"forward_info"`
	// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
	ReplyToMessageId int64 `json:"reply_to_message_id"`
	// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
	Ttl int32 `json:"ttl"`
	// Time left before the message expires, in seconds
	TtlExpiresIn float64 `json:"ttl_expires_in"`
	// If non-zero, the user identifier of the bot through which this message was sent
	ViaBotUserId int32 `json:"via_bot_user_id"`
	// For channel posts, optional author signature
	AuthorSignature string `json:"author_signature"`
	// Number of times this message was viewed
	Views int32 `json:"views"`
	// Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums
	MediaAlbumId JsonInt64 `json:"media_album_id"`
	// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
	RestrictionReason string `json:"restriction_reason"`
	// Content of the message
	Content MessageContent `json:"content"`
	// Reply markup for the message; may be null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *Message) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Message

	return json.Marshal((*stub)(entity))
}

func (*Message) GetClass() string {
	return ClassMessage
}

func (*Message) GetType() string {
	return TypeMessage
}

func (message *Message) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                      int64               `json:"id"`
		SenderUserId            int32               `json:"sender_user_id"`
		ChatId                  int64               `json:"chat_id"`
		SendingState            json.RawMessage     `json:"sending_state"`
		SchedulingState         json.RawMessage     `json:"scheduling_state"`
		IsOutgoing              bool                `json:"is_outgoing"`
		CanBeEdited             bool                `json:"can_be_edited"`
		CanBeForwarded          bool                `json:"can_be_forwarded"`
		CanBeDeletedOnlyForSelf bool                `json:"can_be_deleted_only_for_self"`
		CanBeDeletedForAllUsers bool                `json:"can_be_deleted_for_all_users"`
		IsChannelPost           bool                `json:"is_channel_post"`
		ContainsUnreadMention   bool                `json:"contains_unread_mention"`
		Date                    int32               `json:"date"`
		EditDate                int32               `json:"edit_date"`
		ForwardInfo             *MessageForwardInfo `json:"forward_info"`
		ReplyToMessageId        int64               `json:"reply_to_message_id"`
		Ttl                     int32               `json:"ttl"`
		TtlExpiresIn            float64             `json:"ttl_expires_in"`
		ViaBotUserId            int32               `json:"via_bot_user_id"`
		AuthorSignature         string              `json:"author_signature"`
		Views                   int32               `json:"views"`
		MediaAlbumId            JsonInt64           `json:"media_album_id"`
		RestrictionReason       string              `json:"restriction_reason"`
		Content                 json.RawMessage     `json:"content"`
		ReplyMarkup             json.RawMessage     `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	message.Id = tmp.Id
	message.SenderUserId = tmp.SenderUserId
	message.ChatId = tmp.ChatId
	message.IsOutgoing = tmp.IsOutgoing
	message.CanBeEdited = tmp.CanBeEdited
	message.CanBeForwarded = tmp.CanBeForwarded
	message.CanBeDeletedOnlyForSelf = tmp.CanBeDeletedOnlyForSelf
	message.CanBeDeletedForAllUsers = tmp.CanBeDeletedForAllUsers
	message.IsChannelPost = tmp.IsChannelPost
	message.ContainsUnreadMention = tmp.ContainsUnreadMention
	message.Date = tmp.Date
	message.EditDate = tmp.EditDate
	message.ForwardInfo = tmp.ForwardInfo
	message.ReplyToMessageId = tmp.ReplyToMessageId
	message.Ttl = tmp.Ttl
	message.TtlExpiresIn = tmp.TtlExpiresIn
	message.ViaBotUserId = tmp.ViaBotUserId
	message.AuthorSignature = tmp.AuthorSignature
	message.Views = tmp.Views
	message.MediaAlbumId = tmp.MediaAlbumId
	message.RestrictionReason = tmp.RestrictionReason

	fieldSendingState, _ := UnmarshalMessageSendingState(tmp.SendingState)
	message.SendingState = fieldSendingState

	fieldSchedulingState, _ := UnmarshalMessageSchedulingState(tmp.SchedulingState)
	message.SchedulingState = fieldSchedulingState

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	message.Content = fieldContent

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	message.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Contains a list of messages
type Messages struct {
	meta
	// Approximate total count of messages found
	TotalCount int32 `json:"total_count"`
	// List of messages; messages may be null
	Messages []*Message `json:"messages"`
}

func (entity *Messages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Messages

	return json.Marshal((*stub)(entity))
}

func (*Messages) GetClass() string {
	return ClassMessages
}

func (*Messages) GetType() string {
	return TypeMessages
}

// Contains a list of messages found by a search
type FoundMessages struct {
	meta
	// List of messages
	Messages []*Message `json:"messages"`
	// Value to pass as from_search_id to get more results
	NextFromSearchId JsonInt64 `json:"next_from_search_id"`
}

func (entity *FoundMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FoundMessages

	return json.Marshal((*stub)(entity))
}

func (*FoundMessages) GetClass() string {
	return ClassFoundMessages
}

func (*FoundMessages) GetType() string {
	return TypeFoundMessages
}

// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
type NotificationSettingsScopePrivateChats struct {
	meta
}

func (entity *NotificationSettingsScopePrivateChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopePrivateChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopePrivateChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopePrivateChats) GetType() string {
	return TypeNotificationSettingsScopePrivateChats
}

func (*NotificationSettingsScopePrivateChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopePrivateChats
}

// Notification settings applied to all basic groups and supergroups when the corresponding chat setting has a default value
type NotificationSettingsScopeGroupChats struct {
	meta
}

func (entity *NotificationSettingsScopeGroupChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopeGroupChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopeGroupChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopeGroupChats) GetType() string {
	return TypeNotificationSettingsScopeGroupChats
}

func (*NotificationSettingsScopeGroupChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopeGroupChats
}

// Notification settings applied to all channels when the corresponding chat setting has a default value
type NotificationSettingsScopeChannelChats struct {
	meta
}

func (entity *NotificationSettingsScopeChannelChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationSettingsScopeChannelChats

	return json.Marshal((*stub)(entity))
}

func (*NotificationSettingsScopeChannelChats) GetClass() string {
	return ClassNotificationSettingsScope
}

func (*NotificationSettingsScopeChannelChats) GetType() string {
	return TypeNotificationSettingsScopeChannelChats
}

func (*NotificationSettingsScopeChannelChats) NotificationSettingsScopeType() string {
	return TypeNotificationSettingsScopeChannelChats
}

// Contains information about notification settings for a chat
type ChatNotificationSettings struct {
	meta
	// If true, mute_for is ignored and the value for the relevant type of chat is used instead
	UseDefaultMuteFor bool `json:"use_default_mute_for"`
	// Time left before notifications will be unmuted, in seconds
	MuteFor int32 `json:"mute_for"`
	// If true, sound is ignored and the value for the relevant type of chat is used instead
	UseDefaultSound bool `json:"use_default_sound"`
	// The name of an audio file to be used for notification sounds; only applies to iOS applications
	Sound string `json:"sound"`
	// If true, show_preview is ignored and the value for the relevant type of chat is used instead
	UseDefaultShowPreview bool `json:"use_default_show_preview"`
	// True, if message content should be displayed in notifications
	ShowPreview bool `json:"show_preview"`
	// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead
	UseDefaultDisablePinnedMessageNotifications bool `json:"use_default_disable_pinned_message_notifications"`
	// If true, notifications for incoming pinned messages will be created as for an ordinary unread message
	DisablePinnedMessageNotifications bool `json:"disable_pinned_message_notifications"`
	// If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead
	UseDefaultDisableMentionNotifications bool `json:"use_default_disable_mention_notifications"`
	// If true, notifications for messages with mentions will be created as for an ordinary unread message
	DisableMentionNotifications bool `json:"disable_mention_notifications"`
}

func (entity *ChatNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ChatNotificationSettings) GetClass() string {
	return ClassChatNotificationSettings
}

func (*ChatNotificationSettings) GetType() string {
	return TypeChatNotificationSettings
}

// Contains information about notification settings for several chats
type ScopeNotificationSettings struct {
	meta
	// Time left before notifications will be unmuted, in seconds
	MuteFor int32 `json:"mute_for"`
	// The name of an audio file to be used for notification sounds; only applies to iOS applications
	Sound string `json:"sound"`
	// True, if message content should be displayed in notifications
	ShowPreview bool `json:"show_preview"`
	// True, if notifications for incoming pinned messages will be created as for an ordinary unread message
	DisablePinnedMessageNotifications bool `json:"disable_pinned_message_notifications"`
	// True, if notifications for messages with mentions will be created as for an ordinary unread message
	DisableMentionNotifications bool `json:"disable_mention_notifications"`
}

func (entity *ScopeNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ScopeNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*ScopeNotificationSettings) GetClass() string {
	return ClassScopeNotificationSettings
}

func (*ScopeNotificationSettings) GetType() string {
	return TypeScopeNotificationSettings
}

// Contains information about a message draft
type DraftMessage struct {
	meta
	// Identifier of the message to reply to; 0 if none
	ReplyToMessageId int64 `json:"reply_to_message_id"`
	// Content of the message draft; this should always be of type inputMessageText
	InputMessageText InputMessageContent `json:"input_message_text"`
}

func (entity *DraftMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DraftMessage

	return json.Marshal((*stub)(entity))
}

func (*DraftMessage) GetClass() string {
	return ClassDraftMessage
}

func (*DraftMessage) GetType() string {
	return TypeDraftMessage
}

func (draftMessage *DraftMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ReplyToMessageId int64           `json:"reply_to_message_id"`
		InputMessageText json.RawMessage `json:"input_message_text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	draftMessage.ReplyToMessageId = tmp.ReplyToMessageId

	fieldInputMessageText, _ := UnmarshalInputMessageContent(tmp.InputMessageText)
	draftMessage.InputMessageText = fieldInputMessageText

	return nil
}

// An ordinary chat with a user
type ChatTypePrivate struct {
	meta
	// User identifier
	UserId int32 `json:"user_id"`
}

func (entity *ChatTypePrivate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypePrivate

	return json.Marshal((*stub)(entity))
}

func (*ChatTypePrivate) GetClass() string {
	return ClassChatType
}

func (*ChatTypePrivate) GetType() string {
	return TypeChatTypePrivate
}

func (*ChatTypePrivate) ChatTypeType() string {
	return TypeChatTypePrivate
}

// A basic group (i.e., a chat with 0-200 other users)
type ChatTypeBasicGroup struct {
	meta
	// Basic group identifier
	BasicGroupId int32 `json:"basic_group_id"`
}

func (entity *ChatTypeBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeBasicGroup) GetClass() string {
	return ClassChatType
}

func (*ChatTypeBasicGroup) GetType() string {
	return TypeChatTypeBasicGroup
}

func (*ChatTypeBasicGroup) ChatTypeType() string {
	return TypeChatTypeBasicGroup
}

// A supergroup (i.e. a chat with up to GetOption("supergroup_max_size") other users), or channel (with unlimited members)
type ChatTypeSupergroup struct {
	meta
	// Supergroup or channel identifier
	SupergroupId int32 `json:"supergroup_id"`
	// True, if the supergroup is a channel
	IsChannel bool `json:"is_channel"`
}

func (entity *ChatTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeSupergroup) GetClass() string {
	return ClassChatType
}

func (*ChatTypeSupergroup) GetType() string {
	return TypeChatTypeSupergroup
}

func (*ChatTypeSupergroup) ChatTypeType() string {
	return TypeChatTypeSupergroup
}

// A secret chat with a user
type ChatTypeSecret struct {
	meta
	// Secret chat identifier
	SecretChatId int32 `json:"secret_chat_id"`
	// User identifier of the secret chat peer
	UserId int32 `json:"user_id"`
}

func (entity *ChatTypeSecret) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatTypeSecret

	return json.Marshal((*stub)(entity))
}

func (*ChatTypeSecret) GetClass() string {
	return ClassChatType
}

func (*ChatTypeSecret) GetType() string {
	return TypeChatTypeSecret
}

func (*ChatTypeSecret) ChatTypeType() string {
	return TypeChatTypeSecret
}

// A main list of chats
type ChatListMain struct {
	meta
}

func (entity *ChatListMain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListMain

	return json.Marshal((*stub)(entity))
}

func (*ChatListMain) GetClass() string {
	return ClassChatList
}

func (*ChatListMain) GetType() string {
	return TypeChatListMain
}

func (*ChatListMain) ChatListType() string {
	return TypeChatListMain
}

// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
type ChatListArchive struct {
	meta
}

func (entity *ChatListArchive) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatListArchive

	return json.Marshal((*stub)(entity))
}

func (*ChatListArchive) GetClass() string {
	return ClassChatList
}

func (*ChatListArchive) GetType() string {
	return TypeChatListArchive
}

func (*ChatListArchive) ChatListType() string {
	return TypeChatListArchive
}

// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
type Chat struct {
	meta
	// Chat unique identifier
	Id int64 `json:"id"`
	// Type of the chat
	Type ChatType `json:"type"`
	// A chat list to which the chat belongs; may be null
	ChatList ChatList `json:"chat_list"`
	// Chat title
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhoto `json:"photo"`
	// Actions that non-administrator chat members are allowed to take in the chat
	Permissions *ChatPermissions `json:"permissions"`
	// Last message in the chat; may be null
	LastMessage *Message `json:"last_message"`
	// Descending parameter by which chats are sorted in the main chat list. If the order number of two chats is the same, they must be sorted in descending order by ID. If 0, the position of the chat in the list is undetermined
	Order JsonInt64 `json:"order"`
	// True, if the chat is pinned
	IsPinned bool `json:"is_pinned"`
	// True, if the chat is marked as unread
	IsMarkedAsUnread bool `json:"is_marked_as_unread"`
	// True, if the chat is sponsored by the user's MTProxy server
	IsSponsored bool `json:"is_sponsored"`
	// True, if the chat has scheduled messages
	HasScheduledMessages bool `json:"has_scheduled_messages"`
	// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
	CanBeDeletedOnlyForSelf bool `json:"can_be_deleted_only_for_self"`
	// True, if the chat messages can be deleted for all users
	CanBeDeletedForAllUsers bool `json:"can_be_deleted_for_all_users"`
	// True, if the chat can be reported to Telegram moderators through reportChat
	CanBeReported bool `json:"can_be_reported"`
	// Default value of the disable_notification parameter, used when a message is sent to the chat
	DefaultDisableNotification bool `json:"default_disable_notification"`
	// Number of unread messages in the chat
	UnreadCount int32 `json:"unread_count"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// Identifier of the last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
	// Number of unread messages with a mention/reply in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
	// Notification settings for this chat
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
	// Describes actions which should be possible to do through a chat action bar; may be null
	ActionBar ChatActionBar `json:"action_bar"`
	// Identifier of the pinned message in the chat; 0 if none
	PinnedMessageId int64 `json:"pinned_message_id"`
	// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	ReplyMarkupMessageId int64 `json:"reply_markup_message_id"`
	// A draft of a message in the chat; may be null
	DraftMessage *DraftMessage `json:"draft_message"`
	// Contains client-specific data associated with the chat. (For example, the chat position or local chat notification settings can be stored here.) Persistent if the message database is used
	ClientData string `json:"client_data"`
}

func (entity *Chat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Chat

	return json.Marshal((*stub)(entity))
}

func (*Chat) GetClass() string {
	return ClassChat
}

func (*Chat) GetType() string {
	return TypeChat
}

func (chat *Chat) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                         int64                     `json:"id"`
		Type                       json.RawMessage           `json:"type"`
		ChatList                   json.RawMessage           `json:"chat_list"`
		Title                      string                    `json:"title"`
		Photo                      *ChatPhoto                `json:"photo"`
		Permissions                *ChatPermissions          `json:"permissions"`
		LastMessage                *Message                  `json:"last_message"`
		Order                      JsonInt64                 `json:"order"`
		IsPinned                   bool                      `json:"is_pinned"`
		IsMarkedAsUnread           bool                      `json:"is_marked_as_unread"`
		IsSponsored                bool                      `json:"is_sponsored"`
		HasScheduledMessages       bool                      `json:"has_scheduled_messages"`
		CanBeDeletedOnlyForSelf    bool                      `json:"can_be_deleted_only_for_self"`
		CanBeDeletedForAllUsers    bool                      `json:"can_be_deleted_for_all_users"`
		CanBeReported              bool                      `json:"can_be_reported"`
		DefaultDisableNotification bool                      `json:"default_disable_notification"`
		UnreadCount                int32                     `json:"unread_count"`
		LastReadInboxMessageId     int64                     `json:"last_read_inbox_message_id"`
		LastReadOutboxMessageId    int64                     `json:"last_read_outbox_message_id"`
		UnreadMentionCount         int32                     `json:"unread_mention_count"`
		NotificationSettings       *ChatNotificationSettings `json:"notification_settings"`
		ActionBar                  json.RawMessage           `json:"action_bar"`
		PinnedMessageId            int64                     `json:"pinned_message_id"`
		ReplyMarkupMessageId       int64                     `json:"reply_markup_message_id"`
		DraftMessage               *DraftMessage             `json:"draft_message"`
		ClientData                 string                    `json:"client_data"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chat.Id = tmp.Id
	chat.Title = tmp.Title
	chat.Photo = tmp.Photo
	chat.Permissions = tmp.Permissions
	chat.LastMessage = tmp.LastMessage
	chat.Order = tmp.Order
	chat.IsPinned = tmp.IsPinned
	chat.IsMarkedAsUnread = tmp.IsMarkedAsUnread
	chat.IsSponsored = tmp.IsSponsored
	chat.HasScheduledMessages = tmp.HasScheduledMessages
	chat.CanBeDeletedOnlyForSelf = tmp.CanBeDeletedOnlyForSelf
	chat.CanBeDeletedForAllUsers = tmp.CanBeDeletedForAllUsers
	chat.CanBeReported = tmp.CanBeReported
	chat.DefaultDisableNotification = tmp.DefaultDisableNotification
	chat.UnreadCount = tmp.UnreadCount
	chat.LastReadInboxMessageId = tmp.LastReadInboxMessageId
	chat.LastReadOutboxMessageId = tmp.LastReadOutboxMessageId
	chat.UnreadMentionCount = tmp.UnreadMentionCount
	chat.NotificationSettings = tmp.NotificationSettings
	chat.PinnedMessageId = tmp.PinnedMessageId
	chat.ReplyMarkupMessageId = tmp.ReplyMarkupMessageId
	chat.DraftMessage = tmp.DraftMessage
	chat.ClientData = tmp.ClientData

	fieldType, _ := UnmarshalChatType(tmp.Type)
	chat.Type = fieldType

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	chat.ChatList = fieldChatList

	fieldActionBar, _ := UnmarshalChatActionBar(tmp.ActionBar)
	chat.ActionBar = fieldActionBar

	return nil
}

// Represents a list of chats
type Chats struct {
	meta
	// List of chat identifiers
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *Chats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Chats

	return json.Marshal((*stub)(entity))
}

func (*Chats) GetClass() string {
	return ClassChats
}

func (*Chats) GetType() string {
	return TypeChats
}

// Describes a chat located nearby
type ChatNearby struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Distance to the chat location in meters
	Distance int32 `json:"distance"`
}

func (entity *ChatNearby) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatNearby

	return json.Marshal((*stub)(entity))
}

func (*ChatNearby) GetClass() string {
	return ClassChatNearby
}

func (*ChatNearby) GetType() string {
	return TypeChatNearby
}

// Represents a list of chats located nearby
type ChatsNearby struct {
	meta
	// List of users nearby
	UsersNearby []*ChatNearby `json:"users_nearby"`
	// List of location-based supergroups nearby
	SupergroupsNearby []*ChatNearby `json:"supergroups_nearby"`
}

func (entity *ChatsNearby) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatsNearby

	return json.Marshal((*stub)(entity))
}

func (*ChatsNearby) GetClass() string {
	return ClassChatsNearby
}

func (*ChatsNearby) GetType() string {
	return TypeChatsNearby
}

// Contains a chat invite link
type ChatInviteLink struct {
	meta
	// Chat invite link
	InviteLink string `json:"invite_link"`
}

func (entity *ChatInviteLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLink

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLink) GetClass() string {
	return ClassChatInviteLink
}

func (*ChatInviteLink) GetType() string {
	return TypeChatInviteLink
}

// Contains information about a chat invite link
type ChatInviteLinkInfo struct {
	meta
	// Chat identifier of the invite link; 0 if the user is not a member of this chat
	ChatId int64 `json:"chat_id"`
	// Contains information about the type of the chat
	Type ChatType `json:"type"`
	// Title of the chat
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhoto `json:"photo"`
	// Number of members
	MemberCount int32 `json:"member_count"`
	// User identifiers of some chat members that may be known to the current user
	MemberUserIds []int32 `json:"member_user_ids"`
	// True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
	IsPublic bool `json:"is_public"`
}

func (entity *ChatInviteLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatInviteLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*ChatInviteLinkInfo) GetClass() string {
	return ClassChatInviteLinkInfo
}

func (*ChatInviteLinkInfo) GetType() string {
	return TypeChatInviteLinkInfo
}

func (chatInviteLinkInfo *ChatInviteLinkInfo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId        int64           `json:"chat_id"`
		Type          json.RawMessage `json:"type"`
		Title         string          `json:"title"`
		Photo         *ChatPhoto      `json:"photo"`
		MemberCount   int32           `json:"member_count"`
		MemberUserIds []int32         `json:"member_user_ids"`
		IsPublic      bool            `json:"is_public"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatInviteLinkInfo.ChatId = tmp.ChatId
	chatInviteLinkInfo.Title = tmp.Title
	chatInviteLinkInfo.Photo = tmp.Photo
	chatInviteLinkInfo.MemberCount = tmp.MemberCount
	chatInviteLinkInfo.MemberUserIds = tmp.MemberUserIds
	chatInviteLinkInfo.IsPublic = tmp.IsPublic

	fieldType, _ := UnmarshalChatType(tmp.Type)
	chatInviteLinkInfo.Type = fieldType

	return nil
}

// The chat is public, because it has username
type PublicChatTypeHasUsername struct {
	meta
}

func (entity *PublicChatTypeHasUsername) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicChatTypeHasUsername

	return json.Marshal((*stub)(entity))
}

func (*PublicChatTypeHasUsername) GetClass() string {
	return ClassPublicChatType
}

func (*PublicChatTypeHasUsername) GetType() string {
	return TypePublicChatTypeHasUsername
}

func (*PublicChatTypeHasUsername) PublicChatTypeType() string {
	return TypePublicChatTypeHasUsername
}

// The chat is public, because it is a location-based supergroup
type PublicChatTypeIsLocationBased struct {
	meta
}

func (entity *PublicChatTypeIsLocationBased) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicChatTypeIsLocationBased

	return json.Marshal((*stub)(entity))
}

func (*PublicChatTypeIsLocationBased) GetClass() string {
	return ClassPublicChatType
}

func (*PublicChatTypeIsLocationBased) GetType() string {
	return TypePublicChatTypeIsLocationBased
}

func (*PublicChatTypeIsLocationBased) PublicChatTypeType() string {
	return TypePublicChatTypeIsLocationBased
}

// The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam
type ChatActionBarReportSpam struct {
	meta
}

func (entity *ChatActionBarReportSpam) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportSpam

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportSpam) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportSpam) GetType() string {
	return TypeChatActionBarReportSpam
}

func (*ChatActionBarReportSpam) ChatActionBarType() string {
	return TypeChatActionBarReportSpam
}

// The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason chatReportReasonUnrelatedLocation
type ChatActionBarReportUnrelatedLocation struct {
	meta
}

func (entity *ChatActionBarReportUnrelatedLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportUnrelatedLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportUnrelatedLocation) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportUnrelatedLocation) GetType() string {
	return TypeChatActionBarReportUnrelatedLocation
}

func (*ChatActionBarReportUnrelatedLocation) ChatActionBarType() string {
	return TypeChatActionBarReportUnrelatedLocation
}

// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be added to the contact list using the method addContact, or the other user can be blocked using the method blockUser
type ChatActionBarReportAddBlock struct {
	meta
}

func (entity *ChatActionBarReportAddBlock) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarReportAddBlock

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarReportAddBlock) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarReportAddBlock) GetType() string {
	return TypeChatActionBarReportAddBlock
}

func (*ChatActionBarReportAddBlock) ChatActionBarType() string {
	return TypeChatActionBarReportAddBlock
}

// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
type ChatActionBarAddContact struct {
	meta
}

func (entity *ChatActionBarAddContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarAddContact

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarAddContact) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarAddContact) GetType() string {
	return TypeChatActionBarAddContact
}

func (*ChatActionBarAddContact) ChatActionBarType() string {
	return TypeChatActionBarAddContact
}

// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
type ChatActionBarSharePhoneNumber struct {
	meta
}

func (entity *ChatActionBarSharePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionBarSharePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*ChatActionBarSharePhoneNumber) GetClass() string {
	return ClassChatActionBar
}

func (*ChatActionBarSharePhoneNumber) GetType() string {
	return TypeChatActionBarSharePhoneNumber
}

func (*ChatActionBarSharePhoneNumber) ChatActionBarType() string {
	return TypeChatActionBarSharePhoneNumber
}

// A simple button, with text that should be sent when the button is pressed
type KeyboardButtonTypeText struct {
	meta
}

func (entity *KeyboardButtonTypeText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeText

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeText) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeText) GetType() string {
	return TypeKeyboardButtonTypeText
}

func (*KeyboardButtonTypeText) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeText
}

// A button that sends the user's phone number when pressed; available only in private chats
type KeyboardButtonTypeRequestPhoneNumber struct {
	meta
}

func (entity *KeyboardButtonTypeRequestPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestPhoneNumber) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestPhoneNumber) GetType() string {
	return TypeKeyboardButtonTypeRequestPhoneNumber
}

func (*KeyboardButtonTypeRequestPhoneNumber) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestPhoneNumber
}

// A button that sends the user's location when pressed; available only in private chats
type KeyboardButtonTypeRequestLocation struct {
	meta
}

func (entity *KeyboardButtonTypeRequestLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestLocation

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestLocation) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestLocation) GetType() string {
	return TypeKeyboardButtonTypeRequestLocation
}

func (*KeyboardButtonTypeRequestLocation) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestLocation
}

// A button that allows the user to create and send a poll when pressed; available only in private chats
type KeyboardButtonTypeRequestPoll struct {
	meta
	// If true, only regular polls must be allowed to create
	ForceRegular bool `json:"force_regular"`
	// If true, only polls in quiz mode must be allowed to create
	ForceQuiz bool `json:"force_quiz"`
}

func (entity *KeyboardButtonTypeRequestPoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButtonTypeRequestPoll

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButtonTypeRequestPoll) GetClass() string {
	return ClassKeyboardButtonType
}

func (*KeyboardButtonTypeRequestPoll) GetType() string {
	return TypeKeyboardButtonTypeRequestPoll
}

func (*KeyboardButtonTypeRequestPoll) KeyboardButtonTypeType() string {
	return TypeKeyboardButtonTypeRequestPoll
}

// Represents a single button in a bot keyboard
type KeyboardButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// Type of the button
	Type KeyboardButtonType `json:"type"`
}

func (entity *KeyboardButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub KeyboardButton

	return json.Marshal((*stub)(entity))
}

func (*KeyboardButton) GetClass() string {
	return ClassKeyboardButton
}

func (*KeyboardButton) GetType() string {
	return TypeKeyboardButton
}

func (keyboardButton *KeyboardButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	keyboardButton.Text = tmp.Text

	fieldType, _ := UnmarshalKeyboardButtonType(tmp.Type)
	keyboardButton.Type = fieldType

	return nil
}

// A button that opens a specified URL
type InlineKeyboardButtonTypeUrl struct {
	meta
	// HTTP or tg:// URL to open
	Url string `json:"url"`
}

func (entity *InlineKeyboardButtonTypeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeUrl

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeUrl) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeUrl) GetType() string {
	return TypeInlineKeyboardButtonTypeUrl
}

func (*InlineKeyboardButtonTypeUrl) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeUrl
}

// A button that opens a specified URL and automatically logs in in current user if they allowed to do that
type InlineKeyboardButtonTypeLoginUrl struct {
	meta
	// An HTTP URL to open
	Url string `json:"url"`
	// Unique button identifier
	Id int32 `json:"id"`
	// If non-empty, new text of the button in forwarded messages
	ForwardText string `json:"forward_text"`
}

func (entity *InlineKeyboardButtonTypeLoginUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeLoginUrl

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeLoginUrl) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeLoginUrl) GetType() string {
	return TypeInlineKeyboardButtonTypeLoginUrl
}

func (*InlineKeyboardButtonTypeLoginUrl) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeLoginUrl
}

// A button that sends a special callback query to a bot
type InlineKeyboardButtonTypeCallback struct {
	meta
	// Data to be sent to the bot via a callback query
	Data []byte `json:"data"`
}

func (entity *InlineKeyboardButtonTypeCallback) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallback

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallback) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallback) GetType() string {
	return TypeInlineKeyboardButtonTypeCallback
}

func (*InlineKeyboardButtonTypeCallback) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallback
}

// A button with a game that sends a special callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
type InlineKeyboardButtonTypeCallbackGame struct {
	meta
}

func (entity *InlineKeyboardButtonTypeCallbackGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeCallbackGame

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeCallbackGame) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeCallbackGame) GetType() string {
	return TypeInlineKeyboardButtonTypeCallbackGame
}

func (*InlineKeyboardButtonTypeCallbackGame) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeCallbackGame
}

// A button that forces an inline query to the bot to be inserted in the input field
type InlineKeyboardButtonTypeSwitchInline struct {
	meta
	// Inline query to be sent to the bot
	Query string `json:"query"`
	// True, if the inline query should be sent from the current chat
	InCurrentChat bool `json:"in_current_chat"`
}

func (entity *InlineKeyboardButtonTypeSwitchInline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeSwitchInline

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeSwitchInline) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeSwitchInline) GetType() string {
	return TypeInlineKeyboardButtonTypeSwitchInline
}

func (*InlineKeyboardButtonTypeSwitchInline) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeSwitchInline
}

// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
type InlineKeyboardButtonTypeBuy struct {
	meta
}

func (entity *InlineKeyboardButtonTypeBuy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButtonTypeBuy

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButtonTypeBuy) GetClass() string {
	return ClassInlineKeyboardButtonType
}

func (*InlineKeyboardButtonTypeBuy) GetType() string {
	return TypeInlineKeyboardButtonTypeBuy
}

func (*InlineKeyboardButtonTypeBuy) InlineKeyboardButtonTypeType() string {
	return TypeInlineKeyboardButtonTypeBuy
}

// Represents a single button in an inline keyboard
type InlineKeyboardButton struct {
	meta
	// Text of the button
	Text string `json:"text"`
	// Type of the button
	Type InlineKeyboardButtonType `json:"type"`
}

func (entity *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineKeyboardButton

	return json.Marshal((*stub)(entity))
}

func (*InlineKeyboardButton) GetClass() string {
	return ClassInlineKeyboardButton
}

func (*InlineKeyboardButton) GetType() string {
	return TypeInlineKeyboardButton
}

func (inlineKeyboardButton *InlineKeyboardButton) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text string          `json:"text"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inlineKeyboardButton.Text = tmp.Text

	fieldType, _ := UnmarshalInlineKeyboardButtonType(tmp.Type)
	inlineKeyboardButton.Type = fieldType

	return nil
}

// Instructs clients to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent
type ReplyMarkupRemoveKeyboard struct {
	meta
	// True, if the keyboard is removed only for the mentioned users or the target user of a reply
	IsPersonal bool `json:"is_personal"`
}

func (entity *ReplyMarkupRemoveKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupRemoveKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupRemoveKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupRemoveKeyboard) GetType() string {
	return TypeReplyMarkupRemoveKeyboard
}

func (*ReplyMarkupRemoveKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupRemoveKeyboard
}

// Instructs clients to force a reply to this message
type ReplyMarkupForceReply struct {
	meta
	// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
	IsPersonal bool `json:"is_personal"`
}

func (entity *ReplyMarkupForceReply) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupForceReply

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupForceReply) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupForceReply) GetType() string {
	return TypeReplyMarkupForceReply
}

func (*ReplyMarkupForceReply) ReplyMarkupType() string {
	return TypeReplyMarkupForceReply
}

// Contains a custom keyboard layout to quickly reply to bots
type ReplyMarkupShowKeyboard struct {
	meta
	// A list of rows of bot keyboard buttons
	Rows [][]*KeyboardButton `json:"rows"`
	// True, if the client needs to resize the keyboard vertically
	ResizeKeyboard bool `json:"resize_keyboard"`
	// True, if the client needs to hide the keyboard after use
	OneTime bool `json:"one_time"`
	// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
	IsPersonal bool `json:"is_personal"`
}

func (entity *ReplyMarkupShowKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupShowKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupShowKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupShowKeyboard) GetType() string {
	return TypeReplyMarkupShowKeyboard
}

func (*ReplyMarkupShowKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupShowKeyboard
}

// Contains an inline keyboard layout
type ReplyMarkupInlineKeyboard struct {
	meta
	// A list of rows of inline keyboard buttons
	Rows [][]*InlineKeyboardButton `json:"rows"`
}

func (entity *ReplyMarkupInlineKeyboard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ReplyMarkupInlineKeyboard

	return json.Marshal((*stub)(entity))
}

func (*ReplyMarkupInlineKeyboard) GetClass() string {
	return ClassReplyMarkup
}

func (*ReplyMarkupInlineKeyboard) GetType() string {
	return TypeReplyMarkupInlineKeyboard
}

func (*ReplyMarkupInlineKeyboard) ReplyMarkupType() string {
	return TypeReplyMarkupInlineKeyboard
}

// An HTTP url needs to be open
type LoginUrlInfoOpen struct {
	meta
	// The URL to open
	Url string `json:"url"`
	// True, if there is no need to show an ordinary open URL confirm
	SkipConfirm bool `json:"skip_confirm"`
}

func (entity *LoginUrlInfoOpen) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LoginUrlInfoOpen

	return json.Marshal((*stub)(entity))
}

func (*LoginUrlInfoOpen) GetClass() string {
	return ClassLoginUrlInfo
}

func (*LoginUrlInfoOpen) GetType() string {
	return TypeLoginUrlInfoOpen
}

func (*LoginUrlInfoOpen) LoginUrlInfoType() string {
	return TypeLoginUrlInfoOpen
}

// An authorization confirmation dialog needs to be shown to the user
type LoginUrlInfoRequestConfirmation struct {
	meta
	// An HTTP URL to be opened
	Url string `json:"url"`
	// A domain of the URL
	Domain string `json:"domain"`
	// User identifier of a bot linked with the website
	BotUserId int32 `json:"bot_user_id"`
	// True, if the user needs to be requested to give the permission to the bot to send them messages
	RequestWriteAccess bool `json:"request_write_access"`
}

func (entity *LoginUrlInfoRequestConfirmation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LoginUrlInfoRequestConfirmation

	return json.Marshal((*stub)(entity))
}

func (*LoginUrlInfoRequestConfirmation) GetClass() string {
	return ClassLoginUrlInfo
}

func (*LoginUrlInfoRequestConfirmation) GetType() string {
	return TypeLoginUrlInfoRequestConfirmation
}

func (*LoginUrlInfoRequestConfirmation) LoginUrlInfoType() string {
	return TypeLoginUrlInfoRequestConfirmation
}

// A plain text
type RichTextPlain struct {
	meta
	// Text
	Text string `json:"text"`
}

func (entity *RichTextPlain) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextPlain

	return json.Marshal((*stub)(entity))
}

func (*RichTextPlain) GetClass() string {
	return ClassRichText
}

func (*RichTextPlain) GetType() string {
	return TypeRichTextPlain
}

func (*RichTextPlain) RichTextType() string {
	return TypeRichTextPlain
}

// A bold rich text
type RichTextBold struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextBold) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextBold

	return json.Marshal((*stub)(entity))
}

func (*RichTextBold) GetClass() string {
	return ClassRichText
}

func (*RichTextBold) GetType() string {
	return TypeRichTextBold
}

func (*RichTextBold) RichTextType() string {
	return TypeRichTextBold
}

func (richTextBold *RichTextBold) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextBold.Text = fieldText

	return nil
}

// An italicized rich text
type RichTextItalic struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextItalic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextItalic

	return json.Marshal((*stub)(entity))
}

func (*RichTextItalic) GetClass() string {
	return ClassRichText
}

func (*RichTextItalic) GetType() string {
	return TypeRichTextItalic
}

func (*RichTextItalic) RichTextType() string {
	return TypeRichTextItalic
}

func (richTextItalic *RichTextItalic) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextItalic.Text = fieldText

	return nil
}

// An underlined rich text
type RichTextUnderline struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextUnderline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextUnderline

	return json.Marshal((*stub)(entity))
}

func (*RichTextUnderline) GetClass() string {
	return ClassRichText
}

func (*RichTextUnderline) GetType() string {
	return TypeRichTextUnderline
}

func (*RichTextUnderline) RichTextType() string {
	return TypeRichTextUnderline
}

func (richTextUnderline *RichTextUnderline) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextUnderline.Text = fieldText

	return nil
}

// A strikethrough rich text
type RichTextStrikethrough struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextStrikethrough) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextStrikethrough

	return json.Marshal((*stub)(entity))
}

func (*RichTextStrikethrough) GetClass() string {
	return ClassRichText
}

func (*RichTextStrikethrough) GetType() string {
	return TypeRichTextStrikethrough
}

func (*RichTextStrikethrough) RichTextType() string {
	return TypeRichTextStrikethrough
}

func (richTextStrikethrough *RichTextStrikethrough) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextStrikethrough.Text = fieldText

	return nil
}

// A fixed-width rich text
type RichTextFixed struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextFixed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextFixed

	return json.Marshal((*stub)(entity))
}

func (*RichTextFixed) GetClass() string {
	return ClassRichText
}

func (*RichTextFixed) GetType() string {
	return TypeRichTextFixed
}

func (*RichTextFixed) RichTextType() string {
	return TypeRichTextFixed
}

func (richTextFixed *RichTextFixed) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextFixed.Text = fieldText

	return nil
}

// A rich text URL link
type RichTextUrl struct {
	meta
	// Text
	Text RichText `json:"text"`
	// URL
	Url string `json:"url"`
	// True, if the URL has cached instant view server-side
	IsCached bool `json:"is_cached"`
}

func (entity *RichTextUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextUrl

	return json.Marshal((*stub)(entity))
}

func (*RichTextUrl) GetClass() string {
	return ClassRichText
}

func (*RichTextUrl) GetType() string {
	return TypeRichTextUrl
}

func (*RichTextUrl) RichTextType() string {
	return TypeRichTextUrl
}

func (richTextUrl *RichTextUrl) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		Url      string          `json:"url"`
		IsCached bool            `json:"is_cached"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextUrl.Url = tmp.Url
	richTextUrl.IsCached = tmp.IsCached

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextUrl.Text = fieldText

	return nil
}

// A rich text email link
type RichTextEmailAddress struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Email address
	EmailAddress string `json:"email_address"`
}

func (entity *RichTextEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*RichTextEmailAddress) GetClass() string {
	return ClassRichText
}

func (*RichTextEmailAddress) GetType() string {
	return TypeRichTextEmailAddress
}

func (*RichTextEmailAddress) RichTextType() string {
	return TypeRichTextEmailAddress
}

func (richTextEmailAddress *RichTextEmailAddress) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text         json.RawMessage `json:"text"`
		EmailAddress string          `json:"email_address"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextEmailAddress.EmailAddress = tmp.EmailAddress

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextEmailAddress.Text = fieldText

	return nil
}

// A subscript rich text
type RichTextSubscript struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextSubscript) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextSubscript

	return json.Marshal((*stub)(entity))
}

func (*RichTextSubscript) GetClass() string {
	return ClassRichText
}

func (*RichTextSubscript) GetType() string {
	return TypeRichTextSubscript
}

func (*RichTextSubscript) RichTextType() string {
	return TypeRichTextSubscript
}

func (richTextSubscript *RichTextSubscript) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextSubscript.Text = fieldText

	return nil
}

// A superscript rich text
type RichTextSuperscript struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextSuperscript) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextSuperscript

	return json.Marshal((*stub)(entity))
}

func (*RichTextSuperscript) GetClass() string {
	return ClassRichText
}

func (*RichTextSuperscript) GetType() string {
	return TypeRichTextSuperscript
}

func (*RichTextSuperscript) RichTextType() string {
	return TypeRichTextSuperscript
}

func (richTextSuperscript *RichTextSuperscript) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextSuperscript.Text = fieldText

	return nil
}

// A marked rich text
type RichTextMarked struct {
	meta
	// Text
	Text RichText `json:"text"`
}

func (entity *RichTextMarked) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextMarked

	return json.Marshal((*stub)(entity))
}

func (*RichTextMarked) GetClass() string {
	return ClassRichText
}

func (*RichTextMarked) GetType() string {
	return TypeRichTextMarked
}

func (*RichTextMarked) RichTextType() string {
	return TypeRichTextMarked
}

func (richTextMarked *RichTextMarked) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextMarked.Text = fieldText

	return nil
}

// A rich text phone number
type RichTextPhoneNumber struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *RichTextPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*RichTextPhoneNumber) GetClass() string {
	return ClassRichText
}

func (*RichTextPhoneNumber) GetType() string {
	return TypeRichTextPhoneNumber
}

func (*RichTextPhoneNumber) RichTextType() string {
	return TypeRichTextPhoneNumber
}

func (richTextPhoneNumber *RichTextPhoneNumber) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text        json.RawMessage `json:"text"`
		PhoneNumber string          `json:"phone_number"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextPhoneNumber.PhoneNumber = tmp.PhoneNumber

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextPhoneNumber.Text = fieldText

	return nil
}

// A small image inside the text
type RichTextIcon struct {
	meta
	// The image represented as a document. The image can be in GIF, JPEG or PNG format
	Document *Document `json:"document"`
	// Width of a bounding box in which the image should be shown; 0 if unknown
	Width int32 `json:"width"`
	// Height of a bounding box in which the image should be shown; 0 if unknown
	Height int32 `json:"height"`
}

func (entity *RichTextIcon) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextIcon

	return json.Marshal((*stub)(entity))
}

func (*RichTextIcon) GetClass() string {
	return ClassRichText
}

func (*RichTextIcon) GetType() string {
	return TypeRichTextIcon
}

func (*RichTextIcon) RichTextType() string {
	return TypeRichTextIcon
}

// A rich text anchor
type RichTextAnchor struct {
	meta
	// Text
	Text RichText `json:"text"`
	// Anchor name
	Name string `json:"name"`
}

func (entity *RichTextAnchor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTextAnchor

	return json.Marshal((*stub)(entity))
}

func (*RichTextAnchor) GetClass() string {
	return ClassRichText
}

func (*RichTextAnchor) GetType() string {
	return TypeRichTextAnchor
}

func (*RichTextAnchor) RichTextType() string {
	return TypeRichTextAnchor
}

func (richTextAnchor *RichTextAnchor) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
		Name string          `json:"name"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	richTextAnchor.Name = tmp.Name

	fieldText, _ := UnmarshalRichText(tmp.Text)
	richTextAnchor.Text = fieldText

	return nil
}

// A concatenation of rich texts
type RichTexts struct {
	meta
	// Texts
	Texts []RichText `json:"texts"`
}

func (entity *RichTexts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub RichTexts

	return json.Marshal((*stub)(entity))
}

func (*RichTexts) GetClass() string {
	return ClassRichText
}

func (*RichTexts) GetType() string {
	return TypeRichTexts
}

func (*RichTexts) RichTextType() string {
	return TypeRichTexts
}

// Contains a caption of an instant view web page block, consisting of a text and a trailing credit
type PageBlockCaption struct {
	meta
	// Content of the caption
	Text RichText `json:"text"`
	// Block credit (like HTML tag <cite>)
	Credit RichText `json:"credit"`
}

func (entity *PageBlockCaption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCaption

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCaption) GetClass() string {
	return ClassPageBlockCaption
}

func (*PageBlockCaption) GetType() string {
	return TypePageBlockCaption
}

func (pageBlockCaption *PageBlockCaption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockCaption.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockCaption.Credit = fieldCredit

	return nil
}

// Describes an item of a list page block
type PageBlockListItem struct {
	meta
	// Item label
	Label string `json:"label"`
	// Item blocks
	PageBlocks []PageBlock `json:"page_blocks"`
}

func (entity *PageBlockListItem) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockListItem

	return json.Marshal((*stub)(entity))
}

func (*PageBlockListItem) GetClass() string {
	return ClassPageBlockListItem
}

func (*PageBlockListItem) GetType() string {
	return TypePageBlockListItem
}

// The content should be left-aligned
type PageBlockHorizontalAlignmentLeft struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentLeft

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentLeft) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentLeft) GetType() string {
	return TypePageBlockHorizontalAlignmentLeft
}

func (*PageBlockHorizontalAlignmentLeft) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentLeft
}

// The content should be center-aligned
type PageBlockHorizontalAlignmentCenter struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentCenter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentCenter

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentCenter) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentCenter) GetType() string {
	return TypePageBlockHorizontalAlignmentCenter
}

func (*PageBlockHorizontalAlignmentCenter) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentCenter
}

// The content should be right-aligned
type PageBlockHorizontalAlignmentRight struct {
	meta
}

func (entity *PageBlockHorizontalAlignmentRight) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHorizontalAlignmentRight

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHorizontalAlignmentRight) GetClass() string {
	return ClassPageBlockHorizontalAlignment
}

func (*PageBlockHorizontalAlignmentRight) GetType() string {
	return TypePageBlockHorizontalAlignmentRight
}

func (*PageBlockHorizontalAlignmentRight) PageBlockHorizontalAlignmentType() string {
	return TypePageBlockHorizontalAlignmentRight
}

// The content should be top-aligned
type PageBlockVerticalAlignmentTop struct {
	meta
}

func (entity *PageBlockVerticalAlignmentTop) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentTop

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentTop) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentTop) GetType() string {
	return TypePageBlockVerticalAlignmentTop
}

func (*PageBlockVerticalAlignmentTop) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentTop
}

// The content should be middle-aligned
type PageBlockVerticalAlignmentMiddle struct {
	meta
}

func (entity *PageBlockVerticalAlignmentMiddle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentMiddle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentMiddle) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentMiddle) GetType() string {
	return TypePageBlockVerticalAlignmentMiddle
}

func (*PageBlockVerticalAlignmentMiddle) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentMiddle
}

// The content should be bottom-aligned
type PageBlockVerticalAlignmentBottom struct {
	meta
}

func (entity *PageBlockVerticalAlignmentBottom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVerticalAlignmentBottom

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVerticalAlignmentBottom) GetClass() string {
	return ClassPageBlockVerticalAlignment
}

func (*PageBlockVerticalAlignmentBottom) GetType() string {
	return TypePageBlockVerticalAlignmentBottom
}

func (*PageBlockVerticalAlignmentBottom) PageBlockVerticalAlignmentType() string {
	return TypePageBlockVerticalAlignmentBottom
}

// Represents a cell of a table
type PageBlockTableCell struct {
	meta
	// Cell text; may be null. If the text is null, then the cell should be invisible
	Text RichText `json:"text"`
	// True, if it is a header cell
	IsHeader bool `json:"is_header"`
	// The number of columns the cell should span
	Colspan int32 `json:"colspan"`
	// The number of rows the cell should span
	Rowspan int32 `json:"rowspan"`
	// Horizontal cell content alignment
	Align PageBlockHorizontalAlignment `json:"align"`
	// Vertical cell content alignment
	Valign PageBlockVerticalAlignment `json:"valign"`
}

func (entity *PageBlockTableCell) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTableCell

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTableCell) GetClass() string {
	return ClassPageBlockTableCell
}

func (*PageBlockTableCell) GetType() string {
	return TypePageBlockTableCell
}

func (pageBlockTableCell *PageBlockTableCell) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		IsHeader bool            `json:"is_header"`
		Colspan  int32           `json:"colspan"`
		Rowspan  int32           `json:"rowspan"`
		Align    json.RawMessage `json:"align"`
		Valign   json.RawMessage `json:"valign"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockTableCell.IsHeader = tmp.IsHeader
	pageBlockTableCell.Colspan = tmp.Colspan
	pageBlockTableCell.Rowspan = tmp.Rowspan

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockTableCell.Text = fieldText

	fieldAlign, _ := UnmarshalPageBlockHorizontalAlignment(tmp.Align)
	pageBlockTableCell.Align = fieldAlign

	fieldValign, _ := UnmarshalPageBlockVerticalAlignment(tmp.Valign)
	pageBlockTableCell.Valign = fieldValign

	return nil
}

// Contains information about a related article
type PageBlockRelatedArticle struct {
	meta
	// Related article URL
	Url string `json:"url"`
	// Article title; may be empty
	Title string `json:"title"`
	// Article description; may be empty
	Description string `json:"description"`
	// Article photo; may be null
	Photo *Photo `json:"photo"`
	// Article author; may be empty
	Author string `json:"author"`
	// Point in time (Unix timestamp) when the article was published; 0 if unknown
	PublishDate int32 `json:"publish_date"`
}

func (entity *PageBlockRelatedArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockRelatedArticle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockRelatedArticle) GetClass() string {
	return ClassPageBlockRelatedArticle
}

func (*PageBlockRelatedArticle) GetType() string {
	return TypePageBlockRelatedArticle
}

// The title of a page
type PageBlockTitle struct {
	meta
	// Title
	Title RichText `json:"title"`
}

func (entity *PageBlockTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTitle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTitle) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockTitle) GetType() string {
	return TypePageBlockTitle
}

func (*PageBlockTitle) PageBlockType() string {
	return TypePageBlockTitle
}

func (pageBlockTitle *PageBlockTitle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Title json.RawMessage `json:"title"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldTitle, _ := UnmarshalRichText(tmp.Title)
	pageBlockTitle.Title = fieldTitle

	return nil
}

// The subtitle of a page
type PageBlockSubtitle struct {
	meta
	// Subtitle
	Subtitle RichText `json:"subtitle"`
}

func (entity *PageBlockSubtitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSubtitle

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSubtitle) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSubtitle) GetType() string {
	return TypePageBlockSubtitle
}

func (*PageBlockSubtitle) PageBlockType() string {
	return TypePageBlockSubtitle
}

func (pageBlockSubtitle *PageBlockSubtitle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Subtitle json.RawMessage `json:"subtitle"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldSubtitle, _ := UnmarshalRichText(tmp.Subtitle)
	pageBlockSubtitle.Subtitle = fieldSubtitle

	return nil
}

// The author and publishing date of a page
type PageBlockAuthorDate struct {
	meta
	// Author
	Author RichText `json:"author"`
	// Point in time (Unix timestamp) when the article was published; 0 if unknown
	PublishDate int32 `json:"publish_date"`
}

func (entity *PageBlockAuthorDate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAuthorDate

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAuthorDate) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAuthorDate) GetType() string {
	return TypePageBlockAuthorDate
}

func (*PageBlockAuthorDate) PageBlockType() string {
	return TypePageBlockAuthorDate
}

func (pageBlockAuthorDate *PageBlockAuthorDate) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Author      json.RawMessage `json:"author"`
		PublishDate int32           `json:"publish_date"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockAuthorDate.PublishDate = tmp.PublishDate

	fieldAuthor, _ := UnmarshalRichText(tmp.Author)
	pageBlockAuthorDate.Author = fieldAuthor

	return nil
}

// A header
type PageBlockHeader struct {
	meta
	// Header
	Header RichText `json:"header"`
}

func (entity *PageBlockHeader) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockHeader

	return json.Marshal((*stub)(entity))
}

func (*PageBlockHeader) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockHeader) GetType() string {
	return TypePageBlockHeader
}

func (*PageBlockHeader) PageBlockType() string {
	return TypePageBlockHeader
}

func (pageBlockHeader *PageBlockHeader) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header json.RawMessage `json:"header"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockHeader.Header = fieldHeader

	return nil
}

// A subheader
type PageBlockSubheader struct {
	meta
	// Subheader
	Subheader RichText `json:"subheader"`
}

func (entity *PageBlockSubheader) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSubheader

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSubheader) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSubheader) GetType() string {
	return TypePageBlockSubheader
}

func (*PageBlockSubheader) PageBlockType() string {
	return TypePageBlockSubheader
}

func (pageBlockSubheader *PageBlockSubheader) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Subheader json.RawMessage `json:"subheader"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldSubheader, _ := UnmarshalRichText(tmp.Subheader)
	pageBlockSubheader.Subheader = fieldSubheader

	return nil
}

// A kicker
type PageBlockKicker struct {
	meta
	// Kicker
	Kicker RichText `json:"kicker"`
}

func (entity *PageBlockKicker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockKicker

	return json.Marshal((*stub)(entity))
}

func (*PageBlockKicker) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockKicker) GetType() string {
	return TypePageBlockKicker
}

func (*PageBlockKicker) PageBlockType() string {
	return TypePageBlockKicker
}

func (pageBlockKicker *PageBlockKicker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Kicker json.RawMessage `json:"kicker"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldKicker, _ := UnmarshalRichText(tmp.Kicker)
	pageBlockKicker.Kicker = fieldKicker

	return nil
}

// A text paragraph
type PageBlockParagraph struct {
	meta
	// Paragraph text
	Text RichText `json:"text"`
}

func (entity *PageBlockParagraph) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockParagraph

	return json.Marshal((*stub)(entity))
}

func (*PageBlockParagraph) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockParagraph) GetType() string {
	return TypePageBlockParagraph
}

func (*PageBlockParagraph) PageBlockType() string {
	return TypePageBlockParagraph
}

func (pageBlockParagraph *PageBlockParagraph) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text json.RawMessage `json:"text"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockParagraph.Text = fieldText

	return nil
}

// A preformatted text paragraph
type PageBlockPreformatted struct {
	meta
	// Paragraph text
	Text RichText `json:"text"`
	// Programming language for which the text should be formatted
	Language string `json:"language"`
}

func (entity *PageBlockPreformatted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPreformatted

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPreformatted) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPreformatted) GetType() string {
	return TypePageBlockPreformatted
}

func (*PageBlockPreformatted) PageBlockType() string {
	return TypePageBlockPreformatted
}

func (pageBlockPreformatted *PageBlockPreformatted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text     json.RawMessage `json:"text"`
		Language string          `json:"language"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockPreformatted.Language = tmp.Language

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockPreformatted.Text = fieldText

	return nil
}

// The footer of a page
type PageBlockFooter struct {
	meta
	// Footer
	Footer RichText `json:"footer"`
}

func (entity *PageBlockFooter) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockFooter

	return json.Marshal((*stub)(entity))
}

func (*PageBlockFooter) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockFooter) GetType() string {
	return TypePageBlockFooter
}

func (*PageBlockFooter) PageBlockType() string {
	return TypePageBlockFooter
}

func (pageBlockFooter *PageBlockFooter) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Footer json.RawMessage `json:"footer"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFooter, _ := UnmarshalRichText(tmp.Footer)
	pageBlockFooter.Footer = fieldFooter

	return nil
}

// An empty block separating a page
type PageBlockDivider struct {
	meta
}

func (entity *PageBlockDivider) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockDivider

	return json.Marshal((*stub)(entity))
}

func (*PageBlockDivider) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockDivider) GetType() string {
	return TypePageBlockDivider
}

func (*PageBlockDivider) PageBlockType() string {
	return TypePageBlockDivider
}

// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
type PageBlockAnchor struct {
	meta
	// Name of the anchor
	Name string `json:"name"`
}

func (entity *PageBlockAnchor) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAnchor

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAnchor) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAnchor) GetType() string {
	return TypePageBlockAnchor
}

func (*PageBlockAnchor) PageBlockType() string {
	return TypePageBlockAnchor
}

// A list of data blocks
type PageBlockList struct {
	meta
	// The items of the list
	Items []*PageBlockListItem `json:"items"`
}

func (entity *PageBlockList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockList

	return json.Marshal((*stub)(entity))
}

func (*PageBlockList) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockList) GetType() string {
	return TypePageBlockList
}

func (*PageBlockList) PageBlockType() string {
	return TypePageBlockList
}

// A block quote
type PageBlockBlockQuote struct {
	meta
	// Quote text
	Text RichText `json:"text"`
	// Quote credit
	Credit RichText `json:"credit"`
}

func (entity *PageBlockBlockQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockBlockQuote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockBlockQuote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockBlockQuote) GetType() string {
	return TypePageBlockBlockQuote
}

func (*PageBlockBlockQuote) PageBlockType() string {
	return TypePageBlockBlockQuote
}

func (pageBlockBlockQuote *PageBlockBlockQuote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockBlockQuote.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockBlockQuote.Credit = fieldCredit

	return nil
}

// A pull quote
type PageBlockPullQuote struct {
	meta
	// Quote text
	Text RichText `json:"text"`
	// Quote credit
	Credit RichText `json:"credit"`
}

func (entity *PageBlockPullQuote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPullQuote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPullQuote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPullQuote) GetType() string {
	return TypePageBlockPullQuote
}

func (*PageBlockPullQuote) PageBlockType() string {
	return TypePageBlockPullQuote
}

func (pageBlockPullQuote *PageBlockPullQuote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Text   json.RawMessage `json:"text"`
		Credit json.RawMessage `json:"credit"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldText, _ := UnmarshalRichText(tmp.Text)
	pageBlockPullQuote.Text = fieldText

	fieldCredit, _ := UnmarshalRichText(tmp.Credit)
	pageBlockPullQuote.Credit = fieldCredit

	return nil
}

// An animation
type PageBlockAnimation struct {
	meta
	// Animation file; may be null
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the animation should be played automatically
	NeedAutoplay bool `json:"need_autoplay"`
}

func (entity *PageBlockAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAnimation

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAnimation) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAnimation) GetType() string {
	return TypePageBlockAnimation
}

func (*PageBlockAnimation) PageBlockType() string {
	return TypePageBlockAnimation
}

// An audio file
type PageBlockAudio struct {
	meta
	// Audio file; may be null
	Audio *Audio `json:"audio"`
	// Audio file caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockAudio

	return json.Marshal((*stub)(entity))
}

func (*PageBlockAudio) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockAudio) GetType() string {
	return TypePageBlockAudio
}

func (*PageBlockAudio) PageBlockType() string {
	return TypePageBlockAudio
}

// A photo
type PageBlockPhoto struct {
	meta
	// Photo file; may be null
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *PageBlockCaption `json:"caption"`
	// URL that needs to be opened when the photo is clicked
	Url string `json:"url"`
}

func (entity *PageBlockPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockPhoto

	return json.Marshal((*stub)(entity))
}

func (*PageBlockPhoto) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockPhoto) GetType() string {
	return TypePageBlockPhoto
}

func (*PageBlockPhoto) PageBlockType() string {
	return TypePageBlockPhoto
}

// A video
type PageBlockVideo struct {
	meta
	// Video file; may be null
	Video *Video `json:"video"`
	// Video caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the video should be played automatically
	NeedAutoplay bool `json:"need_autoplay"`
	// True, if the video should be looped
	IsLooped bool `json:"is_looped"`
}

func (entity *PageBlockVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVideo

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVideo) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockVideo) GetType() string {
	return TypePageBlockVideo
}

func (*PageBlockVideo) PageBlockType() string {
	return TypePageBlockVideo
}

// A voice note
type PageBlockVoiceNote struct {
	meta
	// Voice note; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// Voice note caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*PageBlockVoiceNote) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockVoiceNote) GetType() string {
	return TypePageBlockVoiceNote
}

func (*PageBlockVoiceNote) PageBlockType() string {
	return TypePageBlockVoiceNote
}

// A page cover
type PageBlockCover struct {
	meta
	// Cover
	Cover PageBlock `json:"cover"`
}

func (entity *PageBlockCover) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCover

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCover) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockCover) GetType() string {
	return TypePageBlockCover
}

func (*PageBlockCover) PageBlockType() string {
	return TypePageBlockCover
}

func (pageBlockCover *PageBlockCover) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Cover json.RawMessage `json:"cover"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldCover, _ := UnmarshalPageBlock(tmp.Cover)
	pageBlockCover.Cover = fieldCover

	return nil
}

// An embedded web page
type PageBlockEmbedded struct {
	meta
	// Web page URL, if available
	Url string `json:"url"`
	// HTML-markup of the embedded page
	Html string `json:"html"`
	// Poster photo, if available; may be null
	PosterPhoto *Photo `json:"poster_photo"`
	// Block width; 0 if unknown
	Width int32 `json:"width"`
	// Block height; 0 if unknown
	Height int32 `json:"height"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
	// True, if the block should be full width
	IsFullWidth bool `json:"is_full_width"`
	// True, if scrolling should be allowed
	AllowScrolling bool `json:"allow_scrolling"`
}

func (entity *PageBlockEmbedded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockEmbedded

	return json.Marshal((*stub)(entity))
}

func (*PageBlockEmbedded) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockEmbedded) GetType() string {
	return TypePageBlockEmbedded
}

func (*PageBlockEmbedded) PageBlockType() string {
	return TypePageBlockEmbedded
}

// An embedded post
type PageBlockEmbeddedPost struct {
	meta
	// Web page URL
	Url string `json:"url"`
	// Post author
	Author string `json:"author"`
	// Post author photo; may be null
	AuthorPhoto *Photo `json:"author_photo"`
	// Point in time (Unix timestamp) when the post was created; 0 if unknown
	Date int32 `json:"date"`
	// Post content
	PageBlocks []PageBlock `json:"page_blocks"`
	// Post caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockEmbeddedPost) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockEmbeddedPost

	return json.Marshal((*stub)(entity))
}

func (*PageBlockEmbeddedPost) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockEmbeddedPost) GetType() string {
	return TypePageBlockEmbeddedPost
}

func (*PageBlockEmbeddedPost) PageBlockType() string {
	return TypePageBlockEmbeddedPost
}

// A collage
type PageBlockCollage struct {
	meta
	// Collage item contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockCollage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockCollage

	return json.Marshal((*stub)(entity))
}

func (*PageBlockCollage) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockCollage) GetType() string {
	return TypePageBlockCollage
}

func (*PageBlockCollage) PageBlockType() string {
	return TypePageBlockCollage
}

// A slideshow
type PageBlockSlideshow struct {
	meta
	// Slideshow item contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockSlideshow) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockSlideshow

	return json.Marshal((*stub)(entity))
}

func (*PageBlockSlideshow) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockSlideshow) GetType() string {
	return TypePageBlockSlideshow
}

func (*PageBlockSlideshow) PageBlockType() string {
	return TypePageBlockSlideshow
}

// A link to a chat
type PageBlockChatLink struct {
	meta
	// Chat title
	Title string `json:"title"`
	// Chat photo; may be null
	Photo *ChatPhoto `json:"photo"`
	// Chat username, by which all other information about the chat should be resolved
	Username string `json:"username"`
}

func (entity *PageBlockChatLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockChatLink

	return json.Marshal((*stub)(entity))
}

func (*PageBlockChatLink) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockChatLink) GetType() string {
	return TypePageBlockChatLink
}

func (*PageBlockChatLink) PageBlockType() string {
	return TypePageBlockChatLink
}

// A table
type PageBlockTable struct {
	meta
	// Table caption
	Caption RichText `json:"caption"`
	// Table cells
	Cells [][]*PageBlockTableCell `json:"cells"`
	// True, if the table is bordered
	IsBordered bool `json:"is_bordered"`
	// True, if the table is striped
	IsStriped bool `json:"is_striped"`
}

func (entity *PageBlockTable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockTable

	return json.Marshal((*stub)(entity))
}

func (*PageBlockTable) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockTable) GetType() string {
	return TypePageBlockTable
}

func (*PageBlockTable) PageBlockType() string {
	return TypePageBlockTable
}

func (pageBlockTable *PageBlockTable) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Caption    json.RawMessage         `json:"caption"`
		Cells      [][]*PageBlockTableCell `json:"cells"`
		IsBordered bool                    `json:"is_bordered"`
		IsStriped  bool                    `json:"is_striped"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockTable.Cells = tmp.Cells
	pageBlockTable.IsBordered = tmp.IsBordered
	pageBlockTable.IsStriped = tmp.IsStriped

	fieldCaption, _ := UnmarshalRichText(tmp.Caption)
	pageBlockTable.Caption = fieldCaption

	return nil
}

// A collapsible block
type PageBlockDetails struct {
	meta
	// Always visible heading for the block
	Header RichText `json:"header"`
	// Block contents
	PageBlocks []PageBlock `json:"page_blocks"`
	// True, if the block is open by default
	IsOpen bool `json:"is_open"`
}

func (entity *PageBlockDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockDetails

	return json.Marshal((*stub)(entity))
}

func (*PageBlockDetails) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockDetails) GetType() string {
	return TypePageBlockDetails
}

func (*PageBlockDetails) PageBlockType() string {
	return TypePageBlockDetails
}

func (pageBlockDetails *PageBlockDetails) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header     json.RawMessage `json:"header"`
		PageBlocks []PageBlock     `json:"page_blocks"`
		IsOpen     bool            `json:"is_open"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockDetails.PageBlocks = tmp.PageBlocks
	pageBlockDetails.IsOpen = tmp.IsOpen

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockDetails.Header = fieldHeader

	return nil
}

// Related articles
type PageBlockRelatedArticles struct {
	meta
	// Block header
	Header RichText `json:"header"`
	// List of related articles
	Articles []*PageBlockRelatedArticle `json:"articles"`
}

func (entity *PageBlockRelatedArticles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockRelatedArticles

	return json.Marshal((*stub)(entity))
}

func (*PageBlockRelatedArticles) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockRelatedArticles) GetType() string {
	return TypePageBlockRelatedArticles
}

func (*PageBlockRelatedArticles) PageBlockType() string {
	return TypePageBlockRelatedArticles
}

func (pageBlockRelatedArticles *PageBlockRelatedArticles) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Header   json.RawMessage            `json:"header"`
		Articles []*PageBlockRelatedArticle `json:"articles"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	pageBlockRelatedArticles.Articles = tmp.Articles

	fieldHeader, _ := UnmarshalRichText(tmp.Header)
	pageBlockRelatedArticles.Header = fieldHeader

	return nil
}

// A map
type PageBlockMap struct {
	meta
	// Location of the map center
	Location *Location `json:"location"`
	// Map zoom level
	Zoom int32 `json:"zoom"`
	// Map width
	Width int32 `json:"width"`
	// Map height
	Height int32 `json:"height"`
	// Block caption
	Caption *PageBlockCaption `json:"caption"`
}

func (entity *PageBlockMap) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PageBlockMap

	return json.Marshal((*stub)(entity))
}

func (*PageBlockMap) GetClass() string {
	return ClassPageBlock
}

func (*PageBlockMap) GetType() string {
	return TypePageBlockMap
}

func (*PageBlockMap) PageBlockType() string {
	return TypePageBlockMap
}

// Describes an instant view page for a web page
type WebPageInstantView struct {
	meta
	// Content of the web page
	PageBlocks []PageBlock `json:"page_blocks"`
	// Version of the instant view, currently can be 1 or 2
	Version int32 `json:"version"`
	// Instant view URL; may be different from WebPage.url and must be used for the correct anchors handling
	Url string `json:"url"`
	// True, if the instant view must be shown from right to left
	IsRtl bool `json:"is_rtl"`
	// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
	IsFull bool `json:"is_full"`
}

func (entity *WebPageInstantView) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebPageInstantView

	return json.Marshal((*stub)(entity))
}

func (*WebPageInstantView) GetClass() string {
	return ClassWebPageInstantView
}

func (*WebPageInstantView) GetType() string {
	return TypeWebPageInstantView
}

// Describes a web page preview
type WebPage struct {
	meta
	// Original URL of the link
	Url string `json:"url"`
	// URL to display
	DisplayUrl string `json:"display_url"`
	// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
	Type string `json:"type"`
	// Short name of the site (e.g., Google Docs, App Store)
	SiteName string `json:"site_name"`
	// Title of the content
	Title string `json:"title"`
	// Description of the content
	Description string `json:"description"`
	// Image representing the content; may be null
	Photo *Photo `json:"photo"`
	// URL to show in the embedded preview
	EmbedUrl string `json:"embed_url"`
	// MIME type of the embedded preview, (e.g., text/html or video/mp4)
	EmbedType string `json:"embed_type"`
	// Width of the embedded preview
	EmbedWidth int32 `json:"embed_width"`
	// Height of the embedded preview
	EmbedHeight int32 `json:"embed_height"`
	// Duration of the content, in seconds
	Duration int32 `json:"duration"`
	// Author of the content
	Author string `json:"author"`
	// Preview of the content as an animation, if available; may be null
	Animation *Animation `json:"animation"`
	// Preview of the content as an audio file, if available; may be null
	Audio *Audio `json:"audio"`
	// Preview of the content as a document, if available (currently only available for small PDF files and ZIP archives); may be null
	Document *Document `json:"document"`
	// Preview of the content as a sticker for small WEBP files, if available; may be null
	Sticker *Sticker `json:"sticker"`
	// Preview of the content as a video, if available; may be null
	Video *Video `json:"video"`
	// Preview of the content as a video note, if available; may be null
	VideoNote *VideoNote `json:"video_note"`
	// Preview of the content as a voice note, if available; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// Version of instant view, available for the web page (currently can be 1 or 2), 0 if none
	InstantViewVersion int32 `json:"instant_view_version"`
}

func (entity *WebPage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub WebPage

	return json.Marshal((*stub)(entity))
}

func (*WebPage) GetClass() string {
	return ClassWebPage
}

func (*WebPage) GetType() string {
	return TypeWebPage
}

// Describes an address
type Address struct {
	meta
	// A two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// State, if applicable
	State string `json:"state"`
	// City
	City string `json:"city"`
	// First line of the address
	StreetLine1 string `json:"street_line1"`
	// Second line of the address
	StreetLine2 string `json:"street_line2"`
	// Address postal code
	PostalCode string `json:"postal_code"`
}

func (entity *Address) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Address

	return json.Marshal((*stub)(entity))
}

func (*Address) GetClass() string {
	return ClassAddress
}

func (*Address) GetType() string {
	return TypeAddress
}

// Portion of the price of a product (e.g., "delivery cost", "tax amount")
type LabeledPricePart struct {
	meta
	// Label for this portion of the product price
	Label string `json:"label"`
	// Currency amount in minimal quantity of the currency
	Amount int64 `json:"amount"`
}

func (entity *LabeledPricePart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LabeledPricePart

	return json.Marshal((*stub)(entity))
}

func (*LabeledPricePart) GetClass() string {
	return ClassLabeledPricePart
}

func (*LabeledPricePart) GetType() string {
	return TypeLabeledPricePart
}

// Product invoice
type Invoice struct {
	meta
	// ISO 4217 currency code
	Currency string `json:"currency"`
	// A list of objects used to calculate the total price of the product
	PriceParts []*LabeledPricePart `json:"price_parts"`
	// True, if the payment is a test payment
	IsTest bool `json:"is_test"`
	// True, if the user's name is needed for payment
	NeedName bool `json:"need_name"`
	// True, if the user's phone number is needed for payment
	NeedPhoneNumber bool `json:"need_phone_number"`
	// True, if the user's email address is needed for payment
	NeedEmailAddress bool `json:"need_email_address"`
	// True, if the user's shipping address is needed for payment
	NeedShippingAddress bool `json:"need_shipping_address"`
	// True, if the user's phone number will be sent to the provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider"`
	// True, if the user's email address will be sent to the provider
	SendEmailAddressToProvider bool `json:"send_email_address_to_provider"`
	// True, if the total price depends on the shipping method
	IsFlexible bool `json:"is_flexible"`
}

func (entity *Invoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Invoice

	return json.Marshal((*stub)(entity))
}

func (*Invoice) GetClass() string {
	return ClassInvoice
}

func (*Invoice) GetType() string {
	return TypeInvoice
}

// Order information
type OrderInfo struct {
	meta
	// Name of the user
	Name string `json:"name"`
	// Phone number of the user
	PhoneNumber string `json:"phone_number"`
	// Email address of the user
	EmailAddress string `json:"email_address"`
	// Shipping address for this order; may be null
	ShippingAddress *Address `json:"shipping_address"`
}

func (entity *OrderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OrderInfo

	return json.Marshal((*stub)(entity))
}

func (*OrderInfo) GetClass() string {
	return ClassOrderInfo
}

func (*OrderInfo) GetType() string {
	return TypeOrderInfo
}

// One shipping option
type ShippingOption struct {
	meta
	// Shipping option identifier
	Id string `json:"id"`
	// Option title
	Title string `json:"title"`
	// A list of objects used to calculate the total shipping costs
	PriceParts []*LabeledPricePart `json:"price_parts"`
}

func (entity *ShippingOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ShippingOption

	return json.Marshal((*stub)(entity))
}

func (*ShippingOption) GetClass() string {
	return ClassShippingOption
}

func (*ShippingOption) GetType() string {
	return TypeShippingOption
}

// Contains information about saved card credentials
type SavedCredentials struct {
	meta
	// Unique identifier of the saved credentials
	Id string `json:"id"`
	// Title of the saved credentials
	Title string `json:"title"`
}

func (entity *SavedCredentials) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SavedCredentials

	return json.Marshal((*stub)(entity))
}

func (*SavedCredentials) GetClass() string {
	return ClassSavedCredentials
}

func (*SavedCredentials) GetType() string {
	return TypeSavedCredentials
}

// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
type InputCredentialsSaved struct {
	meta
	// Identifier of the saved credentials
	SavedCredentialsId string `json:"saved_credentials_id"`
}

func (entity *InputCredentialsSaved) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsSaved

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsSaved) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsSaved) GetType() string {
	return TypeInputCredentialsSaved
}

func (*InputCredentialsSaved) InputCredentialsType() string {
	return TypeInputCredentialsSaved
}

// Applies if a user enters new credentials on a payment provider website
type InputCredentialsNew struct {
	meta
	// Contains JSON-encoded data with a credential identifier from the payment provider
	Data string `json:"data"`
	// True, if the credential identifier can be saved on the server side
	AllowSave bool `json:"allow_save"`
}

func (entity *InputCredentialsNew) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsNew

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsNew) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsNew) GetType() string {
	return TypeInputCredentialsNew
}

func (*InputCredentialsNew) InputCredentialsType() string {
	return TypeInputCredentialsNew
}

// Applies if a user enters new credentials using Android Pay
type InputCredentialsAndroidPay struct {
	meta
	// JSON-encoded data with the credential identifier
	Data string `json:"data"`
}

func (entity *InputCredentialsAndroidPay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsAndroidPay

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsAndroidPay) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsAndroidPay) GetType() string {
	return TypeInputCredentialsAndroidPay
}

func (*InputCredentialsAndroidPay) InputCredentialsType() string {
	return TypeInputCredentialsAndroidPay
}

// Applies if a user enters new credentials using Apple Pay
type InputCredentialsApplePay struct {
	meta
	// JSON-encoded data with the credential identifier
	Data string `json:"data"`
}

func (entity *InputCredentialsApplePay) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputCredentialsApplePay

	return json.Marshal((*stub)(entity))
}

func (*InputCredentialsApplePay) GetClass() string {
	return ClassInputCredentials
}

func (*InputCredentialsApplePay) GetType() string {
	return TypeInputCredentialsApplePay
}

func (*InputCredentialsApplePay) InputCredentialsType() string {
	return TypeInputCredentialsApplePay
}

// Stripe payment provider
type PaymentsProviderStripe struct {
	meta
	// Stripe API publishable key
	PublishableKey string `json:"publishable_key"`
	// True, if the user country must be provided
	NeedCountry bool `json:"need_country"`
	// True, if the user ZIP/postal code must be provided
	NeedPostalCode bool `json:"need_postal_code"`
	// True, if the cardholder name must be provided
	NeedCardholderName bool `json:"need_cardholder_name"`
}

func (entity *PaymentsProviderStripe) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentsProviderStripe

	return json.Marshal((*stub)(entity))
}

func (*PaymentsProviderStripe) GetClass() string {
	return ClassPaymentsProviderStripe
}

func (*PaymentsProviderStripe) GetType() string {
	return TypePaymentsProviderStripe
}

// Contains information about an invoice payment form
type PaymentForm struct {
	meta
	// Full information of the invoice
	Invoice *Invoice `json:"invoice"`
	// Payment form URL
	Url string `json:"url"`
	// Contains information about the payment provider, if available, to support it natively without the need for opening the URL; may be null
	PaymentsProvider *PaymentsProviderStripe `json:"payments_provider"`
	// Saved server-side order information; may be null
	SavedOrderInfo *OrderInfo `json:"saved_order_info"`
	// Contains information about saved card credentials; may be null
	SavedCredentials *SavedCredentials `json:"saved_credentials"`
	// True, if the user can choose to save credentials
	CanSaveCredentials bool `json:"can_save_credentials"`
	// True, if the user will be able to save credentials protected by a password they set up
	NeedPassword bool `json:"need_password"`
}

func (entity *PaymentForm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentForm

	return json.Marshal((*stub)(entity))
}

func (*PaymentForm) GetClass() string {
	return ClassPaymentForm
}

func (*PaymentForm) GetType() string {
	return TypePaymentForm
}

// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options
type ValidatedOrderInfo struct {
	meta
	// Temporary identifier of the order information
	OrderInfoId string `json:"order_info_id"`
	// Available shipping options
	ShippingOptions []*ShippingOption `json:"shipping_options"`
}

func (entity *ValidatedOrderInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ValidatedOrderInfo

	return json.Marshal((*stub)(entity))
}

func (*ValidatedOrderInfo) GetClass() string {
	return ClassValidatedOrderInfo
}

func (*ValidatedOrderInfo) GetType() string {
	return TypeValidatedOrderInfo
}

// Contains the result of a payment request
type PaymentResult struct {
	meta
	// True, if the payment request was successful; otherwise the verification_url will be not empty
	Success bool `json:"success"`
	// URL for additional payment credentials verification
	VerificationUrl string `json:"verification_url"`
}

func (entity *PaymentResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentResult

	return json.Marshal((*stub)(entity))
}

func (*PaymentResult) GetClass() string {
	return ClassPaymentResult
}

func (*PaymentResult) GetType() string {
	return TypePaymentResult
}

// Contains information about a successful payment
type PaymentReceipt struct {
	meta
	// Point in time (Unix timestamp) when the payment was made
	Date int32 `json:"date"`
	// User identifier of the payment provider bot
	PaymentsProviderUserId int32 `json:"payments_provider_user_id"`
	// Contains information about the invoice
	Invoice *Invoice `json:"invoice"`
	// Contains order information; may be null
	OrderInfo *OrderInfo `json:"order_info"`
	// Chosen shipping option; may be null
	ShippingOption *ShippingOption `json:"shipping_option"`
	// Title of the saved credentials
	CredentialsTitle string `json:"credentials_title"`
}

func (entity *PaymentReceipt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PaymentReceipt

	return json.Marshal((*stub)(entity))
}

func (*PaymentReceipt) GetClass() string {
	return ClassPaymentReceipt
}

func (*PaymentReceipt) GetType() string {
	return TypePaymentReceipt
}

// File with the date it was uploaded
type DatedFile struct {
	meta
	// The file
	File *File `json:"file"`
	// Point in time (Unix timestamp) when the file was uploaded
	Date int32 `json:"date"`
}

func (entity *DatedFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DatedFile

	return json.Marshal((*stub)(entity))
}

func (*DatedFile) GetClass() string {
	return ClassDatedFile
}

func (*DatedFile) GetType() string {
	return TypeDatedFile
}

// A Telegram Passport element containing the user's personal details
type PassportElementTypePersonalDetails struct {
	meta
}

func (entity *PassportElementTypePersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePersonalDetails) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePersonalDetails) GetType() string {
	return TypePassportElementTypePersonalDetails
}

func (*PassportElementTypePersonalDetails) PassportElementTypeType() string {
	return TypePassportElementTypePersonalDetails
}

// A Telegram Passport element containing the user's passport
type PassportElementTypePassport struct {
	meta
}

func (entity *PassportElementTypePassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePassport) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePassport) GetType() string {
	return TypePassportElementTypePassport
}

func (*PassportElementTypePassport) PassportElementTypeType() string {
	return TypePassportElementTypePassport
}

// A Telegram Passport element containing the user's driver license
type PassportElementTypeDriverLicense struct {
	meta
}

func (entity *PassportElementTypeDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeDriverLicense) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeDriverLicense) GetType() string {
	return TypePassportElementTypeDriverLicense
}

func (*PassportElementTypeDriverLicense) PassportElementTypeType() string {
	return TypePassportElementTypeDriverLicense
}

// A Telegram Passport element containing the user's identity card
type PassportElementTypeIdentityCard struct {
	meta
}

func (entity *PassportElementTypeIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeIdentityCard) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeIdentityCard) GetType() string {
	return TypePassportElementTypeIdentityCard
}

func (*PassportElementTypeIdentityCard) PassportElementTypeType() string {
	return TypePassportElementTypeIdentityCard
}

// A Telegram Passport element containing the user's internal passport
type PassportElementTypeInternalPassport struct {
	meta
}

func (entity *PassportElementTypeInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeInternalPassport) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeInternalPassport) GetType() string {
	return TypePassportElementTypeInternalPassport
}

func (*PassportElementTypeInternalPassport) PassportElementTypeType() string {
	return TypePassportElementTypeInternalPassport
}

// A Telegram Passport element containing the user's address
type PassportElementTypeAddress struct {
	meta
}

func (entity *PassportElementTypeAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeAddress) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeAddress) GetType() string {
	return TypePassportElementTypeAddress
}

func (*PassportElementTypeAddress) PassportElementTypeType() string {
	return TypePassportElementTypeAddress
}

// A Telegram Passport element containing the user's utility bill
type PassportElementTypeUtilityBill struct {
	meta
}

func (entity *PassportElementTypeUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeUtilityBill) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeUtilityBill) GetType() string {
	return TypePassportElementTypeUtilityBill
}

func (*PassportElementTypeUtilityBill) PassportElementTypeType() string {
	return TypePassportElementTypeUtilityBill
}

// A Telegram Passport element containing the user's bank statement
type PassportElementTypeBankStatement struct {
	meta
}

func (entity *PassportElementTypeBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeBankStatement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeBankStatement) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeBankStatement) GetType() string {
	return TypePassportElementTypeBankStatement
}

func (*PassportElementTypeBankStatement) PassportElementTypeType() string {
	return TypePassportElementTypeBankStatement
}

// A Telegram Passport element containing the user's rental agreement
type PassportElementTypeRentalAgreement struct {
	meta
}

func (entity *PassportElementTypeRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeRentalAgreement) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeRentalAgreement) GetType() string {
	return TypePassportElementTypeRentalAgreement
}

func (*PassportElementTypeRentalAgreement) PassportElementTypeType() string {
	return TypePassportElementTypeRentalAgreement
}

// A Telegram Passport element containing the registration page of the user's passport
type PassportElementTypePassportRegistration struct {
	meta
}

func (entity *PassportElementTypePassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePassportRegistration) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePassportRegistration) GetType() string {
	return TypePassportElementTypePassportRegistration
}

func (*PassportElementTypePassportRegistration) PassportElementTypeType() string {
	return TypePassportElementTypePassportRegistration
}

// A Telegram Passport element containing the user's temporary registration
type PassportElementTypeTemporaryRegistration struct {
	meta
}

func (entity *PassportElementTypeTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeTemporaryRegistration) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeTemporaryRegistration) GetType() string {
	return TypePassportElementTypeTemporaryRegistration
}

func (*PassportElementTypeTemporaryRegistration) PassportElementTypeType() string {
	return TypePassportElementTypeTemporaryRegistration
}

// A Telegram Passport element containing the user's phone number
type PassportElementTypePhoneNumber struct {
	meta
}

func (entity *PassportElementTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypePhoneNumber) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypePhoneNumber) GetType() string {
	return TypePassportElementTypePhoneNumber
}

func (*PassportElementTypePhoneNumber) PassportElementTypeType() string {
	return TypePassportElementTypePhoneNumber
}

// A Telegram Passport element containing the user's email address
type PassportElementTypeEmailAddress struct {
	meta
}

func (entity *PassportElementTypeEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTypeEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTypeEmailAddress) GetClass() string {
	return ClassPassportElementType
}

func (*PassportElementTypeEmailAddress) GetType() string {
	return TypePassportElementTypeEmailAddress
}

func (*PassportElementTypeEmailAddress) PassportElementTypeType() string {
	return TypePassportElementTypeEmailAddress
}

// Represents a date according to the Gregorian calendar
type Date struct {
	meta
	// Day of the month, 1-31
	Day int32 `json:"day"`
	// Month, 1-12
	Month int32 `json:"month"`
	// Year, 1-9999
	Year int32 `json:"year"`
}

func (entity *Date) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Date

	return json.Marshal((*stub)(entity))
}

func (*Date) GetClass() string {
	return ClassDate
}

func (*Date) GetType() string {
	return TypeDate
}

// Contains the user's personal details
type PersonalDetails struct {
	meta
	// First name of the user written in English; 1-255 characters
	FirstName string `json:"first_name"`
	// Middle name of the user written in English; 0-255 characters
	MiddleName string `json:"middle_name"`
	// Last name of the user written in English; 1-255 characters
	LastName string `json:"last_name"`
	// Native first name of the user; 1-255 characters
	NativeFirstName string `json:"native_first_name"`
	// Native middle name of the user; 0-255 characters
	NativeMiddleName string `json:"native_middle_name"`
	// Native last name of the user; 1-255 characters
	NativeLastName string `json:"native_last_name"`
	// Birthdate of the user
	Birthdate *Date `json:"birthdate"`
	// Gender of the user, "male" or "female"
	Gender string `json:"gender"`
	// A two-letter ISO 3166-1 alpha-2 country code of the user's country
	CountryCode string `json:"country_code"`
	// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
	ResidenceCountryCode string `json:"residence_country_code"`
}

func (entity *PersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PersonalDetails) GetClass() string {
	return ClassPersonalDetails
}

func (*PersonalDetails) GetType() string {
	return TypePersonalDetails
}

// An identity document
type IdentityDocument struct {
	meta
	// Document number; 1-24 characters
	Number string `json:"number"`
	// Document expiry date; may be null
	ExpiryDate *Date `json:"expiry_date"`
	// Front side of the document
	FrontSide *DatedFile `json:"front_side"`
	// Reverse side of the document; only for driver license and identity card
	ReverseSide *DatedFile `json:"reverse_side"`
	// Selfie with the document; may be null
	Selfie *DatedFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
}

func (entity *IdentityDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub IdentityDocument

	return json.Marshal((*stub)(entity))
}

func (*IdentityDocument) GetClass() string {
	return ClassIdentityDocument
}

func (*IdentityDocument) GetType() string {
	return TypeIdentityDocument
}

// An identity document to be saved to Telegram Passport
type InputIdentityDocument struct {
	meta
	// Document number; 1-24 characters
	Number string `json:"number"`
	// Document expiry date, if available
	ExpiryDate *Date `json:"expiry_date"`
	// Front side of the document
	FrontSide InputFile `json:"front_side"`
	// Reverse side of the document; only for driver license and identity card
	ReverseSide InputFile `json:"reverse_side"`
	// Selfie with the document, if available
	Selfie InputFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []InputFile `json:"translation"`
}

func (entity *InputIdentityDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputIdentityDocument

	return json.Marshal((*stub)(entity))
}

func (*InputIdentityDocument) GetClass() string {
	return ClassInputIdentityDocument
}

func (*InputIdentityDocument) GetType() string {
	return TypeInputIdentityDocument
}

func (inputIdentityDocument *InputIdentityDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Number      string          `json:"number"`
		ExpiryDate  *Date           `json:"expiry_date"`
		FrontSide   json.RawMessage `json:"front_side"`
		ReverseSide json.RawMessage `json:"reverse_side"`
		Selfie      json.RawMessage `json:"selfie"`
		Translation []InputFile     `json:"translation"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputIdentityDocument.Number = tmp.Number
	inputIdentityDocument.ExpiryDate = tmp.ExpiryDate
	inputIdentityDocument.Translation = tmp.Translation

	fieldFrontSide, _ := UnmarshalInputFile(tmp.FrontSide)
	inputIdentityDocument.FrontSide = fieldFrontSide

	fieldReverseSide, _ := UnmarshalInputFile(tmp.ReverseSide)
	inputIdentityDocument.ReverseSide = fieldReverseSide

	fieldSelfie, _ := UnmarshalInputFile(tmp.Selfie)
	inputIdentityDocument.Selfie = fieldSelfie

	return nil
}

// A personal document, containing some information about a user
type PersonalDocument struct {
	meta
	// List of files containing the pages of the document
	Files []*DatedFile `json:"files"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
}

func (entity *PersonalDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PersonalDocument

	return json.Marshal((*stub)(entity))
}

func (*PersonalDocument) GetClass() string {
	return ClassPersonalDocument
}

func (*PersonalDocument) GetType() string {
	return TypePersonalDocument
}

// A personal document to be saved to Telegram Passport
type InputPersonalDocument struct {
	meta
	// List of files containing the pages of the document
	Files []InputFile `json:"files"`
	// List of files containing a certified English translation of the document
	Translation []InputFile `json:"translation"`
}

func (entity *InputPersonalDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPersonalDocument

	return json.Marshal((*stub)(entity))
}

func (*InputPersonalDocument) GetClass() string {
	return ClassInputPersonalDocument
}

func (*InputPersonalDocument) GetType() string {
	return TypeInputPersonalDocument
}

// A Telegram Passport element containing the user's personal details
type PassportElementPersonalDetails struct {
	meta
	// Personal details of the user
	PersonalDetails *PersonalDetails `json:"personal_details"`
}

func (entity *PassportElementPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPersonalDetails) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPersonalDetails) GetType() string {
	return TypePassportElementPersonalDetails
}

func (*PassportElementPersonalDetails) PassportElementType() string {
	return TypePassportElementPersonalDetails
}

// A Telegram Passport element containing the user's passport
type PassportElementPassport struct {
	meta
	// Passport
	Passport *IdentityDocument `json:"passport"`
}

func (entity *PassportElementPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPassport) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPassport) GetType() string {
	return TypePassportElementPassport
}

func (*PassportElementPassport) PassportElementType() string {
	return TypePassportElementPassport
}

// A Telegram Passport element containing the user's driver license
type PassportElementDriverLicense struct {
	meta
	// Driver license
	DriverLicense *IdentityDocument `json:"driver_license"`
}

func (entity *PassportElementDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*PassportElementDriverLicense) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementDriverLicense) GetType() string {
	return TypePassportElementDriverLicense
}

func (*PassportElementDriverLicense) PassportElementType() string {
	return TypePassportElementDriverLicense
}

// A Telegram Passport element containing the user's identity card
type PassportElementIdentityCard struct {
	meta
	// Identity card
	IdentityCard *IdentityDocument `json:"identity_card"`
}

func (entity *PassportElementIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*PassportElementIdentityCard) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementIdentityCard) GetType() string {
	return TypePassportElementIdentityCard
}

func (*PassportElementIdentityCard) PassportElementType() string {
	return TypePassportElementIdentityCard
}

// A Telegram Passport element containing the user's internal passport
type PassportElementInternalPassport struct {
	meta
	// Internal passport
	InternalPassport *IdentityDocument `json:"internal_passport"`
}

func (entity *PassportElementInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*PassportElementInternalPassport) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementInternalPassport) GetType() string {
	return TypePassportElementInternalPassport
}

func (*PassportElementInternalPassport) PassportElementType() string {
	return TypePassportElementInternalPassport
}

// A Telegram Passport element containing the user's address
type PassportElementAddress struct {
	meta
	// Address
	Address *Address `json:"address"`
}

func (entity *PassportElementAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementAddress) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementAddress) GetType() string {
	return TypePassportElementAddress
}

func (*PassportElementAddress) PassportElementType() string {
	return TypePassportElementAddress
}

// A Telegram Passport element containing the user's utility bill
type PassportElementUtilityBill struct {
	meta
	// Utility bill
	UtilityBill *PersonalDocument `json:"utility_bill"`
}

func (entity *PassportElementUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*PassportElementUtilityBill) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementUtilityBill) GetType() string {
	return TypePassportElementUtilityBill
}

func (*PassportElementUtilityBill) PassportElementType() string {
	return TypePassportElementUtilityBill
}

// A Telegram Passport element containing the user's bank statement
type PassportElementBankStatement struct {
	meta
	// Bank statement
	BankStatement *PersonalDocument `json:"bank_statement"`
}

func (entity *PassportElementBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementBankStatement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementBankStatement) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementBankStatement) GetType() string {
	return TypePassportElementBankStatement
}

func (*PassportElementBankStatement) PassportElementType() string {
	return TypePassportElementBankStatement
}

// A Telegram Passport element containing the user's rental agreement
type PassportElementRentalAgreement struct {
	meta
	// Rental agreement
	RentalAgreement *PersonalDocument `json:"rental_agreement"`
}

func (entity *PassportElementRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*PassportElementRentalAgreement) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementRentalAgreement) GetType() string {
	return TypePassportElementRentalAgreement
}

func (*PassportElementRentalAgreement) PassportElementType() string {
	return TypePassportElementRentalAgreement
}

// A Telegram Passport element containing the user's passport registration pages
type PassportElementPassportRegistration struct {
	meta
	// Passport registration pages
	PassportRegistration *PersonalDocument `json:"passport_registration"`
}

func (entity *PassportElementPassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPassportRegistration) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPassportRegistration) GetType() string {
	return TypePassportElementPassportRegistration
}

func (*PassportElementPassportRegistration) PassportElementType() string {
	return TypePassportElementPassportRegistration
}

// A Telegram Passport element containing the user's temporary registration
type PassportElementTemporaryRegistration struct {
	meta
	// Temporary registration
	TemporaryRegistration *PersonalDocument `json:"temporary_registration"`
}

func (entity *PassportElementTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*PassportElementTemporaryRegistration) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementTemporaryRegistration) GetType() string {
	return TypePassportElementTemporaryRegistration
}

func (*PassportElementTemporaryRegistration) PassportElementType() string {
	return TypePassportElementTemporaryRegistration
}

// A Telegram Passport element containing the user's phone number
type PassportElementPhoneNumber struct {
	meta
	// Phone number
	PhoneNumber string `json:"phone_number"`
}

func (entity *PassportElementPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*PassportElementPhoneNumber) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementPhoneNumber) GetType() string {
	return TypePassportElementPhoneNumber
}

func (*PassportElementPhoneNumber) PassportElementType() string {
	return TypePassportElementPhoneNumber
}

// A Telegram Passport element containing the user's email address
type PassportElementEmailAddress struct {
	meta
	// Email address
	EmailAddress string `json:"email_address"`
}

func (entity *PassportElementEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*PassportElementEmailAddress) GetClass() string {
	return ClassPassportElement
}

func (*PassportElementEmailAddress) GetType() string {
	return TypePassportElementEmailAddress
}

func (*PassportElementEmailAddress) PassportElementType() string {
	return TypePassportElementEmailAddress
}

// A Telegram Passport element to be saved containing the user's personal details
type InputPassportElementPersonalDetails struct {
	meta
	// Personal details of the user
	PersonalDetails *PersonalDetails `json:"personal_details"`
}

func (entity *InputPassportElementPersonalDetails) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPersonalDetails

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPersonalDetails) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPersonalDetails) GetType() string {
	return TypeInputPassportElementPersonalDetails
}

func (*InputPassportElementPersonalDetails) InputPassportElementType() string {
	return TypeInputPassportElementPersonalDetails
}

// A Telegram Passport element to be saved containing the user's passport
type InputPassportElementPassport struct {
	meta
	// The passport to be saved
	Passport *InputIdentityDocument `json:"passport"`
}

func (entity *InputPassportElementPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPassport

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPassport) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPassport) GetType() string {
	return TypeInputPassportElementPassport
}

func (*InputPassportElementPassport) InputPassportElementType() string {
	return TypeInputPassportElementPassport
}

// A Telegram Passport element to be saved containing the user's driver license
type InputPassportElementDriverLicense struct {
	meta
	// The driver license to be saved
	DriverLicense *InputIdentityDocument `json:"driver_license"`
}

func (entity *InputPassportElementDriverLicense) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementDriverLicense

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementDriverLicense) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementDriverLicense) GetType() string {
	return TypeInputPassportElementDriverLicense
}

func (*InputPassportElementDriverLicense) InputPassportElementType() string {
	return TypeInputPassportElementDriverLicense
}

// A Telegram Passport element to be saved containing the user's identity card
type InputPassportElementIdentityCard struct {
	meta
	// The identity card to be saved
	IdentityCard *InputIdentityDocument `json:"identity_card"`
}

func (entity *InputPassportElementIdentityCard) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementIdentityCard

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementIdentityCard) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementIdentityCard) GetType() string {
	return TypeInputPassportElementIdentityCard
}

func (*InputPassportElementIdentityCard) InputPassportElementType() string {
	return TypeInputPassportElementIdentityCard
}

// A Telegram Passport element to be saved containing the user's internal passport
type InputPassportElementInternalPassport struct {
	meta
	// The internal passport to be saved
	InternalPassport *InputIdentityDocument `json:"internal_passport"`
}

func (entity *InputPassportElementInternalPassport) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementInternalPassport

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementInternalPassport) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementInternalPassport) GetType() string {
	return TypeInputPassportElementInternalPassport
}

func (*InputPassportElementInternalPassport) InputPassportElementType() string {
	return TypeInputPassportElementInternalPassport
}

// A Telegram Passport element to be saved containing the user's address
type InputPassportElementAddress struct {
	meta
	// The address to be saved
	Address *Address `json:"address"`
}

func (entity *InputPassportElementAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementAddress

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementAddress) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementAddress) GetType() string {
	return TypeInputPassportElementAddress
}

func (*InputPassportElementAddress) InputPassportElementType() string {
	return TypeInputPassportElementAddress
}

// A Telegram Passport element to be saved containing the user's utility bill
type InputPassportElementUtilityBill struct {
	meta
	// The utility bill to be saved
	UtilityBill *InputPersonalDocument `json:"utility_bill"`
}

func (entity *InputPassportElementUtilityBill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementUtilityBill

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementUtilityBill) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementUtilityBill) GetType() string {
	return TypeInputPassportElementUtilityBill
}

func (*InputPassportElementUtilityBill) InputPassportElementType() string {
	return TypeInputPassportElementUtilityBill
}

// A Telegram Passport element to be saved containing the user's bank statement
type InputPassportElementBankStatement struct {
	meta
	// The bank statement to be saved
	BankStatement *InputPersonalDocument `json:"bank_statement"`
}

func (entity *InputPassportElementBankStatement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementBankStatement

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementBankStatement) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementBankStatement) GetType() string {
	return TypeInputPassportElementBankStatement
}

func (*InputPassportElementBankStatement) InputPassportElementType() string {
	return TypeInputPassportElementBankStatement
}

// A Telegram Passport element to be saved containing the user's rental agreement
type InputPassportElementRentalAgreement struct {
	meta
	// The rental agreement to be saved
	RentalAgreement *InputPersonalDocument `json:"rental_agreement"`
}

func (entity *InputPassportElementRentalAgreement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementRentalAgreement

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementRentalAgreement) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementRentalAgreement) GetType() string {
	return TypeInputPassportElementRentalAgreement
}

func (*InputPassportElementRentalAgreement) InputPassportElementType() string {
	return TypeInputPassportElementRentalAgreement
}

// A Telegram Passport element to be saved containing the user's passport registration
type InputPassportElementPassportRegistration struct {
	meta
	// The passport registration page to be saved
	PassportRegistration *InputPersonalDocument `json:"passport_registration"`
}

func (entity *InputPassportElementPassportRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPassportRegistration

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPassportRegistration) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPassportRegistration) GetType() string {
	return TypeInputPassportElementPassportRegistration
}

func (*InputPassportElementPassportRegistration) InputPassportElementType() string {
	return TypeInputPassportElementPassportRegistration
}

// A Telegram Passport element to be saved containing the user's temporary registration
type InputPassportElementTemporaryRegistration struct {
	meta
	// The temporary registration document to be saved
	TemporaryRegistration *InputPersonalDocument `json:"temporary_registration"`
}

func (entity *InputPassportElementTemporaryRegistration) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementTemporaryRegistration

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementTemporaryRegistration) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementTemporaryRegistration) GetType() string {
	return TypeInputPassportElementTemporaryRegistration
}

func (*InputPassportElementTemporaryRegistration) InputPassportElementType() string {
	return TypeInputPassportElementTemporaryRegistration
}

// A Telegram Passport element to be saved containing the user's phone number
type InputPassportElementPhoneNumber struct {
	meta
	// The phone number to be saved
	PhoneNumber string `json:"phone_number"`
}

func (entity *InputPassportElementPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementPhoneNumber) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementPhoneNumber) GetType() string {
	return TypeInputPassportElementPhoneNumber
}

func (*InputPassportElementPhoneNumber) InputPassportElementType() string {
	return TypeInputPassportElementPhoneNumber
}

// A Telegram Passport element to be saved containing the user's email address
type InputPassportElementEmailAddress struct {
	meta
	// The email address to be saved
	EmailAddress string `json:"email_address"`
}

func (entity *InputPassportElementEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementEmailAddress) GetClass() string {
	return ClassInputPassportElement
}

func (*InputPassportElementEmailAddress) GetType() string {
	return TypeInputPassportElementEmailAddress
}

func (*InputPassportElementEmailAddress) InputPassportElementType() string {
	return TypeInputPassportElementEmailAddress
}

// Contains information about saved Telegram Passport elements
type PassportElements struct {
	meta
	// Telegram Passport elements
	Elements []PassportElement `json:"elements"`
}

func (entity *PassportElements) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElements

	return json.Marshal((*stub)(entity))
}

func (*PassportElements) GetClass() string {
	return ClassPassportElements
}

func (*PassportElements) GetType() string {
	return TypePassportElements
}

// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type PassportElementErrorSourceUnspecified struct {
	meta
}

func (entity *PassportElementErrorSourceUnspecified) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceUnspecified

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceUnspecified) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceUnspecified) GetType() string {
	return TypePassportElementErrorSourceUnspecified
}

func (*PassportElementErrorSourceUnspecified) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceUnspecified
}

// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
type PassportElementErrorSourceDataField struct {
	meta
	// Field name
	FieldName string `json:"field_name"`
}

func (entity *PassportElementErrorSourceDataField) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceDataField

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceDataField) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceDataField) GetType() string {
	return TypePassportElementErrorSourceDataField
}

func (*PassportElementErrorSourceDataField) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceDataField
}

// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
type PassportElementErrorSourceFrontSide struct {
	meta
}

func (entity *PassportElementErrorSourceFrontSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFrontSide

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFrontSide) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFrontSide) GetType() string {
	return TypePassportElementErrorSourceFrontSide
}

func (*PassportElementErrorSourceFrontSide) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFrontSide
}

// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
type PassportElementErrorSourceReverseSide struct {
	meta
}

func (entity *PassportElementErrorSourceReverseSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceReverseSide

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceReverseSide) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceReverseSide) GetType() string {
	return TypePassportElementErrorSourceReverseSide
}

func (*PassportElementErrorSourceReverseSide) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceReverseSide
}

// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
type PassportElementErrorSourceSelfie struct {
	meta
}

func (entity *PassportElementErrorSourceSelfie) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceSelfie

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceSelfie) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceSelfie) GetType() string {
	return TypePassportElementErrorSourceSelfie
}

func (*PassportElementErrorSourceSelfie) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceSelfie
}

// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceTranslationFile struct {
	meta
	// Index of a file with the error
	FileIndex int32 `json:"file_index"`
}

func (entity *PassportElementErrorSourceTranslationFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceTranslationFile

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceTranslationFile) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceTranslationFile) GetType() string {
	return TypePassportElementErrorSourceTranslationFile
}

func (*PassportElementErrorSourceTranslationFile) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceTranslationFile
}

// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
type PassportElementErrorSourceTranslationFiles struct {
	meta
}

func (entity *PassportElementErrorSourceTranslationFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceTranslationFiles

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceTranslationFiles) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceTranslationFiles) GetType() string {
	return TypePassportElementErrorSourceTranslationFiles
}

func (*PassportElementErrorSourceTranslationFiles) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceTranslationFiles
}

// The file contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceFile struct {
	meta
	// Index of a file with the error
	FileIndex int32 `json:"file_index"`
}

func (entity *PassportElementErrorSourceFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFile

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFile) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFile) GetType() string {
	return TypePassportElementErrorSourceFile
}

func (*PassportElementErrorSourceFile) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFile
}

// The list of attached files contains an error. The error will be considered resolved when the list of files changes
type PassportElementErrorSourceFiles struct {
	meta
}

func (entity *PassportElementErrorSourceFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementErrorSourceFiles

	return json.Marshal((*stub)(entity))
}

func (*PassportElementErrorSourceFiles) GetClass() string {
	return ClassPassportElementErrorSource
}

func (*PassportElementErrorSourceFiles) GetType() string {
	return TypePassportElementErrorSourceFiles
}

func (*PassportElementErrorSourceFiles) PassportElementErrorSourceType() string {
	return TypePassportElementErrorSourceFiles
}

// Contains the description of an error in a Telegram Passport element
type PassportElementError struct {
	meta
	// Type of the Telegram Passport element which has the error
	Type PassportElementType `json:"type"`
	// Error message
	Message string `json:"message"`
	// Error source
	Source PassportElementErrorSource `json:"source"`
}

func (entity *PassportElementError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementError

	return json.Marshal((*stub)(entity))
}

func (*PassportElementError) GetClass() string {
	return ClassPassportElementError
}

func (*PassportElementError) GetType() string {
	return TypePassportElementError
}

func (passportElementError *PassportElementError) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    json.RawMessage `json:"type"`
		Message string          `json:"message"`
		Source  json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportElementError.Message = tmp.Message

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	passportElementError.Type = fieldType

	fieldSource, _ := UnmarshalPassportElementErrorSource(tmp.Source)
	passportElementError.Source = fieldSource

	return nil
}

// Contains information about a Telegram Passport element that was requested by a service
type PassportSuitableElement struct {
	meta
	// Type of the element
	Type PassportElementType `json:"type"`
	// True, if a selfie is required with the identity document
	IsSelfieRequired bool `json:"is_selfie_required"`
	// True, if a certified English translation is required with the document
	IsTranslationRequired bool `json:"is_translation_required"`
	// True, if personal details must include the user's name in the language of their country of residence
	IsNativeNameRequired bool `json:"is_native_name_required"`
}

func (entity *PassportSuitableElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportSuitableElement

	return json.Marshal((*stub)(entity))
}

func (*PassportSuitableElement) GetClass() string {
	return ClassPassportSuitableElement
}

func (*PassportSuitableElement) GetType() string {
	return TypePassportSuitableElement
}

func (passportSuitableElement *PassportSuitableElement) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type                  json.RawMessage `json:"type"`
		IsSelfieRequired      bool            `json:"is_selfie_required"`
		IsTranslationRequired bool            `json:"is_translation_required"`
		IsNativeNameRequired  bool            `json:"is_native_name_required"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	passportSuitableElement.IsSelfieRequired = tmp.IsSelfieRequired
	passportSuitableElement.IsTranslationRequired = tmp.IsTranslationRequired
	passportSuitableElement.IsNativeNameRequired = tmp.IsNativeNameRequired

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	passportSuitableElement.Type = fieldType

	return nil
}

// Contains a description of the required Telegram Passport element that was requested by a service
type PassportRequiredElement struct {
	meta
	// List of Telegram Passport elements any of which is enough to provide
	SuitableElements []*PassportSuitableElement `json:"suitable_elements"`
}

func (entity *PassportRequiredElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportRequiredElement

	return json.Marshal((*stub)(entity))
}

func (*PassportRequiredElement) GetClass() string {
	return ClassPassportRequiredElement
}

func (*PassportRequiredElement) GetType() string {
	return TypePassportRequiredElement
}

// Contains information about a Telegram Passport authorization form that was requested
type PassportAuthorizationForm struct {
	meta
	// Unique identifier of the authorization form
	Id int32 `json:"id"`
	// Information about the Telegram Passport elements that need to be provided to complete the form
	RequiredElements []*PassportRequiredElement `json:"required_elements"`
	// URL for the privacy policy of the service; may be empty
	PrivacyPolicyUrl string `json:"privacy_policy_url"`
}

func (entity *PassportAuthorizationForm) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportAuthorizationForm

	return json.Marshal((*stub)(entity))
}

func (*PassportAuthorizationForm) GetClass() string {
	return ClassPassportAuthorizationForm
}

func (*PassportAuthorizationForm) GetType() string {
	return TypePassportAuthorizationForm
}

// Contains information about a Telegram Passport elements and corresponding errors
type PassportElementsWithErrors struct {
	meta
	// Telegram Passport elements
	Elements []PassportElement `json:"elements"`
	// Errors in the elements that are already available
	Errors []*PassportElementError `json:"errors"`
}

func (entity *PassportElementsWithErrors) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PassportElementsWithErrors

	return json.Marshal((*stub)(entity))
}

func (*PassportElementsWithErrors) GetClass() string {
	return ClassPassportElementsWithErrors
}

func (*PassportElementsWithErrors) GetType() string {
	return TypePassportElementsWithErrors
}

// Contains encrypted Telegram Passport data credentials
type EncryptedCredentials struct {
	meta
	// The encrypted credentials
	Data []byte `json:"data"`
	// The decrypted data hash
	Hash []byte `json:"hash"`
	// Secret for data decryption, encrypted with the service's public key
	Secret []byte `json:"secret"`
}

func (entity *EncryptedCredentials) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EncryptedCredentials

	return json.Marshal((*stub)(entity))
}

func (*EncryptedCredentials) GetClass() string {
	return ClassEncryptedCredentials
}

func (*EncryptedCredentials) GetType() string {
	return TypeEncryptedCredentials
}

// Contains information about an encrypted Telegram Passport element; for bots only
type EncryptedPassportElement struct {
	meta
	// Type of Telegram Passport element
	Type PassportElementType `json:"type"`
	// Encrypted JSON-encoded data about the user
	Data []byte `json:"data"`
	// The front side of an identity document
	FrontSide *DatedFile `json:"front_side"`
	// The reverse side of an identity document; may be null
	ReverseSide *DatedFile `json:"reverse_side"`
	// Selfie with the document; may be null
	Selfie *DatedFile `json:"selfie"`
	// List of files containing a certified English translation of the document
	Translation []*DatedFile `json:"translation"`
	// List of attached files
	Files []*DatedFile `json:"files"`
	// Unencrypted data, phone number or email address
	Value string `json:"value"`
	// Hash of the entire element
	Hash string `json:"hash"`
}

func (entity *EncryptedPassportElement) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub EncryptedPassportElement

	return json.Marshal((*stub)(entity))
}

func (*EncryptedPassportElement) GetClass() string {
	return ClassEncryptedPassportElement
}

func (*EncryptedPassportElement) GetType() string {
	return TypeEncryptedPassportElement
}

func (encryptedPassportElement *EncryptedPassportElement) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type        json.RawMessage `json:"type"`
		Data        []byte          `json:"data"`
		FrontSide   *DatedFile      `json:"front_side"`
		ReverseSide *DatedFile      `json:"reverse_side"`
		Selfie      *DatedFile      `json:"selfie"`
		Translation []*DatedFile    `json:"translation"`
		Files       []*DatedFile    `json:"files"`
		Value       string          `json:"value"`
		Hash        string          `json:"hash"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	encryptedPassportElement.Data = tmp.Data
	encryptedPassportElement.FrontSide = tmp.FrontSide
	encryptedPassportElement.ReverseSide = tmp.ReverseSide
	encryptedPassportElement.Selfie = tmp.Selfie
	encryptedPassportElement.Translation = tmp.Translation
	encryptedPassportElement.Files = tmp.Files
	encryptedPassportElement.Value = tmp.Value
	encryptedPassportElement.Hash = tmp.Hash

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	encryptedPassportElement.Type = fieldType

	return nil
}

// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type InputPassportElementErrorSourceUnspecified struct {
	meta
	// Current hash of the entire element
	ElementHash []byte `json:"element_hash"`
}

func (entity *InputPassportElementErrorSourceUnspecified) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceUnspecified

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceUnspecified) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceUnspecified) GetType() string {
	return TypeInputPassportElementErrorSourceUnspecified
}

func (*InputPassportElementErrorSourceUnspecified) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceUnspecified
}

// A data field contains an error. The error is considered resolved when the field's value changes
type InputPassportElementErrorSourceDataField struct {
	meta
	// Field name
	FieldName string `json:"field_name"`
	// Current data hash
	DataHash []byte `json:"data_hash"`
}

func (entity *InputPassportElementErrorSourceDataField) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceDataField

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceDataField) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceDataField) GetType() string {
	return TypeInputPassportElementErrorSourceDataField
}

func (*InputPassportElementErrorSourceDataField) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceDataField
}

// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
type InputPassportElementErrorSourceFrontSide struct {
	meta
	// Current hash of the file containing the front side
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceFrontSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFrontSide

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFrontSide) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFrontSide) GetType() string {
	return TypeInputPassportElementErrorSourceFrontSide
}

func (*InputPassportElementErrorSourceFrontSide) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFrontSide
}

// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
type InputPassportElementErrorSourceReverseSide struct {
	meta
	// Current hash of the file containing the reverse side
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceReverseSide) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceReverseSide

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceReverseSide) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceReverseSide) GetType() string {
	return TypeInputPassportElementErrorSourceReverseSide
}

func (*InputPassportElementErrorSourceReverseSide) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceReverseSide
}

// The selfie contains an error. The error is considered resolved when the file with the selfie changes
type InputPassportElementErrorSourceSelfie struct {
	meta
	// Current hash of the file containing the selfie
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceSelfie) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceSelfie

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceSelfie) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceSelfie) GetType() string {
	return TypeInputPassportElementErrorSourceSelfie
}

func (*InputPassportElementErrorSourceSelfie) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceSelfie
}

// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
type InputPassportElementErrorSourceTranslationFile struct {
	meta
	// Current hash of the file containing the translation
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceTranslationFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceTranslationFile

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceTranslationFile) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceTranslationFile) GetType() string {
	return TypeInputPassportElementErrorSourceTranslationFile
}

func (*InputPassportElementErrorSourceTranslationFile) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceTranslationFile
}

// The translation of the document contains an error. The error is considered resolved when the list of files changes
type InputPassportElementErrorSourceTranslationFiles struct {
	meta
	// Current hashes of all files with the translation
	FileHashes [][]byte `json:"file_hashes"`
}

func (entity *InputPassportElementErrorSourceTranslationFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceTranslationFiles

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceTranslationFiles) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceTranslationFiles) GetType() string {
	return TypeInputPassportElementErrorSourceTranslationFiles
}

func (*InputPassportElementErrorSourceTranslationFiles) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceTranslationFiles
}

// The file contains an error. The error is considered resolved when the file changes
type InputPassportElementErrorSourceFile struct {
	meta
	// Current hash of the file which has the error
	FileHash []byte `json:"file_hash"`
}

func (entity *InputPassportElementErrorSourceFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFile

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFile) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFile) GetType() string {
	return TypeInputPassportElementErrorSourceFile
}

func (*InputPassportElementErrorSourceFile) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFile
}

// The list of attached files contains an error. The error is considered resolved when the file list changes
type InputPassportElementErrorSourceFiles struct {
	meta
	// Current hashes of all attached files
	FileHashes [][]byte `json:"file_hashes"`
}

func (entity *InputPassportElementErrorSourceFiles) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementErrorSourceFiles

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementErrorSourceFiles) GetClass() string {
	return ClassInputPassportElementErrorSource
}

func (*InputPassportElementErrorSourceFiles) GetType() string {
	return TypeInputPassportElementErrorSourceFiles
}

func (*InputPassportElementErrorSourceFiles) InputPassportElementErrorSourceType() string {
	return TypeInputPassportElementErrorSourceFiles
}

// Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementError struct {
	meta
	// Type of Telegram Passport element that has the error
	Type PassportElementType `json:"type"`
	// Error message
	Message string `json:"message"`
	// Error source
	Source InputPassportElementErrorSource `json:"source"`
}

func (entity *InputPassportElementError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputPassportElementError

	return json.Marshal((*stub)(entity))
}

func (*InputPassportElementError) GetClass() string {
	return ClassInputPassportElementError
}

func (*InputPassportElementError) GetType() string {
	return TypeInputPassportElementError
}

func (inputPassportElementError *InputPassportElementError) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    json.RawMessage `json:"type"`
		Message string          `json:"message"`
		Source  json.RawMessage `json:"source"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputPassportElementError.Message = tmp.Message

	fieldType, _ := UnmarshalPassportElementType(tmp.Type)
	inputPassportElementError.Type = fieldType

	fieldSource, _ := UnmarshalInputPassportElementErrorSource(tmp.Source)
	inputPassportElementError.Source = fieldSource

	return nil
}

// A text message
type MessageText struct {
	meta
	// Text of the message
	Text *FormattedText `json:"text"`
	// A preview of the web page that's mentioned in the text; may be null
	WebPage *WebPage `json:"web_page"`
}

func (entity *MessageText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageText

	return json.Marshal((*stub)(entity))
}

func (*MessageText) GetClass() string {
	return ClassMessageContent
}

func (*MessageText) GetType() string {
	return TypeMessageText
}

func (*MessageText) MessageContentType() string {
	return TypeMessageText
}

// An animation message (GIF-style).
type MessageAnimation struct {
	meta
	// The animation description
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption *FormattedText `json:"caption"`
	// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAnimation

	return json.Marshal((*stub)(entity))
}

func (*MessageAnimation) GetClass() string {
	return ClassMessageContent
}

func (*MessageAnimation) GetType() string {
	return TypeMessageAnimation
}

func (*MessageAnimation) MessageContentType() string {
	return TypeMessageAnimation
}

// An audio message
type MessageAudio struct {
	meta
	// The audio description
	Audio *Audio `json:"audio"`
	// Audio caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageAudio

	return json.Marshal((*stub)(entity))
}

func (*MessageAudio) GetClass() string {
	return ClassMessageContent
}

func (*MessageAudio) GetType() string {
	return TypeMessageAudio
}

func (*MessageAudio) MessageContentType() string {
	return TypeMessageAudio
}

// A document message (general file)
type MessageDocument struct {
	meta
	// The document description
	Document *Document `json:"document"`
	// Document caption
	Caption *FormattedText `json:"caption"`
}

func (entity *MessageDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageDocument

	return json.Marshal((*stub)(entity))
}

func (*MessageDocument) GetClass() string {
	return ClassMessageContent
}

func (*MessageDocument) GetType() string {
	return TypeMessageDocument
}

func (*MessageDocument) MessageContentType() string {
	return TypeMessageDocument
}

// A photo message
type MessagePhoto struct {
	meta
	// The photo description
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption *FormattedText `json:"caption"`
	// True, if the photo must be blurred and must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessagePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessagePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessagePhoto) GetType() string {
	return TypeMessagePhoto
}

func (*MessagePhoto) MessageContentType() string {
	return TypeMessagePhoto
}

// An expired photo message (self-destructed after TTL has elapsed)
type MessageExpiredPhoto struct {
	meta
}

func (entity *MessageExpiredPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredPhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredPhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredPhoto) GetType() string {
	return TypeMessageExpiredPhoto
}

func (*MessageExpiredPhoto) MessageContentType() string {
	return TypeMessageExpiredPhoto
}

// A sticker message
type MessageSticker struct {
	meta
	// The sticker description
	Sticker *Sticker `json:"sticker"`
}

func (entity *MessageSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSticker

	return json.Marshal((*stub)(entity))
}

func (*MessageSticker) GetClass() string {
	return ClassMessageContent
}

func (*MessageSticker) GetType() string {
	return TypeMessageSticker
}

func (*MessageSticker) MessageContentType() string {
	return TypeMessageSticker
}

// A video message
type MessageVideo struct {
	meta
	// The video description
	Video *Video `json:"video"`
	// Video caption
	Caption *FormattedText `json:"caption"`
	// True, if the video thumbnail must be blurred and the video must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageVideo) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideo) GetType() string {
	return TypeMessageVideo
}

func (*MessageVideo) MessageContentType() string {
	return TypeMessageVideo
}

// An expired video message (self-destructed after TTL has elapsed)
type MessageExpiredVideo struct {
	meta
}

func (entity *MessageExpiredVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageExpiredVideo

	return json.Marshal((*stub)(entity))
}

func (*MessageExpiredVideo) GetClass() string {
	return ClassMessageContent
}

func (*MessageExpiredVideo) GetType() string {
	return TypeMessageExpiredVideo
}

func (*MessageExpiredVideo) MessageContentType() string {
	return TypeMessageExpiredVideo
}

// A video note message
type MessageVideoNote struct {
	meta
	// The video note description
	VideoNote *VideoNote `json:"video_note"`
	// True, if at least one of the recipients has viewed the video note
	IsViewed bool `json:"is_viewed"`
	// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
	IsSecret bool `json:"is_secret"`
}

func (entity *MessageVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVideoNote

	return json.Marshal((*stub)(entity))
}

func (*MessageVideoNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageVideoNote) GetType() string {
	return TypeMessageVideoNote
}

func (*MessageVideoNote) MessageContentType() string {
	return TypeMessageVideoNote
}

// A voice note message
type MessageVoiceNote struct {
	meta
	// The voice note description
	VoiceNote *VoiceNote `json:"voice_note"`
	// Voice note caption
	Caption *FormattedText `json:"caption"`
	// True, if at least one of the recipients has listened to the voice note
	IsListened bool `json:"is_listened"`
}

func (entity *MessageVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*MessageVoiceNote) GetClass() string {
	return ClassMessageContent
}

func (*MessageVoiceNote) GetType() string {
	return TypeMessageVoiceNote
}

func (*MessageVoiceNote) MessageContentType() string {
	return TypeMessageVoiceNote
}

// A message with a location
type MessageLocation struct {
	meta
	// The location description
	Location *Location `json:"location"`
	// Time relative to the message sent date until which the location can be updated, in seconds
	LivePeriod int32 `json:"live_period"`
	// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
	ExpiresIn int32 `json:"expires_in"`
}

func (entity *MessageLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLocation

	return json.Marshal((*stub)(entity))
}

func (*MessageLocation) GetClass() string {
	return ClassMessageContent
}

func (*MessageLocation) GetType() string {
	return TypeMessageLocation
}

func (*MessageLocation) MessageContentType() string {
	return TypeMessageLocation
}

// A message with information about a venue
type MessageVenue struct {
	meta
	// The venue description
	Venue *Venue `json:"venue"`
}

func (entity *MessageVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageVenue

	return json.Marshal((*stub)(entity))
}

func (*MessageVenue) GetClass() string {
	return ClassMessageContent
}

func (*MessageVenue) GetType() string {
	return TypeMessageVenue
}

func (*MessageVenue) MessageContentType() string {
	return TypeMessageVenue
}

// A message with a user contact
type MessageContact struct {
	meta
	// The contact description
	Contact *Contact `json:"contact"`
}

func (entity *MessageContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageContact

	return json.Marshal((*stub)(entity))
}

func (*MessageContact) GetClass() string {
	return ClassMessageContent
}

func (*MessageContact) GetType() string {
	return TypeMessageContact
}

func (*MessageContact) MessageContentType() string {
	return TypeMessageContact
}

// A message with a game
type MessageGame struct {
	meta
	// The game description
	Game *Game `json:"game"`
}

func (entity *MessageGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGame

	return json.Marshal((*stub)(entity))
}

func (*MessageGame) GetClass() string {
	return ClassMessageContent
}

func (*MessageGame) GetType() string {
	return TypeMessageGame
}

func (*MessageGame) MessageContentType() string {
	return TypeMessageGame
}

// A message with a poll
type MessagePoll struct {
	meta
	// The poll description
	Poll *Poll `json:"poll"`
}

func (entity *MessagePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePoll

	return json.Marshal((*stub)(entity))
}

func (*MessagePoll) GetClass() string {
	return ClassMessageContent
}

func (*MessagePoll) GetType() string {
	return TypeMessagePoll
}

func (*MessagePoll) MessageContentType() string {
	return TypeMessagePoll
}

// A message with an invoice from a bot
type MessageInvoice struct {
	meta
	// Product title
	Title string `json:"title"`
	// Product description
	Description string `json:"description"`
	// Product photo; may be null
	Photo *Photo `json:"photo"`
	// Currency for the product price
	Currency string `json:"currency"`
	// Product total price in the minimal quantity of the currency
	TotalAmount int64 `json:"total_amount"`
	// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}
	StartParameter string `json:"start_parameter"`
	// True, if the invoice is a test invoice
	IsTest bool `json:"is_test"`
	// True, if the shipping address should be specified
	NeedShippingAddress bool `json:"need_shipping_address"`
	// The identifier of the message with the receipt, after the product has been purchased
	ReceiptMessageId int64 `json:"receipt_message_id"`
}

func (entity *MessageInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageInvoice

	return json.Marshal((*stub)(entity))
}

func (*MessageInvoice) GetClass() string {
	return ClassMessageContent
}

func (*MessageInvoice) GetType() string {
	return TypeMessageInvoice
}

func (*MessageInvoice) MessageContentType() string {
	return TypeMessageInvoice
}

// A message with information about an ended call
type MessageCall struct {
	meta
	// Reason why the call was discarded
	DiscardReason CallDiscardReason `json:"discard_reason"`
	// Call duration, in seconds
	Duration int32 `json:"duration"`
}

func (entity *MessageCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCall

	return json.Marshal((*stub)(entity))
}

func (*MessageCall) GetClass() string {
	return ClassMessageContent
}

func (*MessageCall) GetType() string {
	return TypeMessageCall
}

func (*MessageCall) MessageContentType() string {
	return TypeMessageCall
}

func (messageCall *MessageCall) UnmarshalJSON(data []byte) error {
	var tmp struct {
		DiscardReason json.RawMessage `json:"discard_reason"`
		Duration      int32           `json:"duration"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	messageCall.Duration = tmp.Duration

	fieldDiscardReason, _ := UnmarshalCallDiscardReason(tmp.DiscardReason)
	messageCall.DiscardReason = fieldDiscardReason

	return nil
}

// A newly created basic group
type MessageBasicGroupChatCreate struct {
	meta
	// Title of the basic group
	Title string `json:"title"`
	// User identifiers of members in the basic group
	MemberUserIds []int32 `json:"member_user_ids"`
}

func (entity *MessageBasicGroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageBasicGroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*MessageBasicGroupChatCreate) GetClass() string {
	return ClassMessageContent
}

func (*MessageBasicGroupChatCreate) GetType() string {
	return TypeMessageBasicGroupChatCreate
}

func (*MessageBasicGroupChatCreate) MessageContentType() string {
	return TypeMessageBasicGroupChatCreate
}

// A newly created supergroup or channel
type MessageSupergroupChatCreate struct {
	meta
	// Title of the supergroup or channel
	Title string `json:"title"`
}

func (entity *MessageSupergroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSupergroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*MessageSupergroupChatCreate) GetClass() string {
	return ClassMessageContent
}

func (*MessageSupergroupChatCreate) GetType() string {
	return TypeMessageSupergroupChatCreate
}

func (*MessageSupergroupChatCreate) MessageContentType() string {
	return TypeMessageSupergroupChatCreate
}

// An updated chat title
type MessageChatChangeTitle struct {
	meta
	// New chat title
	Title string `json:"title"`
}

func (entity *MessageChatChangeTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatChangeTitle

	return json.Marshal((*stub)(entity))
}

func (*MessageChatChangeTitle) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatChangeTitle) GetType() string {
	return TypeMessageChatChangeTitle
}

func (*MessageChatChangeTitle) MessageContentType() string {
	return TypeMessageChatChangeTitle
}

// An updated chat photo
type MessageChatChangePhoto struct {
	meta
	// New chat photo
	Photo *Photo `json:"photo"`
}

func (entity *MessageChatChangePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatChangePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageChatChangePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatChangePhoto) GetType() string {
	return TypeMessageChatChangePhoto
}

func (*MessageChatChangePhoto) MessageContentType() string {
	return TypeMessageChatChangePhoto
}

// A deleted chat photo
type MessageChatDeletePhoto struct {
	meta
}

func (entity *MessageChatDeletePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatDeletePhoto

	return json.Marshal((*stub)(entity))
}

func (*MessageChatDeletePhoto) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatDeletePhoto) GetType() string {
	return TypeMessageChatDeletePhoto
}

func (*MessageChatDeletePhoto) MessageContentType() string {
	return TypeMessageChatDeletePhoto
}

// New chat members were added
type MessageChatAddMembers struct {
	meta
	// User identifiers of the new members
	MemberUserIds []int32 `json:"member_user_ids"`
}

func (entity *MessageChatAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatAddMembers

	return json.Marshal((*stub)(entity))
}

func (*MessageChatAddMembers) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatAddMembers) GetType() string {
	return TypeMessageChatAddMembers
}

func (*MessageChatAddMembers) MessageContentType() string {
	return TypeMessageChatAddMembers
}

// A new member joined the chat by invite link
type MessageChatJoinByLink struct {
	meta
}

func (entity *MessageChatJoinByLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatJoinByLink

	return json.Marshal((*stub)(entity))
}

func (*MessageChatJoinByLink) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatJoinByLink) GetType() string {
	return TypeMessageChatJoinByLink
}

func (*MessageChatJoinByLink) MessageContentType() string {
	return TypeMessageChatJoinByLink
}

// A chat member was deleted
type MessageChatDeleteMember struct {
	meta
	// User identifier of the deleted chat member
	UserId int32 `json:"user_id"`
}

func (entity *MessageChatDeleteMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatDeleteMember

	return json.Marshal((*stub)(entity))
}

func (*MessageChatDeleteMember) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatDeleteMember) GetType() string {
	return TypeMessageChatDeleteMember
}

func (*MessageChatDeleteMember) MessageContentType() string {
	return TypeMessageChatDeleteMember
}

// A basic group was upgraded to a supergroup and was deactivated as the result
type MessageChatUpgradeTo struct {
	meta
	// Identifier of the supergroup to which the basic group was upgraded
	SupergroupId int32 `json:"supergroup_id"`
}

func (entity *MessageChatUpgradeTo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatUpgradeTo

	return json.Marshal((*stub)(entity))
}

func (*MessageChatUpgradeTo) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatUpgradeTo) GetType() string {
	return TypeMessageChatUpgradeTo
}

func (*MessageChatUpgradeTo) MessageContentType() string {
	return TypeMessageChatUpgradeTo
}

// A supergroup has been created from a basic group
type MessageChatUpgradeFrom struct {
	meta
	// Title of the newly created supergroup
	Title string `json:"title"`
	// The identifier of the original basic group
	BasicGroupId int32 `json:"basic_group_id"`
}

func (entity *MessageChatUpgradeFrom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatUpgradeFrom

	return json.Marshal((*stub)(entity))
}

func (*MessageChatUpgradeFrom) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatUpgradeFrom) GetType() string {
	return TypeMessageChatUpgradeFrom
}

func (*MessageChatUpgradeFrom) MessageContentType() string {
	return TypeMessageChatUpgradeFrom
}

// A message has been pinned
type MessagePinMessage struct {
	meta
	// Identifier of the pinned message, can be an identifier of a deleted message or 0
	MessageId int64 `json:"message_id"`
}

func (entity *MessagePinMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePinMessage

	return json.Marshal((*stub)(entity))
}

func (*MessagePinMessage) GetClass() string {
	return ClassMessageContent
}

func (*MessagePinMessage) GetType() string {
	return TypeMessagePinMessage
}

func (*MessagePinMessage) MessageContentType() string {
	return TypeMessagePinMessage
}

// A screenshot of a message in the chat has been taken
type MessageScreenshotTaken struct {
	meta
}

func (entity *MessageScreenshotTaken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageScreenshotTaken

	return json.Marshal((*stub)(entity))
}

func (*MessageScreenshotTaken) GetClass() string {
	return ClassMessageContent
}

func (*MessageScreenshotTaken) GetType() string {
	return TypeMessageScreenshotTaken
}

func (*MessageScreenshotTaken) MessageContentType() string {
	return TypeMessageScreenshotTaken
}

// The TTL (Time To Live) setting messages in a secret chat has been changed
type MessageChatSetTtl struct {
	meta
	// New TTL
	Ttl int32 `json:"ttl"`
}

func (entity *MessageChatSetTtl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageChatSetTtl

	return json.Marshal((*stub)(entity))
}

func (*MessageChatSetTtl) GetClass() string {
	return ClassMessageContent
}

func (*MessageChatSetTtl) GetType() string {
	return TypeMessageChatSetTtl
}

func (*MessageChatSetTtl) MessageContentType() string {
	return TypeMessageChatSetTtl
}

// A non-standard action has happened in the chat
type MessageCustomServiceAction struct {
	meta
	// Message text to be shown in the chat
	Text string `json:"text"`
}

func (entity *MessageCustomServiceAction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageCustomServiceAction

	return json.Marshal((*stub)(entity))
}

func (*MessageCustomServiceAction) GetClass() string {
	return ClassMessageContent
}

func (*MessageCustomServiceAction) GetType() string {
	return TypeMessageCustomServiceAction
}

func (*MessageCustomServiceAction) MessageContentType() string {
	return TypeMessageCustomServiceAction
}

// A new high score was achieved in a game
type MessageGameScore struct {
	meta
	// Identifier of the message with the game, can be an identifier of a deleted message
	GameMessageId int64 `json:"game_message_id"`
	// Identifier of the game; may be different from the games presented in the message with the game
	GameId JsonInt64 `json:"game_id"`
	// New score
	Score int32 `json:"score"`
}

func (entity *MessageGameScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageGameScore

	return json.Marshal((*stub)(entity))
}

func (*MessageGameScore) GetClass() string {
	return ClassMessageContent
}

func (*MessageGameScore) GetType() string {
	return TypeMessageGameScore
}

func (*MessageGameScore) MessageContentType() string {
	return TypeMessageGameScore
}

// A payment has been completed
type MessagePaymentSuccessful struct {
	meta
	// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message
	InvoiceMessageId int64 `json:"invoice_message_id"`
	// Currency for the price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the minimal quantity of the currency
	TotalAmount int64 `json:"total_amount"`
}

func (entity *MessagePaymentSuccessful) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentSuccessful

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentSuccessful) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentSuccessful) GetType() string {
	return TypeMessagePaymentSuccessful
}

func (*MessagePaymentSuccessful) MessageContentType() string {
	return TypeMessagePaymentSuccessful
}

// A payment has been completed; for bots only
type MessagePaymentSuccessfulBot struct {
	meta
	// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message
	InvoiceMessageId int64 `json:"invoice_message_id"`
	// Currency for price of the product
	Currency string `json:"currency"`
	// Total price for the product, in the minimal quantity of the currency
	TotalAmount int64 `json:"total_amount"`
	// Invoice payload
	InvoicePayload []byte `json:"invoice_payload"`
	// Identifier of the shipping option chosen by the user; may be empty if not applicable
	ShippingOptionId string `json:"shipping_option_id"`
	// Information about the order; may be null
	OrderInfo *OrderInfo `json:"order_info"`
	// Telegram payment identifier
	TelegramPaymentChargeId string `json:"telegram_payment_charge_id"`
	// Provider payment identifier
	ProviderPaymentChargeId string `json:"provider_payment_charge_id"`
}

func (entity *MessagePaymentSuccessfulBot) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePaymentSuccessfulBot

	return json.Marshal((*stub)(entity))
}

func (*MessagePaymentSuccessfulBot) GetClass() string {
	return ClassMessageContent
}

func (*MessagePaymentSuccessfulBot) GetType() string {
	return TypeMessagePaymentSuccessfulBot
}

func (*MessagePaymentSuccessfulBot) MessageContentType() string {
	return TypeMessagePaymentSuccessfulBot
}

// A contact has registered with Telegram
type MessageContactRegistered struct {
	meta
}

func (entity *MessageContactRegistered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageContactRegistered

	return json.Marshal((*stub)(entity))
}

func (*MessageContactRegistered) GetClass() string {
	return ClassMessageContent
}

func (*MessageContactRegistered) GetType() string {
	return TypeMessageContactRegistered
}

func (*MessageContactRegistered) MessageContentType() string {
	return TypeMessageContactRegistered
}

// The current user has connected a website by logging in using Telegram Login Widget on it
type MessageWebsiteConnected struct {
	meta
	// Domain name of the connected website
	DomainName string `json:"domain_name"`
}

func (entity *MessageWebsiteConnected) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageWebsiteConnected

	return json.Marshal((*stub)(entity))
}

func (*MessageWebsiteConnected) GetClass() string {
	return ClassMessageContent
}

func (*MessageWebsiteConnected) GetType() string {
	return TypeMessageWebsiteConnected
}

func (*MessageWebsiteConnected) MessageContentType() string {
	return TypeMessageWebsiteConnected
}

// Telegram Passport data has been sent
type MessagePassportDataSent struct {
	meta
	// List of Telegram Passport element types sent
	Types []PassportElementType `json:"types"`
}

func (entity *MessagePassportDataSent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePassportDataSent

	return json.Marshal((*stub)(entity))
}

func (*MessagePassportDataSent) GetClass() string {
	return ClassMessageContent
}

func (*MessagePassportDataSent) GetType() string {
	return TypeMessagePassportDataSent
}

func (*MessagePassportDataSent) MessageContentType() string {
	return TypeMessagePassportDataSent
}

// Telegram Passport data has been received; for bots only
type MessagePassportDataReceived struct {
	meta
	// List of received Telegram Passport elements
	Elements []*EncryptedPassportElement `json:"elements"`
	// Encrypted data credentials
	Credentials *EncryptedCredentials `json:"credentials"`
}

func (entity *MessagePassportDataReceived) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessagePassportDataReceived

	return json.Marshal((*stub)(entity))
}

func (*MessagePassportDataReceived) GetClass() string {
	return ClassMessageContent
}

func (*MessagePassportDataReceived) GetType() string {
	return TypeMessagePassportDataReceived
}

func (*MessagePassportDataReceived) MessageContentType() string {
	return TypeMessagePassportDataReceived
}

// Message content that is not supported by the client
type MessageUnsupported struct {
	meta
}

func (entity *MessageUnsupported) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageUnsupported

	return json.Marshal((*stub)(entity))
}

func (*MessageUnsupported) GetClass() string {
	return ClassMessageContent
}

func (*MessageUnsupported) GetType() string {
	return TypeMessageUnsupported
}

func (*MessageUnsupported) MessageContentType() string {
	return TypeMessageUnsupported
}

// A mention of a user by their username
type TextEntityTypeMention struct {
	meta
}

func (entity *TextEntityTypeMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMention

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMention) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMention) GetType() string {
	return TypeTextEntityTypeMention
}

func (*TextEntityTypeMention) TextEntityTypeType() string {
	return TypeTextEntityTypeMention
}

// A hashtag text, beginning with "#"
type TextEntityTypeHashtag struct {
	meta
}

func (entity *TextEntityTypeHashtag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeHashtag

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeHashtag) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeHashtag) GetType() string {
	return TypeTextEntityTypeHashtag
}

func (*TextEntityTypeHashtag) TextEntityTypeType() string {
	return TypeTextEntityTypeHashtag
}

// A cashtag text, beginning with "$" and consisting of capital english letters (i.e. "$USD")
type TextEntityTypeCashtag struct {
	meta
}

func (entity *TextEntityTypeCashtag) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCashtag

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCashtag) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCashtag) GetType() string {
	return TypeTextEntityTypeCashtag
}

func (*TextEntityTypeCashtag) TextEntityTypeType() string {
	return TypeTextEntityTypeCashtag
}

// A bot command, beginning with "/". This shouldn't be highlighted if there are no bots in the chat
type TextEntityTypeBotCommand struct {
	meta
}

func (entity *TextEntityTypeBotCommand) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBotCommand

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBotCommand) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBotCommand) GetType() string {
	return TypeTextEntityTypeBotCommand
}

func (*TextEntityTypeBotCommand) TextEntityTypeType() string {
	return TypeTextEntityTypeBotCommand
}

// An HTTP URL
type TextEntityTypeUrl struct {
	meta
}

func (entity *TextEntityTypeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeUrl

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeUrl) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeUrl) GetType() string {
	return TypeTextEntityTypeUrl
}

func (*TextEntityTypeUrl) TextEntityTypeType() string {
	return TypeTextEntityTypeUrl
}

// An email address
type TextEntityTypeEmailAddress struct {
	meta
}

func (entity *TextEntityTypeEmailAddress) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeEmailAddress

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeEmailAddress) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeEmailAddress) GetType() string {
	return TypeTextEntityTypeEmailAddress
}

func (*TextEntityTypeEmailAddress) TextEntityTypeType() string {
	return TypeTextEntityTypeEmailAddress
}

// A phone number
type TextEntityTypePhoneNumber struct {
	meta
}

func (entity *TextEntityTypePhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePhoneNumber) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePhoneNumber) GetType() string {
	return TypeTextEntityTypePhoneNumber
}

func (*TextEntityTypePhoneNumber) TextEntityTypeType() string {
	return TypeTextEntityTypePhoneNumber
}

// A bold text
type TextEntityTypeBold struct {
	meta
}

func (entity *TextEntityTypeBold) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeBold

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeBold) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeBold) GetType() string {
	return TypeTextEntityTypeBold
}

func (*TextEntityTypeBold) TextEntityTypeType() string {
	return TypeTextEntityTypeBold
}

// An italic text
type TextEntityTypeItalic struct {
	meta
}

func (entity *TextEntityTypeItalic) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeItalic

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeItalic) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeItalic) GetType() string {
	return TypeTextEntityTypeItalic
}

func (*TextEntityTypeItalic) TextEntityTypeType() string {
	return TypeTextEntityTypeItalic
}

// An underlined text
type TextEntityTypeUnderline struct {
	meta
}

func (entity *TextEntityTypeUnderline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeUnderline

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeUnderline) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeUnderline) GetType() string {
	return TypeTextEntityTypeUnderline
}

func (*TextEntityTypeUnderline) TextEntityTypeType() string {
	return TypeTextEntityTypeUnderline
}

// A strikethrough text
type TextEntityTypeStrikethrough struct {
	meta
}

func (entity *TextEntityTypeStrikethrough) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeStrikethrough

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeStrikethrough) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeStrikethrough) GetType() string {
	return TypeTextEntityTypeStrikethrough
}

func (*TextEntityTypeStrikethrough) TextEntityTypeType() string {
	return TypeTextEntityTypeStrikethrough
}

// Text that must be formatted as if inside a code HTML tag
type TextEntityTypeCode struct {
	meta
}

func (entity *TextEntityTypeCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeCode

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeCode) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeCode) GetType() string {
	return TypeTextEntityTypeCode
}

func (*TextEntityTypeCode) TextEntityTypeType() string {
	return TypeTextEntityTypeCode
}

// Text that must be formatted as if inside a pre HTML tag
type TextEntityTypePre struct {
	meta
}

func (entity *TextEntityTypePre) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePre

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePre) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePre) GetType() string {
	return TypeTextEntityTypePre
}

func (*TextEntityTypePre) TextEntityTypeType() string {
	return TypeTextEntityTypePre
}

// Text that must be formatted as if inside pre, and code HTML tags
type TextEntityTypePreCode struct {
	meta
	// Programming language of the code; as defined by the sender
	Language string `json:"language"`
}

func (entity *TextEntityTypePreCode) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypePreCode

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypePreCode) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypePreCode) GetType() string {
	return TypeTextEntityTypePreCode
}

func (*TextEntityTypePreCode) TextEntityTypeType() string {
	return TypeTextEntityTypePreCode
}

// A text description shown instead of a raw URL
type TextEntityTypeTextUrl struct {
	meta
	// HTTP or tg:// URL to be opened when the link is clicked
	Url string `json:"url"`
}

func (entity *TextEntityTypeTextUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeTextUrl

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeTextUrl) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeTextUrl) GetType() string {
	return TypeTextEntityTypeTextUrl
}

func (*TextEntityTypeTextUrl) TextEntityTypeType() string {
	return TypeTextEntityTypeTextUrl
}

// A text shows instead of a raw mention of the user (e.g., when the user has no username)
type TextEntityTypeMentionName struct {
	meta
	// Identifier of the mentioned user
	UserId int32 `json:"user_id"`
}

func (entity *TextEntityTypeMentionName) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextEntityTypeMentionName

	return json.Marshal((*stub)(entity))
}

func (*TextEntityTypeMentionName) GetClass() string {
	return ClassTextEntityType
}

func (*TextEntityTypeMentionName) GetType() string {
	return TypeTextEntityTypeMentionName
}

func (*TextEntityTypeMentionName) TextEntityTypeType() string {
	return TypeTextEntityTypeMentionName
}

// A thumbnail to be sent along with a file; should be in JPEG or WEBP format for stickers, and less than 200 kB in size
type InputThumbnail struct {
	meta
	// Thumbnail file to send. Sending thumbnails by file_id is currently not supported
	Thumbnail InputFile `json:"thumbnail"`
	// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
	Width int32 `json:"width"`
	// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
	Height int32 `json:"height"`
}

func (entity *InputThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputThumbnail

	return json.Marshal((*stub)(entity))
}

func (*InputThumbnail) GetClass() string {
	return ClassInputThumbnail
}

func (*InputThumbnail) GetType() string {
	return TypeInputThumbnail
}

func (inputThumbnail *InputThumbnail) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Thumbnail json.RawMessage `json:"thumbnail"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputThumbnail.Width = tmp.Width
	inputThumbnail.Height = tmp.Height

	fieldThumbnail, _ := UnmarshalInputFile(tmp.Thumbnail)
	inputThumbnail.Thumbnail = fieldThumbnail

	return nil
}

// The message will be sent at the specified date
type MessageSchedulingStateSendAtDate struct {
	meta
	// Date the message will be sent. The date must be within 367 days in the future
	SendDate int32 `json:"send_date"`
}

func (entity *MessageSchedulingStateSendAtDate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendAtDate

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendAtDate) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendAtDate) GetType() string {
	return TypeMessageSchedulingStateSendAtDate
}

func (*MessageSchedulingStateSendAtDate) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendAtDate
}

// The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known
type MessageSchedulingStateSendWhenOnline struct {
	meta
}

func (entity *MessageSchedulingStateSendWhenOnline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageSchedulingStateSendWhenOnline

	return json.Marshal((*stub)(entity))
}

func (*MessageSchedulingStateSendWhenOnline) GetClass() string {
	return ClassMessageSchedulingState
}

func (*MessageSchedulingStateSendWhenOnline) GetType() string {
	return TypeMessageSchedulingStateSendWhenOnline
}

func (*MessageSchedulingStateSendWhenOnline) MessageSchedulingStateType() string {
	return TypeMessageSchedulingStateSendWhenOnline
}

// Options to be used when a message is send
type SendMessageOptions struct {
	meta
	// Pass true to disable notification for the message. Must be false if the message is sent to a secret chat
	DisableNotification bool `json:"disable_notification"`
	// Pass true if the message is sent from the background
	FromBackground bool `json:"from_background"`
	// Message scheduling state. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
	SchedulingState MessageSchedulingState `json:"scheduling_state"`
}

func (entity *SendMessageOptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SendMessageOptions

	return json.Marshal((*stub)(entity))
}

func (*SendMessageOptions) GetClass() string {
	return ClassSendMessageOptions
}

func (*SendMessageOptions) GetType() string {
	return TypeSendMessageOptions
}

func (sendMessageOptions *SendMessageOptions) UnmarshalJSON(data []byte) error {
	var tmp struct {
		DisableNotification bool            `json:"disable_notification"`
		FromBackground      bool            `json:"from_background"`
		SchedulingState     json.RawMessage `json:"scheduling_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	sendMessageOptions.DisableNotification = tmp.DisableNotification
	sendMessageOptions.FromBackground = tmp.FromBackground

	fieldSchedulingState, _ := UnmarshalMessageSchedulingState(tmp.SchedulingState)
	sendMessageOptions.SchedulingState = fieldSchedulingState

	return nil
}

// A text message
type InputMessageText struct {
	meta
	// Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
	Text *FormattedText `json:"text"`
	// True, if rich web page previews for URLs in the message text should be disabled
	DisableWebPagePreview bool `json:"disable_web_page_preview"`
	// True, if a chat message draft should be deleted
	ClearDraft bool `json:"clear_draft"`
}

func (entity *InputMessageText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageText

	return json.Marshal((*stub)(entity))
}

func (*InputMessageText) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageText) GetType() string {
	return TypeInputMessageText
}

func (*InputMessageText) InputMessageContentType() string {
	return TypeInputMessageText
}

// An animation message (GIF-style).
type InputMessageAnimation struct {
	meta
	// Animation file to be sent
	Animation InputFile `json:"animation"`
	// Animation thumbnail, if available
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Duration of the animation, in seconds
	Duration int32 `json:"duration"`
	// Width of the animation; may be replaced by the server
	Width int32 `json:"width"`
	// Height of the animation; may be replaced by the server
	Height int32 `json:"height"`
	// Animation caption; 0-GetOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageAnimation

	return json.Marshal((*stub)(entity))
}

func (*InputMessageAnimation) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageAnimation) GetType() string {
	return TypeInputMessageAnimation
}

func (*InputMessageAnimation) InputMessageContentType() string {
	return TypeInputMessageAnimation
}

func (inputMessageAnimation *InputMessageAnimation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Animation json.RawMessage `json:"animation"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Duration  int32           `json:"duration"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
		Caption   *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageAnimation.Thumbnail = tmp.Thumbnail
	inputMessageAnimation.Duration = tmp.Duration
	inputMessageAnimation.Width = tmp.Width
	inputMessageAnimation.Height = tmp.Height
	inputMessageAnimation.Caption = tmp.Caption

	fieldAnimation, _ := UnmarshalInputFile(tmp.Animation)
	inputMessageAnimation.Animation = fieldAnimation

	return nil
}

// An audio message
type InputMessageAudio struct {
	meta
	// Audio file to be sent
	Audio InputFile `json:"audio"`
	// Thumbnail of the cover for the album, if available
	AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"`
	// Duration of the audio, in seconds; may be replaced by the server
	Duration int32 `json:"duration"`
	// Title of the audio; 0-64 characters; may be replaced by the server
	Title string `json:"title"`
	// Performer of the audio; 0-64 characters, may be replaced by the server
	Performer string `json:"performer"`
	// Audio caption; 0-GetOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageAudio

	return json.Marshal((*stub)(entity))
}

func (*InputMessageAudio) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageAudio) GetType() string {
	return TypeInputMessageAudio
}

func (*InputMessageAudio) InputMessageContentType() string {
	return TypeInputMessageAudio
}

func (inputMessageAudio *InputMessageAudio) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Audio               json.RawMessage `json:"audio"`
		AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"`
		Duration            int32           `json:"duration"`
		Title               string          `json:"title"`
		Performer           string          `json:"performer"`
		Caption             *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageAudio.AlbumCoverThumbnail = tmp.AlbumCoverThumbnail
	inputMessageAudio.Duration = tmp.Duration
	inputMessageAudio.Title = tmp.Title
	inputMessageAudio.Performer = tmp.Performer
	inputMessageAudio.Caption = tmp.Caption

	fieldAudio, _ := UnmarshalInputFile(tmp.Audio)
	inputMessageAudio.Audio = fieldAudio

	return nil
}

// A document message (general file)
type InputMessageDocument struct {
	meta
	// Document to be sent
	Document InputFile `json:"document"`
	// Document thumbnail, if available
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Document caption; 0-GetOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageDocument

	return json.Marshal((*stub)(entity))
}

func (*InputMessageDocument) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageDocument) GetType() string {
	return TypeInputMessageDocument
}

func (*InputMessageDocument) InputMessageContentType() string {
	return TypeInputMessageDocument
}

func (inputMessageDocument *InputMessageDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Document  json.RawMessage `json:"document"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Caption   *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageDocument.Thumbnail = tmp.Thumbnail
	inputMessageDocument.Caption = tmp.Caption

	fieldDocument, _ := UnmarshalInputFile(tmp.Document)
	inputMessageDocument.Document = fieldDocument

	return nil
}

// A photo message
type InputMessagePhoto struct {
	meta
	// Photo to send
	Photo InputFile `json:"photo"`
	// Photo thumbnail to be sent, this is sent to the other party in secret chats only
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the photo, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Photo width
	Width int32 `json:"width"`
	// Photo height
	Height int32 `json:"height"`
	// Photo caption; 0-GetOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
	Ttl int32 `json:"ttl"`
}

func (entity *InputMessagePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePhoto

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePhoto) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePhoto) GetType() string {
	return TypeInputMessagePhoto
}

func (*InputMessagePhoto) InputMessageContentType() string {
	return TypeInputMessagePhoto
}

func (inputMessagePhoto *InputMessagePhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Photo               json.RawMessage `json:"photo"`
		Thumbnail           *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Width               int32           `json:"width"`
		Height              int32           `json:"height"`
		Caption             *FormattedText  `json:"caption"`
		Ttl                 int32           `json:"ttl"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessagePhoto.Thumbnail = tmp.Thumbnail
	inputMessagePhoto.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessagePhoto.Width = tmp.Width
	inputMessagePhoto.Height = tmp.Height
	inputMessagePhoto.Caption = tmp.Caption
	inputMessagePhoto.Ttl = tmp.Ttl

	fieldPhoto, _ := UnmarshalInputFile(tmp.Photo)
	inputMessagePhoto.Photo = fieldPhoto

	return nil
}

// A sticker message
type InputMessageSticker struct {
	meta
	// Sticker to be sent
	Sticker InputFile `json:"sticker"`
	// Sticker thumbnail, if available
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Sticker width
	Width int32 `json:"width"`
	// Sticker height
	Height int32 `json:"height"`
}

func (entity *InputMessageSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageSticker

	return json.Marshal((*stub)(entity))
}

func (*InputMessageSticker) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageSticker) GetType() string {
	return TypeInputMessageSticker
}

func (*InputMessageSticker) InputMessageContentType() string {
	return TypeInputMessageSticker
}

func (inputMessageSticker *InputMessageSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Sticker   json.RawMessage `json:"sticker"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Width     int32           `json:"width"`
		Height    int32           `json:"height"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageSticker.Thumbnail = tmp.Thumbnail
	inputMessageSticker.Width = tmp.Width
	inputMessageSticker.Height = tmp.Height

	fieldSticker, _ := UnmarshalInputFile(tmp.Sticker)
	inputMessageSticker.Sticker = fieldSticker

	return nil
}

// A video message
type InputMessageVideo struct {
	meta
	// Video to be sent
	Video InputFile `json:"video"`
	// Video thumbnail, if available
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// File identifiers of the stickers added to the video, if applicable
	AddedStickerFileIds []int32 `json:"added_sticker_file_ids"`
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// Video width
	Width int32 `json:"width"`
	// Video height
	Height int32 `json:"height"`
	// True, if the video should be tried to be streamed
	SupportsStreaming bool `json:"supports_streaming"`
	// Video caption; 0-GetOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
	// Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
	Ttl int32 `json:"ttl"`
}

func (entity *InputMessageVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVideo

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVideo) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVideo) GetType() string {
	return TypeInputMessageVideo
}

func (*InputMessageVideo) InputMessageContentType() string {
	return TypeInputMessageVideo
}

func (inputMessageVideo *InputMessageVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Video               json.RawMessage `json:"video"`
		Thumbnail           *InputThumbnail `json:"thumbnail"`
		AddedStickerFileIds []int32         `json:"added_sticker_file_ids"`
		Duration            int32           `json:"duration"`
		Width               int32           `json:"width"`
		Height              int32           `json:"height"`
		SupportsStreaming   bool            `json:"supports_streaming"`
		Caption             *FormattedText  `json:"caption"`
		Ttl                 int32           `json:"ttl"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVideo.Thumbnail = tmp.Thumbnail
	inputMessageVideo.AddedStickerFileIds = tmp.AddedStickerFileIds
	inputMessageVideo.Duration = tmp.Duration
	inputMessageVideo.Width = tmp.Width
	inputMessageVideo.Height = tmp.Height
	inputMessageVideo.SupportsStreaming = tmp.SupportsStreaming
	inputMessageVideo.Caption = tmp.Caption
	inputMessageVideo.Ttl = tmp.Ttl

	fieldVideo, _ := UnmarshalInputFile(tmp.Video)
	inputMessageVideo.Video = fieldVideo

	return nil
}

// A video note message
type InputMessageVideoNote struct {
	meta
	// Video note to be sent
	VideoNote InputFile `json:"video_note"`
	// Video thumbnail, if available
	Thumbnail *InputThumbnail `json:"thumbnail"`
	// Duration of the video, in seconds
	Duration int32 `json:"duration"`
	// Video width and height; must be positive and not greater than 640
	Length int32 `json:"length"`
}

func (entity *InputMessageVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVideoNote

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVideoNote) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVideoNote) GetType() string {
	return TypeInputMessageVideoNote
}

func (*InputMessageVideoNote) InputMessageContentType() string {
	return TypeInputMessageVideoNote
}

func (inputMessageVideoNote *InputMessageVideoNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		VideoNote json.RawMessage `json:"video_note"`
		Thumbnail *InputThumbnail `json:"thumbnail"`
		Duration  int32           `json:"duration"`
		Length    int32           `json:"length"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVideoNote.Thumbnail = tmp.Thumbnail
	inputMessageVideoNote.Duration = tmp.Duration
	inputMessageVideoNote.Length = tmp.Length

	fieldVideoNote, _ := UnmarshalInputFile(tmp.VideoNote)
	inputMessageVideoNote.VideoNote = fieldVideoNote

	return nil
}

// A voice note message
type InputMessageVoiceNote struct {
	meta
	// Voice note to be sent
	VoiceNote InputFile `json:"voice_note"`
	// Duration of the voice note, in seconds
	Duration int32 `json:"duration"`
	// Waveform representation of the voice note, in 5-bit format
	Waveform []byte `json:"waveform"`
	// Voice note caption; 0-GetOption("message_caption_length_max") characters
	Caption *FormattedText `json:"caption"`
}

func (entity *InputMessageVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVoiceNote) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVoiceNote) GetType() string {
	return TypeInputMessageVoiceNote
}

func (*InputMessageVoiceNote) InputMessageContentType() string {
	return TypeInputMessageVoiceNote
}

func (inputMessageVoiceNote *InputMessageVoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		VoiceNote json.RawMessage `json:"voice_note"`
		Duration  int32           `json:"duration"`
		Waveform  []byte          `json:"waveform"`
		Caption   *FormattedText  `json:"caption"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessageVoiceNote.Duration = tmp.Duration
	inputMessageVoiceNote.Waveform = tmp.Waveform
	inputMessageVoiceNote.Caption = tmp.Caption

	fieldVoiceNote, _ := UnmarshalInputFile(tmp.VoiceNote)
	inputMessageVoiceNote.VoiceNote = fieldVoiceNote

	return nil
}

// A message with a location
type InputMessageLocation struct {
	meta
	// Location to be sent
	Location *Location `json:"location"`
	// Period for which the location can be updated, in seconds; should be between 60 and 86400 for a live location and 0 otherwise
	LivePeriod int32 `json:"live_period"`
}

func (entity *InputMessageLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageLocation

	return json.Marshal((*stub)(entity))
}

func (*InputMessageLocation) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageLocation) GetType() string {
	return TypeInputMessageLocation
}

func (*InputMessageLocation) InputMessageContentType() string {
	return TypeInputMessageLocation
}

// A message with information about a venue
type InputMessageVenue struct {
	meta
	// Venue to send
	Venue *Venue `json:"venue"`
}

func (entity *InputMessageVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageVenue

	return json.Marshal((*stub)(entity))
}

func (*InputMessageVenue) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageVenue) GetType() string {
	return TypeInputMessageVenue
}

func (*InputMessageVenue) InputMessageContentType() string {
	return TypeInputMessageVenue
}

// A message containing a user contact
type InputMessageContact struct {
	meta
	// Contact to send
	Contact *Contact `json:"contact"`
}

func (entity *InputMessageContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageContact

	return json.Marshal((*stub)(entity))
}

func (*InputMessageContact) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageContact) GetType() string {
	return TypeInputMessageContact
}

func (*InputMessageContact) InputMessageContentType() string {
	return TypeInputMessageContact
}

// A message with a game; not supported for channels or secret chats
type InputMessageGame struct {
	meta
	// User identifier of the bot that owns the game
	BotUserId int32 `json:"bot_user_id"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
}

func (entity *InputMessageGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageGame

	return json.Marshal((*stub)(entity))
}

func (*InputMessageGame) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageGame) GetType() string {
	return TypeInputMessageGame
}

func (*InputMessageGame) InputMessageContentType() string {
	return TypeInputMessageGame
}

// A message with an invoice; can be used only by bots and only in private chats
type InputMessageInvoice struct {
	meta
	// Invoice
	Invoice *Invoice `json:"invoice"`
	// Product title; 1-32 characters
	Title string `json:"title"`
	// Product description; 0-255 characters
	Description string `json:"description"`
	// Product photo URL; optional
	PhotoUrl string `json:"photo_url"`
	// Product photo size
	PhotoSize int32 `json:"photo_size"`
	// Product photo width
	PhotoWidth int32 `json:"photo_width"`
	// Product photo height
	PhotoHeight int32 `json:"photo_height"`
	// The invoice payload
	Payload []byte `json:"payload"`
	// Payment provider token
	ProviderToken string `json:"provider_token"`
	// JSON-encoded data about the invoice, which will be shared with the payment provider
	ProviderData string `json:"provider_data"`
	// Unique invoice bot start_parameter for the generation of this invoice
	StartParameter string `json:"start_parameter"`
}

func (entity *InputMessageInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageInvoice

	return json.Marshal((*stub)(entity))
}

func (*InputMessageInvoice) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageInvoice) GetType() string {
	return TypeInputMessageInvoice
}

func (*InputMessageInvoice) InputMessageContentType() string {
	return TypeInputMessageInvoice
}

// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
type InputMessagePoll struct {
	meta
	// Poll question, 1-255 characters
	Question string `json:"question"`
	// List of poll answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`
	// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
	IsAnonymous bool `json:"is_anonymous"`
	// Type of the poll
	Type PollType `json:"type"`
	// True, if the poll needs to be sent already closed; for bots only
	IsClosed bool `json:"is_closed"`
}

func (entity *InputMessagePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessagePoll

	return json.Marshal((*stub)(entity))
}

func (*InputMessagePoll) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessagePoll) GetType() string {
	return TypeInputMessagePoll
}

func (*InputMessagePoll) InputMessageContentType() string {
	return TypeInputMessagePoll
}

func (inputMessagePoll *InputMessagePoll) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Question    string          `json:"question"`
		Options     []string        `json:"options"`
		IsAnonymous bool            `json:"is_anonymous"`
		Type        json.RawMessage `json:"type"`
		IsClosed    bool            `json:"is_closed"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputMessagePoll.Question = tmp.Question
	inputMessagePoll.Options = tmp.Options
	inputMessagePoll.IsAnonymous = tmp.IsAnonymous
	inputMessagePoll.IsClosed = tmp.IsClosed

	fieldType, _ := UnmarshalPollType(tmp.Type)
	inputMessagePoll.Type = fieldType

	return nil
}

// A forwarded message
type InputMessageForwarded struct {
	meta
	// Identifier for the chat this forwarded message came from
	FromChatId int64 `json:"from_chat_id"`
	// Identifier of the message to forward
	MessageId int64 `json:"message_id"`
	// True, if a game message should be shared within a launched game; applies only to game messages
	InGameShare bool `json:"in_game_share"`
	// True, if content of the message needs to be copied without a link to the original message. Always true if the message is forwarded to a secret chat
	SendCopy bool `json:"send_copy"`
	// True, if media caption of the message copy needs to be removed. Ignored if send_copy is false
	RemoveCaption bool `json:"remove_caption"`
}

func (entity *InputMessageForwarded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputMessageForwarded

	return json.Marshal((*stub)(entity))
}

func (*InputMessageForwarded) GetClass() string {
	return ClassInputMessageContent
}

func (*InputMessageForwarded) GetType() string {
	return TypeInputMessageForwarded
}

func (*InputMessageForwarded) InputMessageContentType() string {
	return TypeInputMessageForwarded
}

// Returns all found messages, no filter is applied
type SearchMessagesFilterEmpty struct {
	meta
}

func (entity *SearchMessagesFilterEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterEmpty

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterEmpty) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterEmpty) GetType() string {
	return TypeSearchMessagesFilterEmpty
}

func (*SearchMessagesFilterEmpty) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterEmpty
}

// Returns only animation messages
type SearchMessagesFilterAnimation struct {
	meta
}

func (entity *SearchMessagesFilterAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterAnimation

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterAnimation) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterAnimation) GetType() string {
	return TypeSearchMessagesFilterAnimation
}

func (*SearchMessagesFilterAnimation) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterAnimation
}

// Returns only audio messages
type SearchMessagesFilterAudio struct {
	meta
}

func (entity *SearchMessagesFilterAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterAudio

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterAudio) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterAudio) GetType() string {
	return TypeSearchMessagesFilterAudio
}

func (*SearchMessagesFilterAudio) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterAudio
}

// Returns only document messages
type SearchMessagesFilterDocument struct {
	meta
}

func (entity *SearchMessagesFilterDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterDocument

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterDocument) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterDocument) GetType() string {
	return TypeSearchMessagesFilterDocument
}

func (*SearchMessagesFilterDocument) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterDocument
}

// Returns only photo messages
type SearchMessagesFilterPhoto struct {
	meta
}

func (entity *SearchMessagesFilterPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPhoto

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPhoto) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPhoto) GetType() string {
	return TypeSearchMessagesFilterPhoto
}

func (*SearchMessagesFilterPhoto) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPhoto
}

// Returns only video messages
type SearchMessagesFilterVideo struct {
	meta
}

func (entity *SearchMessagesFilterVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVideo

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVideo) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVideo) GetType() string {
	return TypeSearchMessagesFilterVideo
}

func (*SearchMessagesFilterVideo) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVideo
}

// Returns only voice note messages
type SearchMessagesFilterVoiceNote struct {
	meta
}

func (entity *SearchMessagesFilterVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVoiceNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVoiceNote) GetType() string {
	return TypeSearchMessagesFilterVoiceNote
}

func (*SearchMessagesFilterVoiceNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVoiceNote
}

// Returns only photo and video messages
type SearchMessagesFilterPhotoAndVideo struct {
	meta
}

func (entity *SearchMessagesFilterPhotoAndVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterPhotoAndVideo

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterPhotoAndVideo) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterPhotoAndVideo) GetType() string {
	return TypeSearchMessagesFilterPhotoAndVideo
}

func (*SearchMessagesFilterPhotoAndVideo) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterPhotoAndVideo
}

// Returns only messages containing URLs
type SearchMessagesFilterUrl struct {
	meta
}

func (entity *SearchMessagesFilterUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUrl

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUrl) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUrl) GetType() string {
	return TypeSearchMessagesFilterUrl
}

func (*SearchMessagesFilterUrl) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUrl
}

// Returns only messages containing chat photos
type SearchMessagesFilterChatPhoto struct {
	meta
}

func (entity *SearchMessagesFilterChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterChatPhoto) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterChatPhoto) GetType() string {
	return TypeSearchMessagesFilterChatPhoto
}

func (*SearchMessagesFilterChatPhoto) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterChatPhoto
}

// Returns only call messages
type SearchMessagesFilterCall struct {
	meta
}

func (entity *SearchMessagesFilterCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterCall

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterCall) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterCall) GetType() string {
	return TypeSearchMessagesFilterCall
}

func (*SearchMessagesFilterCall) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterCall
}

// Returns only incoming call messages with missed/declined discard reasons
type SearchMessagesFilterMissedCall struct {
	meta
}

func (entity *SearchMessagesFilterMissedCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterMissedCall

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterMissedCall) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterMissedCall) GetType() string {
	return TypeSearchMessagesFilterMissedCall
}

func (*SearchMessagesFilterMissedCall) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterMissedCall
}

// Returns only video note messages
type SearchMessagesFilterVideoNote struct {
	meta
}

func (entity *SearchMessagesFilterVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVideoNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVideoNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVideoNote) GetType() string {
	return TypeSearchMessagesFilterVideoNote
}

func (*SearchMessagesFilterVideoNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVideoNote
}

// Returns only voice and video note messages
type SearchMessagesFilterVoiceAndVideoNote struct {
	meta
}

func (entity *SearchMessagesFilterVoiceAndVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterVoiceAndVideoNote

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterVoiceAndVideoNote) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterVoiceAndVideoNote) GetType() string {
	return TypeSearchMessagesFilterVoiceAndVideoNote
}

func (*SearchMessagesFilterVoiceAndVideoNote) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterVoiceAndVideoNote
}

// Returns only messages with mentions of the current user, or messages that are replies to their messages
type SearchMessagesFilterMention struct {
	meta
}

func (entity *SearchMessagesFilterMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterMention

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterMention) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterMention) GetType() string {
	return TypeSearchMessagesFilterMention
}

func (*SearchMessagesFilterMention) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterMention
}

// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query or by the sending user
type SearchMessagesFilterUnreadMention struct {
	meta
}

func (entity *SearchMessagesFilterUnreadMention) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub SearchMessagesFilterUnreadMention

	return json.Marshal((*stub)(entity))
}

func (*SearchMessagesFilterUnreadMention) GetClass() string {
	return ClassSearchMessagesFilter
}

func (*SearchMessagesFilterUnreadMention) GetType() string {
	return TypeSearchMessagesFilterUnreadMention
}

func (*SearchMessagesFilterUnreadMention) SearchMessagesFilterType() string {
	return TypeSearchMessagesFilterUnreadMention
}

// The user is typing a message
type ChatActionTyping struct {
	meta
}

func (entity *ChatActionTyping) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionTyping

	return json.Marshal((*stub)(entity))
}

func (*ChatActionTyping) GetClass() string {
	return ClassChatAction
}

func (*ChatActionTyping) GetType() string {
	return TypeChatActionTyping
}

func (*ChatActionTyping) ChatActionType() string {
	return TypeChatActionTyping
}

// The user is recording a video
type ChatActionRecordingVideo struct {
	meta
}

func (entity *ChatActionRecordingVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVideo

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVideo) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVideo) GetType() string {
	return TypeChatActionRecordingVideo
}

func (*ChatActionRecordingVideo) ChatActionType() string {
	return TypeChatActionRecordingVideo
}

// The user is uploading a video
type ChatActionUploadingVideo struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVideo

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVideo) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVideo) GetType() string {
	return TypeChatActionUploadingVideo
}

func (*ChatActionUploadingVideo) ChatActionType() string {
	return TypeChatActionUploadingVideo
}

// The user is recording a voice note
type ChatActionRecordingVoiceNote struct {
	meta
}

func (entity *ChatActionRecordingVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVoiceNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVoiceNote) GetType() string {
	return TypeChatActionRecordingVoiceNote
}

func (*ChatActionRecordingVoiceNote) ChatActionType() string {
	return TypeChatActionRecordingVoiceNote
}

// The user is uploading a voice note
type ChatActionUploadingVoiceNote struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVoiceNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVoiceNote) GetType() string {
	return TypeChatActionUploadingVoiceNote
}

func (*ChatActionUploadingVoiceNote) ChatActionType() string {
	return TypeChatActionUploadingVoiceNote
}

// The user is uploading a photo
type ChatActionUploadingPhoto struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingPhoto

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingPhoto) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingPhoto) GetType() string {
	return TypeChatActionUploadingPhoto
}

func (*ChatActionUploadingPhoto) ChatActionType() string {
	return TypeChatActionUploadingPhoto
}

// The user is uploading a document
type ChatActionUploadingDocument struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingDocument

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingDocument) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingDocument) GetType() string {
	return TypeChatActionUploadingDocument
}

func (*ChatActionUploadingDocument) ChatActionType() string {
	return TypeChatActionUploadingDocument
}

// The user is picking a location or venue to send
type ChatActionChoosingLocation struct {
	meta
}

func (entity *ChatActionChoosingLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingLocation) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingLocation) GetType() string {
	return TypeChatActionChoosingLocation
}

func (*ChatActionChoosingLocation) ChatActionType() string {
	return TypeChatActionChoosingLocation
}

// The user is picking a contact to send
type ChatActionChoosingContact struct {
	meta
}

func (entity *ChatActionChoosingContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionChoosingContact

	return json.Marshal((*stub)(entity))
}

func (*ChatActionChoosingContact) GetClass() string {
	return ClassChatAction
}

func (*ChatActionChoosingContact) GetType() string {
	return TypeChatActionChoosingContact
}

func (*ChatActionChoosingContact) ChatActionType() string {
	return TypeChatActionChoosingContact
}

// The user has started to play a game
type ChatActionStartPlayingGame struct {
	meta
}

func (entity *ChatActionStartPlayingGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionStartPlayingGame

	return json.Marshal((*stub)(entity))
}

func (*ChatActionStartPlayingGame) GetClass() string {
	return ClassChatAction
}

func (*ChatActionStartPlayingGame) GetType() string {
	return TypeChatActionStartPlayingGame
}

func (*ChatActionStartPlayingGame) ChatActionType() string {
	return TypeChatActionStartPlayingGame
}

// The user is recording a video note
type ChatActionRecordingVideoNote struct {
	meta
}

func (entity *ChatActionRecordingVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionRecordingVideoNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionRecordingVideoNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionRecordingVideoNote) GetType() string {
	return TypeChatActionRecordingVideoNote
}

func (*ChatActionRecordingVideoNote) ChatActionType() string {
	return TypeChatActionRecordingVideoNote
}

// The user is uploading a video note
type ChatActionUploadingVideoNote struct {
	meta
	// Upload progress, as a percentage
	Progress int32 `json:"progress"`
}

func (entity *ChatActionUploadingVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionUploadingVideoNote

	return json.Marshal((*stub)(entity))
}

func (*ChatActionUploadingVideoNote) GetClass() string {
	return ClassChatAction
}

func (*ChatActionUploadingVideoNote) GetType() string {
	return TypeChatActionUploadingVideoNote
}

func (*ChatActionUploadingVideoNote) ChatActionType() string {
	return TypeChatActionUploadingVideoNote
}

// The user has cancelled the previous action
type ChatActionCancel struct {
	meta
}

func (entity *ChatActionCancel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatActionCancel

	return json.Marshal((*stub)(entity))
}

func (*ChatActionCancel) GetClass() string {
	return ClassChatAction
}

func (*ChatActionCancel) GetType() string {
	return TypeChatActionCancel
}

func (*ChatActionCancel) ChatActionType() string {
	return TypeChatActionCancel
}

// The user status was never changed
type UserStatusEmpty struct {
	meta
}

func (entity *UserStatusEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusEmpty

	return json.Marshal((*stub)(entity))
}

func (*UserStatusEmpty) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusEmpty) GetType() string {
	return TypeUserStatusEmpty
}

func (*UserStatusEmpty) UserStatusType() string {
	return TypeUserStatusEmpty
}

// The user is online
type UserStatusOnline struct {
	meta
	// Point in time (Unix timestamp) when the user's online status will expire
	Expires int32 `json:"expires"`
}

func (entity *UserStatusOnline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusOnline

	return json.Marshal((*stub)(entity))
}

func (*UserStatusOnline) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusOnline) GetType() string {
	return TypeUserStatusOnline
}

func (*UserStatusOnline) UserStatusType() string {
	return TypeUserStatusOnline
}

// The user is offline
type UserStatusOffline struct {
	meta
	// Point in time (Unix timestamp) when the user was last online
	WasOnline int32 `json:"was_online"`
}

func (entity *UserStatusOffline) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusOffline

	return json.Marshal((*stub)(entity))
}

func (*UserStatusOffline) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusOffline) GetType() string {
	return TypeUserStatusOffline
}

func (*UserStatusOffline) UserStatusType() string {
	return TypeUserStatusOffline
}

// The user was online recently
type UserStatusRecently struct {
	meta
}

func (entity *UserStatusRecently) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusRecently

	return json.Marshal((*stub)(entity))
}

func (*UserStatusRecently) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusRecently) GetType() string {
	return TypeUserStatusRecently
}

func (*UserStatusRecently) UserStatusType() string {
	return TypeUserStatusRecently
}

// The user is offline, but was online last week
type UserStatusLastWeek struct {
	meta
}

func (entity *UserStatusLastWeek) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusLastWeek

	return json.Marshal((*stub)(entity))
}

func (*UserStatusLastWeek) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusLastWeek) GetType() string {
	return TypeUserStatusLastWeek
}

func (*UserStatusLastWeek) UserStatusType() string {
	return TypeUserStatusLastWeek
}

// The user is offline, but was online last month
type UserStatusLastMonth struct {
	meta
}

func (entity *UserStatusLastMonth) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserStatusLastMonth

	return json.Marshal((*stub)(entity))
}

func (*UserStatusLastMonth) GetClass() string {
	return ClassUserStatus
}

func (*UserStatusLastMonth) GetType() string {
	return TypeUserStatusLastMonth
}

func (*UserStatusLastMonth) UserStatusType() string {
	return TypeUserStatusLastMonth
}

// Represents a list of stickers
type Stickers struct {
	meta
	// List of stickers
	Stickers []*Sticker `json:"stickers"`
}

func (entity *Stickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Stickers

	return json.Marshal((*stub)(entity))
}

func (*Stickers) GetClass() string {
	return ClassStickers
}

func (*Stickers) GetType() string {
	return TypeStickers
}

// Represents a list of emoji
type Emojis struct {
	meta
	// List of emojis
	Emojis []string `json:"emojis"`
}

func (entity *Emojis) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Emojis

	return json.Marshal((*stub)(entity))
}

func (*Emojis) GetClass() string {
	return ClassEmojis
}

func (*Emojis) GetType() string {
	return TypeEmojis
}

// Represents a sticker set
type StickerSet struct {
	meta
	// Identifier of the sticker set
	Id JsonInt64 `json:"id"`
	// Title of the sticker set
	Title string `json:"title"`
	// Name of the sticker set
	Name string `json:"name"`
	// Sticker set thumbnail in WEBP format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
	Thumbnail *PhotoSize `json:"thumbnail"`
	// True, if the sticker set has been installed by the current user
	IsInstalled bool `json:"is_installed"`
	// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsArchived bool `json:"is_archived"`
	// True, if the sticker set is official
	IsOfficial bool `json:"is_official"`
	// True, is the stickers in the set are animated
	IsAnimated bool `json:"is_animated"`
	// True, if the stickers in the set are masks
	IsMasks bool `json:"is_masks"`
	// True for already viewed trending sticker sets
	IsViewed bool `json:"is_viewed"`
	// List of stickers in this set
	Stickers []*Sticker `json:"stickers"`
	// A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
	Emojis []*Emojis `json:"emojis"`
}

func (entity *StickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSet

	return json.Marshal((*stub)(entity))
}

func (*StickerSet) GetClass() string {
	return ClassStickerSet
}

func (*StickerSet) GetType() string {
	return TypeStickerSet
}

// Represents short information about a sticker set
type StickerSetInfo struct {
	meta
	// Identifier of the sticker set
	Id JsonInt64 `json:"id"`
	// Title of the sticker set
	Title string `json:"title"`
	// Name of the sticker set
	Name string `json:"name"`
	// Sticker set thumbnail in WEBP format with width and height 100; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
	// True, if the sticker set has been installed by current user
	IsInstalled bool `json:"is_installed"`
	// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsArchived bool `json:"is_archived"`
	// True, if the sticker set is official
	IsOfficial bool `json:"is_official"`
	// True, is the stickers in the set are animated
	IsAnimated bool `json:"is_animated"`
	// True, if the stickers in the set are masks
	IsMasks bool `json:"is_masks"`
	// True for already viewed trending sticker sets
	IsViewed bool `json:"is_viewed"`
	// Total number of stickers in the set
	Size int32 `json:"size"`
	// Contains up to the first 5 stickers from the set, depending on the context. If the client needs more stickers the full set should be requested
	Covers []*Sticker `json:"covers"`
}

func (entity *StickerSetInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSetInfo

	return json.Marshal((*stub)(entity))
}

func (*StickerSetInfo) GetClass() string {
	return ClassStickerSetInfo
}

func (*StickerSetInfo) GetType() string {
	return TypeStickerSetInfo
}

// Represents a list of sticker sets
type StickerSets struct {
	meta
	// Approximate total number of sticker sets found
	TotalCount int32 `json:"total_count"`
	// List of sticker sets
	Sets []*StickerSetInfo `json:"sets"`
}

func (entity *StickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StickerSets

	return json.Marshal((*stub)(entity))
}

func (*StickerSets) GetClass() string {
	return ClassStickerSets
}

func (*StickerSets) GetType() string {
	return TypeStickerSets
}

// The call wasn't discarded, or the reason is unknown
type CallDiscardReasonEmpty struct {
	meta
}

func (entity *CallDiscardReasonEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonEmpty

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonEmpty) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonEmpty) GetType() string {
	return TypeCallDiscardReasonEmpty
}

func (*CallDiscardReasonEmpty) CallDiscardReasonType() string {
	return TypeCallDiscardReasonEmpty
}

// The call was ended before the conversation started. It was cancelled by the caller or missed by the other party
type CallDiscardReasonMissed struct {
	meta
}

func (entity *CallDiscardReasonMissed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonMissed

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonMissed) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonMissed) GetType() string {
	return TypeCallDiscardReasonMissed
}

func (*CallDiscardReasonMissed) CallDiscardReasonType() string {
	return TypeCallDiscardReasonMissed
}

// The call was ended before the conversation started. It was declined by the other party
type CallDiscardReasonDeclined struct {
	meta
}

func (entity *CallDiscardReasonDeclined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonDeclined

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonDeclined) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonDeclined) GetType() string {
	return TypeCallDiscardReasonDeclined
}

func (*CallDiscardReasonDeclined) CallDiscardReasonType() string {
	return TypeCallDiscardReasonDeclined
}

// The call was ended during the conversation because the users were disconnected
type CallDiscardReasonDisconnected struct {
	meta
}

func (entity *CallDiscardReasonDisconnected) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonDisconnected

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonDisconnected) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonDisconnected) GetType() string {
	return TypeCallDiscardReasonDisconnected
}

func (*CallDiscardReasonDisconnected) CallDiscardReasonType() string {
	return TypeCallDiscardReasonDisconnected
}

// The call was ended because one of the parties hung up
type CallDiscardReasonHungUp struct {
	meta
}

func (entity *CallDiscardReasonHungUp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallDiscardReasonHungUp

	return json.Marshal((*stub)(entity))
}

func (*CallDiscardReasonHungUp) GetClass() string {
	return ClassCallDiscardReason
}

func (*CallDiscardReasonHungUp) GetType() string {
	return TypeCallDiscardReasonHungUp
}

func (*CallDiscardReasonHungUp) CallDiscardReasonType() string {
	return TypeCallDiscardReasonHungUp
}

// Specifies the supported call protocols
type CallProtocol struct {
	meta
	// True, if UDP peer-to-peer connections are supported
	UdpP2p bool `json:"udp_p2p"`
	// True, if connection through UDP reflectors is supported
	UdpReflector bool `json:"udp_reflector"`
	// The minimum supported API layer; use 65
	MinLayer int32 `json:"min_layer"`
	// The maximum supported API layer; use 65
	MaxLayer int32 `json:"max_layer"`
}

func (entity *CallProtocol) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProtocol

	return json.Marshal((*stub)(entity))
}

func (*CallProtocol) GetClass() string {
	return ClassCallProtocol
}

func (*CallProtocol) GetType() string {
	return TypeCallProtocol
}

// Describes the address of UDP reflectors
type CallConnection struct {
	meta
	// Reflector identifier
	Id JsonInt64 `json:"id"`
	// IPv4 reflector address
	Ip string `json:"ip"`
	// IPv6 reflector address
	Ipv6 string `json:"ipv6"`
	// Reflector port number
	Port int32 `json:"port"`
	// Connection peer tag
	PeerTag []byte `json:"peer_tag"`
}

func (entity *CallConnection) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallConnection

	return json.Marshal((*stub)(entity))
}

func (*CallConnection) GetClass() string {
	return ClassCallConnection
}

func (*CallConnection) GetType() string {
	return TypeCallConnection
}

// Contains the call identifier
type CallId struct {
	meta
	// Call identifier
	Id int32 `json:"id"`
}

func (entity *CallId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallId

	return json.Marshal((*stub)(entity))
}

func (*CallId) GetClass() string {
	return ClassCallId
}

func (*CallId) GetType() string {
	return TypeCallId
}

// The call is pending, waiting to be accepted by a user
type CallStatePending struct {
	meta
	// True, if the call has already been created by the server
	IsCreated bool `json:"is_created"`
	// True, if the call has already been received by the other party
	IsReceived bool `json:"is_received"`
}

func (entity *CallStatePending) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStatePending

	return json.Marshal((*stub)(entity))
}

func (*CallStatePending) GetClass() string {
	return ClassCallState
}

func (*CallStatePending) GetType() string {
	return TypeCallStatePending
}

func (*CallStatePending) CallStateType() string {
	return TypeCallStatePending
}

// The call has been answered and encryption keys are being exchanged
type CallStateExchangingKeys struct {
	meta
}

func (entity *CallStateExchangingKeys) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateExchangingKeys

	return json.Marshal((*stub)(entity))
}

func (*CallStateExchangingKeys) GetClass() string {
	return ClassCallState
}

func (*CallStateExchangingKeys) GetType() string {
	return TypeCallStateExchangingKeys
}

func (*CallStateExchangingKeys) CallStateType() string {
	return TypeCallStateExchangingKeys
}

// The call is ready to use
type CallStateReady struct {
	meta
	// Call protocols supported by the peer
	Protocol *CallProtocol `json:"protocol"`
	// Available UDP reflectors
	Connections []*CallConnection `json:"connections"`
	// A JSON-encoded call config
	Config string `json:"config"`
	// Call encryption key
	EncryptionKey []byte `json:"encryption_key"`
	// Encryption key emojis fingerprint
	Emojis []string `json:"emojis"`
	// True, if peer-to-peer connection is allowed by users privacy settings
	AllowP2p bool `json:"allow_p2p"`
}

func (entity *CallStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateReady

	return json.Marshal((*stub)(entity))
}

func (*CallStateReady) GetClass() string {
	return ClassCallState
}

func (*CallStateReady) GetType() string {
	return TypeCallStateReady
}

func (*CallStateReady) CallStateType() string {
	return TypeCallStateReady
}

// The call is hanging up after discardCall has been called
type CallStateHangingUp struct {
	meta
}

func (entity *CallStateHangingUp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateHangingUp

	return json.Marshal((*stub)(entity))
}

func (*CallStateHangingUp) GetClass() string {
	return ClassCallState
}

func (*CallStateHangingUp) GetType() string {
	return TypeCallStateHangingUp
}

func (*CallStateHangingUp) CallStateType() string {
	return TypeCallStateHangingUp
}

// The call has ended successfully
type CallStateDiscarded struct {
	meta
	// The reason, why the call has ended
	Reason CallDiscardReason `json:"reason"`
	// True, if the call rating should be sent to the server
	NeedRating bool `json:"need_rating"`
	// True, if the call debug information should be sent to the server
	NeedDebugInformation bool `json:"need_debug_information"`
}

func (entity *CallStateDiscarded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateDiscarded

	return json.Marshal((*stub)(entity))
}

func (*CallStateDiscarded) GetClass() string {
	return ClassCallState
}

func (*CallStateDiscarded) GetType() string {
	return TypeCallStateDiscarded
}

func (*CallStateDiscarded) CallStateType() string {
	return TypeCallStateDiscarded
}

func (callStateDiscarded *CallStateDiscarded) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Reason               json.RawMessage `json:"reason"`
		NeedRating           bool            `json:"need_rating"`
		NeedDebugInformation bool            `json:"need_debug_information"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	callStateDiscarded.NeedRating = tmp.NeedRating
	callStateDiscarded.NeedDebugInformation = tmp.NeedDebugInformation

	fieldReason, _ := UnmarshalCallDiscardReason(tmp.Reason)
	callStateDiscarded.Reason = fieldReason

	return nil
}

// The call has ended with an error
type CallStateError struct {
	meta
	// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
	Error *Error `json:"error"`
}

func (entity *CallStateError) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallStateError

	return json.Marshal((*stub)(entity))
}

func (*CallStateError) GetClass() string {
	return ClassCallState
}

func (*CallStateError) GetType() string {
	return TypeCallStateError
}

func (*CallStateError) CallStateType() string {
	return TypeCallStateError
}

// The user heard their own voice
type CallProblemEcho struct {
	meta
}

func (entity *CallProblemEcho) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemEcho

	return json.Marshal((*stub)(entity))
}

func (*CallProblemEcho) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemEcho) GetType() string {
	return TypeCallProblemEcho
}

func (*CallProblemEcho) CallProblemType() string {
	return TypeCallProblemEcho
}

// The user heard background noise
type CallProblemNoise struct {
	meta
}

func (entity *CallProblemNoise) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemNoise

	return json.Marshal((*stub)(entity))
}

func (*CallProblemNoise) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemNoise) GetType() string {
	return TypeCallProblemNoise
}

func (*CallProblemNoise) CallProblemType() string {
	return TypeCallProblemNoise
}

// The other side kept disappearing
type CallProblemInterruptions struct {
	meta
}

func (entity *CallProblemInterruptions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemInterruptions

	return json.Marshal((*stub)(entity))
}

func (*CallProblemInterruptions) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemInterruptions) GetType() string {
	return TypeCallProblemInterruptions
}

func (*CallProblemInterruptions) CallProblemType() string {
	return TypeCallProblemInterruptions
}

// The speech was distorted
type CallProblemDistortedSpeech struct {
	meta
}

func (entity *CallProblemDistortedSpeech) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDistortedSpeech

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDistortedSpeech) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDistortedSpeech) GetType() string {
	return TypeCallProblemDistortedSpeech
}

func (*CallProblemDistortedSpeech) CallProblemType() string {
	return TypeCallProblemDistortedSpeech
}

// The user couldn't hear the other side
type CallProblemSilentLocal struct {
	meta
}

func (entity *CallProblemSilentLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemSilentLocal

	return json.Marshal((*stub)(entity))
}

func (*CallProblemSilentLocal) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemSilentLocal) GetType() string {
	return TypeCallProblemSilentLocal
}

func (*CallProblemSilentLocal) CallProblemType() string {
	return TypeCallProblemSilentLocal
}

// The other side couldn't hear the user
type CallProblemSilentRemote struct {
	meta
}

func (entity *CallProblemSilentRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemSilentRemote

	return json.Marshal((*stub)(entity))
}

func (*CallProblemSilentRemote) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemSilentRemote) GetType() string {
	return TypeCallProblemSilentRemote
}

func (*CallProblemSilentRemote) CallProblemType() string {
	return TypeCallProblemSilentRemote
}

// The call ended unexpectedly
type CallProblemDropped struct {
	meta
}

func (entity *CallProblemDropped) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallProblemDropped

	return json.Marshal((*stub)(entity))
}

func (*CallProblemDropped) GetClass() string {
	return ClassCallProblem
}

func (*CallProblemDropped) GetType() string {
	return TypeCallProblemDropped
}

func (*CallProblemDropped) CallProblemType() string {
	return TypeCallProblemDropped
}

// Describes a call
type Call struct {
	meta
	// Call identifier, not persistent
	Id int32 `json:"id"`
	// Peer user identifier
	UserId int32 `json:"user_id"`
	// True, if the call is outgoing
	IsOutgoing bool `json:"is_outgoing"`
	// Call state
	State CallState `json:"state"`
}

func (entity *Call) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Call

	return json.Marshal((*stub)(entity))
}

func (*Call) GetClass() string {
	return ClassCall
}

func (*Call) GetType() string {
	return TypeCall
}

func (call *Call) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id         int32           `json:"id"`
		UserId     int32           `json:"user_id"`
		IsOutgoing bool            `json:"is_outgoing"`
		State      json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	call.Id = tmp.Id
	call.UserId = tmp.UserId
	call.IsOutgoing = tmp.IsOutgoing

	fieldState, _ := UnmarshalCallState(tmp.State)
	call.State = fieldState

	return nil
}

// Contains settings for the authentication of the user's phone number
type PhoneNumberAuthenticationSettings struct {
	meta
	// Pass true if the authentication code may be sent via flash call to the specified phone number
	AllowFlashCall bool `json:"allow_flash_call"`
	// Pass true if the authenticated phone number is used on the current device
	IsCurrentPhoneNumber bool `json:"is_current_phone_number"`
	// For official applications only. True, if the app can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
	AllowSmsRetrieverApi bool `json:"allow_sms_retriever_api"`
}

func (entity *PhoneNumberAuthenticationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PhoneNumberAuthenticationSettings

	return json.Marshal((*stub)(entity))
}

func (*PhoneNumberAuthenticationSettings) GetClass() string {
	return ClassPhoneNumberAuthenticationSettings
}

func (*PhoneNumberAuthenticationSettings) GetType() string {
	return TypePhoneNumberAuthenticationSettings
}

// Represents a list of animations
type Animations struct {
	meta
	// List of animations
	Animations []*Animation `json:"animations"`
}

func (entity *Animations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Animations

	return json.Marshal((*stub)(entity))
}

func (*Animations) GetClass() string {
	return ClassAnimations
}

func (*Animations) GetType() string {
	return TypeAnimations
}

// Represents the result of an ImportContacts request
type ImportedContacts struct {
	meta
	// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
	UserIds []int32 `json:"user_ids"`
	// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
	ImporterCount []int32 `json:"importer_count"`
}

func (entity *ImportedContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ImportedContacts

	return json.Marshal((*stub)(entity))
}

func (*ImportedContacts) GetClass() string {
	return ClassImportedContacts
}

func (*ImportedContacts) GetType() string {
	return TypeImportedContacts
}

// Contains an HTTP URL
type HttpUrl struct {
	meta
	// The URL
	Url string `json:"url"`
}

func (entity *HttpUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub HttpUrl

	return json.Marshal((*stub)(entity))
}

func (*HttpUrl) GetClass() string {
	return ClassHttpUrl
}

func (*HttpUrl) GetType() string {
	return TypeHttpUrl
}

// Represents a link to an animated GIF
type InputInlineQueryResultAnimatedGif struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the query result
	Title string `json:"title"`
	// URL of the static result thumbnail (JPEG or GIF), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the GIF-file (file size must not exceed 1MB)
	GifUrl string `json:"gif_url"`
	// Duration of the GIF, in seconds
	GifDuration int32 `json:"gif_duration"`
	// Width of the GIF
	GifWidth int32 `json:"gif_width"`
	// Height of the GIF
	GifHeight int32 `json:"gif_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAnimatedGif) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAnimatedGif

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAnimatedGif) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAnimatedGif) GetType() string {
	return TypeInputInlineQueryResultAnimatedGif
}

func (*InputInlineQueryResultAnimatedGif) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAnimatedGif
}

func (inputInlineQueryResultAnimatedGif *InputInlineQueryResultAnimatedGif) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		GifUrl              string          `json:"gif_url"`
		GifDuration         int32           `json:"gif_duration"`
		GifWidth            int32           `json:"gif_width"`
		GifHeight           int32           `json:"gif_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAnimatedGif.Id = tmp.Id
	inputInlineQueryResultAnimatedGif.Title = tmp.Title
	inputInlineQueryResultAnimatedGif.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultAnimatedGif.GifUrl = tmp.GifUrl
	inputInlineQueryResultAnimatedGif.GifDuration = tmp.GifDuration
	inputInlineQueryResultAnimatedGif.GifWidth = tmp.GifWidth
	inputInlineQueryResultAnimatedGif.GifHeight = tmp.GifHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAnimatedGif.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAnimatedGif.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an animated (i.e. without sound) H.264/MPEG-4 AVC video
type InputInlineQueryResultAnimatedMpeg4 struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result
	Title string `json:"title"`
	// URL of the static result thumbnail (JPEG or GIF), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the MPEG4-file (file size must not exceed 1MB)
	Mpeg4Url string `json:"mpeg4_url"`
	// Duration of the video, in seconds
	Mpeg4Duration int32 `json:"mpeg4_duration"`
	// Width of the video
	Mpeg4Width int32 `json:"mpeg4_width"`
	// Height of the video
	Mpeg4Height int32 `json:"mpeg4_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAnimatedMpeg4) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAnimatedMpeg4

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAnimatedMpeg4) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAnimatedMpeg4) GetType() string {
	return TypeInputInlineQueryResultAnimatedMpeg4
}

func (*InputInlineQueryResultAnimatedMpeg4) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAnimatedMpeg4
}

func (inputInlineQueryResultAnimatedMpeg4 *InputInlineQueryResultAnimatedMpeg4) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		Mpeg4Url            string          `json:"mpeg4_url"`
		Mpeg4Duration       int32           `json:"mpeg4_duration"`
		Mpeg4Width          int32           `json:"mpeg4_width"`
		Mpeg4Height         int32           `json:"mpeg4_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAnimatedMpeg4.Id = tmp.Id
	inputInlineQueryResultAnimatedMpeg4.Title = tmp.Title
	inputInlineQueryResultAnimatedMpeg4.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultAnimatedMpeg4.Mpeg4Url = tmp.Mpeg4Url
	inputInlineQueryResultAnimatedMpeg4.Mpeg4Duration = tmp.Mpeg4Duration
	inputInlineQueryResultAnimatedMpeg4.Mpeg4Width = tmp.Mpeg4Width
	inputInlineQueryResultAnimatedMpeg4.Mpeg4Height = tmp.Mpeg4Height

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAnimatedMpeg4.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAnimatedMpeg4.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an article or web page
type InputInlineQueryResultArticle struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the result, if it exists
	Url string `json:"url"`
	// True, if the URL must be not shown
	HideUrl bool `json:"hide_url"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result
	Description string `json:"description"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultArticle

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultArticle) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultArticle) GetType() string {
	return TypeInputInlineQueryResultArticle
}

func (*InputInlineQueryResultArticle) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultArticle
}

func (inputInlineQueryResultArticle *InputInlineQueryResultArticle) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Url                 string          `json:"url"`
		HideUrl             bool            `json:"hide_url"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultArticle.Id = tmp.Id
	inputInlineQueryResultArticle.Url = tmp.Url
	inputInlineQueryResultArticle.HideUrl = tmp.HideUrl
	inputInlineQueryResultArticle.Title = tmp.Title
	inputInlineQueryResultArticle.Description = tmp.Description
	inputInlineQueryResultArticle.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultArticle.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultArticle.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultArticle.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultArticle.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an MP3 audio file
type InputInlineQueryResultAudio struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the audio file
	Title string `json:"title"`
	// Performer of the audio file
	Performer string `json:"performer"`
	// The URL of the audio file
	AudioUrl string `json:"audio_url"`
	// Audio file duration, in seconds
	AudioDuration int32 `json:"audio_duration"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAudio, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultAudio

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultAudio) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultAudio) GetType() string {
	return TypeInputInlineQueryResultAudio
}

func (*InputInlineQueryResultAudio) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultAudio
}

func (inputInlineQueryResultAudio *InputInlineQueryResultAudio) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Performer           string          `json:"performer"`
		AudioUrl            string          `json:"audio_url"`
		AudioDuration       int32           `json:"audio_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultAudio.Id = tmp.Id
	inputInlineQueryResultAudio.Title = tmp.Title
	inputInlineQueryResultAudio.Performer = tmp.Performer
	inputInlineQueryResultAudio.AudioUrl = tmp.AudioUrl
	inputInlineQueryResultAudio.AudioDuration = tmp.AudioDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultAudio.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultAudio.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a user contact
type InputInlineQueryResultContact struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// User contact
	Contact *Contact `json:"contact"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultContact

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultContact) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultContact) GetType() string {
	return TypeInputInlineQueryResultContact
}

func (*InputInlineQueryResultContact) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultContact
}

func (inputInlineQueryResultContact *InputInlineQueryResultContact) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Contact             *Contact        `json:"contact"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultContact.Id = tmp.Id
	inputInlineQueryResultContact.Contact = tmp.Contact
	inputInlineQueryResultContact.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultContact.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultContact.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultContact.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultContact.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a file
type InputInlineQueryResultDocument struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the resulting file
	Title string `json:"title"`
	// Short description of the result, if known
	Description string `json:"description"`
	// URL of the file
	DocumentUrl string `json:"document_url"`
	// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
	MimeType string `json:"mime_type"`
	// The URL of the file thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Width of the thumbnail
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Height of the thumbnail
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageDocument, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultDocument

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultDocument) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultDocument) GetType() string {
	return TypeInputInlineQueryResultDocument
}

func (*InputInlineQueryResultDocument) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultDocument
}

func (inputInlineQueryResultDocument *InputInlineQueryResultDocument) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		DocumentUrl         string          `json:"document_url"`
		MimeType            string          `json:"mime_type"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultDocument.Id = tmp.Id
	inputInlineQueryResultDocument.Title = tmp.Title
	inputInlineQueryResultDocument.Description = tmp.Description
	inputInlineQueryResultDocument.DocumentUrl = tmp.DocumentUrl
	inputInlineQueryResultDocument.MimeType = tmp.MimeType
	inputInlineQueryResultDocument.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultDocument.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultDocument.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultDocument.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultDocument.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a game
type InputInlineQueryResultGame struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Short name of the game
	GameShortName string `json:"game_short_name"`
	// Message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *InputInlineQueryResultGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultGame

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultGame) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultGame) GetType() string {
	return TypeInputInlineQueryResultGame
}

func (*InputInlineQueryResultGame) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultGame
}

func (inputInlineQueryResultGame *InputInlineQueryResultGame) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id            string          `json:"id"`
		GameShortName string          `json:"game_short_name"`
		ReplyMarkup   json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultGame.Id = tmp.Id
	inputInlineQueryResultGame.GameShortName = tmp.GameShortName

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultGame.ReplyMarkup = fieldReplyMarkup

	return nil
}

// Represents a point on the map
type InputInlineQueryResultLocation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Location result
	Location *Location `json:"location"`
	// Amount of time relative to the message sent time until the location can be updated, in seconds
	LivePeriod int32 `json:"live_period"`
	// Title of the result
	Title string `json:"title"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultLocation

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultLocation) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultLocation) GetType() string {
	return TypeInputInlineQueryResultLocation
}

func (*InputInlineQueryResultLocation) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultLocation
}

func (inputInlineQueryResultLocation *InputInlineQueryResultLocation) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Location            *Location       `json:"location"`
		LivePeriod          int32           `json:"live_period"`
		Title               string          `json:"title"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultLocation.Id = tmp.Id
	inputInlineQueryResultLocation.Location = tmp.Location
	inputInlineQueryResultLocation.LivePeriod = tmp.LivePeriod
	inputInlineQueryResultLocation.Title = tmp.Title
	inputInlineQueryResultLocation.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultLocation.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultLocation.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultLocation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultLocation.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents link to a JPEG image
type InputInlineQueryResultPhoto struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result, if known
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
	// URL of the photo thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the JPEG photo (photo size must not exceed 5MB)
	PhotoUrl string `json:"photo_url"`
	// Width of the photo
	PhotoWidth int32 `json:"photo_width"`
	// Height of the photo
	PhotoHeight int32 `json:"photo_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessagePhoto, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultPhoto

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultPhoto) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultPhoto) GetType() string {
	return TypeInputInlineQueryResultPhoto
}

func (*InputInlineQueryResultPhoto) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultPhoto
}

func (inputInlineQueryResultPhoto *InputInlineQueryResultPhoto) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		PhotoUrl            string          `json:"photo_url"`
		PhotoWidth          int32           `json:"photo_width"`
		PhotoHeight         int32           `json:"photo_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultPhoto.Id = tmp.Id
	inputInlineQueryResultPhoto.Title = tmp.Title
	inputInlineQueryResultPhoto.Description = tmp.Description
	inputInlineQueryResultPhoto.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultPhoto.PhotoUrl = tmp.PhotoUrl
	inputInlineQueryResultPhoto.PhotoWidth = tmp.PhotoWidth
	inputInlineQueryResultPhoto.PhotoHeight = tmp.PhotoHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultPhoto.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultPhoto.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a WEBP or TGS sticker
type InputInlineQueryResultSticker struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the sticker thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// The URL of the WEBP or TGS sticker (sticker file size must not exceed 5MB)
	StickerUrl string `json:"sticker_url"`
	// Width of the sticker
	StickerWidth int32 `json:"sticker_width"`
	// Height of the sticker
	StickerHeight int32 `json:"sticker_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, inputMessageSticker, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultSticker

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultSticker) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultSticker) GetType() string {
	return TypeInputInlineQueryResultSticker
}

func (*InputInlineQueryResultSticker) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultSticker
}

func (inputInlineQueryResultSticker *InputInlineQueryResultSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		StickerUrl          string          `json:"sticker_url"`
		StickerWidth        int32           `json:"sticker_width"`
		StickerHeight       int32           `json:"sticker_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultSticker.Id = tmp.Id
	inputInlineQueryResultSticker.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultSticker.StickerUrl = tmp.StickerUrl
	inputInlineQueryResultSticker.StickerWidth = tmp.StickerWidth
	inputInlineQueryResultSticker.StickerHeight = tmp.StickerHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultSticker.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultSticker.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents information about a venue
type InputInlineQueryResultVenue struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Venue result
	Venue *Venue `json:"venue"`
	// URL of the result thumbnail, if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// Thumbnail width, if known
	ThumbnailWidth int32 `json:"thumbnail_width"`
	// Thumbnail height, if known
	ThumbnailHeight int32 `json:"thumbnail_height"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVenue

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVenue) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVenue) GetType() string {
	return TypeInputInlineQueryResultVenue
}

func (*InputInlineQueryResultVenue) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVenue
}

func (inputInlineQueryResultVenue *InputInlineQueryResultVenue) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Venue               *Venue          `json:"venue"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		ThumbnailWidth      int32           `json:"thumbnail_width"`
		ThumbnailHeight     int32           `json:"thumbnail_height"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVenue.Id = tmp.Id
	inputInlineQueryResultVenue.Venue = tmp.Venue
	inputInlineQueryResultVenue.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultVenue.ThumbnailWidth = tmp.ThumbnailWidth
	inputInlineQueryResultVenue.ThumbnailHeight = tmp.ThumbnailHeight

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVenue.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVenue.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to a page containing an embedded video player or a video file
type InputInlineQueryResultVideo struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
	// The URL of the video thumbnail (JPEG), if it exists
	ThumbnailUrl string `json:"thumbnail_url"`
	// URL of the embedded video player or video file
	VideoUrl string `json:"video_url"`
	// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
	MimeType string `json:"mime_type"`
	// Width of the video
	VideoWidth int32 `json:"video_width"`
	// Height of the video
	VideoHeight int32 `json:"video_height"`
	// Video duration, in seconds
	VideoDuration int32 `json:"video_duration"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVideo, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVideo

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVideo) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVideo) GetType() string {
	return TypeInputInlineQueryResultVideo
}

func (*InputInlineQueryResultVideo) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVideo
}

func (inputInlineQueryResultVideo *InputInlineQueryResultVideo) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		Description         string          `json:"description"`
		ThumbnailUrl        string          `json:"thumbnail_url"`
		VideoUrl            string          `json:"video_url"`
		MimeType            string          `json:"mime_type"`
		VideoWidth          int32           `json:"video_width"`
		VideoHeight         int32           `json:"video_height"`
		VideoDuration       int32           `json:"video_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVideo.Id = tmp.Id
	inputInlineQueryResultVideo.Title = tmp.Title
	inputInlineQueryResultVideo.Description = tmp.Description
	inputInlineQueryResultVideo.ThumbnailUrl = tmp.ThumbnailUrl
	inputInlineQueryResultVideo.VideoUrl = tmp.VideoUrl
	inputInlineQueryResultVideo.MimeType = tmp.MimeType
	inputInlineQueryResultVideo.VideoWidth = tmp.VideoWidth
	inputInlineQueryResultVideo.VideoHeight = tmp.VideoHeight
	inputInlineQueryResultVideo.VideoDuration = tmp.VideoDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVideo.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVideo.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
type InputInlineQueryResultVoiceNote struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Title of the voice note
	Title string `json:"title"`
	// The URL of the voice note file
	VoiceNoteUrl string `json:"voice_note_url"`
	// Duration of the voice note, in seconds
	VoiceNoteDuration int32 `json:"voice_note_duration"`
	// The message reply markup. Must be of type replyMarkupInlineKeyboard or null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
	// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVoiceNote, InputMessageLocation, InputMessageVenue or InputMessageContact
	InputMessageContent InputMessageContent `json:"input_message_content"`
}

func (entity *InputInlineQueryResultVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputInlineQueryResultVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InputInlineQueryResultVoiceNote) GetClass() string {
	return ClassInputInlineQueryResult
}

func (*InputInlineQueryResultVoiceNote) GetType() string {
	return TypeInputInlineQueryResultVoiceNote
}

func (*InputInlineQueryResultVoiceNote) InputInlineQueryResultType() string {
	return TypeInputInlineQueryResultVoiceNote
}

func (inputInlineQueryResultVoiceNote *InputInlineQueryResultVoiceNote) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id                  string          `json:"id"`
		Title               string          `json:"title"`
		VoiceNoteUrl        string          `json:"voice_note_url"`
		VoiceNoteDuration   int32           `json:"voice_note_duration"`
		ReplyMarkup         json.RawMessage `json:"reply_markup"`
		InputMessageContent json.RawMessage `json:"input_message_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputInlineQueryResultVoiceNote.Id = tmp.Id
	inputInlineQueryResultVoiceNote.Title = tmp.Title
	inputInlineQueryResultVoiceNote.VoiceNoteUrl = tmp.VoiceNoteUrl
	inputInlineQueryResultVoiceNote.VoiceNoteDuration = tmp.VoiceNoteDuration

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	inputInlineQueryResultVoiceNote.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := UnmarshalInputMessageContent(tmp.InputMessageContent)
	inputInlineQueryResultVoiceNote.InputMessageContent = fieldInputMessageContent

	return nil
}

// Represents a link to an article or web page
type InlineQueryResultArticle struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// URL of the result, if it exists
	Url string `json:"url"`
	// True, if the URL must be not shown
	HideUrl bool `json:"hide_url"`
	// Title of the result
	Title string `json:"title"`
	// A short description of the result
	Description string `json:"description"`
	// Result thumbnail; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
}

func (entity *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultArticle

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultArticle) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultArticle) GetType() string {
	return TypeInlineQueryResultArticle
}

func (*InlineQueryResultArticle) InlineQueryResultType() string {
	return TypeInlineQueryResultArticle
}

// Represents a user contact
type InlineQueryResultContact struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// A user contact
	Contact *Contact `json:"contact"`
	// Result thumbnail; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
}

func (entity *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultContact

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultContact) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultContact) GetType() string {
	return TypeInlineQueryResultContact
}

func (*InlineQueryResultContact) InlineQueryResultType() string {
	return TypeInlineQueryResultContact
}

// Represents a point on the map
type InlineQueryResultLocation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Location result
	Location *Location `json:"location"`
	// Title of the result
	Title string `json:"title"`
	// Result thumbnail; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
}

func (entity *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultLocation

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultLocation) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultLocation) GetType() string {
	return TypeInlineQueryResultLocation
}

func (*InlineQueryResultLocation) InlineQueryResultType() string {
	return TypeInlineQueryResultLocation
}

// Represents information about a venue
type InlineQueryResultVenue struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Venue result
	Venue *Venue `json:"venue"`
	// Result thumbnail; may be null
	Thumbnail *PhotoSize `json:"thumbnail"`
}

func (entity *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVenue

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVenue) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVenue) GetType() string {
	return TypeInlineQueryResultVenue
}

func (*InlineQueryResultVenue) InlineQueryResultType() string {
	return TypeInlineQueryResultVenue
}

// Represents information about a game
type InlineQueryResultGame struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Game result
	Game *Game `json:"game"`
}

func (entity *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultGame

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultGame) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultGame) GetType() string {
	return TypeInlineQueryResultGame
}

func (*InlineQueryResultGame) InlineQueryResultType() string {
	return TypeInlineQueryResultGame
}

// Represents an animation file
type InlineQueryResultAnimation struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Animation file
	Animation *Animation `json:"animation"`
	// Animation title
	Title string `json:"title"`
}

func (entity *InlineQueryResultAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultAnimation

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultAnimation) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultAnimation) GetType() string {
	return TypeInlineQueryResultAnimation
}

func (*InlineQueryResultAnimation) InlineQueryResultType() string {
	return TypeInlineQueryResultAnimation
}

// Represents an audio file
type InlineQueryResultAudio struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Audio file
	Audio *Audio `json:"audio"`
}

func (entity *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultAudio

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultAudio) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultAudio) GetType() string {
	return TypeInlineQueryResultAudio
}

func (*InlineQueryResultAudio) InlineQueryResultType() string {
	return TypeInlineQueryResultAudio
}

// Represents a document
type InlineQueryResultDocument struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Document
	Document *Document `json:"document"`
	// Document title
	Title string `json:"title"`
	// Document description
	Description string `json:"description"`
}

func (entity *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultDocument

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultDocument) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultDocument) GetType() string {
	return TypeInlineQueryResultDocument
}

func (*InlineQueryResultDocument) InlineQueryResultType() string {
	return TypeInlineQueryResultDocument
}

// Represents a photo
type InlineQueryResultPhoto struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Photo
	Photo *Photo `json:"photo"`
	// Title of the result, if known
	Title string `json:"title"`
	// A short description of the result, if known
	Description string `json:"description"`
}

func (entity *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultPhoto

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultPhoto) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultPhoto) GetType() string {
	return TypeInlineQueryResultPhoto
}

func (*InlineQueryResultPhoto) InlineQueryResultType() string {
	return TypeInlineQueryResultPhoto
}

// Represents a sticker
type InlineQueryResultSticker struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Sticker
	Sticker *Sticker `json:"sticker"`
}

func (entity *InlineQueryResultSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultSticker

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultSticker) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultSticker) GetType() string {
	return TypeInlineQueryResultSticker
}

func (*InlineQueryResultSticker) InlineQueryResultType() string {
	return TypeInlineQueryResultSticker
}

// Represents a video
type InlineQueryResultVideo struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Video
	Video *Video `json:"video"`
	// Title of the video
	Title string `json:"title"`
	// Description of the video
	Description string `json:"description"`
}

func (entity *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVideo

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVideo) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVideo) GetType() string {
	return TypeInlineQueryResultVideo
}

func (*InlineQueryResultVideo) InlineQueryResultType() string {
	return TypeInlineQueryResultVideo
}

// Represents a voice note
type InlineQueryResultVoiceNote struct {
	meta
	// Unique identifier of the query result
	Id string `json:"id"`
	// Voice note
	VoiceNote *VoiceNote `json:"voice_note"`
	// Title of the voice note
	Title string `json:"title"`
}

func (entity *InlineQueryResultVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResultVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResultVoiceNote) GetClass() string {
	return ClassInlineQueryResult
}

func (*InlineQueryResultVoiceNote) GetType() string {
	return TypeInlineQueryResultVoiceNote
}

func (*InlineQueryResultVoiceNote) InlineQueryResultType() string {
	return TypeInlineQueryResultVoiceNote
}

// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
type InlineQueryResults struct {
	meta
	// Unique identifier of the inline query
	InlineQueryId JsonInt64 `json:"inline_query_id"`
	// The offset for the next request. If empty, there are no more results
	NextOffset string `json:"next_offset"`
	// Results of the query
	Results []InlineQueryResult `json:"results"`
	// If non-empty, this text should be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter
	SwitchPmText string `json:"switch_pm_text"`
	// Parameter for the bot start message
	SwitchPmParameter string `json:"switch_pm_parameter"`
}

func (entity *InlineQueryResults) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InlineQueryResults

	return json.Marshal((*stub)(entity))
}

func (*InlineQueryResults) GetClass() string {
	return ClassInlineQueryResults
}

func (*InlineQueryResults) GetType() string {
	return TypeInlineQueryResults
}

// The payload from a general callback button
type CallbackQueryPayloadData struct {
	meta
	// Data that was attached to the callback button
	Data []byte `json:"data"`
}

func (entity *CallbackQueryPayloadData) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadData

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadData) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadData) GetType() string {
	return TypeCallbackQueryPayloadData
}

func (*CallbackQueryPayloadData) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadData
}

// The payload from a game callback button
type CallbackQueryPayloadGame struct {
	meta
	// A short name of the game that was attached to the callback button
	GameShortName string `json:"game_short_name"`
}

func (entity *CallbackQueryPayloadGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryPayloadGame

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryPayloadGame) GetClass() string {
	return ClassCallbackQueryPayload
}

func (*CallbackQueryPayloadGame) GetType() string {
	return TypeCallbackQueryPayloadGame
}

func (*CallbackQueryPayloadGame) CallbackQueryPayloadType() string {
	return TypeCallbackQueryPayloadGame
}

// Contains a bot's answer to a callback query
type CallbackQueryAnswer struct {
	meta
	// Text of the answer
	Text string `json:"text"`
	// True, if an alert should be shown to the user instead of a toast notification
	ShowAlert bool `json:"show_alert"`
	// URL to be opened
	Url string `json:"url"`
}

func (entity *CallbackQueryAnswer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CallbackQueryAnswer

	return json.Marshal((*stub)(entity))
}

func (*CallbackQueryAnswer) GetClass() string {
	return ClassCallbackQueryAnswer
}

func (*CallbackQueryAnswer) GetType() string {
	return TypeCallbackQueryAnswer
}

// Contains the result of a custom request
type CustomRequestResult struct {
	meta
	// A JSON-serialized result
	Result string `json:"result"`
}

func (entity *CustomRequestResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CustomRequestResult

	return json.Marshal((*stub)(entity))
}

func (*CustomRequestResult) GetClass() string {
	return ClassCustomRequestResult
}

func (*CustomRequestResult) GetType() string {
	return TypeCustomRequestResult
}

// Contains one row of the game high score table
type GameHighScore struct {
	meta
	// Position in the high score table
	Position int32 `json:"position"`
	// User identifier
	UserId int32 `json:"user_id"`
	// User score
	Score int32 `json:"score"`
}

func (entity *GameHighScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GameHighScore

	return json.Marshal((*stub)(entity))
}

func (*GameHighScore) GetClass() string {
	return ClassGameHighScore
}

func (*GameHighScore) GetType() string {
	return TypeGameHighScore
}

// Contains a list of game high scores
type GameHighScores struct {
	meta
	// A list of game high scores
	Scores []*GameHighScore `json:"scores"`
}

func (entity *GameHighScores) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub GameHighScores

	return json.Marshal((*stub)(entity))
}

func (*GameHighScores) GetClass() string {
	return ClassGameHighScores
}

func (*GameHighScores) GetType() string {
	return TypeGameHighScores
}

// A message was edited
type ChatEventMessageEdited struct {
	meta
	// The original message before the edit
	OldMessage *Message `json:"old_message"`
	// The message after it was edited
	NewMessage *Message `json:"new_message"`
}

func (entity *ChatEventMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageEdited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageEdited) GetType() string {
	return TypeChatEventMessageEdited
}

func (*ChatEventMessageEdited) ChatEventActionType() string {
	return TypeChatEventMessageEdited
}

// A message was deleted
type ChatEventMessageDeleted struct {
	meta
	// Deleted message
	Message *Message `json:"message"`
}

func (entity *ChatEventMessageDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageDeleted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageDeleted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageDeleted) GetType() string {
	return TypeChatEventMessageDeleted
}

func (*ChatEventMessageDeleted) ChatEventActionType() string {
	return TypeChatEventMessageDeleted
}

// A poll in a message was stopped
type ChatEventPollStopped struct {
	meta
	// The message with the poll
	Message *Message `json:"message"`
}

func (entity *ChatEventPollStopped) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPollStopped

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPollStopped) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPollStopped) GetType() string {
	return TypeChatEventPollStopped
}

func (*ChatEventPollStopped) ChatEventActionType() string {
	return TypeChatEventPollStopped
}

// A message was pinned
type ChatEventMessagePinned struct {
	meta
	// Pinned message
	Message *Message `json:"message"`
}

func (entity *ChatEventMessagePinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessagePinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessagePinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessagePinned) GetType() string {
	return TypeChatEventMessagePinned
}

func (*ChatEventMessagePinned) ChatEventActionType() string {
	return TypeChatEventMessagePinned
}

// A message was unpinned
type ChatEventMessageUnpinned struct {
	meta
}

func (entity *ChatEventMessageUnpinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMessageUnpinned

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMessageUnpinned) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMessageUnpinned) GetType() string {
	return TypeChatEventMessageUnpinned
}

func (*ChatEventMessageUnpinned) ChatEventActionType() string {
	return TypeChatEventMessageUnpinned
}

// A new member joined the chat
type ChatEventMemberJoined struct {
	meta
}

func (entity *ChatEventMemberJoined) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberJoined

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberJoined) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberJoined) GetType() string {
	return TypeChatEventMemberJoined
}

func (*ChatEventMemberJoined) ChatEventActionType() string {
	return TypeChatEventMemberJoined
}

// A member left the chat
type ChatEventMemberLeft struct {
	meta
}

func (entity *ChatEventMemberLeft) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberLeft

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberLeft) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberLeft) GetType() string {
	return TypeChatEventMemberLeft
}

func (*ChatEventMemberLeft) ChatEventActionType() string {
	return TypeChatEventMemberLeft
}

// A new chat member was invited
type ChatEventMemberInvited struct {
	meta
	// New member user identifier
	UserId int32 `json:"user_id"`
	// New member status
	Status ChatMemberStatus `json:"status"`
}

func (entity *ChatEventMemberInvited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberInvited

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberInvited) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberInvited) GetType() string {
	return TypeChatEventMemberInvited
}

func (*ChatEventMemberInvited) ChatEventActionType() string {
	return TypeChatEventMemberInvited
}

func (chatEventMemberInvited *ChatEventMemberInvited) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int32           `json:"user_id"`
		Status json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberInvited.UserId = tmp.UserId

	fieldStatus, _ := UnmarshalChatMemberStatus(tmp.Status)
	chatEventMemberInvited.Status = fieldStatus

	return nil
}

// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
type ChatEventMemberPromoted struct {
	meta
	// Chat member user identifier
	UserId int32 `json:"user_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberPromoted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberPromoted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberPromoted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberPromoted) GetType() string {
	return TypeChatEventMemberPromoted
}

func (*ChatEventMemberPromoted) ChatEventActionType() string {
	return TypeChatEventMemberPromoted
}

func (chatEventMemberPromoted *ChatEventMemberPromoted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId    int32           `json:"user_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberPromoted.UserId = tmp.UserId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberPromoted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberPromoted.NewStatus = fieldNewStatus

	return nil
}

// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
type ChatEventMemberRestricted struct {
	meta
	// Chat member user identifier
	UserId int32 `json:"user_id"`
	// Previous status of the chat member
	OldStatus ChatMemberStatus `json:"old_status"`
	// New status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"`
}

func (entity *ChatEventMemberRestricted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventMemberRestricted

	return json.Marshal((*stub)(entity))
}

func (*ChatEventMemberRestricted) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventMemberRestricted) GetType() string {
	return TypeChatEventMemberRestricted
}

func (*ChatEventMemberRestricted) ChatEventActionType() string {
	return TypeChatEventMemberRestricted
}

func (chatEventMemberRestricted *ChatEventMemberRestricted) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId    int32           `json:"user_id"`
		OldStatus json.RawMessage `json:"old_status"`
		NewStatus json.RawMessage `json:"new_status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEventMemberRestricted.UserId = tmp.UserId

	fieldOldStatus, _ := UnmarshalChatMemberStatus(tmp.OldStatus)
	chatEventMemberRestricted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := UnmarshalChatMemberStatus(tmp.NewStatus)
	chatEventMemberRestricted.NewStatus = fieldNewStatus

	return nil
}

// The chat title was changed
type ChatEventTitleChanged struct {
	meta
	// Previous chat title
	OldTitle string `json:"old_title"`
	// New chat title
	NewTitle string `json:"new_title"`
}

func (entity *ChatEventTitleChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventTitleChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventTitleChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventTitleChanged) GetType() string {
	return TypeChatEventTitleChanged
}

func (*ChatEventTitleChanged) ChatEventActionType() string {
	return TypeChatEventTitleChanged
}

// The chat permissions was changed
type ChatEventPermissionsChanged struct {
	meta
	// Previous chat permissions
	OldPermissions *ChatPermissions `json:"old_permissions"`
	// New chat permissions
	NewPermissions *ChatPermissions `json:"new_permissions"`
}

func (entity *ChatEventPermissionsChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPermissionsChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPermissionsChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPermissionsChanged) GetType() string {
	return TypeChatEventPermissionsChanged
}

func (*ChatEventPermissionsChanged) ChatEventActionType() string {
	return TypeChatEventPermissionsChanged
}

// The chat description was changed
type ChatEventDescriptionChanged struct {
	meta
	// Previous chat description
	OldDescription string `json:"old_description"`
	// New chat description
	NewDescription string `json:"new_description"`
}

func (entity *ChatEventDescriptionChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventDescriptionChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventDescriptionChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventDescriptionChanged) GetType() string {
	return TypeChatEventDescriptionChanged
}

func (*ChatEventDescriptionChanged) ChatEventActionType() string {
	return TypeChatEventDescriptionChanged
}

// The chat username was changed
type ChatEventUsernameChanged struct {
	meta
	// Previous chat username
	OldUsername string `json:"old_username"`
	// New chat username
	NewUsername string `json:"new_username"`
}

func (entity *ChatEventUsernameChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventUsernameChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventUsernameChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventUsernameChanged) GetType() string {
	return TypeChatEventUsernameChanged
}

func (*ChatEventUsernameChanged) ChatEventActionType() string {
	return TypeChatEventUsernameChanged
}

// The chat photo was changed
type ChatEventPhotoChanged struct {
	meta
	// Previous chat photo value; may be null
	OldPhoto *Photo `json:"old_photo"`
	// New chat photo value; may be null
	NewPhoto *Photo `json:"new_photo"`
}

func (entity *ChatEventPhotoChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventPhotoChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventPhotoChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventPhotoChanged) GetType() string {
	return TypeChatEventPhotoChanged
}

func (*ChatEventPhotoChanged) ChatEventActionType() string {
	return TypeChatEventPhotoChanged
}

// The can_invite_users permission of a supergroup chat was toggled
type ChatEventInvitesToggled struct {
	meta
	// New value of can_invite_users permission
	CanInviteUsers bool `json:"can_invite_users"`
}

func (entity *ChatEventInvitesToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventInvitesToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventInvitesToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventInvitesToggled) GetType() string {
	return TypeChatEventInvitesToggled
}

func (*ChatEventInvitesToggled) ChatEventActionType() string {
	return TypeChatEventInvitesToggled
}

// The linked chat of a supergroup was changed
type ChatEventLinkedChatChanged struct {
	meta
	// Previous supergroup linked chat identifier
	OldLinkedChatId int64 `json:"old_linked_chat_id"`
	// New supergroup linked chat identifier
	NewLinkedChatId int64 `json:"new_linked_chat_id"`
}

func (entity *ChatEventLinkedChatChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLinkedChatChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLinkedChatChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventLinkedChatChanged) GetType() string {
	return TypeChatEventLinkedChatChanged
}

func (*ChatEventLinkedChatChanged) ChatEventActionType() string {
	return TypeChatEventLinkedChatChanged
}

// The slow_mode_delay setting of a supergroup was changed
type ChatEventSlowModeDelayChanged struct {
	meta
	// Previous value of slow_mode_delay
	OldSlowModeDelay int32 `json:"old_slow_mode_delay"`
	// New value of slow_mode_delay
	NewSlowModeDelay int32 `json:"new_slow_mode_delay"`
}

func (entity *ChatEventSlowModeDelayChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventSlowModeDelayChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventSlowModeDelayChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventSlowModeDelayChanged) GetType() string {
	return TypeChatEventSlowModeDelayChanged
}

func (*ChatEventSlowModeDelayChanged) ChatEventActionType() string {
	return TypeChatEventSlowModeDelayChanged
}

// The sign_messages setting of a channel was toggled
type ChatEventSignMessagesToggled struct {
	meta
	// New value of sign_messages
	SignMessages bool `json:"sign_messages"`
}

func (entity *ChatEventSignMessagesToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventSignMessagesToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventSignMessagesToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventSignMessagesToggled) GetType() string {
	return TypeChatEventSignMessagesToggled
}

func (*ChatEventSignMessagesToggled) ChatEventActionType() string {
	return TypeChatEventSignMessagesToggled
}

// The supergroup sticker set was changed
type ChatEventStickerSetChanged struct {
	meta
	// Previous identifier of the chat sticker set; 0 if none
	OldStickerSetId JsonInt64 `json:"old_sticker_set_id"`
	// New identifier of the chat sticker set; 0 if none
	NewStickerSetId JsonInt64 `json:"new_sticker_set_id"`
}

func (entity *ChatEventStickerSetChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventStickerSetChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventStickerSetChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventStickerSetChanged) GetType() string {
	return TypeChatEventStickerSetChanged
}

func (*ChatEventStickerSetChanged) ChatEventActionType() string {
	return TypeChatEventStickerSetChanged
}

// The supergroup location was changed
type ChatEventLocationChanged struct {
	meta
	// Previous location; may be null
	OldLocation *ChatLocation `json:"old_location"`
	// New location; may be null
	NewLocation *ChatLocation `json:"new_location"`
}

func (entity *ChatEventLocationChanged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLocationChanged

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLocationChanged) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventLocationChanged) GetType() string {
	return TypeChatEventLocationChanged
}

func (*ChatEventLocationChanged) ChatEventActionType() string {
	return TypeChatEventLocationChanged
}

// The is_all_history_available setting of a supergroup was toggled
type ChatEventIsAllHistoryAvailableToggled struct {
	meta
	// New value of is_all_history_available
	IsAllHistoryAvailable bool `json:"is_all_history_available"`
}

func (entity *ChatEventIsAllHistoryAvailableToggled) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventIsAllHistoryAvailableToggled

	return json.Marshal((*stub)(entity))
}

func (*ChatEventIsAllHistoryAvailableToggled) GetClass() string {
	return ClassChatEventAction
}

func (*ChatEventIsAllHistoryAvailableToggled) GetType() string {
	return TypeChatEventIsAllHistoryAvailableToggled
}

func (*ChatEventIsAllHistoryAvailableToggled) ChatEventActionType() string {
	return TypeChatEventIsAllHistoryAvailableToggled
}

// Represents a chat event
type ChatEvent struct {
	meta
	// Chat event identifier
	Id JsonInt64 `json:"id"`
	// Point in time (Unix timestamp) when the event happened
	Date int32 `json:"date"`
	// Identifier of the user who performed the action that triggered the event
	UserId int32 `json:"user_id"`
	// Action performed by the user
	Action ChatEventAction `json:"action"`
}

func (entity *ChatEvent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEvent

	return json.Marshal((*stub)(entity))
}

func (*ChatEvent) GetClass() string {
	return ClassChatEvent
}

func (*ChatEvent) GetType() string {
	return TypeChatEvent
}

func (chatEvent *ChatEvent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id     JsonInt64       `json:"id"`
		Date   int32           `json:"date"`
		UserId int32           `json:"user_id"`
		Action json.RawMessage `json:"action"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	chatEvent.Id = tmp.Id
	chatEvent.Date = tmp.Date
	chatEvent.UserId = tmp.UserId

	fieldAction, _ := UnmarshalChatEventAction(tmp.Action)
	chatEvent.Action = fieldAction

	return nil
}

// Contains a list of chat events
type ChatEvents struct {
	meta
	// List of events
	Events []*ChatEvent `json:"events"`
}

func (entity *ChatEvents) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEvents

	return json.Marshal((*stub)(entity))
}

func (*ChatEvents) GetClass() string {
	return ClassChatEvents
}

func (*ChatEvents) GetType() string {
	return TypeChatEvents
}

// Represents a set of filters used to obtain a chat event log
type ChatEventLogFilters struct {
	meta
	// True, if message edits should be returned
	MessageEdits bool `json:"message_edits"`
	// True, if message deletions should be returned
	MessageDeletions bool `json:"message_deletions"`
	// True, if pin/unpin events should be returned
	MessagePins bool `json:"message_pins"`
	// True, if members joining events should be returned
	MemberJoins bool `json:"member_joins"`
	// True, if members leaving events should be returned
	MemberLeaves bool `json:"member_leaves"`
	// True, if invited member events should be returned
	MemberInvites bool `json:"member_invites"`
	// True, if member promotion/demotion events should be returned
	MemberPromotions bool `json:"member_promotions"`
	// True, if member restricted/unrestricted/banned/unbanned events should be returned
	MemberRestrictions bool `json:"member_restrictions"`
	// True, if changes in chat information should be returned
	InfoChanges bool `json:"info_changes"`
	// True, if changes in chat settings should be returned
	SettingChanges bool `json:"setting_changes"`
}

func (entity *ChatEventLogFilters) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatEventLogFilters

	return json.Marshal((*stub)(entity))
}

func (*ChatEventLogFilters) GetClass() string {
	return ClassChatEventLogFilters
}

func (*ChatEventLogFilters) GetType() string {
	return TypeChatEventLogFilters
}

// An ordinary language pack string
type LanguagePackStringValueOrdinary struct {
	meta
	// String value
	Value string `json:"value"`
}

func (entity *LanguagePackStringValueOrdinary) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValueOrdinary

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValueOrdinary) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValueOrdinary) GetType() string {
	return TypeLanguagePackStringValueOrdinary
}

func (*LanguagePackStringValueOrdinary) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValueOrdinary
}

// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info
type LanguagePackStringValuePluralized struct {
	meta
	// Value for zero objects
	ZeroValue string `json:"zero_value"`
	// Value for one object
	OneValue string `json:"one_value"`
	// Value for two objects
	TwoValue string `json:"two_value"`
	// Value for few objects
	FewValue string `json:"few_value"`
	// Value for many objects
	ManyValue string `json:"many_value"`
	// Default value
	OtherValue string `json:"other_value"`
}

func (entity *LanguagePackStringValuePluralized) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValuePluralized

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValuePluralized) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValuePluralized) GetType() string {
	return TypeLanguagePackStringValuePluralized
}

func (*LanguagePackStringValuePluralized) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValuePluralized
}

// A deleted language pack string, the value should be taken from the built-in english language pack
type LanguagePackStringValueDeleted struct {
	meta
}

func (entity *LanguagePackStringValueDeleted) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStringValueDeleted

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStringValueDeleted) GetClass() string {
	return ClassLanguagePackStringValue
}

func (*LanguagePackStringValueDeleted) GetType() string {
	return TypeLanguagePackStringValueDeleted
}

func (*LanguagePackStringValueDeleted) LanguagePackStringValueType() string {
	return TypeLanguagePackStringValueDeleted
}

// Represents one language pack string
type LanguagePackString struct {
	meta
	// String key
	Key string `json:"key"`
	// String value
	Value LanguagePackStringValue `json:"value"`
}

func (entity *LanguagePackString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackString

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackString) GetClass() string {
	return ClassLanguagePackString
}

func (*LanguagePackString) GetType() string {
	return TypeLanguagePackString
}

func (languagePackString *LanguagePackString) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Key   string          `json:"key"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	languagePackString.Key = tmp.Key

	fieldValue, _ := UnmarshalLanguagePackStringValue(tmp.Value)
	languagePackString.Value = fieldValue

	return nil
}

// Contains a list of language pack strings
type LanguagePackStrings struct {
	meta
	// A list of language pack strings
	Strings []*LanguagePackString `json:"strings"`
}

func (entity *LanguagePackStrings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackStrings

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackStrings) GetClass() string {
	return ClassLanguagePackStrings
}

func (*LanguagePackStrings) GetType() string {
	return TypeLanguagePackStrings
}

// Contains information about a language pack
type LanguagePackInfo struct {
	meta
	// Unique language pack identifier
	Id string `json:"id"`
	// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs
	BaseLanguagePackId string `json:"base_language_pack_id"`
	// Language name
	Name string `json:"name"`
	// Name of the language in that language
	NativeName string `json:"native_name"`
	// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info
	PluralCode string `json:"plural_code"`
	// True, if the language pack is official
	IsOfficial bool `json:"is_official"`
	// True, if the language pack strings are RTL
	IsRtl bool `json:"is_rtl"`
	// True, if the language pack is a beta language pack
	IsBeta bool `json:"is_beta"`
	// True, if the language pack is installed by the current user
	IsInstalled bool `json:"is_installed"`
	// Total number of non-deleted strings from the language pack
	TotalStringCount int32 `json:"total_string_count"`
	// Total number of translated strings from the language pack
	TranslatedStringCount int32 `json:"translated_string_count"`
	// Total number of non-deleted strings from the language pack available locally
	LocalStringCount int32 `json:"local_string_count"`
	// Link to language translation interface; empty for custom local language packs
	TranslationUrl string `json:"translation_url"`
}

func (entity *LanguagePackInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LanguagePackInfo

	return json.Marshal((*stub)(entity))
}

func (*LanguagePackInfo) GetClass() string {
	return ClassLanguagePackInfo
}

func (*LanguagePackInfo) GetType() string {
	return TypeLanguagePackInfo
}

// Contains information about the current localization target
type LocalizationTargetInfo struct {
	meta
	// List of available language packs for this application
	LanguagePacks []*LanguagePackInfo `json:"language_packs"`
}

func (entity *LocalizationTargetInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LocalizationTargetInfo

	return json.Marshal((*stub)(entity))
}

func (*LocalizationTargetInfo) GetClass() string {
	return ClassLocalizationTargetInfo
}

func (*LocalizationTargetInfo) GetType() string {
	return TypeLocalizationTargetInfo
}

// A token for Firebase Cloud Messaging
type DeviceTokenFirebaseCloudMessaging struct {
	meta
	// Device registration token; may be empty to de-register a device
	Token string `json:"token"`
	// True, if push notifications should be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenFirebaseCloudMessaging) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenFirebaseCloudMessaging

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenFirebaseCloudMessaging) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenFirebaseCloudMessaging) GetType() string {
	return TypeDeviceTokenFirebaseCloudMessaging
}

func (*DeviceTokenFirebaseCloudMessaging) DeviceTokenType() string {
	return TypeDeviceTokenFirebaseCloudMessaging
}

// A token for Apple Push Notification service
type DeviceTokenApplePush struct {
	meta
	// Device token; may be empty to de-register a device
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
}

func (entity *DeviceTokenApplePush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenApplePush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenApplePush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenApplePush) GetType() string {
	return TypeDeviceTokenApplePush
}

func (*DeviceTokenApplePush) DeviceTokenType() string {
	return TypeDeviceTokenApplePush
}

// A token for Apple Push Notification service VoIP notifications
type DeviceTokenApplePushVoIP struct {
	meta
	// Device token; may be empty to de-register a device
	DeviceToken string `json:"device_token"`
	// True, if App Sandbox is enabled
	IsAppSandbox bool `json:"is_app_sandbox"`
	// True, if push notifications should be additionally encrypted
	Encrypt bool `json:"encrypt"`
}

func (entity *DeviceTokenApplePushVoIP) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenApplePushVoIP

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenApplePushVoIP) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenApplePushVoIP) GetType() string {
	return TypeDeviceTokenApplePushVoIP
}

func (*DeviceTokenApplePushVoIP) DeviceTokenType() string {
	return TypeDeviceTokenApplePushVoIP
}

// A token for Windows Push Notification Services
type DeviceTokenWindowsPush struct {
	meta
	// The access token that will be used to send notifications; may be empty to de-register a device
	AccessToken string `json:"access_token"`
}

func (entity *DeviceTokenWindowsPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenWindowsPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenWindowsPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenWindowsPush) GetType() string {
	return TypeDeviceTokenWindowsPush
}

func (*DeviceTokenWindowsPush) DeviceTokenType() string {
	return TypeDeviceTokenWindowsPush
}

// A token for Microsoft Push Notification Service
type DeviceTokenMicrosoftPush struct {
	meta
	// Push notification channel URI; may be empty to de-register a device
	ChannelUri string `json:"channel_uri"`
}

func (entity *DeviceTokenMicrosoftPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenMicrosoftPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenMicrosoftPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenMicrosoftPush) GetType() string {
	return TypeDeviceTokenMicrosoftPush
}

func (*DeviceTokenMicrosoftPush) DeviceTokenType() string {
	return TypeDeviceTokenMicrosoftPush
}

// A token for Microsoft Push Notification Service VoIP channel
type DeviceTokenMicrosoftPushVoIP struct {
	meta
	// Push notification channel URI; may be empty to de-register a device
	ChannelUri string `json:"channel_uri"`
}

func (entity *DeviceTokenMicrosoftPushVoIP) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenMicrosoftPushVoIP

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenMicrosoftPushVoIP) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenMicrosoftPushVoIP) GetType() string {
	return TypeDeviceTokenMicrosoftPushVoIP
}

func (*DeviceTokenMicrosoftPushVoIP) DeviceTokenType() string {
	return TypeDeviceTokenMicrosoftPushVoIP
}

// A token for web Push API
type DeviceTokenWebPush struct {
	meta
	// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device
	Endpoint string `json:"endpoint"`
	// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
	P256dhBase64url string `json:"p256dh_base64url"`
	// Base64url-encoded authentication secret
	AuthBase64url string `json:"auth_base64url"`
}

func (entity *DeviceTokenWebPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenWebPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenWebPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenWebPush) GetType() string {
	return TypeDeviceTokenWebPush
}

func (*DeviceTokenWebPush) DeviceTokenType() string {
	return TypeDeviceTokenWebPush
}

// A token for Simple Push API for Firefox OS
type DeviceTokenSimplePush struct {
	meta
	// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device
	Endpoint string `json:"endpoint"`
}

func (entity *DeviceTokenSimplePush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenSimplePush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenSimplePush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenSimplePush) GetType() string {
	return TypeDeviceTokenSimplePush
}

func (*DeviceTokenSimplePush) DeviceTokenType() string {
	return TypeDeviceTokenSimplePush
}

// A token for Ubuntu Push Client service
type DeviceTokenUbuntuPush struct {
	meta
	// Token; may be empty to de-register a device
	Token string `json:"token"`
}

func (entity *DeviceTokenUbuntuPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenUbuntuPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenUbuntuPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenUbuntuPush) GetType() string {
	return TypeDeviceTokenUbuntuPush
}

func (*DeviceTokenUbuntuPush) DeviceTokenType() string {
	return TypeDeviceTokenUbuntuPush
}

// A token for BlackBerry Push Service
type DeviceTokenBlackBerryPush struct {
	meta
	// Token; may be empty to de-register a device
	Token string `json:"token"`
}

func (entity *DeviceTokenBlackBerryPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenBlackBerryPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenBlackBerryPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenBlackBerryPush) GetType() string {
	return TypeDeviceTokenBlackBerryPush
}

func (*DeviceTokenBlackBerryPush) DeviceTokenType() string {
	return TypeDeviceTokenBlackBerryPush
}

// A token for Tizen Push Service
type DeviceTokenTizenPush struct {
	meta
	// Push service registration identifier; may be empty to de-register a device
	RegId string `json:"reg_id"`
}

func (entity *DeviceTokenTizenPush) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeviceTokenTizenPush

	return json.Marshal((*stub)(entity))
}

func (*DeviceTokenTizenPush) GetClass() string {
	return ClassDeviceToken
}

func (*DeviceTokenTizenPush) GetType() string {
	return TypeDeviceTokenTizenPush
}

func (*DeviceTokenTizenPush) DeviceTokenType() string {
	return TypeDeviceTokenTizenPush
}

// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
type PushReceiverId struct {
	meta
	// The globally unique identifier of push notification subscription
	Id JsonInt64 `json:"id"`
}

func (entity *PushReceiverId) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushReceiverId

	return json.Marshal((*stub)(entity))
}

func (*PushReceiverId) GetClass() string {
	return ClassPushReceiverId
}

func (*PushReceiverId) GetType() string {
	return TypePushReceiverId
}

// Describes a solid fill of a background
type BackgroundFillSolid struct {
	meta
	// A color of the background in the RGB24 format
	Color int32 `json:"color"`
}

func (entity *BackgroundFillSolid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillSolid

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillSolid) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillSolid) GetType() string {
	return TypeBackgroundFillSolid
}

func (*BackgroundFillSolid) BackgroundFillType() string {
	return TypeBackgroundFillSolid
}

// Describes a gradient fill of a background
type BackgroundFillGradient struct {
	meta
	// A top color of the background in the RGB24 format
	TopColor int32 `json:"top_color"`
	// A bottom color of the background in the RGB24 format
	BottomColor int32 `json:"bottom_color"`
	// Clockwise rotation angle of the gradient, in degrees; 0-359. Should be always divisible by 45
	RotationAngle int32 `json:"rotation_angle"`
}

func (entity *BackgroundFillGradient) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundFillGradient

	return json.Marshal((*stub)(entity))
}

func (*BackgroundFillGradient) GetClass() string {
	return ClassBackgroundFill
}

func (*BackgroundFillGradient) GetType() string {
	return TypeBackgroundFillGradient
}

func (*BackgroundFillGradient) BackgroundFillType() string {
	return TypeBackgroundFillGradient
}

// A wallpaper in JPEG format
type BackgroundTypeWallpaper struct {
	meta
	// True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
	IsBlurred bool `json:"is_blurred"`
	// True, if the background needs to be slightly moved when device is tilted
	IsMoving bool `json:"is_moving"`
}

func (entity *BackgroundTypeWallpaper) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeWallpaper

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeWallpaper) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeWallpaper) GetType() string {
	return TypeBackgroundTypeWallpaper
}

func (*BackgroundTypeWallpaper) BackgroundTypeType() string {
	return TypeBackgroundTypeWallpaper
}

// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
type BackgroundTypePattern struct {
	meta
	// Description of the background fill
	Fill BackgroundFill `json:"fill"`
	// Intensity of the pattern when it is shown above the filled background, 0-100
	Intensity int32 `json:"intensity"`
	// True, if the background needs to be slightly moved when device is tilted
	IsMoving bool `json:"is_moving"`
}

func (entity *BackgroundTypePattern) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypePattern

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypePattern) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypePattern) GetType() string {
	return TypeBackgroundTypePattern
}

func (*BackgroundTypePattern) BackgroundTypeType() string {
	return TypeBackgroundTypePattern
}

func (backgroundTypePattern *BackgroundTypePattern) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Fill      json.RawMessage `json:"fill"`
		Intensity int32           `json:"intensity"`
		IsMoving  bool            `json:"is_moving"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	backgroundTypePattern.Intensity = tmp.Intensity
	backgroundTypePattern.IsMoving = tmp.IsMoving

	fieldFill, _ := UnmarshalBackgroundFill(tmp.Fill)
	backgroundTypePattern.Fill = fieldFill

	return nil
}

// A filled background
type BackgroundTypeFill struct {
	meta
	// Description of the background fill
	Fill BackgroundFill `json:"fill"`
}

func (entity *BackgroundTypeFill) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub BackgroundTypeFill

	return json.Marshal((*stub)(entity))
}

func (*BackgroundTypeFill) GetClass() string {
	return ClassBackgroundType
}

func (*BackgroundTypeFill) GetType() string {
	return TypeBackgroundTypeFill
}

func (*BackgroundTypeFill) BackgroundTypeType() string {
	return TypeBackgroundTypeFill
}

func (backgroundTypeFill *BackgroundTypeFill) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Fill json.RawMessage `json:"fill"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldFill, _ := UnmarshalBackgroundFill(tmp.Fill)
	backgroundTypeFill.Fill = fieldFill

	return nil
}

// Describes a chat background
type Background struct {
	meta
	// Unique background identifier
	Id JsonInt64 `json:"id"`
	// True, if this is one of default backgrounds
	IsDefault bool `json:"is_default"`
	// True, if the background is dark and is recommended to be used with dark theme
	IsDark bool `json:"is_dark"`
	// Unique background name
	Name string `json:"name"`
	// Document with the background; may be null. Null only for filled backgrounds
	Document *Document `json:"document"`
	// Type of the background
	Type BackgroundType `json:"type"`
}

func (entity *Background) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Background

	return json.Marshal((*stub)(entity))
}

func (*Background) GetClass() string {
	return ClassBackground
}

func (*Background) GetType() string {
	return TypeBackground
}

func (background *Background) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id        JsonInt64       `json:"id"`
		IsDefault bool            `json:"is_default"`
		IsDark    bool            `json:"is_dark"`
		Name      string          `json:"name"`
		Document  *Document       `json:"document"`
		Type      json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	background.Id = tmp.Id
	background.IsDefault = tmp.IsDefault
	background.IsDark = tmp.IsDark
	background.Name = tmp.Name
	background.Document = tmp.Document

	fieldType, _ := UnmarshalBackgroundType(tmp.Type)
	background.Type = fieldType

	return nil
}

// Contains a list of backgrounds
type Backgrounds struct {
	meta
	// A list of backgrounds
	Backgrounds []*Background `json:"backgrounds"`
}

func (entity *Backgrounds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Backgrounds

	return json.Marshal((*stub)(entity))
}

func (*Backgrounds) GetClass() string {
	return ClassBackgrounds
}

func (*Backgrounds) GetType() string {
	return TypeBackgrounds
}

// A background from a local file
type InputBackgroundLocal struct {
	meta
	// Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
	Background InputFile `json:"background"`
}

func (entity *InputBackgroundLocal) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundLocal

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundLocal) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundLocal) GetType() string {
	return TypeInputBackgroundLocal
}

func (*InputBackgroundLocal) InputBackgroundType() string {
	return TypeInputBackgroundLocal
}

func (inputBackgroundLocal *InputBackgroundLocal) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Background json.RawMessage `json:"background"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldBackground, _ := UnmarshalInputFile(tmp.Background)
	inputBackgroundLocal.Background = fieldBackground

	return nil
}

// A background from the server
type InputBackgroundRemote struct {
	meta
	// The background identifier
	BackgroundId JsonInt64 `json:"background_id"`
}

func (entity *InputBackgroundRemote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputBackgroundRemote

	return json.Marshal((*stub)(entity))
}

func (*InputBackgroundRemote) GetClass() string {
	return ClassInputBackground
}

func (*InputBackgroundRemote) GetType() string {
	return TypeInputBackgroundRemote
}

func (*InputBackgroundRemote) InputBackgroundType() string {
	return TypeInputBackgroundRemote
}

// Contains a list of hashtags
type Hashtags struct {
	meta
	// A list of hashtags
	Hashtags []string `json:"hashtags"`
}

func (entity *Hashtags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Hashtags

	return json.Marshal((*stub)(entity))
}

func (*Hashtags) GetClass() string {
	return ClassHashtags
}

func (*Hashtags) GetType() string {
	return TypeHashtags
}

// The session can be used
type CanTransferOwnershipResultOk struct {
	meta
}

func (entity *CanTransferOwnershipResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultOk

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultOk) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultOk) GetType() string {
	return TypeCanTransferOwnershipResultOk
}

func (*CanTransferOwnershipResultOk) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultOk
}

// The 2-step verification needs to be enabled first
type CanTransferOwnershipResultPasswordNeeded struct {
	meta
}

func (entity *CanTransferOwnershipResultPasswordNeeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultPasswordNeeded

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultPasswordNeeded) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultPasswordNeeded) GetType() string {
	return TypeCanTransferOwnershipResultPasswordNeeded
}

func (*CanTransferOwnershipResultPasswordNeeded) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultPasswordNeeded
}

// The 2-step verification was enabled recently, user needs to wait
type CanTransferOwnershipResultPasswordTooFresh struct {
	meta
	// Time left before the session can be used to transfer ownership of a chat, in seconds
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanTransferOwnershipResultPasswordTooFresh) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultPasswordTooFresh

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultPasswordTooFresh) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultPasswordTooFresh) GetType() string {
	return TypeCanTransferOwnershipResultPasswordTooFresh
}

func (*CanTransferOwnershipResultPasswordTooFresh) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultPasswordTooFresh
}

// The session was created recently, user needs to wait
type CanTransferOwnershipResultSessionTooFresh struct {
	meta
	// Time left before the session can be used to transfer ownership of a chat, in seconds
	RetryAfter int32 `json:"retry_after"`
}

func (entity *CanTransferOwnershipResultSessionTooFresh) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CanTransferOwnershipResultSessionTooFresh

	return json.Marshal((*stub)(entity))
}

func (*CanTransferOwnershipResultSessionTooFresh) GetClass() string {
	return ClassCanTransferOwnershipResult
}

func (*CanTransferOwnershipResultSessionTooFresh) GetType() string {
	return TypeCanTransferOwnershipResultSessionTooFresh
}

func (*CanTransferOwnershipResultSessionTooFresh) CanTransferOwnershipResultType() string {
	return TypeCanTransferOwnershipResultSessionTooFresh
}

// The username can be set
type CheckChatUsernameResultOk struct {
	meta
}

func (entity *CheckChatUsernameResultOk) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultOk

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultOk) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultOk) GetType() string {
	return TypeCheckChatUsernameResultOk
}

func (*CheckChatUsernameResultOk) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultOk
}

// The username is invalid
type CheckChatUsernameResultUsernameInvalid struct {
	meta
}

func (entity *CheckChatUsernameResultUsernameInvalid) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernameInvalid

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernameInvalid) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernameInvalid) GetType() string {
	return TypeCheckChatUsernameResultUsernameInvalid
}

func (*CheckChatUsernameResultUsernameInvalid) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernameInvalid
}

// The username is occupied
type CheckChatUsernameResultUsernameOccupied struct {
	meta
}

func (entity *CheckChatUsernameResultUsernameOccupied) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultUsernameOccupied

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultUsernameOccupied) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultUsernameOccupied) GetType() string {
	return TypeCheckChatUsernameResultUsernameOccupied
}

func (*CheckChatUsernameResultUsernameOccupied) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultUsernameOccupied
}

// The user has too much chats with username, one of them should be made private first
type CheckChatUsernameResultPublicChatsTooMuch struct {
	meta
}

func (entity *CheckChatUsernameResultPublicChatsTooMuch) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultPublicChatsTooMuch

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultPublicChatsTooMuch) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultPublicChatsTooMuch) GetType() string {
	return TypeCheckChatUsernameResultPublicChatsTooMuch
}

func (*CheckChatUsernameResultPublicChatsTooMuch) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultPublicChatsTooMuch
}

// The user can't be a member of a public supergroup
type CheckChatUsernameResultPublicGroupsUnavailable struct {
	meta
}

func (entity *CheckChatUsernameResultPublicGroupsUnavailable) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub CheckChatUsernameResultPublicGroupsUnavailable

	return json.Marshal((*stub)(entity))
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) GetClass() string {
	return ClassCheckChatUsernameResult
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) GetType() string {
	return TypeCheckChatUsernameResultPublicGroupsUnavailable
}

func (*CheckChatUsernameResultPublicGroupsUnavailable) CheckChatUsernameResultType() string {
	return TypeCheckChatUsernameResultPublicGroupsUnavailable
}

// A general message with hidden content
type PushMessageContentHidden struct {
	meta
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentHidden) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentHidden

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentHidden) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentHidden) GetType() string {
	return TypePushMessageContentHidden
}

func (*PushMessageContentHidden) PushMessageContentType() string {
	return TypePushMessageContentHidden
}

// An animation message (GIF-style).
type PushMessageContentAnimation struct {
	meta
	// Message content; may be null
	Animation *Animation `json:"animation"`
	// Animation caption
	Caption string `json:"caption"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentAnimation

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentAnimation) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentAnimation) GetType() string {
	return TypePushMessageContentAnimation
}

func (*PushMessageContentAnimation) PushMessageContentType() string {
	return TypePushMessageContentAnimation
}

// An audio message
type PushMessageContentAudio struct {
	meta
	// Message content; may be null
	Audio *Audio `json:"audio"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentAudio

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentAudio) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentAudio) GetType() string {
	return TypePushMessageContentAudio
}

func (*PushMessageContentAudio) PushMessageContentType() string {
	return TypePushMessageContentAudio
}

// A message with a user contact
type PushMessageContentContact struct {
	meta
	// Contact's name
	Name string `json:"name"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentContact) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentContact

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentContact) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentContact) GetType() string {
	return TypePushMessageContentContact
}

func (*PushMessageContentContact) PushMessageContentType() string {
	return TypePushMessageContentContact
}

// A contact has registered with Telegram
type PushMessageContentContactRegistered struct {
	meta
}

func (entity *PushMessageContentContactRegistered) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentContactRegistered

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentContactRegistered) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentContactRegistered) GetType() string {
	return TypePushMessageContentContactRegistered
}

func (*PushMessageContentContactRegistered) PushMessageContentType() string {
	return TypePushMessageContentContactRegistered
}

// A document message (a general file)
type PushMessageContentDocument struct {
	meta
	// Message content; may be null
	Document *Document `json:"document"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentDocument

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentDocument) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentDocument) GetType() string {
	return TypePushMessageContentDocument
}

func (*PushMessageContentDocument) PushMessageContentType() string {
	return TypePushMessageContentDocument
}

// A message with a game
type PushMessageContentGame struct {
	meta
	// Game title, empty for pinned game message
	Title string `json:"title"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGame) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGame

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGame) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGame) GetType() string {
	return TypePushMessageContentGame
}

func (*PushMessageContentGame) PushMessageContentType() string {
	return TypePushMessageContentGame
}

// A new high score was achieved in a game
type PushMessageContentGameScore struct {
	meta
	// Game title, empty for pinned message
	Title string `json:"title"`
	// New score, 0 for pinned message
	Score int32 `json:"score"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentGameScore) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentGameScore

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentGameScore) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentGameScore) GetType() string {
	return TypePushMessageContentGameScore
}

func (*PushMessageContentGameScore) PushMessageContentType() string {
	return TypePushMessageContentGameScore
}

// A message with an invoice from a bot
type PushMessageContentInvoice struct {
	meta
	// Product price
	Price string `json:"price"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentInvoice) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentInvoice

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentInvoice) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentInvoice) GetType() string {
	return TypePushMessageContentInvoice
}

func (*PushMessageContentInvoice) PushMessageContentType() string {
	return TypePushMessageContentInvoice
}

// A message with a location
type PushMessageContentLocation struct {
	meta
	// True, if the location is live
	IsLive bool `json:"is_live"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentLocation

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentLocation) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentLocation) GetType() string {
	return TypePushMessageContentLocation
}

func (*PushMessageContentLocation) PushMessageContentType() string {
	return TypePushMessageContentLocation
}

// A photo message
type PushMessageContentPhoto struct {
	meta
	// Message content; may be null
	Photo *Photo `json:"photo"`
	// Photo caption
	Caption string `json:"caption"`
	// True, if the photo is secret
	IsSecret bool `json:"is_secret"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPhoto) GetType() string {
	return TypePushMessageContentPhoto
}

func (*PushMessageContentPhoto) PushMessageContentType() string {
	return TypePushMessageContentPhoto
}

// A message with a poll
type PushMessageContentPoll struct {
	meta
	// Poll question
	Question string `json:"question"`
	// True, if the poll is regular and not in quiz mode
	IsRegular bool `json:"is_regular"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentPoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentPoll

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentPoll) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentPoll) GetType() string {
	return TypePushMessageContentPoll
}

func (*PushMessageContentPoll) PushMessageContentType() string {
	return TypePushMessageContentPoll
}

// A screenshot of a message in the chat has been taken
type PushMessageContentScreenshotTaken struct {
	meta
}

func (entity *PushMessageContentScreenshotTaken) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentScreenshotTaken

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentScreenshotTaken) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentScreenshotTaken) GetType() string {
	return TypePushMessageContentScreenshotTaken
}

func (*PushMessageContentScreenshotTaken) PushMessageContentType() string {
	return TypePushMessageContentScreenshotTaken
}

// A message with a sticker
type PushMessageContentSticker struct {
	meta
	// Message content; may be null
	Sticker *Sticker `json:"sticker"`
	// Emoji corresponding to the sticker; may be empty
	Emoji string `json:"emoji"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentSticker

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentSticker) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentSticker) GetType() string {
	return TypePushMessageContentSticker
}

func (*PushMessageContentSticker) PushMessageContentType() string {
	return TypePushMessageContentSticker
}

// A text message
type PushMessageContentText struct {
	meta
	// Message text
	Text string `json:"text"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentText) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentText

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentText) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentText) GetType() string {
	return TypePushMessageContentText
}

func (*PushMessageContentText) PushMessageContentType() string {
	return TypePushMessageContentText
}

// A video message
type PushMessageContentVideo struct {
	meta
	// Message content; may be null
	Video *Video `json:"video"`
	// Video caption
	Caption string `json:"caption"`
	// True, if the video is secret
	IsSecret bool `json:"is_secret"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVideo

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVideo) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVideo) GetType() string {
	return TypePushMessageContentVideo
}

func (*PushMessageContentVideo) PushMessageContentType() string {
	return TypePushMessageContentVideo
}

// A video note message
type PushMessageContentVideoNote struct {
	meta
	// Message content; may be null
	VideoNote *VideoNote `json:"video_note"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVideoNote

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVideoNote) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVideoNote) GetType() string {
	return TypePushMessageContentVideoNote
}

func (*PushMessageContentVideoNote) PushMessageContentType() string {
	return TypePushMessageContentVideoNote
}

// A voice note message
type PushMessageContentVoiceNote struct {
	meta
	// Message content; may be null
	VoiceNote *VoiceNote `json:"voice_note"`
	// True, if the message is a pinned message with the specified content
	IsPinned bool `json:"is_pinned"`
}

func (entity *PushMessageContentVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentVoiceNote) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentVoiceNote) GetType() string {
	return TypePushMessageContentVoiceNote
}

func (*PushMessageContentVoiceNote) PushMessageContentType() string {
	return TypePushMessageContentVoiceNote
}

// A newly created basic group
type PushMessageContentBasicGroupChatCreate struct {
	meta
}

func (entity *PushMessageContentBasicGroupChatCreate) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentBasicGroupChatCreate

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentBasicGroupChatCreate) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentBasicGroupChatCreate) GetType() string {
	return TypePushMessageContentBasicGroupChatCreate
}

func (*PushMessageContentBasicGroupChatCreate) PushMessageContentType() string {
	return TypePushMessageContentBasicGroupChatCreate
}

// New chat members were invited to a group
type PushMessageContentChatAddMembers struct {
	meta
	// Name of the added member
	MemberName string `json:"member_name"`
	// True, if the current user was added to the group
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the user has returned to the group themself
	IsReturned bool `json:"is_returned"`
}

func (entity *PushMessageContentChatAddMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatAddMembers

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatAddMembers) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatAddMembers) GetType() string {
	return TypePushMessageContentChatAddMembers
}

func (*PushMessageContentChatAddMembers) PushMessageContentType() string {
	return TypePushMessageContentChatAddMembers
}

// A chat photo was edited
type PushMessageContentChatChangePhoto struct {
	meta
}

func (entity *PushMessageContentChatChangePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatChangePhoto

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatChangePhoto) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatChangePhoto) GetType() string {
	return TypePushMessageContentChatChangePhoto
}

func (*PushMessageContentChatChangePhoto) PushMessageContentType() string {
	return TypePushMessageContentChatChangePhoto
}

// A chat title was edited
type PushMessageContentChatChangeTitle struct {
	meta
	// New chat title
	Title string `json:"title"`
}

func (entity *PushMessageContentChatChangeTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatChangeTitle

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatChangeTitle) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatChangeTitle) GetType() string {
	return TypePushMessageContentChatChangeTitle
}

func (*PushMessageContentChatChangeTitle) PushMessageContentType() string {
	return TypePushMessageContentChatChangeTitle
}

// A chat member was deleted
type PushMessageContentChatDeleteMember struct {
	meta
	// Name of the deleted member
	MemberName string `json:"member_name"`
	// True, if the current user was deleted from the group
	IsCurrentUser bool `json:"is_current_user"`
	// True, if the user has left the group themself
	IsLeft bool `json:"is_left"`
}

func (entity *PushMessageContentChatDeleteMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatDeleteMember

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatDeleteMember) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatDeleteMember) GetType() string {
	return TypePushMessageContentChatDeleteMember
}

func (*PushMessageContentChatDeleteMember) PushMessageContentType() string {
	return TypePushMessageContentChatDeleteMember
}

// A new member joined the chat by invite link
type PushMessageContentChatJoinByLink struct {
	meta
}

func (entity *PushMessageContentChatJoinByLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentChatJoinByLink

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentChatJoinByLink) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentChatJoinByLink) GetType() string {
	return TypePushMessageContentChatJoinByLink
}

func (*PushMessageContentChatJoinByLink) PushMessageContentType() string {
	return TypePushMessageContentChatJoinByLink
}

// A forwarded messages
type PushMessageContentMessageForwards struct {
	meta
	// Number of forwarded messages
	TotalCount int32 `json:"total_count"`
}

func (entity *PushMessageContentMessageForwards) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentMessageForwards

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentMessageForwards) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentMessageForwards) GetType() string {
	return TypePushMessageContentMessageForwards
}

func (*PushMessageContentMessageForwards) PushMessageContentType() string {
	return TypePushMessageContentMessageForwards
}

// A media album
type PushMessageContentMediaAlbum struct {
	meta
	// Number of messages in the album
	TotalCount int32 `json:"total_count"`
	// True, if the album has at least one photo
	HasPhotos bool `json:"has_photos"`
	// True, if the album has at least one video
	HasVideos bool `json:"has_videos"`
}

func (entity *PushMessageContentMediaAlbum) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PushMessageContentMediaAlbum

	return json.Marshal((*stub)(entity))
}

func (*PushMessageContentMediaAlbum) GetClass() string {
	return ClassPushMessageContent
}

func (*PushMessageContentMediaAlbum) GetType() string {
	return TypePushMessageContentMediaAlbum
}

func (*PushMessageContentMediaAlbum) PushMessageContentType() string {
	return TypePushMessageContentMediaAlbum
}

// New message was received
type NotificationTypeNewMessage struct {
	meta
	// The message
	Message *Message `json:"message"`
}

func (entity *NotificationTypeNewMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewMessage

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewMessage) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewMessage) GetType() string {
	return TypeNotificationTypeNewMessage
}

func (*NotificationTypeNewMessage) NotificationTypeType() string {
	return TypeNotificationTypeNewMessage
}

// New secret chat was created
type NotificationTypeNewSecretChat struct {
	meta
}

func (entity *NotificationTypeNewSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewSecretChat

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewSecretChat) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewSecretChat) GetType() string {
	return TypeNotificationTypeNewSecretChat
}

func (*NotificationTypeNewSecretChat) NotificationTypeType() string {
	return TypeNotificationTypeNewSecretChat
}

// New call was received
type NotificationTypeNewCall struct {
	meta
	// Call identifier
	CallId int32 `json:"call_id"`
}

func (entity *NotificationTypeNewCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewCall

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewCall) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewCall) GetType() string {
	return TypeNotificationTypeNewCall
}

func (*NotificationTypeNewCall) NotificationTypeType() string {
	return TypeNotificationTypeNewCall
}

// New message was received through a push notification
type NotificationTypeNewPushMessage struct {
	meta
	// The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages and as reply_to_message_id
	MessageId int64 `json:"message_id"`
	// Sender of the message. Corresponding user may be inaccessible
	SenderUserId int32 `json:"sender_user_id"`
	// Push message content
	Content PushMessageContent `json:"content"`
}

func (entity *NotificationTypeNewPushMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationTypeNewPushMessage

	return json.Marshal((*stub)(entity))
}

func (*NotificationTypeNewPushMessage) GetClass() string {
	return ClassNotificationType
}

func (*NotificationTypeNewPushMessage) GetType() string {
	return TypeNotificationTypeNewPushMessage
}

func (*NotificationTypeNewPushMessage) NotificationTypeType() string {
	return TypeNotificationTypeNewPushMessage
}

func (notificationTypeNewPushMessage *NotificationTypeNewPushMessage) UnmarshalJSON(data []byte) error {
	var tmp struct {
		MessageId    int64           `json:"message_id"`
		SenderUserId int32           `json:"sender_user_id"`
		Content      json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notificationTypeNewPushMessage.MessageId = tmp.MessageId
	notificationTypeNewPushMessage.SenderUserId = tmp.SenderUserId

	fieldContent, _ := UnmarshalPushMessageContent(tmp.Content)
	notificationTypeNewPushMessage.Content = fieldContent

	return nil
}

// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
type NotificationGroupTypeMessages struct {
	meta
}

func (entity *NotificationGroupTypeMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeMessages

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeMessages) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeMessages) GetType() string {
	return TypeNotificationGroupTypeMessages
}

func (*NotificationGroupTypeMessages) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeMessages
}

// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
type NotificationGroupTypeMentions struct {
	meta
}

func (entity *NotificationGroupTypeMentions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeMentions

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeMentions) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeMentions) GetType() string {
	return TypeNotificationGroupTypeMentions
}

func (*NotificationGroupTypeMentions) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeMentions
}

// A group containing a notification of type notificationTypeNewSecretChat
type NotificationGroupTypeSecretChat struct {
	meta
}

func (entity *NotificationGroupTypeSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeSecretChat

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeSecretChat) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeSecretChat) GetType() string {
	return TypeNotificationGroupTypeSecretChat
}

func (*NotificationGroupTypeSecretChat) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeSecretChat
}

// A group containing notifications of type notificationTypeNewCall
type NotificationGroupTypeCalls struct {
	meta
}

func (entity *NotificationGroupTypeCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroupTypeCalls

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroupTypeCalls) GetClass() string {
	return ClassNotificationGroupType
}

func (*NotificationGroupTypeCalls) GetType() string {
	return TypeNotificationGroupTypeCalls
}

func (*NotificationGroupTypeCalls) NotificationGroupTypeType() string {
	return TypeNotificationGroupTypeCalls
}

// Contains information about a notification
type Notification struct {
	meta
	// Unique persistent identifier of this notification
	Id int32 `json:"id"`
	// Notification date
	Date int32 `json:"date"`
	// True, if the notification was initially silent
	IsSilent bool `json:"is_silent"`
	// Notification type
	Type NotificationType `json:"type"`
}

func (entity *Notification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Notification

	return json.Marshal((*stub)(entity))
}

func (*Notification) GetClass() string {
	return ClassNotification
}

func (*Notification) GetType() string {
	return TypeNotification
}

func (notification *Notification) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id       int32           `json:"id"`
		Date     int32           `json:"date"`
		IsSilent bool            `json:"is_silent"`
		Type     json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notification.Id = tmp.Id
	notification.Date = tmp.Date
	notification.IsSilent = tmp.IsSilent

	fieldType, _ := UnmarshalNotificationType(tmp.Type)
	notification.Type = fieldType

	return nil
}

// Describes a group of notifications
type NotificationGroup struct {
	meta
	// Unique persistent auto-incremented from 1 identifier of the notification group
	Id int32 `json:"id"`
	// Type of the group
	Type NotificationGroupType `json:"type"`
	// Identifier of a chat to which all notifications in the group belong
	ChatId int64 `json:"chat_id"`
	// Total number of active notifications in the group
	TotalCount int32 `json:"total_count"`
	// The list of active notifications
	Notifications []*Notification `json:"notifications"`
}

func (entity *NotificationGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NotificationGroup

	return json.Marshal((*stub)(entity))
}

func (*NotificationGroup) GetClass() string {
	return ClassNotificationGroup
}

func (*NotificationGroup) GetType() string {
	return TypeNotificationGroup
}

func (notificationGroup *NotificationGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id            int32           `json:"id"`
		Type          json.RawMessage `json:"type"`
		ChatId        int64           `json:"chat_id"`
		TotalCount    int32           `json:"total_count"`
		Notifications []*Notification `json:"notifications"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	notificationGroup.Id = tmp.Id
	notificationGroup.ChatId = tmp.ChatId
	notificationGroup.TotalCount = tmp.TotalCount
	notificationGroup.Notifications = tmp.Notifications

	fieldType, _ := UnmarshalNotificationGroupType(tmp.Type)
	notificationGroup.Type = fieldType

	return nil
}

// Represents a boolean option
type OptionValueBoolean struct {
	meta
	// The value of the option
	Value bool `json:"value"`
}

func (entity *OptionValueBoolean) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueBoolean

	return json.Marshal((*stub)(entity))
}

func (*OptionValueBoolean) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueBoolean) GetType() string {
	return TypeOptionValueBoolean
}

func (*OptionValueBoolean) OptionValueType() string {
	return TypeOptionValueBoolean
}

// Represents an unknown option or an option which has a default value
type OptionValueEmpty struct {
	meta
}

func (entity *OptionValueEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueEmpty

	return json.Marshal((*stub)(entity))
}

func (*OptionValueEmpty) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueEmpty) GetType() string {
	return TypeOptionValueEmpty
}

func (*OptionValueEmpty) OptionValueType() string {
	return TypeOptionValueEmpty
}

// Represents an integer option
type OptionValueInteger struct {
	meta
	// The value of the option
	Value int32 `json:"value"`
}

func (entity *OptionValueInteger) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueInteger

	return json.Marshal((*stub)(entity))
}

func (*OptionValueInteger) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueInteger) GetType() string {
	return TypeOptionValueInteger
}

func (*OptionValueInteger) OptionValueType() string {
	return TypeOptionValueInteger
}

// Represents a string option
type OptionValueString struct {
	meta
	// The value of the option
	Value string `json:"value"`
}

func (entity *OptionValueString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub OptionValueString

	return json.Marshal((*stub)(entity))
}

func (*OptionValueString) GetClass() string {
	return ClassOptionValue
}

func (*OptionValueString) GetType() string {
	return TypeOptionValueString
}

func (*OptionValueString) OptionValueType() string {
	return TypeOptionValueString
}

// Represents one member of a JSON object
type JsonObjectMember struct {
	meta
	// Member's key
	Key string `json:"key"`
	// Member's value
	Value JsonValue `json:"value"`
}

func (entity *JsonObjectMember) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonObjectMember

	return json.Marshal((*stub)(entity))
}

func (*JsonObjectMember) GetClass() string {
	return ClassJsonObjectMember
}

func (*JsonObjectMember) GetType() string {
	return TypeJsonObjectMember
}

func (jsonObjectMember *JsonObjectMember) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Key   string          `json:"key"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	jsonObjectMember.Key = tmp.Key

	fieldValue, _ := UnmarshalJsonValue(tmp.Value)
	jsonObjectMember.Value = fieldValue

	return nil
}

// Represents a null JSON value
type JsonValueNull struct {
	meta
}

func (entity *JsonValueNull) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueNull

	return json.Marshal((*stub)(entity))
}

func (*JsonValueNull) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueNull) GetType() string {
	return TypeJsonValueNull
}

func (*JsonValueNull) JsonValueType() string {
	return TypeJsonValueNull
}

// Represents a boolean JSON value
type JsonValueBoolean struct {
	meta
	// The value
	Value bool `json:"value"`
}

func (entity *JsonValueBoolean) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueBoolean

	return json.Marshal((*stub)(entity))
}

func (*JsonValueBoolean) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueBoolean) GetType() string {
	return TypeJsonValueBoolean
}

func (*JsonValueBoolean) JsonValueType() string {
	return TypeJsonValueBoolean
}

// Represents a numeric JSON value
type JsonValueNumber struct {
	meta
	// The value
	Value float64 `json:"value"`
}

func (entity *JsonValueNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueNumber

	return json.Marshal((*stub)(entity))
}

func (*JsonValueNumber) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueNumber) GetType() string {
	return TypeJsonValueNumber
}

func (*JsonValueNumber) JsonValueType() string {
	return TypeJsonValueNumber
}

// Represents a string JSON value
type JsonValueString struct {
	meta
	// The value
	Value string `json:"value"`
}

func (entity *JsonValueString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueString

	return json.Marshal((*stub)(entity))
}

func (*JsonValueString) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueString) GetType() string {
	return TypeJsonValueString
}

func (*JsonValueString) JsonValueType() string {
	return TypeJsonValueString
}

// Represents a JSON array
type JsonValueArray struct {
	meta
	// The list of array elements
	Values []JsonValue `json:"values"`
}

func (entity *JsonValueArray) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueArray

	return json.Marshal((*stub)(entity))
}

func (*JsonValueArray) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueArray) GetType() string {
	return TypeJsonValueArray
}

func (*JsonValueArray) JsonValueType() string {
	return TypeJsonValueArray
}

// Represents a JSON object
type JsonValueObject struct {
	meta
	// The list of object members
	Members []*JsonObjectMember `json:"members"`
}

func (entity *JsonValueObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub JsonValueObject

	return json.Marshal((*stub)(entity))
}

func (*JsonValueObject) GetClass() string {
	return ClassJsonValue
}

func (*JsonValueObject) GetType() string {
	return TypeJsonValueObject
}

func (*JsonValueObject) JsonValueType() string {
	return TypeJsonValueObject
}

// A rule to allow all users to do something
type UserPrivacySettingRuleAllowAll struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowAll

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowAll) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowAll) GetType() string {
	return TypeUserPrivacySettingRuleAllowAll
}

func (*UserPrivacySettingRuleAllowAll) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowAll
}

// A rule to allow all of a user's contacts to do something
type UserPrivacySettingRuleAllowContacts struct {
	meta
}

func (entity *UserPrivacySettingRuleAllowContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowContacts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowContacts) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowContacts) GetType() string {
	return TypeUserPrivacySettingRuleAllowContacts
}

func (*UserPrivacySettingRuleAllowContacts) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowContacts
}

// A rule to allow certain specified users to do something
type UserPrivacySettingRuleAllowUsers struct {
	meta
	// The user identifiers, total number of users in all rules must not exceed 1000
	UserIds []int32 `json:"user_ids"`
}

func (entity *UserPrivacySettingRuleAllowUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowUsers) GetType() string {
	return TypeUserPrivacySettingRuleAllowUsers
}

func (*UserPrivacySettingRuleAllowUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowUsers
}

// A rule to allow all members of certain specified basic groups and supergroups to doing something
type UserPrivacySettingRuleAllowChatMembers struct {
	meta
	// The chat identifiers, total number of chats in all rules must not exceed 20
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *UserPrivacySettingRuleAllowChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleAllowChatMembers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleAllowChatMembers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleAllowChatMembers) GetType() string {
	return TypeUserPrivacySettingRuleAllowChatMembers
}

func (*UserPrivacySettingRuleAllowChatMembers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleAllowChatMembers
}

// A rule to restrict all users from doing something
type UserPrivacySettingRuleRestrictAll struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictAll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictAll

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictAll) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictAll) GetType() string {
	return TypeUserPrivacySettingRuleRestrictAll
}

func (*UserPrivacySettingRuleRestrictAll) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictAll
}

// A rule to restrict all contacts of a user from doing something
type UserPrivacySettingRuleRestrictContacts struct {
	meta
}

func (entity *UserPrivacySettingRuleRestrictContacts) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictContacts

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictContacts) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictContacts) GetType() string {
	return TypeUserPrivacySettingRuleRestrictContacts
}

func (*UserPrivacySettingRuleRestrictContacts) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictContacts
}

// A rule to restrict all specified users from doing something
type UserPrivacySettingRuleRestrictUsers struct {
	meta
	// The user identifiers, total number of users in all rules must not exceed 1000
	UserIds []int32 `json:"user_ids"`
}

func (entity *UserPrivacySettingRuleRestrictUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictUsers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictUsers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictUsers) GetType() string {
	return TypeUserPrivacySettingRuleRestrictUsers
}

func (*UserPrivacySettingRuleRestrictUsers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictUsers
}

// A rule to restrict all members of specified basic groups and supergroups from doing something
type UserPrivacySettingRuleRestrictChatMembers struct {
	meta
	// The chat identifiers, total number of chats in all rules must not exceed 20
	ChatIds []int64 `json:"chat_ids"`
}

func (entity *UserPrivacySettingRuleRestrictChatMembers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRuleRestrictChatMembers

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRuleRestrictChatMembers) GetClass() string {
	return ClassUserPrivacySettingRule
}

func (*UserPrivacySettingRuleRestrictChatMembers) GetType() string {
	return TypeUserPrivacySettingRuleRestrictChatMembers
}

func (*UserPrivacySettingRuleRestrictChatMembers) UserPrivacySettingRuleType() string {
	return TypeUserPrivacySettingRuleRestrictChatMembers
}

// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
type UserPrivacySettingRules struct {
	meta
	// A list of rules
	Rules []UserPrivacySettingRule `json:"rules"`
}

func (entity *UserPrivacySettingRules) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingRules

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingRules) GetClass() string {
	return ClassUserPrivacySettingRules
}

func (*UserPrivacySettingRules) GetType() string {
	return TypeUserPrivacySettingRules
}

// A privacy setting for managing whether the user's online status is visible
type UserPrivacySettingShowStatus struct {
	meta
}

func (entity *UserPrivacySettingShowStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowStatus

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowStatus) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowStatus) GetType() string {
	return TypeUserPrivacySettingShowStatus
}

func (*UserPrivacySettingShowStatus) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowStatus
}

// A privacy setting for managing whether the user's profile photo is visible
type UserPrivacySettingShowProfilePhoto struct {
	meta
}

func (entity *UserPrivacySettingShowProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowProfilePhoto) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowProfilePhoto) GetType() string {
	return TypeUserPrivacySettingShowProfilePhoto
}

func (*UserPrivacySettingShowProfilePhoto) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowProfilePhoto
}

// A privacy setting for managing whether a link to the user's account is included in forwarded messages
type UserPrivacySettingShowLinkInForwardedMessages struct {
	meta
}

func (entity *UserPrivacySettingShowLinkInForwardedMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowLinkInForwardedMessages

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowLinkInForwardedMessages) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowLinkInForwardedMessages) GetType() string {
	return TypeUserPrivacySettingShowLinkInForwardedMessages
}

func (*UserPrivacySettingShowLinkInForwardedMessages) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowLinkInForwardedMessages
}

// A privacy setting for managing whether the user's phone number is visible
type UserPrivacySettingShowPhoneNumber struct {
	meta
}

func (entity *UserPrivacySettingShowPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingShowPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingShowPhoneNumber) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingShowPhoneNumber) GetType() string {
	return TypeUserPrivacySettingShowPhoneNumber
}

func (*UserPrivacySettingShowPhoneNumber) UserPrivacySettingType() string {
	return TypeUserPrivacySettingShowPhoneNumber
}

// A privacy setting for managing whether the user can be invited to chats
type UserPrivacySettingAllowChatInvites struct {
	meta
}

func (entity *UserPrivacySettingAllowChatInvites) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowChatInvites

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowChatInvites) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowChatInvites) GetType() string {
	return TypeUserPrivacySettingAllowChatInvites
}

func (*UserPrivacySettingAllowChatInvites) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowChatInvites
}

// A privacy setting for managing whether the user can be called
type UserPrivacySettingAllowCalls struct {
	meta
}

func (entity *UserPrivacySettingAllowCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowCalls

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowCalls) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowCalls) GetType() string {
	return TypeUserPrivacySettingAllowCalls
}

func (*UserPrivacySettingAllowCalls) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowCalls
}

// A privacy setting for managing whether peer-to-peer connections can be used for calls
type UserPrivacySettingAllowPeerToPeerCalls struct {
	meta
}

func (entity *UserPrivacySettingAllowPeerToPeerCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowPeerToPeerCalls

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowPeerToPeerCalls) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowPeerToPeerCalls) GetType() string {
	return TypeUserPrivacySettingAllowPeerToPeerCalls
}

func (*UserPrivacySettingAllowPeerToPeerCalls) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowPeerToPeerCalls
}

// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
type UserPrivacySettingAllowFindingByPhoneNumber struct {
	meta
}

func (entity *UserPrivacySettingAllowFindingByPhoneNumber) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UserPrivacySettingAllowFindingByPhoneNumber

	return json.Marshal((*stub)(entity))
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) GetClass() string {
	return ClassUserPrivacySetting
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) GetType() string {
	return TypeUserPrivacySettingAllowFindingByPhoneNumber
}

func (*UserPrivacySettingAllowFindingByPhoneNumber) UserPrivacySettingType() string {
	return TypeUserPrivacySettingAllowFindingByPhoneNumber
}

// Contains information about the period of inactivity after which the current user's account will automatically be deleted
type AccountTtl struct {
	meta
	// Number of days of inactivity before the account will be flagged for deletion; should range from 30-366 days
	Days int32 `json:"days"`
}

func (entity *AccountTtl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AccountTtl

	return json.Marshal((*stub)(entity))
}

func (*AccountTtl) GetClass() string {
	return ClassAccountTtl
}

func (*AccountTtl) GetType() string {
	return TypeAccountTtl
}

// Contains information about one session in a Telegram application used by the current user. Sessions should be shown to the user in the returned order
type Session struct {
	meta
	// Session identifier
	Id JsonInt64 `json:"id"`
	// True, if this session is the current session
	IsCurrent bool `json:"is_current"`
	// True, if a password is needed to complete authorization of the session
	IsPasswordPending bool `json:"is_password_pending"`
	// Telegram API identifier, as provided by the application
	ApiId int32 `json:"api_id"`
	// Name of the application, as provided by the application
	ApplicationName string `json:"application_name"`
	// The version of the application, as provided by the application
	ApplicationVersion string `json:"application_version"`
	// True, if the application is an official application or uses the api_id of an official application
	IsOfficialApplication bool `json:"is_official_application"`
	// Model of the device the application has been run or is running on, as provided by the application
	DeviceModel string `json:"device_model"`
	// Operating system the application has been run or is running on, as provided by the application
	Platform string `json:"platform"`
	// Version of the operating system the application has been run or is running on, as provided by the application
	SystemVersion string `json:"system_version"`
	// Point in time (Unix timestamp) when the user has logged in
	LogInDate int32 `json:"log_in_date"`
	// Point in time (Unix timestamp) when the session was last used
	LastActiveDate int32 `json:"last_active_date"`
	// IP address from which the session was created, in human-readable format
	Ip string `json:"ip"`
	// A two-letter country code for the country from which the session was created, based on the IP address
	Country string `json:"country"`
	// Region code from which the session was created, based on the IP address
	Region string `json:"region"`
}

func (entity *Session) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Session

	return json.Marshal((*stub)(entity))
}

func (*Session) GetClass() string {
	return ClassSession
}

func (*Session) GetType() string {
	return TypeSession
}

// Contains a list of sessions
type Sessions struct {
	meta
	// List of sessions
	Sessions []*Session `json:"sessions"`
}

func (entity *Sessions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Sessions

	return json.Marshal((*stub)(entity))
}

func (*Sessions) GetClass() string {
	return ClassSessions
}

func (*Sessions) GetType() string {
	return TypeSessions
}

// Contains information about one website the current user is logged in with Telegram
type ConnectedWebsite struct {
	meta
	// Website identifier
	Id JsonInt64 `json:"id"`
	// The domain name of the website
	DomainName string `json:"domain_name"`
	// User identifier of a bot linked with the website
	BotUserId int32 `json:"bot_user_id"`
	// The version of a browser used to log in
	Browser string `json:"browser"`
	// Operating system the browser is running on
	Platform string `json:"platform"`
	// Point in time (Unix timestamp) when the user was logged in
	LogInDate int32 `json:"log_in_date"`
	// Point in time (Unix timestamp) when obtained authorization was last used
	LastActiveDate int32 `json:"last_active_date"`
	// IP address from which the user was logged in, in human-readable format
	Ip string `json:"ip"`
	// Human-readable description of a country and a region, from which the user was logged in, based on the IP address
	Location string `json:"location"`
}

func (entity *ConnectedWebsite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectedWebsite

	return json.Marshal((*stub)(entity))
}

func (*ConnectedWebsite) GetClass() string {
	return ClassConnectedWebsite
}

func (*ConnectedWebsite) GetType() string {
	return TypeConnectedWebsite
}

// Contains a list of websites the current user is logged in with Telegram
type ConnectedWebsites struct {
	meta
	// List of connected websites
	Websites []*ConnectedWebsite `json:"websites"`
}

func (entity *ConnectedWebsites) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectedWebsites

	return json.Marshal((*stub)(entity))
}

func (*ConnectedWebsites) GetClass() string {
	return ClassConnectedWebsites
}

func (*ConnectedWebsites) GetType() string {
	return TypeConnectedWebsites
}

// The chat contains spam messages
type ChatReportReasonSpam struct {
	meta
}

func (entity *ChatReportReasonSpam) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonSpam

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonSpam) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonSpam) GetType() string {
	return TypeChatReportReasonSpam
}

func (*ChatReportReasonSpam) ChatReportReasonType() string {
	return TypeChatReportReasonSpam
}

// The chat promotes violence
type ChatReportReasonViolence struct {
	meta
}

func (entity *ChatReportReasonViolence) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonViolence

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonViolence) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonViolence) GetType() string {
	return TypeChatReportReasonViolence
}

func (*ChatReportReasonViolence) ChatReportReasonType() string {
	return TypeChatReportReasonViolence
}

// The chat contains pornographic messages
type ChatReportReasonPornography struct {
	meta
}

func (entity *ChatReportReasonPornography) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonPornography

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonPornography) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonPornography) GetType() string {
	return TypeChatReportReasonPornography
}

func (*ChatReportReasonPornography) ChatReportReasonType() string {
	return TypeChatReportReasonPornography
}

// The chat has child abuse related content
type ChatReportReasonChildAbuse struct {
	meta
}

func (entity *ChatReportReasonChildAbuse) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonChildAbuse

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonChildAbuse) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonChildAbuse) GetType() string {
	return TypeChatReportReasonChildAbuse
}

func (*ChatReportReasonChildAbuse) ChatReportReasonType() string {
	return TypeChatReportReasonChildAbuse
}

// The chat contains copyrighted content
type ChatReportReasonCopyright struct {
	meta
}

func (entity *ChatReportReasonCopyright) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonCopyright

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonCopyright) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonCopyright) GetType() string {
	return TypeChatReportReasonCopyright
}

func (*ChatReportReasonCopyright) ChatReportReasonType() string {
	return TypeChatReportReasonCopyright
}

// The location-based chat is unrelated to its stated location
type ChatReportReasonUnrelatedLocation struct {
	meta
}

func (entity *ChatReportReasonUnrelatedLocation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonUnrelatedLocation

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonUnrelatedLocation) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonUnrelatedLocation) GetType() string {
	return TypeChatReportReasonUnrelatedLocation
}

func (*ChatReportReasonUnrelatedLocation) ChatReportReasonType() string {
	return TypeChatReportReasonUnrelatedLocation
}

// A custom reason provided by the user
type ChatReportReasonCustom struct {
	meta
	// Report text
	Text string `json:"text"`
}

func (entity *ChatReportReasonCustom) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ChatReportReasonCustom

	return json.Marshal((*stub)(entity))
}

func (*ChatReportReasonCustom) GetClass() string {
	return ClassChatReportReason
}

func (*ChatReportReasonCustom) GetType() string {
	return TypeChatReportReasonCustom
}

func (*ChatReportReasonCustom) ChatReportReasonType() string {
	return TypeChatReportReasonCustom
}

// Contains a public HTTPS link to a message in a supergroup or channel with a username
type PublicMessageLink struct {
	meta
	// Message link
	Link string `json:"link"`
	// HTML-code for embedding the message
	Html string `json:"html"`
}

func (entity *PublicMessageLink) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub PublicMessageLink

	return json.Marshal((*stub)(entity))
}

func (*PublicMessageLink) GetClass() string {
	return ClassPublicMessageLink
}

func (*PublicMessageLink) GetType() string {
	return TypePublicMessageLink
}

// Contains information about a link to a message in a chat
type MessageLinkInfo struct {
	meta
	// True, if the link is a public link for a message in a chat
	IsPublic bool `json:"is_public"`
	// If found, identifier of the chat to which the message belongs, 0 otherwise
	ChatId int64 `json:"chat_id"`
	// If found, the linked message; may be null
	Message *Message `json:"message"`
	// True, if the whole media album to which the message belongs is linked
	ForAlbum bool `json:"for_album"`
}

func (entity *MessageLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub MessageLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*MessageLinkInfo) GetClass() string {
	return ClassMessageLinkInfo
}

func (*MessageLinkInfo) GetType() string {
	return TypeMessageLinkInfo
}

// Contains a part of a file
type FilePart struct {
	meta
	// File bytes
	Data []byte `json:"data"`
}

func (entity *FilePart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FilePart

	return json.Marshal((*stub)(entity))
}

func (*FilePart) GetClass() string {
	return ClassFilePart
}

func (*FilePart) GetType() string {
	return TypeFilePart
}

// The data is not a file
type FileTypeNone struct {
	meta
}

func (entity *FileTypeNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeNone

	return json.Marshal((*stub)(entity))
}

func (*FileTypeNone) GetClass() string {
	return ClassFileType
}

func (*FileTypeNone) GetType() string {
	return TypeFileTypeNone
}

func (*FileTypeNone) FileTypeType() string {
	return TypeFileTypeNone
}

// The file is an animation
type FileTypeAnimation struct {
	meta
}

func (entity *FileTypeAnimation) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeAnimation

	return json.Marshal((*stub)(entity))
}

func (*FileTypeAnimation) GetClass() string {
	return ClassFileType
}

func (*FileTypeAnimation) GetType() string {
	return TypeFileTypeAnimation
}

func (*FileTypeAnimation) FileTypeType() string {
	return TypeFileTypeAnimation
}

// The file is an audio file
type FileTypeAudio struct {
	meta
}

func (entity *FileTypeAudio) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeAudio

	return json.Marshal((*stub)(entity))
}

func (*FileTypeAudio) GetClass() string {
	return ClassFileType
}

func (*FileTypeAudio) GetType() string {
	return TypeFileTypeAudio
}

func (*FileTypeAudio) FileTypeType() string {
	return TypeFileTypeAudio
}

// The file is a document
type FileTypeDocument struct {
	meta
}

func (entity *FileTypeDocument) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeDocument

	return json.Marshal((*stub)(entity))
}

func (*FileTypeDocument) GetClass() string {
	return ClassFileType
}

func (*FileTypeDocument) GetType() string {
	return TypeFileTypeDocument
}

func (*FileTypeDocument) FileTypeType() string {
	return TypeFileTypeDocument
}

// The file is a photo
type FileTypePhoto struct {
	meta
}

func (entity *FileTypePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypePhoto

	return json.Marshal((*stub)(entity))
}

func (*FileTypePhoto) GetClass() string {
	return ClassFileType
}

func (*FileTypePhoto) GetType() string {
	return TypeFileTypePhoto
}

func (*FileTypePhoto) FileTypeType() string {
	return TypeFileTypePhoto
}

// The file is a profile photo
type FileTypeProfilePhoto struct {
	meta
}

func (entity *FileTypeProfilePhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeProfilePhoto

	return json.Marshal((*stub)(entity))
}

func (*FileTypeProfilePhoto) GetClass() string {
	return ClassFileType
}

func (*FileTypeProfilePhoto) GetType() string {
	return TypeFileTypeProfilePhoto
}

func (*FileTypeProfilePhoto) FileTypeType() string {
	return TypeFileTypeProfilePhoto
}

// The file was sent to a secret chat (the file type is not known to the server)
type FileTypeSecret struct {
	meta
}

func (entity *FileTypeSecret) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecret

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecret) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecret) GetType() string {
	return TypeFileTypeSecret
}

func (*FileTypeSecret) FileTypeType() string {
	return TypeFileTypeSecret
}

// The file is a thumbnail of a file from a secret chat
type FileTypeSecretThumbnail struct {
	meta
}

func (entity *FileTypeSecretThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecretThumbnail

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecretThumbnail) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecretThumbnail) GetType() string {
	return TypeFileTypeSecretThumbnail
}

func (*FileTypeSecretThumbnail) FileTypeType() string {
	return TypeFileTypeSecretThumbnail
}

// The file is a file from Secure storage used for storing Telegram Passport files
type FileTypeSecure struct {
	meta
}

func (entity *FileTypeSecure) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSecure

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSecure) GetClass() string {
	return ClassFileType
}

func (*FileTypeSecure) GetType() string {
	return TypeFileTypeSecure
}

func (*FileTypeSecure) FileTypeType() string {
	return TypeFileTypeSecure
}

// The file is a sticker
type FileTypeSticker struct {
	meta
}

func (entity *FileTypeSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeSticker

	return json.Marshal((*stub)(entity))
}

func (*FileTypeSticker) GetClass() string {
	return ClassFileType
}

func (*FileTypeSticker) GetType() string {
	return TypeFileTypeSticker
}

func (*FileTypeSticker) FileTypeType() string {
	return TypeFileTypeSticker
}

// The file is a thumbnail of another file
type FileTypeThumbnail struct {
	meta
}

func (entity *FileTypeThumbnail) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeThumbnail

	return json.Marshal((*stub)(entity))
}

func (*FileTypeThumbnail) GetClass() string {
	return ClassFileType
}

func (*FileTypeThumbnail) GetType() string {
	return TypeFileTypeThumbnail
}

func (*FileTypeThumbnail) FileTypeType() string {
	return TypeFileTypeThumbnail
}

// The file type is not yet known
type FileTypeUnknown struct {
	meta
}

func (entity *FileTypeUnknown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeUnknown

	return json.Marshal((*stub)(entity))
}

func (*FileTypeUnknown) GetClass() string {
	return ClassFileType
}

func (*FileTypeUnknown) GetType() string {
	return TypeFileTypeUnknown
}

func (*FileTypeUnknown) FileTypeType() string {
	return TypeFileTypeUnknown
}

// The file is a video
type FileTypeVideo struct {
	meta
}

func (entity *FileTypeVideo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideo

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideo) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideo) GetType() string {
	return TypeFileTypeVideo
}

func (*FileTypeVideo) FileTypeType() string {
	return TypeFileTypeVideo
}

// The file is a video note
type FileTypeVideoNote struct {
	meta
}

func (entity *FileTypeVideoNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVideoNote

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVideoNote) GetClass() string {
	return ClassFileType
}

func (*FileTypeVideoNote) GetType() string {
	return TypeFileTypeVideoNote
}

func (*FileTypeVideoNote) FileTypeType() string {
	return TypeFileTypeVideoNote
}

// The file is a voice note
type FileTypeVoiceNote struct {
	meta
}

func (entity *FileTypeVoiceNote) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeVoiceNote

	return json.Marshal((*stub)(entity))
}

func (*FileTypeVoiceNote) GetClass() string {
	return ClassFileType
}

func (*FileTypeVoiceNote) GetType() string {
	return TypeFileTypeVoiceNote
}

func (*FileTypeVoiceNote) FileTypeType() string {
	return TypeFileTypeVoiceNote
}

// The file is a wallpaper or a background pattern
type FileTypeWallpaper struct {
	meta
}

func (entity *FileTypeWallpaper) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub FileTypeWallpaper

	return json.Marshal((*stub)(entity))
}

func (*FileTypeWallpaper) GetClass() string {
	return ClassFileType
}

func (*FileTypeWallpaper) GetType() string {
	return TypeFileTypeWallpaper
}

func (*FileTypeWallpaper) FileTypeType() string {
	return TypeFileTypeWallpaper
}

// Contains the storage usage statistics for a specific file type
type StorageStatisticsByFileType struct {
	meta
	// File type
	FileType FileType `json:"file_type"`
	// Total size of the files
	Size int64 `json:"size"`
	// Total number of files
	Count int32 `json:"count"`
}

func (entity *StorageStatisticsByFileType) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsByFileType

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsByFileType) GetClass() string {
	return ClassStorageStatisticsByFileType
}

func (*StorageStatisticsByFileType) GetType() string {
	return TypeStorageStatisticsByFileType
}

func (storageStatisticsByFileType *StorageStatisticsByFileType) UnmarshalJSON(data []byte) error {
	var tmp struct {
		FileType json.RawMessage `json:"file_type"`
		Size     int64           `json:"size"`
		Count    int32           `json:"count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	storageStatisticsByFileType.Size = tmp.Size
	storageStatisticsByFileType.Count = tmp.Count

	fieldFileType, _ := UnmarshalFileType(tmp.FileType)
	storageStatisticsByFileType.FileType = fieldFileType

	return nil
}

// Contains the storage usage statistics for a specific chat
type StorageStatisticsByChat struct {
	meta
	// Chat identifier; 0 if none
	ChatId int64 `json:"chat_id"`
	// Total size of the files in the chat
	Size int64 `json:"size"`
	// Total number of files in the chat
	Count int32 `json:"count"`
	// Statistics split by file types
	ByFileType []*StorageStatisticsByFileType `json:"by_file_type"`
}

func (entity *StorageStatisticsByChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsByChat

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsByChat) GetClass() string {
	return ClassStorageStatisticsByChat
}

func (*StorageStatisticsByChat) GetType() string {
	return TypeStorageStatisticsByChat
}

// Contains the exact storage usage statistics split by chats and file type
type StorageStatistics struct {
	meta
	// Total size of files
	Size int64 `json:"size"`
	// Total number of files
	Count int32 `json:"count"`
	// Statistics split by chats
	ByChat []*StorageStatisticsByChat `json:"by_chat"`
}

func (entity *StorageStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatistics

	return json.Marshal((*stub)(entity))
}

func (*StorageStatistics) GetClass() string {
	return ClassStorageStatistics
}

func (*StorageStatistics) GetType() string {
	return TypeStorageStatistics
}

// Contains approximate storage usage statistics, excluding files of unknown file type
type StorageStatisticsFast struct {
	meta
	// Approximate total size of files
	FilesSize int64 `json:"files_size"`
	// Approximate number of files
	FileCount int32 `json:"file_count"`
	// Size of the database
	DatabaseSize int64 `json:"database_size"`
	// Size of the language pack database
	LanguagePackDatabaseSize int64 `json:"language_pack_database_size"`
	// Size of the TDLib internal log
	LogSize int64 `json:"log_size"`
}

func (entity *StorageStatisticsFast) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub StorageStatisticsFast

	return json.Marshal((*stub)(entity))
}

func (*StorageStatisticsFast) GetClass() string {
	return ClassStorageStatisticsFast
}

func (*StorageStatisticsFast) GetType() string {
	return TypeStorageStatisticsFast
}

// Contains database statistics
type DatabaseStatistics struct {
	meta
	// Database statistics in an unspecified human-readable format
	Statistics string `json:"statistics"`
}

func (entity *DatabaseStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DatabaseStatistics

	return json.Marshal((*stub)(entity))
}

func (*DatabaseStatistics) GetClass() string {
	return ClassDatabaseStatistics
}

func (*DatabaseStatistics) GetType() string {
	return TypeDatabaseStatistics
}

// The network is not available
type NetworkTypeNone struct {
	meta
}

func (entity *NetworkTypeNone) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeNone

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeNone) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeNone) GetType() string {
	return TypeNetworkTypeNone
}

func (*NetworkTypeNone) NetworkTypeType() string {
	return TypeNetworkTypeNone
}

// A mobile network
type NetworkTypeMobile struct {
	meta
}

func (entity *NetworkTypeMobile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeMobile

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeMobile) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeMobile) GetType() string {
	return TypeNetworkTypeMobile
}

func (*NetworkTypeMobile) NetworkTypeType() string {
	return TypeNetworkTypeMobile
}

// A mobile roaming network
type NetworkTypeMobileRoaming struct {
	meta
}

func (entity *NetworkTypeMobileRoaming) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeMobileRoaming

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeMobileRoaming) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeMobileRoaming) GetType() string {
	return TypeNetworkTypeMobileRoaming
}

func (*NetworkTypeMobileRoaming) NetworkTypeType() string {
	return TypeNetworkTypeMobileRoaming
}

// A Wi-Fi network
type NetworkTypeWiFi struct {
	meta
}

func (entity *NetworkTypeWiFi) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeWiFi

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeWiFi) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeWiFi) GetType() string {
	return TypeNetworkTypeWiFi
}

func (*NetworkTypeWiFi) NetworkTypeType() string {
	return TypeNetworkTypeWiFi
}

// A different network type (e.g., Ethernet network)
type NetworkTypeOther struct {
	meta
}

func (entity *NetworkTypeOther) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkTypeOther

	return json.Marshal((*stub)(entity))
}

func (*NetworkTypeOther) GetClass() string {
	return ClassNetworkType
}

func (*NetworkTypeOther) GetType() string {
	return TypeNetworkTypeOther
}

func (*NetworkTypeOther) NetworkTypeType() string {
	return TypeNetworkTypeOther
}

// Contains information about the total amount of data that was used to send and receive files
type NetworkStatisticsEntryFile struct {
	meta
	// Type of the file the data is part of
	FileType FileType `json:"file_type"`
	// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	NetworkType NetworkType `json:"network_type"`
	// Total number of bytes sent
	SentBytes int64 `json:"sent_bytes"`
	// Total number of bytes received
	ReceivedBytes int64 `json:"received_bytes"`
}

func (entity *NetworkStatisticsEntryFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatisticsEntryFile

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatisticsEntryFile) GetClass() string {
	return ClassNetworkStatisticsEntry
}

func (*NetworkStatisticsEntryFile) GetType() string {
	return TypeNetworkStatisticsEntryFile
}

func (*NetworkStatisticsEntryFile) NetworkStatisticsEntryType() string {
	return TypeNetworkStatisticsEntryFile
}

func (networkStatisticsEntryFile *NetworkStatisticsEntryFile) UnmarshalJSON(data []byte) error {
	var tmp struct {
		FileType      json.RawMessage `json:"file_type"`
		NetworkType   json.RawMessage `json:"network_type"`
		SentBytes     int64           `json:"sent_bytes"`
		ReceivedBytes int64           `json:"received_bytes"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatisticsEntryFile.SentBytes = tmp.SentBytes
	networkStatisticsEntryFile.ReceivedBytes = tmp.ReceivedBytes

	fieldFileType, _ := UnmarshalFileType(tmp.FileType)
	networkStatisticsEntryFile.FileType = fieldFileType

	fieldNetworkType, _ := UnmarshalNetworkType(tmp.NetworkType)
	networkStatisticsEntryFile.NetworkType = fieldNetworkType

	return nil
}

// Contains information about the total amount of data that was used for calls
type NetworkStatisticsEntryCall struct {
	meta
	// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	NetworkType NetworkType `json:"network_type"`
	// Total number of bytes sent
	SentBytes int64 `json:"sent_bytes"`
	// Total number of bytes received
	ReceivedBytes int64 `json:"received_bytes"`
	// Total call duration, in seconds
	Duration float64 `json:"duration"`
}

func (entity *NetworkStatisticsEntryCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatisticsEntryCall

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatisticsEntryCall) GetClass() string {
	return ClassNetworkStatisticsEntry
}

func (*NetworkStatisticsEntryCall) GetType() string {
	return TypeNetworkStatisticsEntryCall
}

func (*NetworkStatisticsEntryCall) NetworkStatisticsEntryType() string {
	return TypeNetworkStatisticsEntryCall
}

func (networkStatisticsEntryCall *NetworkStatisticsEntryCall) UnmarshalJSON(data []byte) error {
	var tmp struct {
		NetworkType   json.RawMessage `json:"network_type"`
		SentBytes     int64           `json:"sent_bytes"`
		ReceivedBytes int64           `json:"received_bytes"`
		Duration      float64         `json:"duration"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	networkStatisticsEntryCall.SentBytes = tmp.SentBytes
	networkStatisticsEntryCall.ReceivedBytes = tmp.ReceivedBytes
	networkStatisticsEntryCall.Duration = tmp.Duration

	fieldNetworkType, _ := UnmarshalNetworkType(tmp.NetworkType)
	networkStatisticsEntryCall.NetworkType = fieldNetworkType

	return nil
}

// A full list of available network statistic entries
type NetworkStatistics struct {
	meta
	// Point in time (Unix timestamp) when the app began collecting statistics
	SinceDate int32 `json:"since_date"`
	// Network statistics entries
	Entries []NetworkStatisticsEntry `json:"entries"`
}

func (entity *NetworkStatistics) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub NetworkStatistics

	return json.Marshal((*stub)(entity))
}

func (*NetworkStatistics) GetClass() string {
	return ClassNetworkStatistics
}

func (*NetworkStatistics) GetType() string {
	return TypeNetworkStatistics
}

// Contains auto-download settings
type AutoDownloadSettings struct {
	meta
	// True, if the auto-download is enabled
	IsAutoDownloadEnabled bool `json:"is_auto_download_enabled"`
	// The maximum size of a photo file to be auto-downloaded
	MaxPhotoFileSize int32 `json:"max_photo_file_size"`
	// The maximum size of a video file to be auto-downloaded
	MaxVideoFileSize int32 `json:"max_video_file_size"`
	// The maximum size of other file types to be auto-downloaded
	MaxOtherFileSize int32 `json:"max_other_file_size"`
	// The maximum suggested bitrate for uploaded videos
	VideoUploadBitrate int32 `json:"video_upload_bitrate"`
	// True, if the beginning of videos needs to be preloaded for instant playback
	PreloadLargeVideos bool `json:"preload_large_videos"`
	// True, if the next audio track needs to be preloaded while the user is listening to an audio file
	PreloadNextAudio bool `json:"preload_next_audio"`
	// True, if "use less data for calls" option needs to be enabled
	UseLessDataForCalls bool `json:"use_less_data_for_calls"`
}

func (entity *AutoDownloadSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutoDownloadSettings

	return json.Marshal((*stub)(entity))
}

func (*AutoDownloadSettings) GetClass() string {
	return ClassAutoDownloadSettings
}

func (*AutoDownloadSettings) GetType() string {
	return TypeAutoDownloadSettings
}

// Contains auto-download settings presets for the user
type AutoDownloadSettingsPresets struct {
	meta
	// Preset with lowest settings; supposed to be used by default when roaming
	Low *AutoDownloadSettings `json:"low"`
	// Preset with medium settings; supposed to be used by default when using mobile data
	Medium *AutoDownloadSettings `json:"medium"`
	// Preset with highest settings; supposed to be used by default when connected on Wi-Fi
	High *AutoDownloadSettings `json:"high"`
}

func (entity *AutoDownloadSettingsPresets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub AutoDownloadSettingsPresets

	return json.Marshal((*stub)(entity))
}

func (*AutoDownloadSettingsPresets) GetClass() string {
	return ClassAutoDownloadSettingsPresets
}

func (*AutoDownloadSettingsPresets) GetType() string {
	return TypeAutoDownloadSettingsPresets
}

// Currently waiting for the network to become available. Use setNetworkType to change the available network type
type ConnectionStateWaitingForNetwork struct {
	meta
}

func (entity *ConnectionStateWaitingForNetwork) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateWaitingForNetwork

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateWaitingForNetwork) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateWaitingForNetwork) GetType() string {
	return TypeConnectionStateWaitingForNetwork
}

func (*ConnectionStateWaitingForNetwork) ConnectionStateType() string {
	return TypeConnectionStateWaitingForNetwork
}

// Currently establishing a connection with a proxy server
type ConnectionStateConnectingToProxy struct {
	meta
}

func (entity *ConnectionStateConnectingToProxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateConnectingToProxy

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateConnectingToProxy) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateConnectingToProxy) GetType() string {
	return TypeConnectionStateConnectingToProxy
}

func (*ConnectionStateConnectingToProxy) ConnectionStateType() string {
	return TypeConnectionStateConnectingToProxy
}

// Currently establishing a connection to the Telegram servers
type ConnectionStateConnecting struct {
	meta
}

func (entity *ConnectionStateConnecting) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateConnecting

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateConnecting) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateConnecting) GetType() string {
	return TypeConnectionStateConnecting
}

func (*ConnectionStateConnecting) ConnectionStateType() string {
	return TypeConnectionStateConnecting
}

// Downloading data received while the client was offline
type ConnectionStateUpdating struct {
	meta
}

func (entity *ConnectionStateUpdating) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateUpdating

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateUpdating) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateUpdating) GetType() string {
	return TypeConnectionStateUpdating
}

func (*ConnectionStateUpdating) ConnectionStateType() string {
	return TypeConnectionStateUpdating
}

// There is a working connection to the Telegram servers
type ConnectionStateReady struct {
	meta
}

func (entity *ConnectionStateReady) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ConnectionStateReady

	return json.Marshal((*stub)(entity))
}

func (*ConnectionStateReady) GetClass() string {
	return ClassConnectionState
}

func (*ConnectionStateReady) GetType() string {
	return TypeConnectionStateReady
}

func (*ConnectionStateReady) ConnectionStateType() string {
	return TypeConnectionStateReady
}

// A category containing frequently used private chats with non-bot users
type TopChatCategoryUsers struct {
	meta
}

func (entity *TopChatCategoryUsers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryUsers

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryUsers) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryUsers) GetType() string {
	return TypeTopChatCategoryUsers
}

func (*TopChatCategoryUsers) TopChatCategoryType() string {
	return TypeTopChatCategoryUsers
}

// A category containing frequently used private chats with bot users
type TopChatCategoryBots struct {
	meta
}

func (entity *TopChatCategoryBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryBots) GetType() string {
	return TypeTopChatCategoryBots
}

func (*TopChatCategoryBots) TopChatCategoryType() string {
	return TypeTopChatCategoryBots
}

// A category containing frequently used basic groups and supergroups
type TopChatCategoryGroups struct {
	meta
}

func (entity *TopChatCategoryGroups) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryGroups

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryGroups) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryGroups) GetType() string {
	return TypeTopChatCategoryGroups
}

func (*TopChatCategoryGroups) TopChatCategoryType() string {
	return TypeTopChatCategoryGroups
}

// A category containing frequently used channels
type TopChatCategoryChannels struct {
	meta
}

func (entity *TopChatCategoryChannels) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryChannels

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryChannels) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryChannels) GetType() string {
	return TypeTopChatCategoryChannels
}

func (*TopChatCategoryChannels) TopChatCategoryType() string {
	return TypeTopChatCategoryChannels
}

// A category containing frequently used chats with inline bots sorted by their usage in inline mode
type TopChatCategoryInlineBots struct {
	meta
}

func (entity *TopChatCategoryInlineBots) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryInlineBots

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryInlineBots) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryInlineBots) GetType() string {
	return TypeTopChatCategoryInlineBots
}

func (*TopChatCategoryInlineBots) TopChatCategoryType() string {
	return TypeTopChatCategoryInlineBots
}

// A category containing frequently used chats used for calls
type TopChatCategoryCalls struct {
	meta
}

func (entity *TopChatCategoryCalls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryCalls

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryCalls) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryCalls) GetType() string {
	return TypeTopChatCategoryCalls
}

func (*TopChatCategoryCalls) TopChatCategoryType() string {
	return TypeTopChatCategoryCalls
}

// A category containing frequently used chats used to forward messages
type TopChatCategoryForwardChats struct {
	meta
}

func (entity *TopChatCategoryForwardChats) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TopChatCategoryForwardChats

	return json.Marshal((*stub)(entity))
}

func (*TopChatCategoryForwardChats) GetClass() string {
	return ClassTopChatCategory
}

func (*TopChatCategoryForwardChats) GetType() string {
	return TypeTopChatCategoryForwardChats
}

func (*TopChatCategoryForwardChats) TopChatCategoryType() string {
	return TypeTopChatCategoryForwardChats
}

// A URL linking to a user
type TMeUrlTypeUser struct {
	meta
	// Identifier of the user
	UserId int32 `json:"user_id"`
}

func (entity *TMeUrlTypeUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeUser

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeUser) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeUser) GetType() string {
	return TypeTMeUrlTypeUser
}

func (*TMeUrlTypeUser) TMeUrlTypeType() string {
	return TypeTMeUrlTypeUser
}

// A URL linking to a public supergroup or channel
type TMeUrlTypeSupergroup struct {
	meta
	// Identifier of the supergroup or channel
	SupergroupId int64 `json:"supergroup_id"`
}

func (entity *TMeUrlTypeSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeSupergroup

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeSupergroup) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeSupergroup) GetType() string {
	return TypeTMeUrlTypeSupergroup
}

func (*TMeUrlTypeSupergroup) TMeUrlTypeType() string {
	return TypeTMeUrlTypeSupergroup
}

// A chat invite link
type TMeUrlTypeChatInvite struct {
	meta
	// Chat invite link info
	Info *ChatInviteLinkInfo `json:"info"`
}

func (entity *TMeUrlTypeChatInvite) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeChatInvite

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeChatInvite) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeChatInvite) GetType() string {
	return TypeTMeUrlTypeChatInvite
}

func (*TMeUrlTypeChatInvite) TMeUrlTypeType() string {
	return TypeTMeUrlTypeChatInvite
}

// A URL linking to a sticker set
type TMeUrlTypeStickerSet struct {
	meta
	// Identifier of the sticker set
	StickerSetId JsonInt64 `json:"sticker_set_id"`
}

func (entity *TMeUrlTypeStickerSet) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrlTypeStickerSet

	return json.Marshal((*stub)(entity))
}

func (*TMeUrlTypeStickerSet) GetClass() string {
	return ClassTMeUrlType
}

func (*TMeUrlTypeStickerSet) GetType() string {
	return TypeTMeUrlTypeStickerSet
}

func (*TMeUrlTypeStickerSet) TMeUrlTypeType() string {
	return TypeTMeUrlTypeStickerSet
}

// Represents a URL linking to an internal Telegram entity
type TMeUrl struct {
	meta
	// URL
	Url string `json:"url"`
	// Type of the URL
	Type TMeUrlType `json:"type"`
}

func (entity *TMeUrl) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrl

	return json.Marshal((*stub)(entity))
}

func (*TMeUrl) GetClass() string {
	return ClassTMeUrl
}

func (*TMeUrl) GetType() string {
	return TypeTMeUrl
}

func (tMeUrl *TMeUrl) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Url  string          `json:"url"`
		Type json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	tMeUrl.Url = tmp.Url

	fieldType, _ := UnmarshalTMeUrlType(tmp.Type)
	tMeUrl.Type = fieldType

	return nil
}

// Contains a list of t.me URLs
type TMeUrls struct {
	meta
	// List of URLs
	Urls []*TMeUrl `json:"urls"`
}

func (entity *TMeUrls) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TMeUrls

	return json.Marshal((*stub)(entity))
}

func (*TMeUrls) GetClass() string {
	return ClassTMeUrls
}

func (*TMeUrls) GetType() string {
	return TypeTMeUrls
}

// Contains a counter
type Count struct {
	meta
	// Count
	Count int32 `json:"count"`
}

func (entity *Count) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Count

	return json.Marshal((*stub)(entity))
}

func (*Count) GetClass() string {
	return ClassCount
}

func (*Count) GetType() string {
	return TypeCount
}

// Contains some text
type Text struct {
	meta
	// Text
	Text string `json:"text"`
}

func (entity *Text) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Text

	return json.Marshal((*stub)(entity))
}

func (*Text) GetClass() string {
	return ClassText
}

func (*Text) GetType() string {
	return TypeText
}

// Contains a value representing a number of seconds
type Seconds struct {
	meta
	// Number of seconds
	Seconds float64 `json:"seconds"`
}

func (entity *Seconds) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Seconds

	return json.Marshal((*stub)(entity))
}

func (*Seconds) GetClass() string {
	return ClassSeconds
}

func (*Seconds) GetType() string {
	return TypeSeconds
}

// Contains information about a tg:// deep link
type DeepLinkInfo struct {
	meta
	// Text to be shown to the user
	Text *FormattedText `json:"text"`
	// True, if user should be asked to update the application
	NeedUpdateApplication bool `json:"need_update_application"`
}

func (entity *DeepLinkInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub DeepLinkInfo

	return json.Marshal((*stub)(entity))
}

func (*DeepLinkInfo) GetClass() string {
	return ClassDeepLinkInfo
}

func (*DeepLinkInfo) GetType() string {
	return TypeDeepLinkInfo
}

// The text should be parsed in markdown-style
type TextParseModeMarkdown struct {
	meta
	// Version of the parser: 0 or 1 - Bot API Markdown parse mode, 2 - Bot API MarkdownV2 parse mode
	Version int32 `json:"version"`
}

func (entity *TextParseModeMarkdown) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextParseModeMarkdown

	return json.Marshal((*stub)(entity))
}

func (*TextParseModeMarkdown) GetClass() string {
	return ClassTextParseMode
}

func (*TextParseModeMarkdown) GetType() string {
	return TypeTextParseModeMarkdown
}

func (*TextParseModeMarkdown) TextParseModeType() string {
	return TypeTextParseModeMarkdown
}

// The text should be parsed in HTML-style
type TextParseModeHTML struct {
	meta
}

func (entity *TextParseModeHTML) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TextParseModeHTML

	return json.Marshal((*stub)(entity))
}

func (*TextParseModeHTML) GetClass() string {
	return ClassTextParseMode
}

func (*TextParseModeHTML) GetType() string {
	return TypeTextParseModeHTML
}

func (*TextParseModeHTML) TextParseModeType() string {
	return TypeTextParseModeHTML
}

// A SOCKS5 proxy server
type ProxyTypeSocks5 struct {
	meta
	// Username for logging in; may be empty
	Username string `json:"username"`
	// Password for logging in; may be empty
	Password string `json:"password"`
}

func (entity *ProxyTypeSocks5) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeSocks5

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeSocks5) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeSocks5) GetType() string {
	return TypeProxyTypeSocks5
}

func (*ProxyTypeSocks5) ProxyTypeType() string {
	return TypeProxyTypeSocks5
}

// A HTTP transparent proxy server
type ProxyTypeHttp struct {
	meta
	// Username for logging in; may be empty
	Username string `json:"username"`
	// Password for logging in; may be empty
	Password string `json:"password"`
	// Pass true, if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
	HttpOnly bool `json:"http_only"`
}

func (entity *ProxyTypeHttp) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeHttp

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeHttp) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeHttp) GetType() string {
	return TypeProxyTypeHttp
}

func (*ProxyTypeHttp) ProxyTypeType() string {
	return TypeProxyTypeHttp
}

// An MTProto proxy server
type ProxyTypeMtproto struct {
	meta
	// The proxy's secret in hexadecimal encoding
	Secret string `json:"secret"`
}

func (entity *ProxyTypeMtproto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub ProxyTypeMtproto

	return json.Marshal((*stub)(entity))
}

func (*ProxyTypeMtproto) GetClass() string {
	return ClassProxyType
}

func (*ProxyTypeMtproto) GetType() string {
	return TypeProxyTypeMtproto
}

func (*ProxyTypeMtproto) ProxyTypeType() string {
	return TypeProxyTypeMtproto
}

// Contains information about a proxy server
type Proxy struct {
	meta
	// Unique identifier of the proxy
	Id int32 `json:"id"`
	// Proxy server IP address
	Server string `json:"server"`
	// Proxy server port
	Port int32 `json:"port"`
	// Point in time (Unix timestamp) when the proxy was last used; 0 if never
	LastUsedDate int32 `json:"last_used_date"`
	// True, if the proxy is enabled now
	IsEnabled bool `json:"is_enabled"`
	// Type of the proxy
	Type ProxyType `json:"type"`
}

func (entity *Proxy) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Proxy

	return json.Marshal((*stub)(entity))
}

func (*Proxy) GetClass() string {
	return ClassProxy
}

func (*Proxy) GetType() string {
	return TypeProxy
}

func (proxy *Proxy) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           int32           `json:"id"`
		Server       string          `json:"server"`
		Port         int32           `json:"port"`
		LastUsedDate int32           `json:"last_used_date"`
		IsEnabled    bool            `json:"is_enabled"`
		Type         json.RawMessage `json:"type"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	proxy.Id = tmp.Id
	proxy.Server = tmp.Server
	proxy.Port = tmp.Port
	proxy.LastUsedDate = tmp.LastUsedDate
	proxy.IsEnabled = tmp.IsEnabled

	fieldType, _ := UnmarshalProxyType(tmp.Type)
	proxy.Type = fieldType

	return nil
}

// Represents a list of proxy servers
type Proxies struct {
	meta
	// List of proxy servers
	Proxies []*Proxy `json:"proxies"`
}

func (entity *Proxies) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Proxies

	return json.Marshal((*stub)(entity))
}

func (*Proxies) GetClass() string {
	return ClassProxies
}

func (*Proxies) GetType() string {
	return TypeProxies
}

// Describes a sticker that should be added to a sticker set
type InputSticker struct {
	meta
	// PNG image with the sticker; must be up to 512 kB in size and fit in a 512x512 square
	PngSticker InputFile `json:"png_sticker"`
	// Emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// For masks, position where the mask should be placed; may be null
	MaskPosition *MaskPosition `json:"mask_position"`
}

func (entity *InputSticker) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub InputSticker

	return json.Marshal((*stub)(entity))
}

func (*InputSticker) GetClass() string {
	return ClassInputSticker
}

func (*InputSticker) GetType() string {
	return TypeInputSticker
}

func (inputSticker *InputSticker) UnmarshalJSON(data []byte) error {
	var tmp struct {
		PngSticker   json.RawMessage `json:"png_sticker"`
		Emojis       string          `json:"emojis"`
		MaskPosition *MaskPosition   `json:"mask_position"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	inputSticker.Emojis = tmp.Emojis
	inputSticker.MaskPosition = tmp.MaskPosition

	fieldPngSticker, _ := UnmarshalInputFile(tmp.PngSticker)
	inputSticker.PngSticker = fieldPngSticker

	return nil
}

// The user authorization state has changed
type UpdateAuthorizationState struct {
	meta
	// New authorization state
	AuthorizationState AuthorizationState `json:"authorization_state"`
}

func (entity *UpdateAuthorizationState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateAuthorizationState

	return json.Marshal((*stub)(entity))
}

func (*UpdateAuthorizationState) GetClass() string {
	return ClassUpdate
}

func (*UpdateAuthorizationState) GetType() string {
	return TypeUpdateAuthorizationState
}

func (*UpdateAuthorizationState) UpdateType() string {
	return TypeUpdateAuthorizationState
}

func (updateAuthorizationState *UpdateAuthorizationState) UnmarshalJSON(data []byte) error {
	var tmp struct {
		AuthorizationState json.RawMessage `json:"authorization_state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldAuthorizationState, _ := UnmarshalAuthorizationState(tmp.AuthorizationState)
	updateAuthorizationState.AuthorizationState = fieldAuthorizationState

	return nil
}

// A new message was received; can also be an outgoing message
type UpdateNewMessage struct {
	meta
	// The new message
	Message *Message `json:"message"`
}

func (entity *UpdateNewMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewMessage) GetType() string {
	return TypeUpdateNewMessage
}

func (*UpdateNewMessage) UpdateType() string {
	return TypeUpdateNewMessage
}

// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
type UpdateMessageSendAcknowledged struct {
	meta
	// The chat identifier of the sent message
	ChatId int64 `json:"chat_id"`
	// A temporary message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageSendAcknowledged) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendAcknowledged

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendAcknowledged) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendAcknowledged) GetType() string {
	return TypeUpdateMessageSendAcknowledged
}

func (*UpdateMessageSendAcknowledged) UpdateType() string {
	return TypeUpdateMessageSendAcknowledged
}

// A message has been successfully sent
type UpdateMessageSendSucceeded struct {
	meta
	// Information about the sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
	Message *Message `json:"message"`
	// The previous temporary message identifier
	OldMessageId int64 `json:"old_message_id"`
}

func (entity *UpdateMessageSendSucceeded) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendSucceeded

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendSucceeded) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendSucceeded) GetType() string {
	return TypeUpdateMessageSendSucceeded
}

func (*UpdateMessageSendSucceeded) UpdateType() string {
	return TypeUpdateMessageSendSucceeded
}

// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
type UpdateMessageSendFailed struct {
	meta
	// Contains information about the message which failed to send
	Message *Message `json:"message"`
	// The previous temporary message identifier
	OldMessageId int64 `json:"old_message_id"`
	// An error code
	ErrorCode int32 `json:"error_code"`
	// Error message
	ErrorMessage string `json:"error_message"`
}

func (entity *UpdateMessageSendFailed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageSendFailed

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageSendFailed) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageSendFailed) GetType() string {
	return TypeUpdateMessageSendFailed
}

func (*UpdateMessageSendFailed) UpdateType() string {
	return TypeUpdateMessageSendFailed
}

// The message content has changed
type UpdateMessageContent struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// New message content
	NewContent MessageContent `json:"new_content"`
}

func (entity *UpdateMessageContent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageContent

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageContent) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageContent) GetType() string {
	return TypeUpdateMessageContent
}

func (*UpdateMessageContent) UpdateType() string {
	return TypeUpdateMessageContent
}

func (updateMessageContent *UpdateMessageContent) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId     int64           `json:"chat_id"`
		MessageId  int64           `json:"message_id"`
		NewContent json.RawMessage `json:"new_content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageContent.ChatId = tmp.ChatId
	updateMessageContent.MessageId = tmp.MessageId

	fieldNewContent, _ := UnmarshalMessageContent(tmp.NewContent)
	updateMessageContent.NewContent = fieldNewContent

	return nil
}

// A message was edited. Changes in the message content will come in a separate updateMessageContent
type UpdateMessageEdited struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// Point in time (Unix timestamp) when the message was edited
	EditDate int32 `json:"edit_date"`
	// New message reply markup; may be null
	ReplyMarkup ReplyMarkup `json:"reply_markup"`
}

func (entity *UpdateMessageEdited) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageEdited

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageEdited) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageEdited) GetType() string {
	return TypeUpdateMessageEdited
}

func (*UpdateMessageEdited) UpdateType() string {
	return TypeUpdateMessageEdited
}

func (updateMessageEdited *UpdateMessageEdited) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId      int64           `json:"chat_id"`
		MessageId   int64           `json:"message_id"`
		EditDate    int32           `json:"edit_date"`
		ReplyMarkup json.RawMessage `json:"reply_markup"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateMessageEdited.ChatId = tmp.ChatId
	updateMessageEdited.MessageId = tmp.MessageId
	updateMessageEdited.EditDate = tmp.EditDate

	fieldReplyMarkup, _ := UnmarshalReplyMarkup(tmp.ReplyMarkup)
	updateMessageEdited.ReplyMarkup = fieldReplyMarkup

	return nil
}

// The view count of the message has changed
type UpdateMessageViews struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// New value of the view count
	Views int32 `json:"views"`
}

func (entity *UpdateMessageViews) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageViews

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageViews) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageViews) GetType() string {
	return TypeUpdateMessageViews
}

func (*UpdateMessageViews) UpdateType() string {
	return TypeUpdateMessageViews
}

// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages
type UpdateMessageContentOpened struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageContentOpened) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageContentOpened

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageContentOpened) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageContentOpened) GetType() string {
	return TypeUpdateMessageContentOpened
}

func (*UpdateMessageContentOpened) UpdateType() string {
	return TypeUpdateMessageContentOpened
}

// A message with an unread mention was read
type UpdateMessageMentionRead struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Message identifier
	MessageId int64 `json:"message_id"`
	// The new number of unread mention messages left in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
}

func (entity *UpdateMessageMentionRead) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageMentionRead

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageMentionRead) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageMentionRead) GetType() string {
	return TypeUpdateMessageMentionRead
}

func (*UpdateMessageMentionRead) UpdateType() string {
	return TypeUpdateMessageMentionRead
}

// A message with a live location was viewed. When the update is received, the client is supposed to update the live location
type UpdateMessageLiveLocationViewed struct {
	meta
	// Identifier of the chat with the live location message
	ChatId int64 `json:"chat_id"`
	// Identifier of the message with live location
	MessageId int64 `json:"message_id"`
}

func (entity *UpdateMessageLiveLocationViewed) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateMessageLiveLocationViewed

	return json.Marshal((*stub)(entity))
}

func (*UpdateMessageLiveLocationViewed) GetClass() string {
	return ClassUpdate
}

func (*UpdateMessageLiveLocationViewed) GetType() string {
	return TypeUpdateMessageLiveLocationViewed
}

func (*UpdateMessageLiveLocationViewed) UpdateType() string {
	return TypeUpdateMessageLiveLocationViewed
}

// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the client. The chat field changes will be reported through separate updates
type UpdateNewChat struct {
	meta
	// The chat
	Chat *Chat `json:"chat"`
}

func (entity *UpdateNewChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChat) GetType() string {
	return TypeUpdateNewChat
}

func (*UpdateNewChat) UpdateType() string {
	return TypeUpdateNewChat
}

// The list to which the chat belongs was changed. This update is guaranteed to be sent only when chat.order == 0 and the current or the new chat list is null
type UpdateChatChatList struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat's chat list; may be null
	ChatList ChatList `json:"chat_list"`
}

func (entity *UpdateChatChatList) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatChatList

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatChatList) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatChatList) GetType() string {
	return TypeUpdateChatChatList
}

func (*UpdateChatChatList) UpdateType() string {
	return TypeUpdateChatChatList
}

func (updateChatChatList *UpdateChatChatList) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId   int64           `json:"chat_id"`
		ChatList json.RawMessage `json:"chat_list"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatChatList.ChatId = tmp.ChatId

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateChatChatList.ChatList = fieldChatList

	return nil
}

// The title of a chat was changed
type UpdateChatTitle struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat title
	Title string `json:"title"`
}

func (entity *UpdateChatTitle) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatTitle

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatTitle) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatTitle) GetType() string {
	return TypeUpdateChatTitle
}

func (*UpdateChatTitle) UpdateType() string {
	return TypeUpdateChatTitle
}

// A chat photo was changed
type UpdateChatPhoto struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat photo; may be null
	Photo *ChatPhoto `json:"photo"`
}

func (entity *UpdateChatPhoto) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPhoto

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPhoto) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPhoto) GetType() string {
	return TypeUpdateChatPhoto
}

func (*UpdateChatPhoto) UpdateType() string {
	return TypeUpdateChatPhoto
}

// Chat permissions was changed
type UpdateChatPermissions struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new chat permissions
	Permissions *ChatPermissions `json:"permissions"`
}

func (entity *UpdateChatPermissions) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPermissions

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPermissions) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPermissions) GetType() string {
	return TypeUpdateChatPermissions
}

func (*UpdateChatPermissions) UpdateType() string {
	return TypeUpdateChatPermissions
}

// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case
type UpdateChatLastMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new last message in the chat; may be null
	LastMessage *Message `json:"last_message"`
	// New value of the chat order
	Order JsonInt64 `json:"order"`
}

func (entity *UpdateChatLastMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatLastMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatLastMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatLastMessage) GetType() string {
	return TypeUpdateChatLastMessage
}

func (*UpdateChatLastMessage) UpdateType() string {
	return TypeUpdateChatLastMessage
}

// The order of the chat in the chat list has changed. Instead of this update updateChatLastMessage, updateChatIsPinned, updateChatDraftMessage, or updateChatIsSponsored might be sent
type UpdateChatOrder struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of the order
	Order JsonInt64 `json:"order"`
}

func (entity *UpdateChatOrder) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatOrder

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatOrder) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatOrder) GetType() string {
	return TypeUpdateChatOrder
}

func (*UpdateChatOrder) UpdateType() string {
	return TypeUpdateChatOrder
}

// A chat was pinned or unpinned
type UpdateChatIsPinned struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_pinned
	IsPinned bool `json:"is_pinned"`
	// New value of the chat order
	Order JsonInt64 `json:"order"`
}

func (entity *UpdateChatIsPinned) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsPinned

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsPinned) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsPinned) GetType() string {
	return TypeUpdateChatIsPinned
}

func (*UpdateChatIsPinned) UpdateType() string {
	return TypeUpdateChatIsPinned
}

// A chat was marked as unread or was read
type UpdateChatIsMarkedAsUnread struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_marked_as_unread
	IsMarkedAsUnread bool `json:"is_marked_as_unread"`
}

func (entity *UpdateChatIsMarkedAsUnread) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsMarkedAsUnread

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsMarkedAsUnread) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsMarkedAsUnread) GetType() string {
	return TypeUpdateChatIsMarkedAsUnread
}

func (*UpdateChatIsMarkedAsUnread) UpdateType() string {
	return TypeUpdateChatIsMarkedAsUnread
}

// A chat's is_sponsored field has changed
type UpdateChatIsSponsored struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of is_sponsored
	IsSponsored bool `json:"is_sponsored"`
	// New value of chat order
	Order JsonInt64 `json:"order"`
}

func (entity *UpdateChatIsSponsored) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatIsSponsored

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatIsSponsored) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatIsSponsored) GetType() string {
	return TypeUpdateChatIsSponsored
}

func (*UpdateChatIsSponsored) UpdateType() string {
	return TypeUpdateChatIsSponsored
}

// A chat's has_scheduled_messages field has changed
type UpdateChatHasScheduledMessages struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// New value of has_scheduled_messages
	HasScheduledMessages bool `json:"has_scheduled_messages"`
}

func (entity *UpdateChatHasScheduledMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatHasScheduledMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatHasScheduledMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatHasScheduledMessages) GetType() string {
	return TypeUpdateChatHasScheduledMessages
}

func (*UpdateChatHasScheduledMessages) UpdateType() string {
	return TypeUpdateChatHasScheduledMessages
}

// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
type UpdateChatDefaultDisableNotification struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new default_disable_notification value
	DefaultDisableNotification bool `json:"default_disable_notification"`
}

func (entity *UpdateChatDefaultDisableNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatDefaultDisableNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatDefaultDisableNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatDefaultDisableNotification) GetType() string {
	return TypeUpdateChatDefaultDisableNotification
}

func (*UpdateChatDefaultDisableNotification) UpdateType() string {
	return TypeUpdateChatDefaultDisableNotification
}

// Incoming messages were read or number of unread messages has been changed
type UpdateChatReadInbox struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the last read incoming message
	LastReadInboxMessageId int64 `json:"last_read_inbox_message_id"`
	// The number of unread messages left in the chat
	UnreadCount int32 `json:"unread_count"`
}

func (entity *UpdateChatReadInbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReadInbox

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReadInbox) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReadInbox) GetType() string {
	return TypeUpdateChatReadInbox
}

func (*UpdateChatReadInbox) UpdateType() string {
	return TypeUpdateChatReadInbox
}

// Outgoing messages were read
type UpdateChatReadOutbox struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of last read outgoing message
	LastReadOutboxMessageId int64 `json:"last_read_outbox_message_id"`
}

func (entity *UpdateChatReadOutbox) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReadOutbox

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReadOutbox) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReadOutbox) GetType() string {
	return TypeUpdateChatReadOutbox
}

func (*UpdateChatReadOutbox) UpdateType() string {
	return TypeUpdateChatReadOutbox
}

// The chat unread_mention_count has changed
type UpdateChatUnreadMentionCount struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The number of unread mention messages left in the chat
	UnreadMentionCount int32 `json:"unread_mention_count"`
}

func (entity *UpdateChatUnreadMentionCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatUnreadMentionCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatUnreadMentionCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatUnreadMentionCount) GetType() string {
	return TypeUpdateChatUnreadMentionCount
}

func (*UpdateChatUnreadMentionCount) UpdateType() string {
	return TypeUpdateChatUnreadMentionCount
}

// Notification settings for a chat were changed
type UpdateChatNotificationSettings struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new notification settings
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateChatNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatNotificationSettings) GetType() string {
	return TypeUpdateChatNotificationSettings
}

func (*UpdateChatNotificationSettings) UpdateType() string {
	return TypeUpdateChatNotificationSettings
}

// Notification settings for some type of chats were updated
type UpdateScopeNotificationSettings struct {
	meta
	// Types of chats for which notification settings were updated
	Scope NotificationSettingsScope `json:"scope"`
	// The new notification settings
	NotificationSettings *ScopeNotificationSettings `json:"notification_settings"`
}

func (entity *UpdateScopeNotificationSettings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateScopeNotificationSettings

	return json.Marshal((*stub)(entity))
}

func (*UpdateScopeNotificationSettings) GetClass() string {
	return ClassUpdate
}

func (*UpdateScopeNotificationSettings) GetType() string {
	return TypeUpdateScopeNotificationSettings
}

func (*UpdateScopeNotificationSettings) UpdateType() string {
	return TypeUpdateScopeNotificationSettings
}

func (updateScopeNotificationSettings *UpdateScopeNotificationSettings) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Scope                json.RawMessage            `json:"scope"`
		NotificationSettings *ScopeNotificationSettings `json:"notification_settings"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateScopeNotificationSettings.NotificationSettings = tmp.NotificationSettings

	fieldScope, _ := UnmarshalNotificationSettingsScope(tmp.Scope)
	updateScopeNotificationSettings.Scope = fieldScope

	return nil
}

// The chat action bar was changed
type UpdateChatActionBar struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new value of the action bar; may be null
	ActionBar ChatActionBar `json:"action_bar"`
}

func (entity *UpdateChatActionBar) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatActionBar

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatActionBar) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatActionBar) GetType() string {
	return TypeUpdateChatActionBar
}

func (*UpdateChatActionBar) UpdateType() string {
	return TypeUpdateChatActionBar
}

func (updateChatActionBar *UpdateChatActionBar) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId    int64           `json:"chat_id"`
		ActionBar json.RawMessage `json:"action_bar"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateChatActionBar.ChatId = tmp.ChatId

	fieldActionBar, _ := UnmarshalChatActionBar(tmp.ActionBar)
	updateChatActionBar.ActionBar = fieldActionBar

	return nil
}

// The chat pinned message was changed
type UpdateChatPinnedMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new identifier of the pinned message; 0 if there is no pinned message in the chat
	PinnedMessageId int64 `json:"pinned_message_id"`
}

func (entity *UpdateChatPinnedMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatPinnedMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatPinnedMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatPinnedMessage) GetType() string {
	return TypeUpdateChatPinnedMessage
}

func (*UpdateChatPinnedMessage) UpdateType() string {
	return TypeUpdateChatPinnedMessage
}

// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
type UpdateChatReplyMarkup struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	ReplyMarkupMessageId int64 `json:"reply_markup_message_id"`
}

func (entity *UpdateChatReplyMarkup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatReplyMarkup

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatReplyMarkup) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatReplyMarkup) GetType() string {
	return TypeUpdateChatReplyMarkup
}

func (*UpdateChatReplyMarkup) UpdateType() string {
	return TypeUpdateChatReplyMarkup
}

// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update shouldn't be applied
type UpdateChatDraftMessage struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// The new draft message; may be null
	DraftMessage *DraftMessage `json:"draft_message"`
	// New value of the chat order
	Order JsonInt64 `json:"order"`
}

func (entity *UpdateChatDraftMessage) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatDraftMessage

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatDraftMessage) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatDraftMessage) GetType() string {
	return TypeUpdateChatDraftMessage
}

func (*UpdateChatDraftMessage) UpdateType() string {
	return TypeUpdateChatDraftMessage
}

// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed
type UpdateChatOnlineMemberCount struct {
	meta
	// Identifier of the chat
	ChatId int64 `json:"chat_id"`
	// New number of online members in the chat, or 0 if unknown
	OnlineMemberCount int32 `json:"online_member_count"`
}

func (entity *UpdateChatOnlineMemberCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateChatOnlineMemberCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateChatOnlineMemberCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateChatOnlineMemberCount) GetType() string {
	return TypeUpdateChatOnlineMemberCount
}

func (*UpdateChatOnlineMemberCount) UpdateType() string {
	return TypeUpdateChatOnlineMemberCount
}

// A notification was changed
type UpdateNotification struct {
	meta
	// Unique notification group identifier
	NotificationGroupId int32 `json:"notification_group_id"`
	// Changed notification
	Notification *Notification `json:"notification"`
}

func (entity *UpdateNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateNotification) GetType() string {
	return TypeUpdateNotification
}

func (*UpdateNotification) UpdateType() string {
	return TypeUpdateNotification
}

// A list of active notifications in a notification group has changed
type UpdateNotificationGroup struct {
	meta
	// Unique notification group identifier
	NotificationGroupId int32 `json:"notification_group_id"`
	// New type of the notification group
	Type NotificationGroupType `json:"type"`
	// Identifier of a chat to which all notifications in the group belong
	ChatId int64 `json:"chat_id"`
	// Chat identifier, which notification settings must be applied to the added notifications
	NotificationSettingsChatId int64 `json:"notification_settings_chat_id"`
	// True, if the notifications should be shown without sound
	IsSilent bool `json:"is_silent"`
	// Total number of unread notifications in the group, can be bigger than number of active notifications
	TotalCount int32 `json:"total_count"`
	// List of added group notifications, sorted by notification ID
	AddedNotifications []*Notification `json:"added_notifications"`
	// Identifiers of removed group notifications, sorted by notification ID
	RemovedNotificationIds []int32 `json:"removed_notification_ids"`
}

func (entity *UpdateNotificationGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNotificationGroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateNotificationGroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateNotificationGroup) GetType() string {
	return TypeUpdateNotificationGroup
}

func (*UpdateNotificationGroup) UpdateType() string {
	return TypeUpdateNotificationGroup
}

func (updateNotificationGroup *UpdateNotificationGroup) UnmarshalJSON(data []byte) error {
	var tmp struct {
		NotificationGroupId        int32           `json:"notification_group_id"`
		Type                       json.RawMessage `json:"type"`
		ChatId                     int64           `json:"chat_id"`
		NotificationSettingsChatId int64           `json:"notification_settings_chat_id"`
		IsSilent                   bool            `json:"is_silent"`
		TotalCount                 int32           `json:"total_count"`
		AddedNotifications         []*Notification `json:"added_notifications"`
		RemovedNotificationIds     []int32         `json:"removed_notification_ids"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNotificationGroup.NotificationGroupId = tmp.NotificationGroupId
	updateNotificationGroup.ChatId = tmp.ChatId
	updateNotificationGroup.NotificationSettingsChatId = tmp.NotificationSettingsChatId
	updateNotificationGroup.IsSilent = tmp.IsSilent
	updateNotificationGroup.TotalCount = tmp.TotalCount
	updateNotificationGroup.AddedNotifications = tmp.AddedNotifications
	updateNotificationGroup.RemovedNotificationIds = tmp.RemovedNotificationIds

	fieldType, _ := UnmarshalNotificationGroupType(tmp.Type)
	updateNotificationGroup.Type = fieldType

	return nil
}

// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
type UpdateActiveNotifications struct {
	meta
	// Lists of active notification groups
	Groups []*NotificationGroup `json:"groups"`
}

func (entity *UpdateActiveNotifications) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateActiveNotifications

	return json.Marshal((*stub)(entity))
}

func (*UpdateActiveNotifications) GetClass() string {
	return ClassUpdate
}

func (*UpdateActiveNotifications) GetType() string {
	return TypeUpdateActiveNotifications
}

func (*UpdateActiveNotifications) UpdateType() string {
	return TypeUpdateActiveNotifications
}

// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
type UpdateHavePendingNotifications struct {
	meta
	// True, if there are some delayed notification updates, which will be sent soon
	HaveDelayedNotifications bool `json:"have_delayed_notifications"`
	// True, if there can be some yet unreceived notifications, which are being fetched from the server
	HaveUnreceivedNotifications bool `json:"have_unreceived_notifications"`
}

func (entity *UpdateHavePendingNotifications) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateHavePendingNotifications

	return json.Marshal((*stub)(entity))
}

func (*UpdateHavePendingNotifications) GetClass() string {
	return ClassUpdate
}

func (*UpdateHavePendingNotifications) GetType() string {
	return TypeUpdateHavePendingNotifications
}

func (*UpdateHavePendingNotifications) UpdateType() string {
	return TypeUpdateHavePendingNotifications
}

// Some messages were deleted
type UpdateDeleteMessages struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifiers of the deleted messages
	MessageIds []int64 `json:"message_ids"`
	// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
	IsPermanent bool `json:"is_permanent"`
	// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
	FromCache bool `json:"from_cache"`
}

func (entity *UpdateDeleteMessages) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateDeleteMessages

	return json.Marshal((*stub)(entity))
}

func (*UpdateDeleteMessages) GetClass() string {
	return ClassUpdate
}

func (*UpdateDeleteMessages) GetType() string {
	return TypeUpdateDeleteMessages
}

func (*UpdateDeleteMessages) UpdateType() string {
	return TypeUpdateDeleteMessages
}

// User activity in the chat has changed
type UpdateUserChatAction struct {
	meta
	// Chat identifier
	ChatId int64 `json:"chat_id"`
	// Identifier of a user performing an action
	UserId int32 `json:"user_id"`
	// The action description
	Action ChatAction `json:"action"`
}

func (entity *UpdateUserChatAction) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserChatAction

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserChatAction) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserChatAction) GetType() string {
	return TypeUpdateUserChatAction
}

func (*UpdateUserChatAction) UpdateType() string {
	return TypeUpdateUserChatAction
}

func (updateUserChatAction *UpdateUserChatAction) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatId int64           `json:"chat_id"`
		UserId int32           `json:"user_id"`
		Action json.RawMessage `json:"action"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserChatAction.ChatId = tmp.ChatId
	updateUserChatAction.UserId = tmp.UserId

	fieldAction, _ := UnmarshalChatAction(tmp.Action)
	updateUserChatAction.Action = fieldAction

	return nil
}

// The user went online or offline
type UpdateUserStatus struct {
	meta
	// User identifier
	UserId int32 `json:"user_id"`
	// New status of the user
	Status UserStatus `json:"status"`
}

func (entity *UpdateUserStatus) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserStatus

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserStatus) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserStatus) GetType() string {
	return TypeUpdateUserStatus
}

func (*UpdateUserStatus) UpdateType() string {
	return TypeUpdateUserStatus
}

func (updateUserStatus *UpdateUserStatus) UnmarshalJSON(data []byte) error {
	var tmp struct {
		UserId int32           `json:"user_id"`
		Status json.RawMessage `json:"status"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserStatus.UserId = tmp.UserId

	fieldStatus, _ := UnmarshalUserStatus(tmp.Status)
	updateUserStatus.Status = fieldStatus

	return nil
}

// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the client
type UpdateUser struct {
	meta
	// New data about the user
	User *User `json:"user"`
}

func (entity *UpdateUser) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUser

	return json.Marshal((*stub)(entity))
}

func (*UpdateUser) GetClass() string {
	return ClassUpdate
}

func (*UpdateUser) GetType() string {
	return TypeUpdateUser
}

func (*UpdateUser) UpdateType() string {
	return TypeUpdateUser
}

// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the client
type UpdateBasicGroup struct {
	meta
	// New data about the group
	BasicGroup *BasicGroup `json:"basic_group"`
}

func (entity *UpdateBasicGroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBasicGroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateBasicGroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateBasicGroup) GetType() string {
	return TypeUpdateBasicGroup
}

func (*UpdateBasicGroup) UpdateType() string {
	return TypeUpdateBasicGroup
}

// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the client
type UpdateSupergroup struct {
	meta
	// New data about the supergroup
	Supergroup *Supergroup `json:"supergroup"`
}

func (entity *UpdateSupergroup) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSupergroup

	return json.Marshal((*stub)(entity))
}

func (*UpdateSupergroup) GetClass() string {
	return ClassUpdate
}

func (*UpdateSupergroup) GetType() string {
	return TypeUpdateSupergroup
}

func (*UpdateSupergroup) UpdateType() string {
	return TypeUpdateSupergroup
}

// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the client
type UpdateSecretChat struct {
	meta
	// New data about the secret chat
	SecretChat *SecretChat `json:"secret_chat"`
}

func (entity *UpdateSecretChat) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSecretChat

	return json.Marshal((*stub)(entity))
}

func (*UpdateSecretChat) GetClass() string {
	return ClassUpdate
}

func (*UpdateSecretChat) GetType() string {
	return TypeUpdateSecretChat
}

func (*UpdateSecretChat) UpdateType() string {
	return TypeUpdateSecretChat
}

// Some data from userFullInfo has been changed
type UpdateUserFullInfo struct {
	meta
	// User identifier
	UserId int32 `json:"user_id"`
	// New full information about the user
	UserFullInfo *UserFullInfo `json:"user_full_info"`
}

func (entity *UpdateUserFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserFullInfo) GetType() string {
	return TypeUpdateUserFullInfo
}

func (*UpdateUserFullInfo) UpdateType() string {
	return TypeUpdateUserFullInfo
}

// Some data from basicGroupFullInfo has been changed
type UpdateBasicGroupFullInfo struct {
	meta
	// Identifier of a basic group
	BasicGroupId int32 `json:"basic_group_id"`
	// New full information about the group
	BasicGroupFullInfo *BasicGroupFullInfo `json:"basic_group_full_info"`
}

func (entity *UpdateBasicGroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateBasicGroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateBasicGroupFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateBasicGroupFullInfo) GetType() string {
	return TypeUpdateBasicGroupFullInfo
}

func (*UpdateBasicGroupFullInfo) UpdateType() string {
	return TypeUpdateBasicGroupFullInfo
}

// Some data from supergroupFullInfo has been changed
type UpdateSupergroupFullInfo struct {
	meta
	// Identifier of the supergroup or channel
	SupergroupId int32 `json:"supergroup_id"`
	// New full information about the supergroup
	SupergroupFullInfo *SupergroupFullInfo `json:"supergroup_full_info"`
}

func (entity *UpdateSupergroupFullInfo) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSupergroupFullInfo

	return json.Marshal((*stub)(entity))
}

func (*UpdateSupergroupFullInfo) GetClass() string {
	return ClassUpdate
}

func (*UpdateSupergroupFullInfo) GetType() string {
	return TypeUpdateSupergroupFullInfo
}

func (*UpdateSupergroupFullInfo) UpdateType() string {
	return TypeUpdateSupergroupFullInfo
}

// Service notification from the server. Upon receiving this the client must show a popup with the content of the notification
type UpdateServiceNotification struct {
	meta
	// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" should be shown under notification; if user presses the second, all local data should be destroyed using Destroy method
	Type string `json:"type"`
	// Notification content
	Content MessageContent `json:"content"`
}

func (entity *UpdateServiceNotification) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateServiceNotification

	return json.Marshal((*stub)(entity))
}

func (*UpdateServiceNotification) GetClass() string {
	return ClassUpdate
}

func (*UpdateServiceNotification) GetType() string {
	return TypeUpdateServiceNotification
}

func (*UpdateServiceNotification) UpdateType() string {
	return TypeUpdateServiceNotification
}

func (updateServiceNotification *UpdateServiceNotification) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Type    string          `json:"type"`
		Content json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateServiceNotification.Type = tmp.Type

	fieldContent, _ := UnmarshalMessageContent(tmp.Content)
	updateServiceNotification.Content = fieldContent

	return nil
}

// Information about a file was updated
type UpdateFile struct {
	meta
	// New data about the file
	File *File `json:"file"`
}

func (entity *UpdateFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFile

	return json.Marshal((*stub)(entity))
}

func (*UpdateFile) GetClass() string {
	return ClassUpdate
}

func (*UpdateFile) GetType() string {
	return TypeUpdateFile
}

func (*UpdateFile) UpdateType() string {
	return TypeUpdateFile
}

// The file generation process needs to be started by the client
type UpdateFileGenerationStart struct {
	meta
	// Unique identifier for the generation process
	GenerationId JsonInt64 `json:"generation_id"`
	// The path to a file from which a new file is generated; may be empty
	OriginalPath string `json:"original_path"`
	// The path to a file that should be created and where the new file should be generated
	DestinationPath string `json:"destination_path"`
	// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which should be downloaded by the client
	Conversion string `json:"conversion"`
}

func (entity *UpdateFileGenerationStart) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileGenerationStart

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileGenerationStart) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileGenerationStart) GetType() string {
	return TypeUpdateFileGenerationStart
}

func (*UpdateFileGenerationStart) UpdateType() string {
	return TypeUpdateFileGenerationStart
}

// File generation is no longer needed
type UpdateFileGenerationStop struct {
	meta
	// Unique identifier for the generation process
	GenerationId JsonInt64 `json:"generation_id"`
}

func (entity *UpdateFileGenerationStop) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFileGenerationStop

	return json.Marshal((*stub)(entity))
}

func (*UpdateFileGenerationStop) GetClass() string {
	return ClassUpdate
}

func (*UpdateFileGenerationStop) GetType() string {
	return TypeUpdateFileGenerationStop
}

func (*UpdateFileGenerationStop) UpdateType() string {
	return TypeUpdateFileGenerationStop
}

// New call was created or information about a call was updated
type UpdateCall struct {
	meta
	// New data about a call
	Call *Call `json:"call"`
}

func (entity *UpdateCall) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateCall

	return json.Marshal((*stub)(entity))
}

func (*UpdateCall) GetClass() string {
	return ClassUpdate
}

func (*UpdateCall) GetType() string {
	return TypeUpdateCall
}

func (*UpdateCall) UpdateType() string {
	return TypeUpdateCall
}

// Some privacy setting rules have been changed
type UpdateUserPrivacySettingRules struct {
	meta
	// The privacy setting
	Setting UserPrivacySetting `json:"setting"`
	// New privacy rules
	Rules *UserPrivacySettingRules `json:"rules"`
}

func (entity *UpdateUserPrivacySettingRules) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUserPrivacySettingRules

	return json.Marshal((*stub)(entity))
}

func (*UpdateUserPrivacySettingRules) GetClass() string {
	return ClassUpdate
}

func (*UpdateUserPrivacySettingRules) GetType() string {
	return TypeUpdateUserPrivacySettingRules
}

func (*UpdateUserPrivacySettingRules) UpdateType() string {
	return TypeUpdateUserPrivacySettingRules
}

func (updateUserPrivacySettingRules *UpdateUserPrivacySettingRules) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Setting json.RawMessage          `json:"setting"`
		Rules   *UserPrivacySettingRules `json:"rules"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUserPrivacySettingRules.Rules = tmp.Rules

	fieldSetting, _ := UnmarshalUserPrivacySetting(tmp.Setting)
	updateUserPrivacySettingRules.Setting = fieldSetting

	return nil
}

// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
type UpdateUnreadMessageCount struct {
	meta
	// The chat list with changed number of unread messages
	ChatList ChatList `json:"chat_list"`
	// Total number of unread messages
	UnreadCount int32 `json:"unread_count"`
	// Total number of unread messages in unmuted chats
	UnreadUnmutedCount int32 `json:"unread_unmuted_count"`
}

func (entity *UpdateUnreadMessageCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnreadMessageCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnreadMessageCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnreadMessageCount) GetType() string {
	return TypeUpdateUnreadMessageCount
}

func (*UpdateUnreadMessageCount) UpdateType() string {
	return TypeUpdateUnreadMessageCount
}

func (updateUnreadMessageCount *UpdateUnreadMessageCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatList           json.RawMessage `json:"chat_list"`
		UnreadCount        int32           `json:"unread_count"`
		UnreadUnmutedCount int32           `json:"unread_unmuted_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUnreadMessageCount.UnreadCount = tmp.UnreadCount
	updateUnreadMessageCount.UnreadUnmutedCount = tmp.UnreadUnmutedCount

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateUnreadMessageCount.ChatList = fieldChatList

	return nil
}

// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
type UpdateUnreadChatCount struct {
	meta
	// The chat list with changed number of unread messages
	ChatList ChatList `json:"chat_list"`
	// Approximate total number of chats in the chat list
	TotalCount int32 `json:"total_count"`
	// Total number of unread chats
	UnreadCount int32 `json:"unread_count"`
	// Total number of unread unmuted chats
	UnreadUnmutedCount int32 `json:"unread_unmuted_count"`
	// Total number of chats marked as unread
	MarkedAsUnreadCount int32 `json:"marked_as_unread_count"`
	// Total number of unmuted chats marked as unread
	MarkedAsUnreadUnmutedCount int32 `json:"marked_as_unread_unmuted_count"`
}

func (entity *UpdateUnreadChatCount) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUnreadChatCount

	return json.Marshal((*stub)(entity))
}

func (*UpdateUnreadChatCount) GetClass() string {
	return ClassUpdate
}

func (*UpdateUnreadChatCount) GetType() string {
	return TypeUpdateUnreadChatCount
}

func (*UpdateUnreadChatCount) UpdateType() string {
	return TypeUpdateUnreadChatCount
}

func (updateUnreadChatCount *UpdateUnreadChatCount) UnmarshalJSON(data []byte) error {
	var tmp struct {
		ChatList                   json.RawMessage `json:"chat_list"`
		TotalCount                 int32           `json:"total_count"`
		UnreadCount                int32           `json:"unread_count"`
		UnreadUnmutedCount         int32           `json:"unread_unmuted_count"`
		MarkedAsUnreadCount        int32           `json:"marked_as_unread_count"`
		MarkedAsUnreadUnmutedCount int32           `json:"marked_as_unread_unmuted_count"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateUnreadChatCount.TotalCount = tmp.TotalCount
	updateUnreadChatCount.UnreadCount = tmp.UnreadCount
	updateUnreadChatCount.UnreadUnmutedCount = tmp.UnreadUnmutedCount
	updateUnreadChatCount.MarkedAsUnreadCount = tmp.MarkedAsUnreadCount
	updateUnreadChatCount.MarkedAsUnreadUnmutedCount = tmp.MarkedAsUnreadUnmutedCount

	fieldChatList, _ := UnmarshalChatList(tmp.ChatList)
	updateUnreadChatCount.ChatList = fieldChatList

	return nil
}

// An option changed its value
type UpdateOption struct {
	meta
	// The option name
	Name string `json:"name"`
	// The new option value
	Value OptionValue `json:"value"`
}

func (entity *UpdateOption) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateOption

	return json.Marshal((*stub)(entity))
}

func (*UpdateOption) GetClass() string {
	return ClassUpdate
}

func (*UpdateOption) GetType() string {
	return TypeUpdateOption
}

func (*UpdateOption) UpdateType() string {
	return TypeUpdateOption
}

func (updateOption *UpdateOption) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Name  string          `json:"name"`
		Value json.RawMessage `json:"value"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateOption.Name = tmp.Name

	fieldValue, _ := UnmarshalOptionValue(tmp.Value)
	updateOption.Value = fieldValue

	return nil
}

// The list of installed sticker sets was updated
type UpdateInstalledStickerSets struct {
	meta
	// True, if the list of installed mask sticker sets was updated
	IsMasks bool `json:"is_masks"`
	// The new list of installed ordinary sticker sets
	StickerSetIds []JsonInt64 `json:"sticker_set_ids"`
}

func (entity *UpdateInstalledStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateInstalledStickerSets

	return json.Marshal((*stub)(entity))
}

func (*UpdateInstalledStickerSets) GetClass() string {
	return ClassUpdate
}

func (*UpdateInstalledStickerSets) GetType() string {
	return TypeUpdateInstalledStickerSets
}

func (*UpdateInstalledStickerSets) UpdateType() string {
	return TypeUpdateInstalledStickerSets
}

// The list of trending sticker sets was updated or some of them were viewed
type UpdateTrendingStickerSets struct {
	meta
	// The new list of trending sticker sets
	StickerSets *StickerSets `json:"sticker_sets"`
}

func (entity *UpdateTrendingStickerSets) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateTrendingStickerSets

	return json.Marshal((*stub)(entity))
}

func (*UpdateTrendingStickerSets) GetClass() string {
	return ClassUpdate
}

func (*UpdateTrendingStickerSets) GetType() string {
	return TypeUpdateTrendingStickerSets
}

func (*UpdateTrendingStickerSets) UpdateType() string {
	return TypeUpdateTrendingStickerSets
}

// The list of recently used stickers was updated
type UpdateRecentStickers struct {
	meta
	// True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated
	IsAttached bool `json:"is_attached"`
	// The new list of file identifiers of recently used stickers
	StickerIds []int32 `json:"sticker_ids"`
}

func (entity *UpdateRecentStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateRecentStickers

	return json.Marshal((*stub)(entity))
}

func (*UpdateRecentStickers) GetClass() string {
	return ClassUpdate
}

func (*UpdateRecentStickers) GetType() string {
	return TypeUpdateRecentStickers
}

func (*UpdateRecentStickers) UpdateType() string {
	return TypeUpdateRecentStickers
}

// The list of favorite stickers was updated
type UpdateFavoriteStickers struct {
	meta
	// The new list of file identifiers of favorite stickers
	StickerIds []int32 `json:"sticker_ids"`
}

func (entity *UpdateFavoriteStickers) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateFavoriteStickers

	return json.Marshal((*stub)(entity))
}

func (*UpdateFavoriteStickers) GetClass() string {
	return ClassUpdate
}

func (*UpdateFavoriteStickers) GetType() string {
	return TypeUpdateFavoriteStickers
}

func (*UpdateFavoriteStickers) UpdateType() string {
	return TypeUpdateFavoriteStickers
}

// The list of saved animations was updated
type UpdateSavedAnimations struct {
	meta
	// The new list of file identifiers of saved animations
	AnimationIds []int32 `json:"animation_ids"`
}

func (entity *UpdateSavedAnimations) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSavedAnimations

	return json.Marshal((*stub)(entity))
}

func (*UpdateSavedAnimations) GetClass() string {
	return ClassUpdate
}

func (*UpdateSavedAnimations) GetType() string {
	return TypeUpdateSavedAnimations
}

func (*UpdateSavedAnimations) UpdateType() string {
	return TypeUpdateSavedAnimations
}

// The selected background has changed
type UpdateSelectedBackground struct {
	meta
	// True, if background for dark theme has changed
	ForDarkTheme bool `json:"for_dark_theme"`
	// The new selected background; may be null
	Background *Background `json:"background"`
}

func (entity *UpdateSelectedBackground) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateSelectedBackground

	return json.Marshal((*stub)(entity))
}

func (*UpdateSelectedBackground) GetClass() string {
	return ClassUpdate
}

func (*UpdateSelectedBackground) GetType() string {
	return TypeUpdateSelectedBackground
}

func (*UpdateSelectedBackground) UpdateType() string {
	return TypeUpdateSelectedBackground
}

// Some language pack strings have been updated
type UpdateLanguagePackStrings struct {
	meta
	// Localization target to which the language pack belongs
	LocalizationTarget string `json:"localization_target"`
	// Identifier of the updated language pack
	LanguagePackId string `json:"language_pack_id"`
	// List of changed language pack strings
	Strings []*LanguagePackString `json:"strings"`
}

func (entity *UpdateLanguagePackStrings) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateLanguagePackStrings

	return json.Marshal((*stub)(entity))
}

func (*UpdateLanguagePackStrings) GetClass() string {
	return ClassUpdate
}

func (*UpdateLanguagePackStrings) GetType() string {
	return TypeUpdateLanguagePackStrings
}

func (*UpdateLanguagePackStrings) UpdateType() string {
	return TypeUpdateLanguagePackStrings
}

// The connection state has changed
type UpdateConnectionState struct {
	meta
	// The new connection state
	State ConnectionState `json:"state"`
}

func (entity *UpdateConnectionState) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateConnectionState

	return json.Marshal((*stub)(entity))
}

func (*UpdateConnectionState) GetClass() string {
	return ClassUpdate
}

func (*UpdateConnectionState) GetType() string {
	return TypeUpdateConnectionState
}

func (*UpdateConnectionState) UpdateType() string {
	return TypeUpdateConnectionState
}

func (updateConnectionState *UpdateConnectionState) UnmarshalJSON(data []byte) error {
	var tmp struct {
		State json.RawMessage `json:"state"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	fieldState, _ := UnmarshalConnectionState(tmp.State)
	updateConnectionState.State = fieldState

	return nil
}

// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method should be called with the reason "Decline ToS update"
type UpdateTermsOfService struct {
	meta
	// Identifier of the terms of service
	TermsOfServiceId string `json:"terms_of_service_id"`
	// The new terms of service
	TermsOfService *TermsOfService `json:"terms_of_service"`
}

func (entity *UpdateTermsOfService) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateTermsOfService

	return json.Marshal((*stub)(entity))
}

func (*UpdateTermsOfService) GetClass() string {
	return ClassUpdate
}

func (*UpdateTermsOfService) GetType() string {
	return TypeUpdateTermsOfService
}

func (*UpdateTermsOfService) UpdateType() string {
	return TypeUpdateTermsOfService
}

// List of users nearby has changed. The update is sent only 60 seconds after a successful searchChatsNearby request
type UpdateUsersNearby struct {
	meta
	// The new list of users nearby
	UsersNearby []*ChatNearby `json:"users_nearby"`
}

func (entity *UpdateUsersNearby) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateUsersNearby

	return json.Marshal((*stub)(entity))
}

func (*UpdateUsersNearby) GetClass() string {
	return ClassUpdate
}

func (*UpdateUsersNearby) GetType() string {
	return TypeUpdateUsersNearby
}

func (*UpdateUsersNearby) UpdateType() string {
	return TypeUpdateUsersNearby
}

// A new incoming inline query; for bots only
type UpdateNewInlineQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int32 `json:"sender_user_id"`
	// User location, provided by the client; may be null
	UserLocation *Location `json:"user_location"`
	// Text of the query
	Query string `json:"query"`
	// Offset of the first entry to return
	Offset string `json:"offset"`
}

func (entity *UpdateNewInlineQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewInlineQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewInlineQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewInlineQuery) GetType() string {
	return TypeUpdateNewInlineQuery
}

func (*UpdateNewInlineQuery) UpdateType() string {
	return TypeUpdateNewInlineQuery
}

// The user has chosen a result of an inline query; for bots only
type UpdateNewChosenInlineResult struct {
	meta
	// Identifier of the user who sent the query
	SenderUserId int32 `json:"sender_user_id"`
	// User location, provided by the client; may be null
	UserLocation *Location `json:"user_location"`
	// Text of the query
	Query string `json:"query"`
	// Identifier of the chosen result
	ResultId string `json:"result_id"`
	// Identifier of the sent inline message, if known
	InlineMessageId string `json:"inline_message_id"`
}

func (entity *UpdateNewChosenInlineResult) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewChosenInlineResult

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewChosenInlineResult) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewChosenInlineResult) GetType() string {
	return TypeUpdateNewChosenInlineResult
}

func (*UpdateNewChosenInlineResult) UpdateType() string {
	return TypeUpdateNewChosenInlineResult
}

// A new incoming callback query; for bots only
type UpdateNewCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int32 `json:"sender_user_id"`
	// Identifier of the chat where the query was sent
	ChatId int64 `json:"chat_id"`
	// Identifier of the message, from which the query originated
	MessageId int64 `json:"message_id"`
	// Identifier that uniquely corresponds to the chat to which the message was sent
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCallbackQuery) GetType() string {
	return TypeUpdateNewCallbackQuery
}

func (*UpdateNewCallbackQuery) UpdateType() string {
	return TypeUpdateNewCallbackQuery
}

func (updateNewCallbackQuery *UpdateNewCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id           JsonInt64       `json:"id"`
		SenderUserId int32           `json:"sender_user_id"`
		ChatId       int64           `json:"chat_id"`
		MessageId    int64           `json:"message_id"`
		ChatInstance JsonInt64       `json:"chat_instance"`
		Payload      json.RawMessage `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewCallbackQuery.Id = tmp.Id
	updateNewCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewCallbackQuery.ChatId = tmp.ChatId
	updateNewCallbackQuery.MessageId = tmp.MessageId
	updateNewCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming callback query from a message sent via a bot; for bots only
type UpdateNewInlineCallbackQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int32 `json:"sender_user_id"`
	// Identifier of the inline message, from which the query originated
	InlineMessageId string `json:"inline_message_id"`
	// An identifier uniquely corresponding to the chat a message was sent to
	ChatInstance JsonInt64 `json:"chat_instance"`
	// Query payload
	Payload CallbackQueryPayload `json:"payload"`
}

func (entity *UpdateNewInlineCallbackQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewInlineCallbackQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewInlineCallbackQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewInlineCallbackQuery) GetType() string {
	return TypeUpdateNewInlineCallbackQuery
}

func (*UpdateNewInlineCallbackQuery) UpdateType() string {
	return TypeUpdateNewInlineCallbackQuery
}

func (updateNewInlineCallbackQuery *UpdateNewInlineCallbackQuery) UnmarshalJSON(data []byte) error {
	var tmp struct {
		Id              JsonInt64       `json:"id"`
		SenderUserId    int32           `json:"sender_user_id"`
		InlineMessageId string          `json:"inline_message_id"`
		ChatInstance    JsonInt64       `json:"chat_instance"`
		Payload         json.RawMessage `json:"payload"`
	}

	err := json.Unmarshal(data, &tmp)
	if err != nil {
		return err
	}

	updateNewInlineCallbackQuery.Id = tmp.Id
	updateNewInlineCallbackQuery.SenderUserId = tmp.SenderUserId
	updateNewInlineCallbackQuery.InlineMessageId = tmp.InlineMessageId
	updateNewInlineCallbackQuery.ChatInstance = tmp.ChatInstance

	fieldPayload, _ := UnmarshalCallbackQueryPayload(tmp.Payload)
	updateNewInlineCallbackQuery.Payload = fieldPayload

	return nil
}

// A new incoming shipping query; for bots only. Only for invoices with flexible price
type UpdateNewShippingQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int32 `json:"sender_user_id"`
	// Invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// User shipping address
	ShippingAddress *Address `json:"shipping_address"`
}

func (entity *UpdateNewShippingQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewShippingQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewShippingQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewShippingQuery) GetType() string {
	return TypeUpdateNewShippingQuery
}

func (*UpdateNewShippingQuery) UpdateType() string {
	return TypeUpdateNewShippingQuery
}

// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
type UpdateNewPreCheckoutQuery struct {
	meta
	// Unique query identifier
	Id JsonInt64 `json:"id"`
	// Identifier of the user who sent the query
	SenderUserId int32 `json:"sender_user_id"`
	// Currency for the product price
	Currency string `json:"currency"`
	// Total price for the product, in the minimal quantity of the currency
	TotalAmount int64 `json:"total_amount"`
	// Invoice payload
	InvoicePayload []byte `json:"invoice_payload"`
	// Identifier of a shipping option chosen by the user; may be empty if not applicable
	ShippingOptionId string `json:"shipping_option_id"`
	// Information about the order; may be null
	OrderInfo *OrderInfo `json:"order_info"`
}

func (entity *UpdateNewPreCheckoutQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewPreCheckoutQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewPreCheckoutQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewPreCheckoutQuery) GetType() string {
	return TypeUpdateNewPreCheckoutQuery
}

func (*UpdateNewPreCheckoutQuery) UpdateType() string {
	return TypeUpdateNewPreCheckoutQuery
}

// A new incoming event; for bots only
type UpdateNewCustomEvent struct {
	meta
	// A JSON-serialized event
	Event string `json:"event"`
}

func (entity *UpdateNewCustomEvent) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCustomEvent

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCustomEvent) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCustomEvent) GetType() string {
	return TypeUpdateNewCustomEvent
}

func (*UpdateNewCustomEvent) UpdateType() string {
	return TypeUpdateNewCustomEvent
}

// A new incoming query; for bots only
type UpdateNewCustomQuery struct {
	meta
	// The query identifier
	Id JsonInt64 `json:"id"`
	// JSON-serialized query data
	Data string `json:"data"`
	// Query timeout
	Timeout int32 `json:"timeout"`
}

func (entity *UpdateNewCustomQuery) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdateNewCustomQuery

	return json.Marshal((*stub)(entity))
}

func (*UpdateNewCustomQuery) GetClass() string {
	return ClassUpdate
}

func (*UpdateNewCustomQuery) GetType() string {
	return TypeUpdateNewCustomQuery
}

func (*UpdateNewCustomQuery) UpdateType() string {
	return TypeUpdateNewCustomQuery
}

// A poll was updated; for bots only
type UpdatePoll struct {
	meta
	// New data about the poll
	Poll *Poll `json:"poll"`
}

func (entity *UpdatePoll) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePoll

	return json.Marshal((*stub)(entity))
}

func (*UpdatePoll) GetClass() string {
	return ClassUpdate
}

func (*UpdatePoll) GetType() string {
	return TypeUpdatePoll
}

func (*UpdatePoll) UpdateType() string {
	return TypeUpdatePoll
}

// A user changed the answer to a poll; for bots only
type UpdatePollAnswer struct {
	meta
	// Unique poll identifier
	PollId JsonInt64 `json:"poll_id"`
	// The user, who changed the answer to the poll
	UserId int32 `json:"user_id"`
	// 0-based identifiers of answer options, chosen by the user
	OptionIds []int32 `json:"option_ids"`
}

func (entity *UpdatePollAnswer) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub UpdatePollAnswer

	return json.Marshal((*stub)(entity))
}

func (*UpdatePollAnswer) GetClass() string {
	return ClassUpdate
}

func (*UpdatePollAnswer) GetType() string {
	return TypeUpdatePollAnswer
}

func (*UpdatePollAnswer) UpdateType() string {
	return TypeUpdatePollAnswer
}

// Contains a list of updates
type Updates struct {
	meta
	// List of updates
	Updates []Update `json:"updates"`
}

func (entity *Updates) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub Updates

	return json.Marshal((*stub)(entity))
}

func (*Updates) GetClass() string {
	return ClassUpdates
}

func (*Updates) GetType() string {
	return TypeUpdates
}

// The log is written to stderr or an OS specific log
type LogStreamDefault struct {
	meta
}

func (entity *LogStreamDefault) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamDefault

	return json.Marshal((*stub)(entity))
}

func (*LogStreamDefault) GetClass() string {
	return ClassLogStream
}

func (*LogStreamDefault) GetType() string {
	return TypeLogStreamDefault
}

func (*LogStreamDefault) LogStreamType() string {
	return TypeLogStreamDefault
}

// The log is written to a file
type LogStreamFile struct {
	meta
	// Path to the file to where the internal TDLib log will be written
	Path string `json:"path"`
	// The maximum size of the file to where the internal TDLib log is written before the file will be auto-rotated
	MaxFileSize int64 `json:"max_file_size"`
}

func (entity *LogStreamFile) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamFile

	return json.Marshal((*stub)(entity))
}

func (*LogStreamFile) GetClass() string {
	return ClassLogStream
}

func (*LogStreamFile) GetType() string {
	return TypeLogStreamFile
}

func (*LogStreamFile) LogStreamType() string {
	return TypeLogStreamFile
}

// The log is written nowhere
type LogStreamEmpty struct {
	meta
}

func (entity *LogStreamEmpty) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogStreamEmpty

	return json.Marshal((*stub)(entity))
}

func (*LogStreamEmpty) GetClass() string {
	return ClassLogStream
}

func (*LogStreamEmpty) GetType() string {
	return TypeLogStreamEmpty
}

func (*LogStreamEmpty) LogStreamType() string {
	return TypeLogStreamEmpty
}

// Contains a TDLib internal log verbosity level
type LogVerbosityLevel struct {
	meta
	// Log verbosity level
	VerbosityLevel int32 `json:"verbosity_level"`
}

func (entity *LogVerbosityLevel) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogVerbosityLevel

	return json.Marshal((*stub)(entity))
}

func (*LogVerbosityLevel) GetClass() string {
	return ClassLogVerbosityLevel
}

func (*LogVerbosityLevel) GetType() string {
	return TypeLogVerbosityLevel
}

// Contains a list of available TDLib internal log tags
type LogTags struct {
	meta
	// List of log tags
	Tags []string `json:"tags"`
}

func (entity *LogTags) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub LogTags

	return json.Marshal((*stub)(entity))
}

func (*LogTags) GetClass() string {
	return ClassLogTags
}

func (*LogTags) GetType() string {
	return TypeLogTags
}

// A simple object containing a number; for testing only
type TestInt struct {
	meta
	// Number
	Value int32 `json:"value"`
}

func (entity *TestInt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestInt

	return json.Marshal((*stub)(entity))
}

func (*TestInt) GetClass() string {
	return ClassTestInt
}

func (*TestInt) GetType() string {
	return TypeTestInt
}

// A simple object containing a string; for testing only
type TestString struct {
	meta
	// String
	Value string `json:"value"`
}

func (entity *TestString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestString

	return json.Marshal((*stub)(entity))
}

func (*TestString) GetClass() string {
	return ClassTestString
}

func (*TestString) GetType() string {
	return TypeTestString
}

// A simple object containing a sequence of bytes; for testing only
type TestBytes struct {
	meta
	// Bytes
	Value []byte `json:"value"`
}

func (entity *TestBytes) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestBytes

	return json.Marshal((*stub)(entity))
}

func (*TestBytes) GetClass() string {
	return ClassTestBytes
}

func (*TestBytes) GetType() string {
	return TypeTestBytes
}

// A simple object containing a vector of numbers; for testing only
type TestVectorInt struct {
	meta
	// Vector of numbers
	Value []int32 `json:"value"`
}

func (entity *TestVectorInt) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorInt

	return json.Marshal((*stub)(entity))
}

func (*TestVectorInt) GetClass() string {
	return ClassTestVectorInt
}

func (*TestVectorInt) GetType() string {
	return TypeTestVectorInt
}

// A simple object containing a vector of objects that hold a number; for testing only
type TestVectorIntObject struct {
	meta
	// Vector of objects
	Value []*TestInt `json:"value"`
}

func (entity *TestVectorIntObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorIntObject

	return json.Marshal((*stub)(entity))
}

func (*TestVectorIntObject) GetClass() string {
	return ClassTestVectorIntObject
}

func (*TestVectorIntObject) GetType() string {
	return TypeTestVectorIntObject
}

// A simple object containing a vector of strings; for testing only
type TestVectorString struct {
	meta
	// Vector of strings
	Value []string `json:"value"`
}

func (entity *TestVectorString) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorString

	return json.Marshal((*stub)(entity))
}

func (*TestVectorString) GetClass() string {
	return ClassTestVectorString
}

func (*TestVectorString) GetType() string {
	return TypeTestVectorString
}

// A simple object containing a vector of objects that hold a string; for testing only
type TestVectorStringObject struct {
	meta
	// Vector of objects
	Value []*TestString `json:"value"`
}

func (entity *TestVectorStringObject) MarshalJSON() ([]byte, error) {
	entity.meta.Type = entity.GetType()

	type stub TestVectorStringObject

	return json.Marshal((*stub)(entity))
}

func (*TestVectorStringObject) GetClass() string {
	return ClassTestVectorStringObject
}

func (*TestVectorStringObject) GetType() string {
	return TypeTestVectorStringObject
}
