package main

import (
	"bufio"
	"flag"
	"fmt"
	"github.com/zelenin/go-tdlib/internal/codegen"
	"github.com/zelenin/go-tdlib/internal/tlparser"
	"log"
	"net/http"
	"os"
	"path/filepath"
)

type config struct {
	version             string
	outputDirPath       string
	packageName         string
	functionFileName    string
	typeFileName        string
	unmarshalerFileName string
	versionFileName     string
}

func main() {
	var config config

	flag.StringVar(&config.version, "version", "", "TDLib version")
	flag.StringVar(&config.outputDirPath, "outputDir", "./tdlib", "output directory")
	flag.StringVar(&config.packageName, "package", "tdlib", "package name")
	flag.StringVar(&config.functionFileName, "functionFile", "function.go", "functions filename")
	flag.StringVar(&config.typeFileName, "typeFile", "type.go", "types filename")
	flag.StringVar(&config.unmarshalerFileName, "unmarshalerFile", "unmarshaler.go", "unmarshalers filename")
	flag.StringVar(&config.versionFileName, "versionFile", "version.go", "version filename")

	flag.Parse()

	resp, err := http.Get("https://raw.githubusercontent.com/tdlib/td/" + config.version + "/td/generate/scheme/td_api.tl")
	if err != nil {
		log.Fatalf("http.Get error: %s", err)
		return
	}
	defer resp.Body.Close()

	schema, err := tlparser.Parse(resp.Body)
	if err != nil {
		log.Fatalf("schema parse error: %s", err)
		return
	}

	err = os.MkdirAll(config.outputDirPath, 0755)
	if err != nil {
		log.Fatalf("error creating %s: %s", config.outputDirPath, err)
	}

	var writer *bufio.Writer

	functionFilePath := filepath.Join(config.outputDirPath, config.functionFileName)

	os.Remove(functionFilePath)
	functionFile, err := os.OpenFile(functionFilePath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, os.ModePerm)
	if err != nil {
		log.Fatalf("functionFile open error: %s", err)
	}
	defer functionFile.Close()

	writer = bufio.NewWriter(functionFile)
	writer.Write(codegen.GenerateFunctions(schema, config.packageName))
	writer.Flush()

	typeFilePath := filepath.Join(config.outputDirPath, config.typeFileName)

	os.Remove(typeFilePath)
	typeFile, err := os.OpenFile(typeFilePath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, os.ModePerm)
	if err != nil {
		log.Fatalf("typeFile open error: %s", err)
	}
	defer typeFile.Close()

	writer = bufio.NewWriter(typeFile)
	writer.Write(codegen.GenerateTypes(schema, config.packageName))
	writer.Flush()

	unmarshalerFilePath := filepath.Join(config.outputDirPath, config.unmarshalerFileName)

	os.Remove(unmarshalerFilePath)
	unmarshalerFile, err := os.OpenFile(unmarshalerFilePath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, os.ModePerm)
	if err != nil {
		log.Fatalf("unmarshalerFile open error: %s", err)
	}
	defer unmarshalerFile.Close()

	writer = bufio.NewWriter(unmarshalerFile)
	writer.Write(codegen.GenerateUnmarshalers(schema, config.packageName))
	writer.Flush()

	versionFilePath := filepath.Join(config.outputDirPath, config.versionFileName)

	os.Remove(versionFilePath)
	versionFile, err := os.OpenFile(versionFilePath, os.O_CREATE|os.O_RDWR|os.O_TRUNC, os.ModePerm)
	if err != nil {
		log.Fatalf("unmarshalerFile open error: %s", err)
	}
	defer versionFile.Close()

	writer = bufio.NewWriter(versionFile)
	writer.Write([]byte(fmt.Sprintf(`// AUTOGENERATED
package %s

const TDLIB_VERSION = %q
`, config.packageName, config.version)))
	writer.Flush()
}
